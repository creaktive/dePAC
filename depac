#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"AnyEvent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT';
  package AnyEvent;
  BEGIN{
  require"AnyEvent/constants.pm";
  &AnyEvent::common_sense;
  }
  use Carp ();
  our$VERSION=7.14;
  our$MODEL;
  our@ISA;
  our@REGISTRY;
  our$VERBOSE;
  our%PROTOCOL;
  our$MAX_SIGNAL_LATENCY=$ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY}||10;
  BEGIN{
  eval"sub TAINT (){".(${^TAINT}*1)."}";
  delete@ENV{grep/^PERL_ANYEVENT_/,keys%ENV}
    if${^TAINT};
  $ENV{"PERL_ANYEVENT_$_"}=$ENV{"AE_$_"}for grep s/^AE_//&&!exists$ENV{"PERL_ANYEVENT_$_"},keys%ENV;
  @ENV{grep/^PERL_ANYEVENT_/,keys%ENV}=()
    if${^TAINT};
  $VERBOSE=length$ENV{PERL_ANYEVENT_VERBOSE}?$ENV{PERL_ANYEVENT_VERBOSE}*1:4;
  my$idx;
  $PROTOCOL{$_}= ++$idx
    for reverse split/\s*,\s*/,
    $ENV{PERL_ANYEVENT_PROTOCOLS}||"ipv4,ipv6";
  }
  our@post_detect;
  sub post_detect(&){
  my($cb)=@_;
  push@post_detect,$cb;
  defined wantarray
    ?bless\$cb,"AnyEvent::Util::postdetect"
    :()
  }
  sub AnyEvent::Util::postdetect::DESTROY{
  @post_detect=grep$_!=${$_[0]},@post_detect;
  }
  our$POSTPONE_W;
  our@POSTPONE;
  sub _postpone_exec{
  undef$POSTPONE_W;
  &{shift@POSTPONE}while@POSTPONE;
  }
  sub postpone(&){
  push@POSTPONE,shift;
  $POSTPONE_W||=AE::timer(0,0,\&_postpone_exec);
  ()
  }
  sub log($$;@){
  if($_[0]<=($VERBOSE||1)){
  local($!,$@);
  require AnyEvent::Log;
  goto&log;
  }
  0
  }
  sub _logger($;$){
  my($level,$renabled)=@_;
  $$renabled=$level<=$VERBOSE;
  my$logger=[(caller)[0],$level,$renabled];
  $AnyEvent::Log::LOGGER{$logger+0}=$logger;
  }
  if(length$ENV{PERL_ANYEVENT_LOG}){
  require AnyEvent::Log;
  }
  BEGIN{
  *_fh_nonblocking=AnyEvent::WIN32
    ?sub($$){
  ioctl$_[0],0x8004667e,pack"L",$_[1];
    }
    :sub($$){
  fcntl$_[0],AnyEvent::F_SETFL,$_[1]?AnyEvent::O_NONBLOCK:0;
    };
  }
  sub fh_block($){
  _fh_nonblocking shift,0
  }
  sub fh_unblock($){
  _fh_nonblocking shift,1
  }
  our@models=([EV::=>AnyEvent::Impl::EV::],[AnyEvent::Loop::=>AnyEvent::Impl::Perl::],[Irssi::=>AnyEvent::Impl::Irssi::],[Event::=>AnyEvent::Impl::Event::],[Glib::=>AnyEvent::Impl::Glib::],[Event::Lib::=>AnyEvent::Impl::EventLib::],[Tk::=>AnyEvent::Impl::Tk::],[UV::=>AnyEvent::Impl::UV::],[Qt::=>AnyEvent::Impl::Qt::],[POE::Kernel::=>AnyEvent::Impl::POE::],[Wx::=>AnyEvent::Impl::POE::],[Prima::=>AnyEvent::Impl::POE::],[IO::Async::Loop::=>AnyEvent::Impl::IOAsync::],[Cocoa::EventLoop::=>AnyEvent::Impl::Cocoa::],[FLTK::=>AnyEvent::Impl::FLTK::],);
  our@isa_hook;
  sub _isa_set{
  my@pkg=("AnyEvent",(map$_->[0],grep defined,@isa_hook),$MODEL);
  @{"$pkg[$_-1]::ISA"}=$pkg[$_]for 1..$#pkg;
  grep$_&&$_->[1],@isa_hook
    and AE::_reset();
  }
  sub _isa_hook($$;$){
  my($i,$pkg,$reset_ae)=@_;
  $isa_hook[$i]=$pkg?[$pkg,$reset_ae]:undef;
  _isa_set;
  }
  our@methods=qw(io timer time now now_update signal child idle condvar);
  sub detect(){
  return$MODEL if$MODEL;
  AnyEvent::log fatal=>"IO::Async::Loop::AnyEvent detected - that module is broken by\n"."design, abuses internals and breaks AnyEvent - will not continue."
    if exists$INC{"IO/Async/Loop/AnyEvent.pm"};
  local$!;
  local$SIG{__DIE__};
  *detect=sub (){$MODEL};
  delete@{"AnyEvent::"}{@methods};
  undef@methods;
  if($ENV{PERL_ANYEVENT_MODEL}=~/^([a-zA-Z0-9:]+)$/){
  my$model=$1;
  $model="AnyEvent::Impl::$model" unless$model=~s/::$//;
  if(eval"require $model"){
  AnyEvent::log 7=>"Loaded model '$model' (forced by \$ENV{PERL_ANYEVENT_MODEL}), using it.";
  $MODEL=$model;
  }
  else{
  AnyEvent::log 4=>"Unable to load model '$model' (from \$ENV{PERL_ANYEVENT_MODEL}):\n$@";
  }
  }
  unless($MODEL){
  for(@REGISTRY,@models){
  my($package,$model)=@$_;
  if(${"$package\::VERSION"}>0){
  if(eval"require $model"){
  AnyEvent::log 7=>"Autodetected model '$model', using it.";
  $MODEL=$model;
  last;
  }
  else{
  AnyEvent::log 8=>"Detected event loop $package, but cannot load '$model', skipping: $@";
  }
  }
  }
  unless($MODEL){
  for(@REGISTRY,@models){
  my($package,$model)=@$_;
  if(eval"require $package"
  and${"$package\::VERSION"}>0
  and eval"require $model")
  {
  AnyEvent::log 7=>"Autoloaded model '$model', using it.";
  $MODEL=$model;
  last;
  }
  }
  $MODEL
    or AnyEvent::log fatal=>"Backend autodetection failed - did you properly install AnyEvent?";
  }
  }
  undef@models;
  undef@REGISTRY;
  push@{"$MODEL\::ISA"},"AnyEvent::Base";
  for(qw(time signal child idle)){
  undef&{"AnyEvent::Base::$_"}
    if defined&{"$MODEL\::$_"};
  }
  _isa_set;
  if($ENV{PERL_ANYEVENT_STRICT}){
  require AnyEvent::Strict;
  }
  if($ENV{PERL_ANYEVENT_DEBUG_WRAP}){
  require AnyEvent::Debug;
  AnyEvent::Debug::wrap($ENV{PERL_ANYEVENT_DEBUG_WRAP});
  }
  if(length$ENV{PERL_ANYEVENT_DEBUG_SHELL}){
  require AnyEvent::Socket;
  require AnyEvent::Debug;
  my$shell=$ENV{PERL_ANYEVENT_DEBUG_SHELL};
  $shell=~s/\$\$/$$/g;
  my($host,$service)=AnyEvent::Socket::parse_hostport($shell);
  $AnyEvent::Debug::SHELL=AnyEvent::Debug::shell($host,$service);
  }
  (shift@post_detect)->()while@post_detect;
  undef@post_detect;
  *post_detect=sub(&){
  shift->();
  undef
  };
  $MODEL
  }
  for my $name(@methods){
  *$name=sub{
  detect;
  goto&{UNIVERSAL::can AnyEvent=>"SUPER::$name"}
  };
  }
  sub _dupfh($$;$$){
  my($poll,$fh,$r,$w)=@_;
  my($rw,$mode)=$poll eq"r"?($r,"<&"):($w,">&");
  open my$fh2,$mode,$fh
    or die"AnyEvent->io: cannot dup() filehandle in mode '$poll': $!,";
  ($fh2,$rw)
  }
  package AE;
  our$VERSION=$AnyEvent::VERSION;
  sub _reset(){
  eval q{
        # fall back to the main API by default - backends and AnyEvent::Base
        # implementations can overwrite these.
  
        sub io($$$) {
           AnyEvent->io (fh => $_[0], poll => $_[1] ? "w" : "r", cb => $_[2])
        }
  
        sub timer($$$) {
           AnyEvent->timer (after => $_[0], interval => $_[1], cb => $_[2])
        }
  
        sub signal($$) {
           AnyEvent->signal (signal => $_[0], cb => $_[1])
        }
  
        sub child($$) {
           AnyEvent->child (pid => $_[0], cb => $_[1])
        }
  
        sub idle($) {
           AnyEvent->idle (cb => $_[0]);
        }
  
        sub cv(;&) {
           AnyEvent->condvar (@_ ? (cb => $_[0]) : ())
        }
  
        sub now() {
           AnyEvent->now
        }
  
        sub now_update() {
           AnyEvent->now_update
        }
  
        sub time() {
           AnyEvent->time
        }
  
        *postpone = \&AnyEvent::postpone;
        *log      = \&AnyEvent::log;
     };
  die if$@;
  }
  BEGIN{_reset}
  package AnyEvent::Base;
  sub time{
  eval q{ # poor man's autoloading {}
        # probe for availability of Time::HiRes
        if (eval "use Time::HiRes (); Time::HiRes::time (); 1") {
           *time     = sub { Time::HiRes::time () };
           *AE::time = \&    Time::HiRes::time     ;
           *now      = \&time;
           AnyEvent::log 8 => "using Time::HiRes for sub-second timing accuracy.";
           # if (eval "use POSIX (); (POSIX::times())...
        } else {
           *time     = sub   { CORE::time };
           *AE::time = sub (){ CORE::time };
           *now      = \&time;
           AnyEvent::log 3 => "Using built-in time(), no sub-second resolution!";
        }
     };
  die if$@;
  &time
  }
  *now=\&time;
  sub now_update{}
  sub _poll{
  Carp::croak"$AnyEvent::MODEL does not support blocking waits. Caught";
  }
  sub condvar{
  eval q{ # poor man's autoloading {}
        *condvar = sub {
           bless { @_ == 3 ? (_ae_cb => $_[2]) : () }, "AnyEvent::CondVar"
        };
  
        *AE::cv = sub (;&) {
           bless { @_ ? (_ae_cb => shift) : () }, "AnyEvent::CondVar"
        };
     };
  die if$@;
  &condvar
  }
  our$HAVE_ASYNC_INTERRUPT;
  sub _have_async_interrupt(){
  $HAVE_ASYNC_INTERRUPT=1*(!$ENV{PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT}&&eval"use Async::Interrupt 1.02 (); 1")
    unless defined$HAVE_ASYNC_INTERRUPT;
  $HAVE_ASYNC_INTERRUPT
  }
  our($SIGPIPE_R,$SIGPIPE_W,%SIG_CB,%SIG_EV,$SIG_IO);
  our(%SIG_ASY,%SIG_ASY_W);
  our($SIG_COUNT,$SIG_TW);
  sub _sig_add(){
  unless($SIG_COUNT++){
  my$NOW=AE::now;
  $SIG_TW=AE::timer$MAX_SIGNAL_LATENCY - ($NOW-int$NOW),$MAX_SIGNAL_LATENCY,sub{};
  }
  }
  sub _sig_del{
  undef$SIG_TW
    unless --$SIG_COUNT;
  }
  our$_sig_name_init;
  $_sig_name_init=sub{
  eval q{ # poor man's autoloading {}
        undef $_sig_name_init;
  
        if (_have_async_interrupt) {
           *sig2num  = \&Async::Interrupt::sig2num;
           *sig2name = \&Async::Interrupt::sig2name;
        } else {
           require Config;
  
           my %signame2num;
           @signame2num{ split ' ', $Config::Config{sig_name} }
                          = split ' ', $Config::Config{sig_num};
  
           my @signum2name;
           @signum2name[values %signame2num] = keys %signame2num;
  
           *sig2num = sub($) {
              $_[0] > 0 ? shift : $signame2num{+shift}
           };
           *sig2name = sub ($) {
              $_[0] > 0 ? $signum2name[+shift] : shift
           };
        }
     };
  die if$@;
  };
  sub sig2num ($){&$_sig_name_init;&sig2num}
  sub sig2name($){&$_sig_name_init;&sig2name}
  sub signal{
  eval q{ # poor man's autoloading {}
        # probe for availability of Async::Interrupt 
        if (_have_async_interrupt) {
           AnyEvent::log 8 => "Using Async::Interrupt for race-free signal handling.";
  
           $SIGPIPE_R = new Async::Interrupt::EventPipe;
           $SIG_IO = AE::io $SIGPIPE_R->fileno, 0, \&_signal_exec;
  
        } else {
           AnyEvent::log 8 => "Using emulated perl signal handling with latency timer.";
  
           if (AnyEvent::WIN32) {
              require AnyEvent::Util;
  
              ($SIGPIPE_R, $SIGPIPE_W) = AnyEvent::Util::portable_pipe ();
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_R, 1) if $SIGPIPE_R;
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_W, 1) if $SIGPIPE_W; # just in case
           } else {
              pipe $SIGPIPE_R, $SIGPIPE_W;
              fcntl $SIGPIPE_R, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_R;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_W; # just in case
  
              # not strictly required, as $^F is normally 2, but let's make sure...
              fcntl $SIGPIPE_R, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
           }
  
           $SIGPIPE_R
              or Carp::croak "AnyEvent: unable to create a signal reporting pipe: $!\n";
  
           $SIG_IO = AE::io $SIGPIPE_R, 0, \&_signal_exec;
        }
  
        *signal = $HAVE_ASYNC_INTERRUPT
           ? sub {
                my (undef, %arg) = @_;
  
                # async::interrupt
                my $signal = sig2num $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG_ASY{$signal} ||= new Async::Interrupt
                   cb             => sub { undef $SIG_EV{$signal} },
                   signal         => $signal,
                   pipe           => [$SIGPIPE_R->filenos],
                   pipe_autodrain => 0,
                ;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
           : sub {
                my (undef, %arg) = @_;
  
                # pure perl
                my $signal = sig2name $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG{$signal} ||= sub {
                   local $!;
                   syswrite $SIGPIPE_W, "\x00", 1 unless %SIG_EV;
                   undef $SIG_EV{$signal};
                };
  
                # can't do signal processing without introducing races in pure perl,
                # so limit the signal latency.
                _sig_add;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
        ;
  
        *AnyEvent::Base::signal::DESTROY = sub {
           my ($signal, $cb) = @{$_[0]};
  
           _sig_del;
  
           delete $SIG_CB{$signal}{$cb};
  
           $HAVE_ASYNC_INTERRUPT
              ? delete $SIG_ASY{$signal}
              : # delete doesn't work with older perls - they then
                # print weird messages, or just unconditionally exit
                # instead of getting the default action.
                undef $SIG{$signal}
              unless keys %{ $SIG_CB{$signal} };
        };
  
        *_signal_exec = sub {
           $HAVE_ASYNC_INTERRUPT
              ? $SIGPIPE_R->drain
              : sysread $SIGPIPE_R, (my $dummy), 9;
  
           while (%SIG_EV) {
              for (keys %SIG_EV) {
                 delete $SIG_EV{$_};
                 &$_ for values %{ $SIG_CB{$_} || {} };
              }
           }
        };
     };
  die if$@;
  &signal
  }
  our%PID_CB;
  our$CHLD_W;
  our$CHLD_DELAY_W;
  sub _emit_childstatus($$){
  my(undef,$rpid,$rstatus)=@_;
  $_->($rpid,$rstatus)
    for values%{$PID_CB{$rpid}||{}},
    values%{$PID_CB{0}||{}};
  }
  sub child{
  eval q{ # poor man's autoloading {}
        *_sigchld = sub {
           my $pid;
  
           AnyEvent->_emit_childstatus ($pid, $?)
              while ($pid = waitpid -1, WNOHANG) > 0;
        };
  
        *child = sub {
           my (undef, %arg) = @_;
  
           my $pid = $arg{pid};
           my $cb  = $arg{cb};
  
           $PID_CB{$pid}{$cb+0} = $cb;
  
           unless ($CHLD_W) {
              $CHLD_W = AE::signal CHLD => \&_sigchld;
              # child could be a zombie already, so make at least one round
              &_sigchld;
           }
  
           bless [$pid, $cb+0], "AnyEvent::Base::child"
        };
  
        *AnyEvent::Base::child::DESTROY = sub {
           my ($pid, $icb) = @{$_[0]};
  
           delete $PID_CB{$pid}{$icb};
           delete $PID_CB{$pid} unless keys %{ $PID_CB{$pid} };
  
           undef $CHLD_W unless keys %PID_CB;
        };
     };
  die if$@;
  &child
  }
  sub idle{
  eval q{ # poor man's autoloading {}
        *idle = sub {
           my (undef, %arg) = @_;
  
           my ($cb, $w, $rcb) = $arg{cb};
  
           $rcb = sub {
              if ($cb) {
                 $w = AE::time;
                 &$cb;
                 $w = AE::time - $w;
  
                 # never use more then 50% of the time for the idle watcher,
                 # within some limits
                 $w = 0.0001 if $w < 0.0001;
                 $w = 5      if $w > 5;
  
                 $w = AE::timer $w, 0, $rcb;
              } else {
                 # clean up...
                 undef $w;
                 undef $rcb;
              }
           };
  
           $w = AE::timer 0.05, 0, $rcb;
  
           bless \\$cb, "AnyEvent::Base::idle"
        };
  
        *AnyEvent::Base::idle::DESTROY = sub {
           undef $${$_[0]};
        };
     };
  die if$@;
  &idle
  }
  package AnyEvent::CondVar;
  our@ISA=AnyEvent::CondVar::Base::;
  sub new{
  my$class=shift;
  bless AnyEvent->condvar(@_),$class
  }
  package AnyEvent::CondVar::Base;
  ${"AnyEvent::CondVar::Base::OVERLOAD"}{dummy}++;
  *{'AnyEvent::CondVar::Base::()'}=sub{};
  *{'AnyEvent::CondVar::Base::(&{}'}=sub{
  my$self=shift;
  sub{$self->send(@_)}
  };
  ${'AnyEvent::CondVar::Base::()'}=1;
  our$WAITING;
  sub _send{
  }
  sub _wait{
  AnyEvent->_poll until$_[0]{_ae_sent};
  }
  sub send{
  my$cv=shift;
  $cv->{_ae_sent}=[@_];
  (delete$cv->{_ae_cb})->($cv)if$cv->{_ae_cb};
  $cv->_send;
  }
  sub croak{
  $_[0]{_ae_croak}=$_[1];
  $_[0]->send;
  }
  sub ready{
  $_[0]{_ae_sent}
  }
  sub recv{
  unless($_[0]{_ae_sent}){
  $WAITING
    and Carp::croak"AnyEvent::CondVar: recursive blocking wait attempted";
  local$WAITING=1;
  $_[0]->_wait;
  }
  $_[0]{_ae_croak}
    and Carp::croak$_[0]{_ae_croak};
  wantarray
    ?@{$_[0]{_ae_sent}}
    :$_[0]{_ae_sent}[0]
  }
  sub cb{
  my$cv=shift;
       @_
    and$cv->{_ae_cb}=shift
    and$cv->{_ae_sent}
    and(delete$cv->{_ae_cb})->($cv);
  $cv->{_ae_cb}
  }
  sub begin{
  ++$_[0]{_ae_counter};
  $_[0]{_ae_end_cb}=$_[1]if@_>1;
  }
  sub end{
  return if --$_[0]{_ae_counter};
  &{
  $_[0]{_ae_end_cb}
    ||sub{$_[0]->send}
  };
  }
  *broadcast=\&send;
  *wait=\&recv;
  undef$SIG{CHLD}
    if$SIG{CHLD}eq 'IGNORE';
  $SIG{PIPE}=sub{}
    unless defined$SIG{PIPE};
  1
ANYEVENT

$fatpacked{"AnyEvent/DNS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_DNS';
  package AnyEvent::DNS;
  use Carp ();
  use Socket qw(AF_INET SOCK_DGRAM SOCK_STREAM);
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use AnyEvent::Util qw(AF_INET6);
  our$VERSION=$AnyEvent::VERSION;
  our@DNS_FALLBACK;
  {
  my$prep=sub{
  $_=$_->[rand@$_]for@_;
  push@_,splice@_,rand$_,1 for reverse 1..@_;
  $_=pack"H*",$_ for@_;
  \@_
  };
  my$ipv4=$prep->(["08080808","08080404"],);
  my$ipv6=$prep->(["20014860486000000000000000008888","20014860486000000000000000008844"],);
  undef$ipv4 unless$AnyEvent::PROTOCOL{ipv4};
  undef$ipv6 unless$AnyEvent::PROTOCOL{ipv6};
  ($ipv6,$ipv4)=($ipv4,$ipv6)
    if$AnyEvent::PROTOCOL{ipv6}>$AnyEvent::PROTOCOL{ipv4};
  @DNS_FALLBACK=(@$ipv4,@$ipv6);
  }
  sub MAX_PKT(){4096}
  sub DOMAIN_PORT(){53}
  sub resolver ();
  sub a($$){
  my($domain,$cb)=@_;
  resolver->resolve(
  $domain=>"a",
  sub{
  $cb->(map$_->[4],@_);
  }
  );
  }
  sub aaaa($$){
  my($domain,$cb)=@_;
  resolver->resolve(
  $domain=>"aaaa",
  sub{
  $cb->(map$_->[4],@_);
  }
  );
  }
  sub mx($$){
  my($domain,$cb)=@_;
  resolver->resolve(
  $domain=>"mx",
  sub{
  $cb->(map$_->[5],sort{$a->[4]<=>$b->[4]}@_);
  }
  );
  }
  sub ns($$){
  my($domain,$cb)=@_;
  resolver->resolve(
  $domain=>"ns",
  sub{
  $cb->(map$_->[4],@_);
  }
  );
  }
  sub txt($$){
  my($domain,$cb)=@_;
  resolver->resolve(
  $domain=>"txt",
  sub{
  $cb->(map$_->[4],@_);
  }
  );
  }
  sub srv($$$$){
  my($service,$proto,$domain,$cb)=@_;
  resolver->resolve(
  "_$service._$proto.$domain"=>"srv",
  sub{
  my@res;
  my%pri;
  push@{$pri{$_->[4]}},[@$_[4,5,6,7]]for@_;
  for my $pri(sort{$a<=>$b}keys%pri){
  my@rr=sort{$a->[1]<=>$b->[1]}@{delete$pri{$pri}};
  my$sum;
  $sum+=$_->[1]for@rr;
  while(@rr){
  my$w=int rand$sum+1;
  for(0..$#rr){
  if(($w-=$rr[$_][1])<=0){
  $sum-=$rr[$_][1];
  push@res,splice@rr,$_,1,();
  last;
  }
  }
  }
  }
  $cb->(@res);
  }
  );
  }
  sub ptr($$){
  my($domain,$cb)=@_;
  resolver->resolve(
  $domain=>"ptr",
  sub{
  $cb->(map$_->[4],@_);
  }
  );
  }
  sub any($$){
  my($domain,$cb)=@_;
  resolver->resolve($domain=>"*",$cb);
  }
  sub _munge_ptr($){
  my$ipn=$_[0]
    or return;
  my$ptr;
  my$af=AnyEvent::Socket::address_family($ipn);
  if($af==AF_INET6){
  $ipn=substr$ipn,0,16;
  if($ipn=~s/^\x00{10}(?:\xff\xff|\x00\x00)//){
  $af=AF_INET;
  }
  else{
  $ptr=join".",(reverse split//,unpack"H32",$ipn),"ip6.arpa.";
  }
  }
  if($af==AF_INET){
  $ptr=join".",(reverse unpack"C4",$ipn),"in-addr.arpa.";
  }
  $ptr
  }
  sub reverse_lookup($$){
  my($ip,$cb)=@_;
  $ip=_munge_ptr AnyEvent::Socket::parse_address($ip)
    or return$cb->();
  resolver->resolve(
  $ip=>"ptr",
  sub{
  $cb->(map$_->[4],@_);
  }
  );
  }
  sub reverse_verify($$){
  my($ip,$cb)=@_;
  my$ipn=AnyEvent::Socket::parse_address($ip)
    or return$cb->();
  my$af=AnyEvent::Socket::address_family($ipn);
  my@res;
  my$cnt;
  my$ptr=_munge_ptr$ipn
    or return$cb->();
  $ip=AnyEvent::Socket::format_address($ipn);
  ptr$ptr,sub{
  for my $name(@_){
  ++$cnt;
  resolver->resolve(
  "$name."=>($af==(AF_INET)?"a":"aaaa"),
  sub{
  for(@_){
  push@res,$name
    if$_->[4]eq$ip;
  }
  $cb->(@res)unless --$cnt;
  }
  );
  }
  $cb->()unless$cnt;
  };
  }
  our$EDNS0=$ENV{PERL_ANYEVENT_EDNS0}*1;
  our%opcode_id=(
  query=>0,
  iquery=>1,
  status=>2,
  notify=>4,
  update=>5,
  map+($_=>$_),3,6..15
  );
  our%opcode_str=reverse%opcode_id;
  our%rcode_id=(
  noerror=>0,
  formerr=>1,
  servfail=>2,
  nxdomain=>3,
  notimp=>4,
  refused=>5,
  yxdomain=>6,
  yxrrset=>7,
  nxrrset=>8,
  notauth=>9,
  notzone=>10,
  map+($_=>$_),11..15
  );
  our%rcode_str=reverse%rcode_id;
  our%type_id=(
  a=>1,
  ns=>2,
  md=>3,
  mf=>4,
  cname=>5,
  soa=>6,
  mb=>7,
  mg=>8,
  mr=>9,
  null=>10,
  wks=>11,
  ptr=>12,
  hinfo=>13,
  minfo=>14,
  mx=>15,
  txt=>16,
  sig=>24,
  key=>25,
  gpos=>27,
  aaaa=>28,
  loc=>29,
  srv=>33,
  naptr=>35,
  dname=>39,
  opt=>41,
  ds=>43,
  sshfp=>44,
  rrsig=>46,
  nsec=>47,
  dnskey=>48,
  smimea=>53,
  cds=>59,
  cdnskey=>60,
  openpgpkey=>61,
  csync=>62,
  spf=>99,
  tkey=>249,
  tsig=>250,
  ixfr=>251,
  axfr=>252,
  mailb=>253,
  "*"=>255,
  uri=>256,
  );
  our%type_str=reverse%type_id;
  our%class_id=(
  in=>1,
  ch=>3,
  hs=>4,
  none=>254,
  "*"=>255,
  );
  our%class_str=reverse%class_id;
  sub _enc_name($){
  pack"(C/a*)*",(split/\./,shift),""
  }
  if($]<5.008){
  *_enc_name=sub ($){
  join"",map+(pack"C/a*",$_),(split/\./,shift),""
  };
  }
  sub _enc_qd(){
  (_enc_name$_->[0]).pack"nn",($_->[1]>0?$_->[1]:$type_id{$_->[1]}),($_->[3]>0?$_->[2]:$class_id{$_->[2]||"in"})
  }
  sub _enc_rr(){
  die"encoding of resource records is not supported";
  }
  sub dns_pack($){
  my($req)=@_;
  pack"nn nnnn a* a* a* a* a*",$req->{id},!!$req->{qr}*0x8000+$opcode_id{$req->{op}}*0x0800+!!$req->{aa}*0x0400+!!$req->{tc}*0x0200+!!$req->{rd}*0x0100+!!$req->{ra}*0x0080+!!$req->{ad}*0x0020+!!$req->{cd}*0x0010+$rcode_id{$req->{rc}}*0x0001,scalar@{$req->{qd}||[]},scalar@{$req->{an}||[]},scalar@{$req->{ns}||[]},$EDNS0+scalar@{$req->{ar}||[]},(join"",map _enc_qd,@{$req->{qd}||[]}),(join"",map _enc_rr,@{$req->{an}||[]}),(join"",map _enc_rr,@{$req->{ns}||[]}),(join"",map _enc_rr,@{$req->{ar}||[]}),($EDNS0?pack"C nnNn",0,41,MAX_PKT,0,0:"")
  }
  our$ofs;
  our$pkt;
  sub _dec_name{
  my@res;
  my$redir;
  my$ptr=$ofs;
  my$cnt;
  while(){
  return undef if ++$cnt>=256;
  my$len=ord substr$pkt,$ptr++,1;
  if($len>=0xc0){
  $ptr++;
  $ofs=$ptr if$ptr>$ofs;
  $ptr=(unpack"n",substr$pkt,$ptr-2,2)&0x3fff;
  }
  elsif($len){
  push@res,substr$pkt,$ptr,$len;
  $ptr+=$len;
  }
  else{
  $ofs=$ptr if$ptr>$ofs;
  return join".",@res;
  }
  }
  }
  sub _dec_qd{
  my$qname=_dec_name;
  my($qt,$qc)=unpack"nn",substr$pkt,$ofs;
  $ofs+=4;
  [$qname,$type_str{$qt}||$qt,$class_str{$qc}||$qc]
  }
  our%dec_rr=(
  1=>sub{join".",unpack"C4",$_},
  2=>sub{local$ofs=$ofs-length;_dec_name},
  5=>sub{local$ofs=$ofs-length;_dec_name},
  6=>sub{
  local$ofs=$ofs-length;
  my$mname=_dec_name;
  my$rname=_dec_name;
  ($mname,$rname,unpack"NNNNN",substr$pkt,$ofs)
  },
  11=>sub{((join".",unpack"C4",$_),unpack"C a*",substr$_,4)},
  12=>sub{local$ofs=$ofs-length;_dec_name},
  13=>sub{unpack"C/a* C/a*",$_},
  15=>sub{local$ofs=$ofs+2-length;((unpack"n",$_),_dec_name)},
  16=>sub{unpack"(C/a*)*",$_},
  28=>sub{AnyEvent::Socket::format_ipv6($_)},
  33=>sub{local$ofs=$ofs+6-length;((unpack"nnn",$_),_dec_name)},
  35=>sub{
  my($order,$preference,$flags,$service,$regexp,$offset)=unpack"nn C/a* C/a* C/a* .",$_;
  local$ofs=$ofs+$offset-length;
  ($order,$preference,$flags,$service,$regexp,_dec_name)
  },
  39=>sub{local$ofs=$ofs-length;_dec_name},
  99=>sub{unpack"(C/a*)*",$_},
  );
  sub _dec_rr{
  my$name=_dec_name;
  my($rt,$rc,$ttl,$rdlen)=unpack"nn N n",substr$pkt,$ofs;
  $ofs+=10;
  local$_=substr$pkt,$ofs,$rdlen;
  $ofs+=$rdlen;
  [$name,$type_str{$rt}||$rt,$class_str{$rc}||$rc,$ttl,($dec_rr{$rt}||sub{$_})->(),]
  }
  sub dns_unpack($){
  local$pkt=shift;
  my($id,$flags,$qd,$an,$ns,$ar)=unpack"nn nnnn A*",$pkt;
  local$ofs=6*2;
  {
  id=>$id,
  qr=>!!($flags&0x8000),
  aa=>!!($flags&0x0400),
  tc=>!!($flags&0x0200),
  rd=>!!($flags&0x0100),
  ra=>!!($flags&0x0080),
  ad=>!!($flags&0x0020),
  cd=>!!($flags&0x0010),
  op=>$opcode_str{($flags&0x001e)>>11},
  rc=>$rcode_str{($flags&0x000f)},
  qd=>[map _dec_qd,1..$qd],
  an=>[map _dec_rr,1..$an],
  ns=>[map _dec_rr,1..$ns],
  ar=>[map _dec_rr,1..$ar],
  }
  }
  use Carp ();
  use Scalar::Util ();
  use Socket ();
  our$NOW;
  our$RESOLVER;
  sub resolver(){
  $RESOLVER||do{
  $RESOLVER=new AnyEvent::DNS
    untaint=>1,
    max_outstanding=>$ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}*1||10,
    ;
  $ENV{PERL_ANYEVENT_RESOLV_CONF}
    ?$RESOLVER->_load_resolv_conf_file($ENV{PERL_ANYEVENT_RESOLV_CONF})
    :$RESOLVER->os_config;
  $RESOLVER
  }
  }
  sub new{
  my($class,%arg)=@_;
  my$self=bless{
  server=>[],
  timeout=>[2,5,5],
  search=>[],
  ndots=>1,
  max_outstanding=>10,
  reuse=>300,
  %arg,
  inhibit=>0,
  reuse_q=>[],
  },$class;
  my$got_socket;
  Scalar::Util::weaken(my$wself=$self);
  if(socket my$fh4,AF_INET,Socket::SOCK_DGRAM(),0){
  ++$got_socket;
  AnyEvent::fh_unblock$fh4;
  $self->{fh4}=$fh4;
  $self->{rw4}=AE::io$fh4,0,sub{
  if(my$peer=recv$fh4,my$pkt,MAX_PKT,0){
  $wself->_recv($pkt,$peer);
  }
  };
  }
  if(AF_INET6&&socket my$fh6,AF_INET6,Socket::SOCK_DGRAM(),0){
  ++$got_socket;
  $self->{fh6}=$fh6;
  AnyEvent::fh_unblock$fh6;
  $self->{rw6}=AE::io$fh6,0,sub{
  if(my$peer=recv$fh6,my$pkt,MAX_PKT,0){
  $wself->_recv($pkt,$peer);
  }
  };
  }
  $got_socket
    or Carp::croak"unable to create either an IPv4 or an IPv6 socket";
  $self->_compile;
  $self
  }
  sub _config_begin{
  ++$_[0]{inhibit};
  }
  sub _config_done{
  --$_[0]{inhibit};
  $_[0]->_compile;
  $_[0]->_scheduler;
  }
  sub parse_resolv_conf{
  my($self,$resolvconf)=@_;
  $self->{server}=[];
  $self->{search}=[];
  my$attempts;
  for(split/\n/,$resolvconf){
  s/\s*[;#].*$//;
  if(/^\s*nameserver\s+(\S+)\s*$/i){
  my$ip=$1;
  if(my$ipn=AnyEvent::Socket::parse_address($ip)){
  push@{$self->{server}},$ipn;
  }
  else{
  AE::log 5=>"nameserver $ip invalid and ignored, while parsing resolver config.";
  }
  }
  elsif(/^\s*domain\s+(\S*)\s*$/i){
  $self->{search}=[$1];
  }
  elsif(/^\s*search\s+(.*?)\s*$/i){
  $self->{search}=[split/\s+/,$1];
  }
  elsif(/^\s*sortlist\s+(.*?)\s*$/i){
  }
  elsif(/^\s*options\s+(.*?)\s*$/i){
  for(split/\s+/,$1){
  if(/^timeout:(\d+)$/){
  $self->{timeout}=[$1];
  }
  elsif(/^attempts:(\d+)$/){
  $attempts=$1;
  }
  elsif(/^ndots:(\d+)$/){
  $self->{ndots}=$1;
  }
  else{
  }
  }
  }
  else{
  }
  }
  $self->{timeout}=[($self->{timeout}[0])x$attempts]
    if$attempts;
  $self->_compile;
  }
  sub _load_resolv_conf_file{
  my($self,$resolv_conf)=@_;
  $self->_config_begin;
  require AnyEvent::IO;
  AnyEvent::IO::aio_load(
  $resolv_conf,
  sub{
  if(my($contents)=@_){
  $self->parse_resolv_conf($contents);
  }
  else{
  AE::log 4=>"$resolv_conf: $!";
  }
  $self->_config_done;
  }
  );
  }
  sub os_config{
  my($self)=@_;
  $self->_config_begin;
  $self->{server}=[];
  $self->{search}=[];
  if((AnyEvent::WIN32||$^O=~/cygwin/i)){
  unless(
  eval{
  require Net::DNS::Resolver;
  my$r=Net::DNS::Resolver->new;
  $r->nameservers
    or die;
  for my $s($r->nameservers){
  if(my$ipn=AnyEvent::Socket::parse_address($s)){
  push@{$self->{server}},$ipn;
  }
  }
  $self->{search}=[$r->searchlist];
  1
  }
    )
  {
  if(open my$fh,"ipconfig /all |"){
  my$dns;
  local$_;
  while(<$fh>){
  if(s/^\s.*\bdns\b.*://i){
  $dns=1;
  }
  elsif(/^\S/||/^\s[^:]{16,}: /){
  $dns=0;
  }
  if($dns&&/^\s*(\S+)\s*$/){
  my$s=$1;
  $s=~s/%\d+(?!\S)//;
  if(my$ipn=AnyEvent::Socket::parse_address($s)){
  push@{$self->{server}},$ipn;
  }
  else{
  push@{$self->{search}},$s;
  }
  }
  }
  }
  }
  push@{$self->{server}},@DNS_FALLBACK;
  $self->_config_done;
  }
  else{
  require AnyEvent::IO;
  AnyEvent::IO::aio_stat(
  "/etc/resolv.conf",
  sub{
  $self->_load_resolv_conf_file("/etc/resolv.conf")
    if@_;
  $self->_config_done;
  }
  );
  }
  }
  sub timeout{
  my($self,@timeout)=@_;
  $self->{timeout}=\@timeout;
  $self->_compile;
  }
  sub max_outstanding{
  my($self,$max)=@_;
  $self->{max_outstanding}=$max;
  $self->_compile;
  }
  sub _compile{
  my$self=shift;
  my%search;
  $self->{search}=[grep 0<length,grep!$search{$_}++,@{$self->{search}}];
  my%server;
  $self->{server}=[grep 0<length,grep!$server{$_}++,@{$self->{server}}];
  unless(@{$self->{server}}){
  my$default=$AnyEvent::PROTOCOL{ipv6}>$AnyEvent::PROTOCOL{ipv4}?"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1":"\x7f\x00\x00\x01";
  $self->{server}=[$default,@DNS_FALLBACK];
  }
  my@retry;
  for my $timeout(@{$self->{timeout}}){
  for my $server(@{$self->{server}}){
  push@retry,[$server,$timeout];
  }
  }
  $self->{retry}=\@retry;
  }
  sub _feed{
  my($self,$res)=@_;
  ($res)=$res=~/^(.*)$/s
    if AnyEvent::TAINT&&$self->{untaint};
  $res=dns_unpack$res
    or return;
  my$id=$self->{id}{$res->{id}};
  return unless ref$id;
  $NOW=time;
  $id->[1]->($res);
  }
  sub _recv{
  my($self,$pkt,$peer)=@_;
  my($port,$host)=AnyEvent::Socket::unpack_sockaddr($peer);
  return unless$port==DOMAIN_PORT&&grep$_ eq$host,@{$self->{server}};
  $self->_feed($pkt);
  }
  sub _free_id{
  my($self,$id,$timeout)=@_;
  if($timeout){
  $self->{id}{$id}=1;
  push@{$self->{reuse_q}},[$NOW+$self->{reuse},$id];
  }
  else{
  delete$self->{id}{$id};
  }
  --$self->{outstanding};
  $self->_scheduler;
  }
  sub _exec{
  my($self,$req)=@_;
  my$retry;
  my$do_retry;
  $do_retry=sub{
  my$retry_cfg=$self->{retry}[$retry++]
    or do{
  $self->_free_id($req->[2],$retry>1);
  undef$do_retry;
  return$req->[1]->();
    };
  my($server,$timeout)=@$retry_cfg;
  $self->{id}{$req->[2]}=[
  (
  AE::timer$timeout,
  0,
  sub{
  $NOW=time;
  &$do_retry if$do_retry;
  }
  ),
  sub{
  my($res)=@_;
  if($res->{tc}){
  AnyEvent::Socket::tcp_connect(
  AnyEvent::Socket::format_address($server),
  DOMAIN_PORT,
  sub{
  return unless$do_retry;
  my($fh)=@_
    or return&$do_retry;
  require AnyEvent::Handle;
  my$handle;
  $handle=new AnyEvent::Handle
    fh=>$fh,
    timeout=>$timeout,
    on_error=>sub{
  undef$handle;
  return unless$do_retry;
  &$do_retry;
    };
  $handle->push_write(pack"n/a*",$req->[0]);
  $handle->push_read(
  chunk=>2,
  sub{
  $handle->unshift_read(
  chunk=>(unpack"n",$_[1]),
  sub{
  undef$handle;
  $self->_feed($_[1]);
  }
  );
  }
  );
  },
  sub{$timeout}
  );
  }
  else{
  $self->_free_id($req->[2],$retry>1);
  undef$do_retry;
  return$req->[1]->($res);
  }
  }
  ];
  my$sa=AnyEvent::Socket::pack_sockaddr(DOMAIN_PORT,$server);
  my$fh=AF_INET==AnyEvent::Socket::sockaddr_family($sa)?$self->{fh4}:$self->{fh6}
    or return&$do_retry;
  send$fh,$req->[0],0,$sa;
  };
  &$do_retry;
  }
  sub _scheduler{
  my($self)=@_;
  return if$self->{inhibit};
  $NOW=time;
  delete$self->{id}{(shift@{$self->{reuse_q}})->[1]}while@{$self->{reuse_q}}&&$self->{reuse_q}[0][0]<=$NOW;
  while($self->{outstanding}<$self->{max_outstanding}){
  if(@{$self->{reuse_q}}>=30000){
  $self->{reuse_to}||=AE::timer$self->{reuse_q}[0][0]-$NOW,0,sub{
  delete$self->{reuse_to};
  $self->_scheduler;
  };
  last;
  }
  if(my$req=shift@{$self->{queue}}){
  while(){
  $req->[2]=int rand 65536;
  last unless exists$self->{id}{$req->[2]};
  }
  ++$self->{outstanding};
  $self->{id}{$req->[2]}=1;
  substr$req->[0],0,2,pack"n",$req->[2];
  $self->_exec($req);
  }
  elsif(my$cb=shift@{$self->{wait}}){
  $cb->($self);
  }
  else{
  last;
  }
  }
  }
  sub request($$){
  my($self,$req,$cb)=@_;
  for(@{$req->{qd}}){
  return AE::postpone sub{$cb->(undef)}
    if 255<length$_->[0];
  }
  push@{$self->{queue}},[dns_pack$req,$cb];
  $self->_scheduler;
  }
  sub resolve($%){
  my$cb=pop;
  my($self,$qname,$qtype,%opt)=@_;
  $self->wait_for_slot(
  sub{
  my$self=shift;
  my@search=
     $qname=~s/\.$//?""
    :$opt{search}?@{$opt{search}}
    :($qname=~y/.//)>=$self->{ndots}?("",@{$self->{search}})
    :(@{$self->{search}},"");
  my$class=$opt{class}||"in";
  my%atype=
    $opt{accept}
    ?map+($_=>1),@{$opt{accept}}
    :($qtype=>1);
  my($do_search,$do_req);
  $do_search=sub{
  @search
    or(undef$do_search),(undef$do_req),return$cb->();
  (my$name=lc"$qname.".shift@search)=~s/\.$//;
  my$depth=10;
  $do_req=sub{
  $self->request(
  {
  rd=>1,
  qd=>[[$name,$qtype,$class]],
  },
  sub{
  my($res)=@_
    or return$do_search->();
  my$cname;
  while(){
  my@rr=grep$name eq lc$_->[0]&&($atype{"*"}||$atype{$_->[1]}),@{$res->{an}};
  (undef$do_search),(undef$do_req),return$cb->(@rr)
    if@rr;
  my@rr=grep$name eq lc$_->[0]&&$_->[1]eq"cname",@{$res->{an}};
  if(@rr){
  $depth--
    or return$do_search->();
  $cname=1;
  $name=lc$rr[0][4];
  }
  elsif($cname){
  return$do_req->();
  }
  else{
  return$do_search->();
  }
  }
  }
  );
  };
  $do_req->();
  };
  $do_search->();
  }
  );
  }
  sub wait_for_slot{
  my($self,$cb)=@_;
  push@{$self->{wait}},$cb;
  $self->_scheduler;
  }
  use AnyEvent::Socket ();
  1
ANYEVENT_DNS

$fatpacked{"AnyEvent/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_HTTP';
  package AnyEvent::HTTP;
  use common::sense;
  use Errno ();
  use AnyEvent 5.0 ();
  use AnyEvent::Util ();
  use AnyEvent::Handle ();
  use base Exporter::;
  our$VERSION=2.24;
  our@EXPORT=qw(http_get http_post http_head http_request);
  our$USERAGENT="Mozilla/5.0 (compatible; U; AnyEvent-HTTP/$VERSION; +http://software.schmorp.de/pkg/AnyEvent)";
  our$MAX_RECURSE=10;
  our$PERSISTENT_TIMEOUT=3;
  our$TIMEOUT=300;
  our$MAX_PER_HOST=4;
  our$PROXY;
  our$ACTIVE=0;
  my%KA_CACHE;
  my%CO_SLOT;
  sub _slot_schedule;
  sub _slot_schedule($){
  my$host=shift;
  while($CO_SLOT{$host}[0]<$MAX_PER_HOST){
  if(my$cb=shift@{$CO_SLOT{$host}[1]}){
  ++$CO_SLOT{$host}[0];
  ++$ACTIVE;
  $cb->(
  AnyEvent::Util::guard{
  --$ACTIVE;
  --$CO_SLOT{$host}[0];
  _slot_schedule$host;
  }
  );
  }
  else{
  delete$CO_SLOT{$host}unless$CO_SLOT{$host}[0];
  last;
  }
  }
  }
  sub _get_slot($$){
  push@{$CO_SLOT{$_[0]}[1]},$_[1];
  _slot_schedule$_[0];
  }
  sub cookie_jar_expire($;$){
  my($jar,$session_end)=@_;
  %$jar=()if$jar->{version}!=2;
  my$anow=AE::now;
  while(my($chost,$paths)=each%$jar){
  next unless ref$paths;
  while(my($cpath,$cookies)=each%$paths){
  while(my($cookie,$kv)=each%$cookies){
  if(exists$kv->{_expires}){
  delete$cookies->{$cookie}
    if$anow>$kv->{_expires};
  }
  elsif($session_end){
  delete$cookies->{$cookie};
  }
  }
  delete$paths->{$cpath}
    unless%$cookies;
  }
  delete$jar->{$chost}
    unless%$paths;
  }
  }
  sub cookie_jar_extract($$$$){
  my($jar,$scheme,$host,$path)=@_;
  %$jar=()if$jar->{version}!=2;
  $host=AnyEvent::Util::idn_to_ascii$host
    if$host=~/[^\x00-\x7f]/;
  my@cookies;
  while(my($chost,$paths)=each%$jar){
  next unless ref$paths;
  $chost eq$host
    or".$chost" eq substr$host,-1-length$chost
    or next;
  while(my($cpath,$cookies)=each%$paths){
  next unless$cpath eq substr$path,0,length$cpath;
  while(my($cookie,$kv)=each%$cookies){
  next if$scheme ne"https"&&exists$kv->{secure};
  if(exists$kv->{_expires}and AE::now>$kv->{_expires}){
  delete$cookies->{$cookie};
  next;
  }
  my$value=$kv->{value};
  if($value=~/[=;,[:space:]]/){
  $value=~s/([\\"])/\\$1/g;
  $value="\"$value\"";
  }
  push@cookies,"$cookie=$value";
  }
  }
  }
  \@cookies
  }
  sub cookie_jar_set_cookie($$$$){
  my($jar,$set_cookie,$host,$date)=@_;
  %$jar=()if$jar->{version}!=2;
  my$anow=int AE::now;
  my$snow;
  for($set_cookie){
  my@kv;
  while(
  m{
              \G\s*
              (?:
                 expires \s*=\s* ([A-Z][a-z][a-z]+,\ [^,;]+)
                 | ([^=;,[:space:]]+) (?: \s*=\s* (?: "((?:[^\\"]+|\\.)*)" | ([^;,[:space:]]*) ) )?
              )
           }gcxsi
    )
  {
  my$name=$2;
  my$value=$4;
  if(defined$1){
  $name="expires";
  $value=$1;
  }
  elsif(defined$3){
  $value=$3;
  $value=~s/\\(.)/$1/gs;
  }
  push@kv,@kv?lc$name:$name,$value;
  last unless/\G\s*;/gc;
  }
  last unless@kv;
  my$name=shift@kv;
  my%kv=(value=>shift@kv,@kv);
  if(exists$kv{"max-age"}){
  $kv{_expires}=$anow+delete$kv{"max-age"};
  }
  elsif(exists$kv{expires}){
  $snow||=parse_date($date)||$anow;
  $kv{_expires}=$anow+(parse_date(delete$kv{expires})-$snow);
  }
  else{
  delete$kv{_expires};
  }
  my$cdom;
  my$cpath=(delete$kv{path})||"/";
  if(exists$kv{domain}){
  $cdom=$kv{domain};
  $cdom=~s/^\.?/./;
  next if$cdom=~/\.$/;
  my$ndots=$cdom=~y/.//;
  next if$ndots<($cdom=~/\.[^.][^.]\.[^.][^.]$/?3:2);
  $cdom=substr$cdom,1;
  }
  else{
  $cdom=$host;
  }
  $jar->{version}=2;
  $jar->{lc$cdom}{$cpath}{$name}=\%kv;
  redo if/\G\s*,/gc;
  }
  }
  sub ka_fetch($){
  my$ka_key=shift;
  my$hdl=pop@{$KA_CACHE{$ka_key}};
  delete$KA_CACHE{$ka_key}
    unless@{$KA_CACHE{$ka_key}};
  $hdl
  }
  sub ka_store($$){
  my($ka_key,$hdl)=@_;
  my$kaa=$KA_CACHE{$ka_key}||=[];
  my$destroy=sub{
  my@ka=grep$_!=$hdl,@{$KA_CACHE{$ka_key}};
  $hdl->destroy;
  @ka
    ?$KA_CACHE{$ka_key}=\@ka
    :delete$KA_CACHE{$ka_key};
  };
  $hdl->on_error($destroy);
  $hdl->on_eof($destroy);
  $hdl->on_read($destroy);
  $hdl->timeout($PERSISTENT_TIMEOUT);
  push@$kaa,$hdl;
  shift@$kaa while@$kaa>$MAX_PER_HOST;
  }
  sub _parse_hdr(){
  my%hdr;
  $hdr{lc$1}.=",$2" while/\G
              ([^:\000-\037]*):
              [\011\040]*
              ((?: [^\012]+ | \012[\011\040] )*)
              \012
           /gxc;
  /\G$/
    or return;
  substr$_,0,1,"" for values%hdr;
  \%hdr
  }
  our$qr_nlnl=qr{(?<![^\012])\015?\012};
  our$TLS_CTX_LOW={cache=>1,sslv2=>1};
  our$TLS_CTX_HIGH={cache=>1,verify=>1,verify_peername=>"https"};
  sub _destroy_state(\%){
  my($state)=@_;
  $state->{handle}->destroy if$state->{handle};
  %$state=();
  }
  sub _error(\%$$){
  my($state,$cb,$hdr)=@_;
  &_destroy_state($state);
  $cb->(undef,$hdr);
  ()
  }
  our%IDEMPOTENT=(
  DELETE=>1,
  GET=>1,
  HEAD=>1,
  OPTIONS=>1,
  PUT=>1,
  TRACE=>1,
  ACL=>1,
  "BASELINE-CONTROL"=>1,
  BIND=>1,
  CHECKIN=>1,
  CHECKOUT=>1,
  COPY=>1,
  LABEL=>1,
  LINK=>1,
  MERGE=>1,
  MKACTIVITY=>1,
  MKCALENDAR=>1,
  MKCOL=>1,
  MKREDIRECTREF=>1,
  MKWORKSPACE=>1,
  MOVE=>1,
  ORDERPATCH=>1,
  PROPFIND=>1,
  PROPPATCH=>1,
  REBIND=>1,
  REPORT=>1,
  SEARCH=>1,
  UNBIND=>1,
  UNCHECKOUT=>1,
  UNLINK=>1,
  UNLOCK=>1,
  UPDATE=>1,
  UPDATEREDIRECTREF=>1,
  "VERSION-CONTROL"=>1,
  );
  sub http_request($$@){
  my$cb=pop;
  my($method,$url,%arg)=@_;
  my%hdr;
  $arg{tls_ctx}=$TLS_CTX_LOW  if$arg{tls_ctx}eq"low"||!exists$arg{tls_ctx};
  $arg{tls_ctx}=$TLS_CTX_HIGH if$arg{tls_ctx}eq"high";
  $method=uc$method;
  if(my$hdr=$arg{headers}){
  while(my($k,$v)=each%$hdr){
  $hdr{lc$k}=$v;
  }
  }
  my@pseudo=(URL=>$url);
  push@pseudo,Redirect=>delete$arg{Redirect}if exists$arg{Redirect};
  my$recurse=exists$arg{recurse}?delete$arg{recurse}:$MAX_RECURSE;
  return$cb->(undef,{@pseudo,Status=>599,Reason=>"Too many redirections"})
    if$recurse<0;
  my$proxy=exists$arg{proxy}?$arg{proxy}:$PROXY;
  my$timeout=$arg{timeout}||$TIMEOUT;
  my($uscheme,$uauthority,$upath,$query,undef)=$url=~m|^([^:]+):(?://([^/?#]*))?([^?#]*)(?:(\?[^#]*))?(?:#(.*))?$|;
  $uscheme=lc$uscheme;
  my$uport=
     $uscheme eq"http"?80
    :$uscheme eq"https"?443
    :return$cb->(undef,{@pseudo,Status=>599,Reason=>"Only http and https URL schemes supported"});
  $uauthority=~/^(?: .*\@ )? ([^\@]+?) (?: : (\d+) )?$/x
    or return$cb->(undef,{@pseudo,Status=>599,Reason=>"Unparsable URL"});
  my$uhost=lc$1;
  $uport=$2 if defined$2;
  $hdr{host}=defined$2?"$uhost:$2":"$uhost"
    unless exists$hdr{host};
  $uhost=~s/^\[(.*)\]$/$1/;
  $upath.=$query if length$query;
  $upath=~s%^/?%/%;
  if(my$jar=$arg{cookie_jar}){
  my$cookies=cookie_jar_extract$jar,$uscheme,$uhost,$upath;
  $hdr{cookie}=join"; ",@$cookies
    if@$cookies;
  }
  my($rhost,$rport,$rscheme,$rpath);
  if($proxy){
  ($rpath,$rhost,$rport,$rscheme)=($url,@$proxy);
  $rscheme="http" unless defined$rscheme;
  $rscheme="http" if$uscheme eq"https"&&$rscheme eq"https";
  $rhost=lc$rhost;
  $rscheme=lc$rscheme;
  }
  else{
  ($rhost,$rport,$rscheme,$rpath)=($uhost,$uport,$uscheme,$upath);
  }
  $hdr{referer}="$uscheme://$uauthority$upath" unless exists$hdr{referer};
  $hdr{"user-agent"}=$USERAGENT                     unless exists$hdr{"user-agent"};
  $hdr{"content-length"}=length$arg{body}
    if length$arg{body}||$method ne"GET";
  my$idempotent=$IDEMPOTENT{$method};
  my$persistent=exists$arg{persistent}?!!$arg{persistent}:$idempotent;
  my$keepalive=exists$arg{keepalive}?!!$arg{keepalive}:!$proxy;
  my$was_persistent;
  my$ka_key="$uscheme\x00$uhost\x00$uport\x00$arg{sessionid}";
  $hdr{connection}=($persistent?$keepalive?"keep-alive, ":"":"close, ")."Te";
  $hdr{te}="trailers" unless exists$hdr{te};
  my%state=(connect_guard=>1);
  my$ae_error=595;
  my$handle_actual_request=sub{
  $ae_error=596;
  my$hdl=$state{handle};
  $hdl->starttls("connect")if$uscheme eq"https"&&!exists$hdl->{tls};
  $hdl->push_write("$method $rpath HTTP/1.1\015\012".(join"",map"\u$_: $hdr{$_}\015\012",grep defined$hdr{$_},keys%hdr)."\015\012".$arg{body});
  return unless%state;
  %hdr=();
  $state{read_response}=sub{
  return unless%state;
  for("$_[1]"){
  y/\015//d;
  /^HTTP\/0*([0-9\.]+) \s+ ([0-9]{3}) (?: \s+ ([^\012]*) )? \012/gxci
    or return _error%state,$cb,{@pseudo,Status=>599,Reason=>"Invalid server response"};
  return$state{handle}->push_read(line=>$qr_nlnl,$state{read_response})
    if$2 eq 100;
  push@pseudo,
    HTTPVersion=>$1,
    Status=>$2,
    Reason=>$3,
    ;
  my$hdr=_parse_hdr
    or return _error%state,$cb,{@pseudo,Status=>599,Reason=>"Garbled response headers"};
  %hdr=(%$hdr,@pseudo);
  }
  if(exists$hdr{location}){
  my$loc=$hdr{location};
  if($loc=~m%^//%){
  $loc="$uscheme:$loc";
  }
  elsif($loc eq""){
  $loc=$url;
  }
  elsif($loc!~/^(?: $ | [^:\/?\#]+ : )/x){
  $loc=~s/^\.\/+//;
  if($loc!~m%^[.?#]%){
  my$prefix="$uscheme://$uauthority";
  unless($loc=~s/^\///){
  $prefix.=$upath;
  $prefix=~s/\/[^\/]*$//;
  }
  $loc="$prefix/$loc";
  }
  elsif(eval{require URI}){
  $loc=URI->new_abs($loc,$url)->as_string;
  }
  else{
  return _error%state,$cb,{@pseudo,Status=>599,Reason=>"Cannot parse Location (URI module missing)"};
  }
  }
  $hdr{location}=$loc;
  }
  my$redirect;
  if($recurse){
  my$status=$hdr{Status};
  if($status==301 or$status==302 or$status==303){
  $redirect=1;
  unless($method eq"HEAD"){
  $method="GET";
  delete$arg{body};
  }
  }
  elsif($status==307 or$status==308){
  $redirect=1;
  }
  }
  my$finish=sub{
  if($state{handle}){
  if(
    $persistent
  &&$_[3]
  &&(
   $hdr{HTTPVersion}<1.1
  ?$hdr{connection}=~/\bkeep-?alive\b/i
  :$hdr{connection}!~/\bclose\b/i
  )
    )
  {
  ka_store$ka_key,delete$state{handle};
  }
  else{
  $state{handle}->destroy;
  }
  }
  %state=();
  if(defined$_[1]){
  $hdr{OrigStatus}=$hdr{Status};
  $hdr{Status}=$_[1];
  $hdr{OrigReason}=$hdr{Reason};
  $hdr{Reason}=$_[2];
  }
  if($arg{cookie_jar}){
  cookie_jar_set_cookie$arg{cookie_jar},$hdr{"set-cookie"},$uhost,$hdr{date};
  }
  if($redirect&&exists$hdr{location}){
  $state{recurse}=http_request(
  $method=>$hdr{location},
  %arg,
  recurse=>$recurse-1,
  Redirect=>[$_[0],\%hdr],
  sub{
  %state=();
  &$cb
  },
  );
  }
  else{
  $cb->($_[0],\%hdr);
  }
  };
  $ae_error=597;
  my$chunked=$hdr{"transfer-encoding"}=~/\bchunked\b/i;
  my$len=$chunked?undef:$hdr{"content-length"};
  if(!$redirect&&$arg{on_header}&&!$arg{on_header}(\%hdr)){
  $finish->(undef,598=>"Request cancelled by on_header");
  }
  elsif($hdr{Status}=~/^(?:1..|204|205|304)$/
  or$method eq"HEAD"
  or(defined$len&&$len==0))
  {
  $finish->("",undef,undef,1);
  }
  elsif(!$redirect&&$arg{want_body_handle}){
  $_[0]->on_eof(undef);
  $_[0]->on_error(undef);
  $_[0]->on_read(undef);
  $finish->(delete$state{handle});
  }
  elsif($chunked){
  my$cl=0;
  my$body="";
  my$on_body=(!$redirect&&$arg{on_body})||sub{$body.=shift;1};
  $state{read_chunk}=sub{
  $_[1]=~/^([0-9a-fA-F]+)/
    or return$finish->(undef,$ae_error=>"Garbled chunked transfer encoding");
  my$len=hex$1;
  if($len){
  $cl+=$len;
  $_[0]->push_read(
  chunk=>$len,
  sub{
  $on_body->($_[1],\%hdr)
    or return$finish->(undef,598=>"Request cancelled by on_body");
  $_[0]->push_read(
  line=>sub{
  length$_[1]
    and return$finish->(undef,$ae_error=>"Garbled chunked transfer encoding");
  $_[0]->push_read(line=>$state{read_chunk});
  }
  );
  }
  );
  }
  else{
  $hdr{"content-length"}||=$cl;
  $_[0]->push_read(
  line=>$qr_nlnl,
  sub{
  if(length$_[1]){
  for("$_[1]"){
  y/\015//d;
  my$hdr=_parse_hdr
    or return$finish->(undef,$ae_error=>"Garbled response trailers");
  %hdr=(%hdr,%$hdr);
  }
  }
  $finish->($body,undef,undef,1);
  }
  );
  }
  };
  $_[0]->push_read(line=>$state{read_chunk});
  }
  elsif(!$redirect&&$arg{on_body}){
  if(defined$len){
  $_[0]->on_read(
  sub{
  $len-=length$_[0]{rbuf};
  $arg{on_body}(delete$_[0]{rbuf},\%hdr)
    or return$finish->(undef,598=>"Request cancelled by on_body");
  $len>0
    or$finish->("",undef,undef,1);
  }
  );
  }
  else{
  $_[0]->on_eof(
  sub{
  $finish->("");
  }
  );
  $_[0]->on_read(
  sub{
  $arg{on_body}(delete$_[0]{rbuf},\%hdr)
    or$finish->(undef,598=>"Request cancelled by on_body");
  }
  );
  }
  }
  else{
  $_[0]->on_eof(undef);
  if(defined$len){
  $_[0]->on_read(
  sub{
  $finish->((substr delete$_[0]{rbuf},0,$len,""),undef,undef,1)
    if$len<=length$_[0]{rbuf};
  }
  );
  }
  else{
  $_[0]->on_error(
  sub{
  ($!==Errno::EPIPE||!$!)
    ?$finish->(delete$_[0]{rbuf})
    :$finish->(undef,$ae_error=>$_[2]);
  }
  );
  $_[0]->on_read(sub{});
  }
  }
  };
  if($was_persistent&&$idempotent){
  my$old_eof=$hdl->{on_eof};
  $hdl->{on_eof}=sub{
  _destroy_state%state;
  %state=();
  $state{recurse}=http_request(
  $method=>$url,
  %arg,
  recurse=>$recurse-1,
  persistent=>0,
  sub{
  %state=();
  &$cb
  }
  );
  };
  $hdl->on_read(
  sub{
  return unless%state;
  $hdl->{on_eof}=$old_eof;
  $hdl->push_read(line=>$qr_nlnl,$state{read_response});
  }
  );
  }
  else{
  $hdl->push_read(line=>$qr_nlnl,$state{read_response});
  }
  };
  my$prepare_handle=sub{
  my($hdl)=$state{handle};
  $hdl->on_error(
  sub{
  _error%state,$cb,{@pseudo,Status=>$ae_error,Reason=>$_[2]};
  }
  );
  $hdl->on_eof(
  sub{
  _error%state,$cb,{@pseudo,Status=>$ae_error,Reason=>"Unexpected end-of-file"};
  }
  );
  $hdl->timeout_reset;
  $hdl->timeout($timeout);
  };
  my$connect_cb=sub{
  my$fh=shift
    or return _error%state,$cb,{@pseudo,Status=>$ae_error,Reason=>"$!"};
  return unless delete$state{connect_guard};
  $state{handle}=new AnyEvent::Handle
    %{$arg{handle_params}},
    fh=>$fh,
    peername=>$uhost,
    tls_ctx=>$arg{tls_ctx},
    ;
  $prepare_handle->();
  if($proxy&&$uscheme eq"https"){
  my$auth=
    exists$hdr{"proxy-authorization"}
    ?"proxy-authorization: ".(delete$hdr{"proxy-authorization"})."\015\012"
    :"";
  $state{handle}->push_write("CONNECT $uhost:$uport HTTP/1.0\015\012$auth\015\012");
  $state{handle}->push_read(
  line=>$qr_nlnl,
  sub{
  $_[1]=~/^HTTP\/([0-9\.]+) \s+ ([0-9]{3}) (?: \s+ ([^\015\012]*) )?/ix
    or return _error%state,$cb,{@pseudo,Status=>599,Reason=>"Invalid proxy connect response ($_[1])"};
  if($2==200){
  $rpath=$upath;
  $handle_actual_request->();
  }
  else{
  _error%state,$cb,{@pseudo,Status=>$2,Reason=>$3};
  }
  }
  );
  }
  else{
  delete$hdr{"proxy-authorization"}unless$proxy;
  $handle_actual_request->();
  }
  };
  _get_slot$uhost,sub{
  $state{slot_guard}=shift;
  return unless$state{connect_guard};
  if($persistent&&$KA_CACHE{$ka_key}){
  $was_persistent=1;
  $state{handle}=ka_fetch$ka_key;
  $prepare_handle->();
  $handle_actual_request->();
  }
  else{
  my$tcp_connect=$arg{tcp_connect}
    ||do{require AnyEvent::Socket;\&AnyEvent::Socket::tcp_connect};
  $state{connect_guard}=$tcp_connect->($rhost,$rport,$connect_cb,$arg{on_prepare}||sub{$timeout});
  }
  };
  defined wantarray&&AnyEvent::Util::guard{_destroy_state%state}
  }
  sub http_get($@){
  unshift@_,"GET";
  &http_request
  }
  sub http_head($@){
  unshift@_,"HEAD";
  &http_request
  }
  sub http_post($$@){
  my$url=shift;
  unshift@_,"POST",$url,"body";
  &http_request
  }
  our@month=qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  our@weekday=qw(Sun Mon Tue Wed Thu Fri Sat);
  sub format_date($){
  my($time)=@_;
  my($S,$M,$H,$mday,$mon,$year,$wday,$yday,undef)=gmtime$time;
  sprintf"%s, %02d %s %04d %02d:%02d:%02d GMT",$weekday[$wday],$mday,$month[$mon],$year+1900,$H,$M,$S;
  }
  sub parse_date($){
  my($date)=@_;
  my($d,$m,$y,$H,$M,$S);
  if($date=~/^[A-Z][a-z][a-z]+, ([0-9][0-9]?)[\- ]([A-Z][a-z][a-z])[\- ]([0-9][0-9][0-9][0-9]) ([0-9][0-9]?):([0-9][0-9]?):([0-9][0-9]?) GMT$/){
  ($d,$m,$y,$H,$M,$S)=($1,$2,$3,$4,$5,$6);
  }
  elsif($date=~/^[A-Z][a-z][a-z]+, ([0-9][0-9]?)-([A-Z][a-z][a-z])-([0-9][0-9]) ([0-9][0-9]?):([0-9][0-9]?):([0-9][0-9]?) GMT$/){
  ($d,$m,$y,$H,$M,$S)=($1,$2,$3<69?$3+2000:$3+1900,$4,$5,$6);
  }
  elsif($date=~/^[A-Z][a-z][a-z]+ ([A-Z][a-z][a-z]) ([0-9 ]?[0-9]) ([0-9][0-9]?):([0-9][0-9]?):([0-9][0-9]?) ([0-9][0-9][0-9][0-9])$/){
  ($d,$m,$y,$H,$M,$S)=($2,$1,$6,$3,$4,$5);
  }
  for(0..11){
  if($m eq$month[$_]){
  require Time::Local;
  return eval{Time::Local::timegm($S,$M,$H,$d,$_,$y)};
  }
  }
  undef
  }
  sub set_proxy($){
  if(length$_[0]){
  $_[0]=~m%^(http):// ([^:/]+) (?: : (\d*) )?%ix
    or Carp::croak"$_[0]: invalid proxy URL";
  $PROXY=[$2,$3||3128,$1]
  }
  else{
  undef$PROXY;
  }
  }
  eval{set_proxy$ENV{http_proxy};};
  1
ANYEVENT_HTTP

$fatpacked{"AnyEvent/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_HANDLE';
  package AnyEvent::Handle;
  use Scalar::Util ();
  use List::Util ();
  use Carp ();
  use Errno qw(EAGAIN EWOULDBLOCK EINTR);
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use AnyEvent::Util qw(WSAEWOULDBLOCK);
  our$VERSION=$AnyEvent::VERSION;
  sub _load_func($){
  my$func=$_[0];
  unless(defined&$func){
  my$pkg=$func;
  do{
  $pkg=~s/::[^:]+$//
    or return;
  eval"require $pkg";
  }until defined&$func;
  }
  \&$func
  }
  sub MAX_READ_SIZE(){131072}
  sub new{
  my$class=shift;
  my$self=bless{@_},$class;
  if($self->{fh}){
  $self->_start;
  return unless$self->{fh};
  }
  elsif($self->{connect}){
  require AnyEvent::Socket;
  $self->{peername}=$self->{connect}[0]
    unless exists$self->{peername};
  $self->{_skip_drain_rbuf}=1;
  {
  Scalar::Util::weaken(my$self=$self);
  $self->{_connect}=AnyEvent::Socket::tcp_connect(
  $self->{connect}[0],
  $self->{connect}[1],
  sub{
  my($fh,$host,$port,$retry)=@_;
  delete$self->{_connect};
  if($fh){
  $self->{fh}=$fh;
  delete$self->{_skip_drain_rbuf};
  $self->_start;
  $self->{on_connect}
    and$self->{on_connect}(
  $self,$host,$port,
  sub{
  delete@$self{qw(fh _tw _rtw _wtw _ww _rw _eof _queue rbuf _wbuf tls _tls_rbuf _tls_wbuf)};
  $self->{_skip_drain_rbuf}=1;
  &$retry;
  }
    );
  }
  else{
  if($self->{on_connect_error}){
  $self->{on_connect_error}($self,"$!");
  $self->destroy if$self;
  }
  else{
  $self->_error($!,1);
  }
  }
  },
  sub{
  local$self->{fh}=$_[0];
  $self->{on_prepare}
    ?$self->{on_prepare}->($self)
    :()
  }
  );
  }
  }
  else{
  Carp::croak"AnyEvent::Handle: either an existing fh or the connect parameter must be specified";
  }
  $self
  }
  sub _start{
  my($self)=@_;
  my$type=getsockopt$self->{fh},Socket::SOL_SOCKET(),Socket::SO_TYPE();
  Carp::croak"AnyEvent::Handle: only stream sockets supported, anything else will NOT work!"
    if Socket::SOCK_STREAM()!=(unpack"I",$type)&&defined$type;
  AnyEvent::fh_unblock$self->{fh};
  $self->{_activity}=$self->{_ractivity}=$self->{_wactivity}=AE::now;
  $self->{read_size}||=2048;
  $self->{max_read_size}=$self->{read_size}
    if$self->{read_size}>($self->{max_read_size}||MAX_READ_SIZE);
  $self->timeout(delete$self->{timeout})if$self->{timeout};
  $self->rtimeout(delete$self->{rtimeout})if$self->{rtimeout};
  $self->wtimeout(delete$self->{wtimeout})if$self->{wtimeout};
  $self->no_delay(delete$self->{no_delay})if exists$self->{no_delay}&&$self->{no_delay};
  $self->keepalive(delete$self->{keepalive})if exists$self->{keepalive}&&$self->{keepalive};
  $self->oobinline(exists$self->{oobinline}?delete$self->{oobinline}:1);
  $self->starttls(delete$self->{tls},delete$self->{tls_ctx})
    if$self->{tls};
  $self->on_drain(delete$self->{on_drain})if$self->{on_drain};
  $self->start_read
    if$self->{on_read}||@{$self->{_queue}};
  $self->_drain_wbuf;
  }
  sub _error{
  my($self,$errno,$fatal,$message)=@_;
  $!=$errno;
  $message||="$!";
  if($self->{on_error}){
  $self->{on_error}($self,$fatal,$message);
  $self->destroy if$fatal;
  }
  elsif($self->{fh}||$self->{connect}){
  $self->destroy;
  Carp::croak"AnyEvent::Handle uncaught error: $message";
  }
  }
  sub fh{$_[0]{fh}}
  sub on_error{
  $_[0]{on_error}=$_[1];
  }
  sub on_eof{
  $_[0]{on_eof}=$_[1];
  }
  sub autocork{
  $_[0]{autocork}=$_[1];
  }
  sub no_delay{
  $_[0]{no_delay}=$_[1];
  setsockopt$_[0]{fh},Socket::IPPROTO_TCP(),Socket::TCP_NODELAY(),int$_[1]
    if$_[0]{fh};
  }
  sub keepalive{
  $_[0]{keepalive}=$_[1];
  eval{
  local$SIG{__DIE__};
  setsockopt$_[0]{fh},Socket::SOL_SOCKET(),Socket::SO_KEEPALIVE(),int$_[1]
    if$_[0]{fh};
  };
  }
  sub oobinline{
  $_[0]{oobinline}=$_[1];
  eval{
  local$SIG{__DIE__};
  setsockopt$_[0]{fh},Socket::SOL_SOCKET(),Socket::SO_OOBINLINE(),int$_[1]
    if$_[0]{fh};
  };
  }
  sub on_starttls{
  $_[0]{on_starttls}=$_[1];
  }
  sub on_stoptls{
  $_[0]{on_stoptls}=$_[1];
  }
  sub rbuf_max{
  $_[0]{rbuf_max}=$_[1];
  }
  sub wbuf_max{
  $_[0]{wbuf_max}=$_[1];
  }
  for my $dir("","r","w"){
  my$timeout="${dir}timeout";
  my$tw="_${dir}tw";
  my$on_timeout="on_${dir}timeout";
  my$activity="_${dir}activity";
  my$cb;
  *$on_timeout=sub{
  $_[0]{$on_timeout}=$_[1];
  };
  *$timeout=sub{
  my($self,$new_value)=@_;
  $new_value>=0
    or Carp::croak"AnyEvent::Handle->$timeout called with negative timeout ($new_value), caught";
  $self->{$timeout}=$new_value;
  delete$self->{$tw};
  &$cb;
  };
  *{"${dir}timeout_reset"}=sub{
  $_[0]{$activity}=AE::now;
  };
  $cb=sub{
  my($self)=@_;
  if($self->{$timeout}&&$self->{fh}){
  my$NOW=AE::now;
  my$after=$self->{$activity}+$self->{$timeout}-$NOW;
  if($after<=0){
  $self->{$activity}=$NOW;
  if($self->{$on_timeout}){
  $self->{$on_timeout}($self);
  }
  else{
  $self->_error(Errno::ETIMEDOUT);
  }
  return unless$self->{$timeout};
  $after=$self->{$timeout};
  }
  Scalar::Util::weaken$self;
  return unless$self;
  $self->{$tw}||=AE::timer$after,0,sub{
  delete$self->{$tw};
  $cb->($self);
  };
  }
  else{
  delete$self->{$tw};
  }
  }
  }
  sub on_drain{
  my($self,$cb)=@_;
  $self->{on_drain}=$cb;
  $cb->($self)
    if$cb&&$self->{low_water_mark}>=(length$self->{wbuf})+(length$self->{_tls_wbuf});
  }
  sub _drain_wbuf{
  my($self)=@_;
  if(!$self->{_ww}&&length$self->{wbuf}){
  Scalar::Util::weaken$self;
  my$cb=sub{
  my$len=syswrite$self->{fh},$self->{wbuf};
  if(defined$len){
  substr$self->{wbuf},0,$len,"";
  $self->{_activity}=$self->{_wactivity}=AE::now;
  $self->{on_drain}($self)
    if$self->{low_water_mark}>=(length$self->{wbuf})+(length$self->{_tls_wbuf})
    &&$self->{on_drain};
  delete$self->{_ww}unless length$self->{wbuf};
  }
  elsif($!!=EAGAIN&&$!!=EINTR&&$!!=EWOULDBLOCK&&$!!=WSAEWOULDBLOCK){
  $self->_error($!,1);
  }
  };
  $cb->()unless$self->{autocork};
  $self->{_ww}=AE::io$self->{fh},1,$cb
    if length$self->{wbuf};
  if(defined$self->{wbuf_max}
  &&$self->{wbuf_max}<length$self->{wbuf})
  {
  $self->_error(Errno::ENOSPC,1),return;
  }
  }
  }
  our%WH;
  sub register_write_type($$){
  $WH{$_[0]}=$_[1];
  }
  sub push_write{
  my$self=shift;
  if(@_>1){
  my$type=shift;
  @_=
    ($WH{$type}||=_load_func"$type\::anyevent_write_type" or Carp::croak"unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_write")->($self,@_);
  }
  if($self->{tls}){
  utf8::downgrade$self->{_tls_wbuf}.=$_[0];
  &_dotls($self)if$self->{fh};
  }
  else{
  utf8::downgrade$self->{wbuf}.=$_[0];
  $self->_drain_wbuf if$self->{fh};
  }
  }
  register_write_type netstring=>sub{
  my($self,$string)=@_;
  (length$string).":$string,"
  };
  register_write_type packstring=>sub{
  my($self,$format,$string)=@_;
  pack"$format/a*",$string
  };
  sub json_coder(){
  eval{require JSON::XS;JSON::XS->new->utf8}
    ||do{require JSON::PP;JSON::PP->new->utf8}
  }
  register_write_type json=>sub{
  my($self,$ref)=@_;
  ($self->{json}||=json_coder)->encode($ref)
  };
  sub cbor_coder(){
  require CBOR::XS;
  CBOR::XS->new
  }
  register_write_type cbor=>sub{
  my($self,$scalar)=@_;
  ($self->{cbor}||=cbor_coder)->encode($scalar)
  };
  register_write_type storable=>sub{
  my($self,$ref)=@_;
  require Storable unless$Storable::VERSION;
  pack"w/a*",Storable::nfreeze($ref)
  };
  sub push_shutdown{
  my($self)=@_;
  delete$self->{low_water_mark};
  $self->on_drain(sub{shutdown$_[0]{fh},1});
  }
  sub _drain_rbuf{
  my($self)=@_;
  return if$self->{_skip_drain_rbuf};
  local$self->{_skip_drain_rbuf}=1;
  while(){
  $self->{rbuf}.=delete$self->{_tls_rbuf}
    if exists$self->{_tls_rbuf};
  my$len=length$self->{rbuf};
  if(my$cb=shift@{$self->{_queue}}){
  unless($cb->($self)){
  $self->_error(Errno::EPIPE,1),return
    if$self->{_eof};
  unshift@{$self->{_queue}},$cb;
  last;
  }
  }
  elsif($self->{on_read}){
  last unless$len;
  $self->{on_read}($self);
  if($len==length$self->{rbuf}&&!@{$self->{_queue}}&&$self->{on_read}){
  $self->_error(Errno::EPIPE,1),return
    if$self->{_eof};
  last;
  }
  }
  else{
  delete$self->{_rw}unless$self->{tls};
  last;
  }
  }
  if($self->{_eof}){
  $self->{on_eof}
    ?$self->{on_eof}($self)
    :$self->_error(0,1,"Unexpected end-of-file");
  return;
  }
  if(defined$self->{rbuf_max}
  &&$self->{rbuf_max}<length$self->{rbuf})
  {
  $self->_error(Errno::ENOSPC,1),return;
  }
  unless($self->{_rw}){
  $self->start_read
    if$self->{on_read}||@{$self->{_queue}};
  }
  }
  sub on_read{
  my($self,$cb)=@_;
  $self->{on_read}=$cb;
  $self->_drain_rbuf if$cb;
  }
  sub rbuf:lvalue{
  $_[0]{rbuf}
  }
  our%RH;
  sub register_read_type($$){
  $RH{$_[0]}=$_[1];
  }
  sub push_read{
  my$self=shift;
  my$cb=pop;
  if(@_){
  my$type=shift;
  $cb=
    ($RH{$type}||=_load_func"$type\::anyevent_read_type" or Carp::croak"unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_read")->($self,$cb,@_);
  }
  push@{$self->{_queue}},$cb;
  $self->_drain_rbuf;
  }
  sub unshift_read{
  my$self=shift;
  my$cb=pop;
  if(@_){
  my$type=shift;
  $cb=
    ($RH{$type}||=_load_func"$type\::anyevent_read_type" or Carp::croak"unsupported/unloadable type '$type' passed to AnyEvent::Handle::unshift_read")->($self,$cb,@_);
  }
  unshift@{$self->{_queue}},$cb;
  $self->_drain_rbuf;
  }
  register_read_type chunk=>sub{
  my($self,$cb,$len)=@_;
  sub{
  $len<=length$_[0]{rbuf}or return;
  $cb->($_[0],substr$_[0]{rbuf},0,$len,"");
  1
  }
  };
  register_read_type line=>sub{
  my($self,$cb,$eol)=@_;
  if(@_<3){
  sub{
  (my$pos=index$_[0]{rbuf},"\012")>=0
    or return;
  (my$str=substr$_[0]{rbuf},0,$pos+1,"")=~s/(\015?\012)\Z// or die;
  $cb->($_[0],$str,"$1");
  1
  }
  }
  else{
  $eol=quotemeta$eol unless ref$eol;
  $eol=qr|^(.*?)($eol)|s;
  sub{
  $_[0]{rbuf}=~s/$eol// or return;
  $cb->($_[0],"$1","$2");
  1
  }
  }
  };
  register_read_type regex=>sub{
  my($self,$cb,$accept,$reject,$skip)=@_;
  my$data;
  my$rbuf=\$self->{rbuf};
  sub{
  if($$rbuf=~$accept){
  $data.=substr$$rbuf,0,$+[0],"";
  $cb->($_[0],$data);
  return 1;
  }
  if($reject&&$$rbuf=~$reject){
  $_[0]->_error(Errno::EBADMSG);
  }
  if($skip&&$$rbuf=~$skip){
  $data.=substr$$rbuf,0,$+[0],"";
  }
  ()
  }
  };
  register_read_type netstring=>sub{
  my($self,$cb)=@_;
  sub{
  unless($_[0]{rbuf}=~s/^(0|[1-9][0-9]*)://){
  if($_[0]{rbuf}=~/[^0-9]/){
  $_[0]->_error(Errno::EBADMSG);
  }
  return;
  }
  my$len=$1;
  $_[0]->unshift_read(
  chunk=>$len,
  sub{
  my$string=$_[1];
  $_[0]->unshift_read(
  chunk=>1,
  sub{
  if($_[1]eq","){
  $cb->($_[0],$string);
  }
  else{
  $_[0]->_error(Errno::EBADMSG);
  }
  }
  );
  }
  );
  1
  }
  };
  register_read_type packstring=>sub{
  my($self,$cb,$format)=@_;
  sub{
  defined(my$len=eval{unpack$format,$_[0]{rbuf}})
    or return;
  $format=length pack$format,$len;
  if($format+$len<=length$_[0]{rbuf}){
  my$data=substr$_[0]{rbuf},$format,$len;
  substr$_[0]{rbuf},0,$format+$len,"";
  $cb->($_[0],$data);
  }
  else{
  substr$_[0]{rbuf},0,$format,"";
  $_[0]->unshift_read(chunk=>$len,$cb);
  }
  1
  }
  };
  register_read_type json=>sub{
  my($self,$cb)=@_;
  my$json=$self->{json}||=json_coder;
  my$data;
  sub{
  my$ref=eval{$json->incr_parse($_[0]{rbuf})};
  if($ref){
  $_[0]{rbuf}=$json->incr_text;
  $json->incr_text="";
  $cb->($_[0],$ref);
  1
  }
  elsif($@){
  $json->incr_skip;
  $_[0]{rbuf}=$json->incr_text;
  $json->incr_text="";
  $_[0]->_error(Errno::EBADMSG);
  ()
  }
  else{
  $_[0]{rbuf}="";
  ()
  }
  }
  };
  register_read_type cbor=>sub{
  my($self,$cb)=@_;
  my$cbor=$self->{cbor}||=cbor_coder;
  my$data;
  sub{
  my(@value)=eval{$cbor->incr_parse($_[0]{rbuf})};
  if(@value){
  $cb->($_[0],@value);
  1
  }
  elsif($@){
  $cbor->incr_reset;
  $_[0]->_error(Errno::EBADMSG);
  ()
  }
  else{
  ()
  }
  }
  };
  register_read_type storable=>sub{
  my($self,$cb)=@_;
  require Storable unless$Storable::VERSION;
  sub{
  defined(my$len=eval{unpack"w",$_[0]{rbuf}})
    or return;
  my$format=length pack"w",$len;
  if($format+$len<=length$_[0]{rbuf}){
  my$data=substr$_[0]{rbuf},$format,$len;
  substr$_[0]{rbuf},0,$format+$len,"";
  eval{$cb->($_[0],Storable::thaw($data));1}
    or return$_[0]->_error(Errno::EBADMSG);
  }
  else{
  substr$_[0]{rbuf},0,$format,"";
  $_[0]->unshift_read(
  chunk=>$len,
  sub{
  eval{$cb->($_[0],Storable::thaw($_[1]));1}
    or$_[0]->_error(Errno::EBADMSG);
  }
  );
  }
  1
  }
  };
  register_read_type tls_detect=>sub{
  my($self,$cb)=@_;
  sub{
  if($self->{rbuf}=~/^(?:\z| \x16 (\z| [\x03\x04] (?:\z| . (?:\z| [\x00-\x40] ))))/xs
  or$self->{rbuf}=~/^(?:\z| [\x80-\xff] (?:\z| . (?:\z| \x01 (\z| [\x03\x04] (?:\z| . (?:\z| . ))))))/xs)
  {
  return if 3!=length$1;
  my($major,$minor)=unpack"CC",$1;
  $cb->($self,"accept",$major+$minor*0.1);
  }
  else{
  $cb->($self,undef);
  }
  1
  }
  };
  register_read_type tls_autostart=>sub{
  my($self,@tls)=@_;
  $RH{tls_detect}(
  $self,
  sub{
  return unless$_[1];
  $_[0]->starttls(@tls);
  }
  )
  };
  sub stop_read{
  my($self)=@_;
  delete$self->{_rw};
  }
  sub start_read{
  my($self)=@_;
  unless($self->{_rw}||$self->{_eof}||!$self->{fh}){
  Scalar::Util::weaken$self;
  $self->{_rw}=AE::io$self->{fh},0,sub{
  my$rbuf=\($self->{tls}?my$buf:$self->{rbuf});
  my$len=sysread$self->{fh},$$rbuf,$self->{read_size},length$$rbuf;
  if($len>0){
  $self->{_activity}=$self->{_ractivity}=AE::now;
  if($self->{tls}){
  Net::SSLeay::BIO_write($self->{_rbio},$$rbuf);
  &_dotls($self);
  }
  else{
  $self->_drain_rbuf;
  }
  if($len==$self->{read_size}){
  $self->{read_size}*=2;
  $self->{read_size}=$self->{max_read_size}||MAX_READ_SIZE
    if$self->{read_size}>($self->{max_read_size}||MAX_READ_SIZE);
  }
  }
  elsif(defined$len){
  delete$self->{_rw};
  $self->{_eof}=1;
  $self->_drain_rbuf;
  }
  elsif($!!=EAGAIN&&$!!=EINTR&&$!!=EWOULDBLOCK&&$!!=WSAEWOULDBLOCK){
  return$self->_error($!,1);
  }
  };
  }
  }
  our$ERROR_SYSCALL;
  our$ERROR_WANT_READ;
  sub _tls_error{
  my($self,$err)=@_;
  return$self->_error($!,1)
    if$err==Net::SSLeay::ERROR_SYSCALL();
  my$err=Net::SSLeay::ERR_error_string(Net::SSLeay::ERR_get_error());
  $err=~s/^error:[0-9a-fA-F]{8}:[^:]+:([^:]+):/\L$1: /;
  if($self->{_on_starttls}){
  (delete$self->{_on_starttls})->($self,undef,$err);
  &_freetls;
  }
  else{
  &_freetls;
  $self->_error(Errno::EPROTO,1,$err);
  }
  }
  sub _dotls{
  my($self)=@_;
  my$tmp;
  while(length$self->{_tls_wbuf}){
  if(($tmp=Net::SSLeay::write($self->{tls},$self->{_tls_wbuf}))<=0){
  $tmp=Net::SSLeay::get_error($self->{tls},$tmp);
  return$self->_tls_error($tmp)
    if$tmp!=$ERROR_WANT_READ
    &&($tmp!=$ERROR_SYSCALL||$!);
  last;
  }
  substr$self->{_tls_wbuf},0,$tmp,"";
  }
  while(defined($tmp=Net::SSLeay::read($self->{tls}))){
  unless(length$tmp){
  $self->{_on_starttls}
    and(delete$self->{_on_starttls})->($self,undef,"EOF during handshake");
  &_freetls;
  if($self->{on_stoptls}){
  $self->{on_stoptls}($self);
  return;
  }
  else{
  delete$self->{_rw};
  $self->{_eof}=1;
  }
  }
  $self->{_tls_rbuf}.=$tmp;
  $self->_drain_rbuf;
  $self->{tls}or return;
  }
  $tmp=Net::SSLeay::get_error($self->{tls},-1);
  return$self->_tls_error($tmp)
    if$tmp!=$ERROR_WANT_READ
    &&($tmp!=$ERROR_SYSCALL||$!);
  while(length($tmp=Net::SSLeay::BIO_read($self->{_wbio}))){
  $self->{wbuf}.=$tmp;
  $self->_drain_wbuf;
  $self->{tls}or return;
  }
  $self->{_on_starttls}
    and Net::SSLeay::state($self->{tls})==Net::SSLeay::ST_OK()
    and(delete$self->{_on_starttls})->($self,1,"TLS/SSL connection established");
  }
  our%TLS_CACHE;
  sub starttls{
  my($self,$tls,$ctx)=@_;
  Carp::croak"It is an error to call starttls on an AnyEvent::Handle object while TLS is already active, caught"
    if$self->{tls};
  unless(defined$AnyEvent::TLS::VERSION){
  eval{
  require Net::SSLeay;
  require AnyEvent::TLS;
  1
  }or return$self->_error(Errno::EPROTO,1,"TLS support not available on this system");
  }
  $self->{tls}=$tls;
  $self->{tls_ctx}=$ctx if@_>2;
  return unless$self->{fh};
  $ERROR_SYSCALL=Net::SSLeay::ERROR_SYSCALL();
  $ERROR_WANT_READ=Net::SSLeay::ERROR_WANT_READ();
  $tls=delete$self->{tls};
  $ctx=$self->{tls_ctx};
  local$Carp::CarpLevel=1;
  if("HASH" eq ref$ctx){
  if($ctx->{cache}){
  my$key=$ctx+0;
  $ctx=$TLS_CACHE{$key}||=new AnyEvent::TLS%$ctx;
  }
  else{
  $ctx=new AnyEvent::TLS%$ctx;
  }
  }
  $self->{tls_ctx}=$ctx||TLS_CTX();
  $self->{tls}=$tls=$self->{tls_ctx}->_get_session($tls,$self,$self->{peername});
  Net::SSLeay::set_mode($tls,1|2);
  $self->{_rbio}=Net::SSLeay::BIO_new(Net::SSLeay::BIO_s_mem());
  $self->{_wbio}=Net::SSLeay::BIO_new(Net::SSLeay::BIO_s_mem());
  Net::SSLeay::BIO_write($self->{_rbio},$self->{rbuf});
  $self->{rbuf}="";
  Net::SSLeay::set_bio($tls,$self->{_rbio},$self->{_wbio});
  $self->{_on_starttls}=sub{$_[0]{on_starttls}(@_)}
    if$self->{on_starttls};
  &_dotls;
  $self->start_read;
  }
  sub stoptls{
  my($self)=@_;
  if($self->{tls}&&$self->{fh}){
  Net::SSLeay::shutdown($self->{tls});
  &_dotls;
  }
  }
  sub _freetls{
  my($self)=@_;
  return unless$self->{tls};
  $self->{tls_ctx}->_put_session(delete$self->{tls})
    if$self->{tls}>0;
  delete@$self{qw(_rbio _wbio _tls_wbuf _on_starttls)};
  }
  *resettls=\&_freetls;
  sub DESTROY{
  my($self)=@_;
  &_freetls;
  my$linger=exists$self->{linger}?$self->{linger}:3600;
  if($linger&&length$self->{wbuf}&&$self->{fh}){
  my$fh=delete$self->{fh};
  my$wbuf=delete$self->{wbuf};
  my@linger;
  push@linger,AE::io$fh,1,sub{
  my$len=syswrite$fh,$wbuf,length$wbuf;
  if($len>0){
  substr$wbuf,0,$len,"";
  }
  elsif(defined$len||($!!=EAGAIN&&$!!=EINTR&&$!!=EWOULDBLOCK&&$!!=WSAEWOULDBLOCK)){
  @linger=();
  }
  };
  push@linger,AE::timer$linger,0,sub{
  @linger=();
  };
  }
  }
  sub destroy{
  my($self)=@_;
  $self->DESTROY;
  %$self=();
  bless$self,"AnyEvent::Handle::destroyed";
  }
  sub AnyEvent::Handle::destroyed::AUTOLOAD{
  }
  sub destroyed{0}
  sub AnyEvent::Handle::destroyed::destroyed{1}
  our$TLS_CTX;
  sub TLS_CTX(){
  $TLS_CTX||=do{
  require AnyEvent::TLS;
  new AnyEvent::TLS
  }
  }
  1
ANYEVENT_HANDLE

$fatpacked{"AnyEvent/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO';
  package AnyEvent::IO;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use base"Exporter";
  our@AIO_REQ=qw(
    aio_load aio_open aio_close aio_seek aio_read aio_write aio_truncate
    aio_utime aio_chown aio_chmod aio_stat aio_lstat
    aio_link aio_symlink aio_readlink aio_rename aio_unlink
    aio_mkdir aio_rmdir aio_readdir
  );
  *EXPORT=\@AIO_REQ;
  our@FLAGS=qw(O_RDONLY O_WRONLY O_RDWR O_CREAT O_EXCL O_TRUNC O_APPEND);
  *EXPORT_OK=\@FLAGS;
  our%EXPORT_TAGS=(flags=>\@FLAGS,aio=>\@AIO_REQ);
  our$MODEL;
  if($MODEL){
  AE::log 7=>"Found preloaded IO model '$MODEL', using it.";
  }
  else{
  if($ENV{PERL_ANYEVENT_IO_MODEL}=~/^([a-zA-Z0-9:]+)$/){
  if(eval{require"AnyEvent/IO/$ENV{PERL_ANYEVENT_IO_MODEL}.pm"}){
  AE::log 7=>"Loaded IO model '$MODEL' (forced by \$ENV{PERL_ANYEVENT_IO_MODEL}), using it.";
  }
  else{
  undef$MODEL;
  AE::log 4=>"Unable to load IO model '$ENV{PERL_ANYEVENT_IO_MODEL}' (from \$ENV{PERL_ANYEVENT_IO_MODEL}):\n$@";
  }
  }
  unless($MODEL){
  if(eval{require IO::AIO;require AnyEvent::AIO;require AnyEvent::IO::IOAIO}){
  AE::log 7=>"Autoloaded IO model 'IOAIO', using it.";
  }
  else{
  require AnyEvent::IO::Perl;
  AE::log 7=>"Autoloaded IO model 'Perl', using it.";
  }
  }
  }
  1
ANYEVENT_IO

$fatpacked{"AnyEvent/IO/IOAIO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO_IOAIO';
  package AnyEvent::IO::IOAIO;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  our$VERSION=$AnyEvent::VERSION;
  package AnyEvent::IO;
  use IO::AIO 4.13 ();
  use AnyEvent::AIO ();
  our$MODEL="AnyEvent::IO::IOAIO";
  sub aio_load($$){
  my($cb,$data)=$_[1];
  IO::AIO::aio_load$_[0],$data,sub{$cb->($_[0]>=0?$data:())};
  }
  sub aio_open($$$$){
  my$cb=$_[3];
  IO::AIO::aio_open$_[0],$_[1],$_[2],sub{$cb->($_[0]or())};
  }
  sub aio_close($$){
  my$cb=$_[1];
  IO::AIO::aio_close$_[0],sub{$cb->($_[0]>=0?1:())};
  }
  sub aio_seek($$$$){
  my($cb)=$_[3];
  IO::AIO::aio_seek$_[0],$_[1],$_[2],sub{$cb->($_[0]>=0?$_[0]:())};
  }
  sub aio_read($$$){
  my($cb,$data)=$_[2];
  IO::AIO::aio_read$_[0],undef,$_[1],$data,0,sub{$cb->($_[0]>=0?$data:())};
  }
  sub aio_write($$$){
  my$cb=$_[2];
  IO::AIO::aio_write$_[0],undef,(length$_[1]),$_[1],0,sub{$cb->($_[0]>=0?$_[0]:())};
  }
  sub aio_truncate($$$){
  my$cb=$_[2];
  IO::AIO::aio_truncate$_[0],$_[1],sub{$cb->($_[0]?():1)};
  }
  sub aio_utime($$$$){
  my$cb=$_[3];
  IO::AIO::aio_utime$_[0],$_[1],$_[2],sub{$cb->($_[0]?():1)};
  }
  sub aio_chown($$$$){
  my$cb=$_[3];
  IO::AIO::aio_chown$_[0],$_[1],$_[2],sub{$cb->($_[0]?():1)};
  }
  sub aio_chmod($$$){
  my$cb=$_[2];
  IO::AIO::aio_chmod$_[0],$_[1],sub{$cb->($_[0]?():1)};
  }
  sub aio_stat($$){
  my$cb=$_[1];
  IO::AIO::aio_stat$_[0],sub{$cb->($_[0]?():1)};
  }
  sub aio_lstat($$){
  my$cb=$_[1];
  IO::AIO::aio_lstat$_[0],sub{$cb->($_[0]?():1)}
  }
  sub aio_link($$$){
  my$cb=$_[2];
  IO::AIO::aio_link$_[0],$_[1],sub{$cb->($_[0]?():1)};
  }
  sub aio_symlink($$$){
  my$cb=$_[2];
  IO::AIO::aio_symlink$_[0],$_[1],sub{$cb->($_[0]?():1)};
  }
  sub aio_readlink($$){
  my$cb=$_[1];
  IO::AIO::aio_readlink$_[0],sub{$cb->(defined$_[0]?$_[0]:())};
  }
  sub aio_rename($$$){
  my$cb=$_[2];
  IO::AIO::aio_rename$_[0],$_[1],sub{$cb->($_[0]?():1)};
  }
  sub aio_unlink($$){
  my$cb=$_[1];
  IO::AIO::aio_unlink$_[0],sub{$cb->($_[0]?():1)};
  }
  sub aio_mkdir($$$){
  my$cb=$_[2];
  IO::AIO::aio_mkdir$_[0],$_[1],sub{$cb->($_[0]?():1)};
  }
  sub aio_rmdir($$){
  my$cb=$_[1];
  IO::AIO::aio_rmdir$_[0],sub{$cb->($_[0]?():1)};
  }
  sub aio_readdir($$){
  my$cb=$_[1];
  IO::AIO::aio_readdirx$_[0],IO::AIO::READDIR_DIRS_FIRST|IO::AIO::READDIR_STAT_ORDER,sub{$cb->($_[0]or());};
  }
  1
ANYEVENT_IO_IOAIO

$fatpacked{"AnyEvent/IO/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO_PERL';
  package AnyEvent::IO::Perl;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  our$VERSION=$AnyEvent::VERSION;
  package AnyEvent::IO;
  our$MODEL="AnyEvent::IO::Perl";
  sub aio_load($$){
  my($path,$cb,$fh,$data)=@_;
  $cb->((open$fh,"<:raw:perlio",$path and stat$fh and(-s _)==sysread$fh,$data,-s _)?$data:());
  }
  sub aio_open($$$$){
  sysopen my$fh,$_[0],$_[1],$_[2]
    or return$_[3]();
  $_[3]($fh)
  }
  sub aio_close($$){
  $_[1](close$_[0]);
  }
  sub aio_seek($$$$){
  my$data;
  $_[3](sysseek$_[0],$_[1],$_[2]or());
  }
  sub aio_read($$$){
  my$data;
  $_[2]((defined sysread$_[0],$data,$_[1])?$data:());
  }
  sub aio_write($$$){
  my$res=syswrite$_[0],$_[1];
  $_[2](defined$res?$res:());
  }
  sub aio_truncate($$$){
  $_[2](truncate$_[0],$_[1]or());
  }
  sub aio_utime($$$$){
  $_[3](utime$_[1],$_[2],$_[0]or());
  }
  sub aio_chown($$$$){
  $_[3](chown defined$_[1]?$_[1]:-1,defined$_[2]?$_[2]:-1,$_[0]or());
  }
  sub aio_chmod($$$){
  $_[2](chmod$_[1],$_[0]or());
  }
  sub aio_stat($$){
  $_[1](stat$_[0]);
  }
  sub aio_lstat($$){
  $_[1](lstat$_[0]);
  }
  sub aio_link($$$){
  $_[2](link$_[0],$_[1]or());
  }
  sub aio_symlink($$$){
  $_[2](symlink$_[0],$_[1]or());
  }
  sub aio_readlink($$){
  my$res=readlink$_[0];
  $_[1](defined$res?$res:());
  }
  sub aio_rename($$$){
  $_[2](rename$_[0],$_[1]or());
  }
  sub aio_unlink($$){
  $_[1](unlink$_[0]or());
  }
  sub aio_mkdir($$$){
  $_[2](mkdir$_[0],$_[1]or());
  }
  sub aio_rmdir($$){
  $_[1](rmdir$_[0]or());
  }
  sub aio_readdir($$){
  my($fh,@res);
  opendir$fh,$_[0]
    or return$_[1]();
  @res=grep!/^\.\.?$/,readdir$fh;
  $_[1]((closedir$fh)?\@res:());
  }
  1
ANYEVENT_IO_PERL

$fatpacked{"AnyEvent/Impl/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_COCOA';
  package AnyEvent::Impl::Cocoa;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use Cocoa::EventLoop;
  sub io{
  my($class,%arg)=@_;
  Cocoa::EventLoop->io(%arg)
  }
  sub timer{
  my($class,%arg)=@_;
  Cocoa::EventLoop->timer(%arg)
  }
  1
ANYEVENT_IMPL_COCOA

$fatpacked{"AnyEvent/Impl/EV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EV';
  package AnyEvent::Impl::EV;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use EV 4.00;
  *AE::time=\&EV::time;
  *AE::now=\&EV::now;
  *AE::now_update=\&EV::now_update;
  *AE::timer=\&EV::timer;
  *AE::signal=\&EV::signal;
  *AE::idle=\&EV::idle;
  sub time{EV::time}
  sub now{EV::now}
  sub now_update{EV::now_update}
  *AE::io=
    defined&EV::_ae_io
    ?\&EV::_ae_io
    :sub($$$){EV::io$_[0],$_[1]?EV::WRITE:EV::READ,$_[2]};
  sub timer{
  my($class,%arg)=@_;
  EV::timer$arg{after},$arg{interval},$arg{cb}
  }
  sub io{
  my($class,%arg)=@_;
  EV::io$arg{fh},$arg{poll}eq"r"?EV::READ:EV::WRITE,$arg{cb}
  }
  sub signal{
  my($class,%arg)=@_;
  EV::signal$arg{signal},$arg{cb}
  }
  sub child{
  my($class,%arg)=@_;
  my$cb=$arg{cb};
  EV::child$arg{pid},0,sub{
  $cb->($_[0]->rpid,$_[0]->rstatus);
  }
  }
  sub idle{
  my($class,%arg)=@_;
  EV::idle$arg{cb}
  }
  sub _poll{
  EV::run EV::RUN_ONCE;
  }
  sub AnyEvent::CondVar::Base::_wait{
  EV::run EV::RUN_ONCE until exists$_[0]{_ae_sent};
  }
  1
ANYEVENT_IMPL_EV

$fatpacked{"AnyEvent/Impl/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EVENT';
  package AnyEvent::Impl::Event;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use Event qw(unloop);
  sub io{
  my(undef,%arg)=@_;
  $arg{fd}=delete$arg{fh};
  $arg{poll}.="e" if AnyEvent::WIN32;
  my$cb=$arg{cb};
  $arg{cb}=sub{&$cb};
  bless\(Event->io(%arg)),__PACKAGE__
  }
  sub timer{
  my(undef,%arg)=@_;
  $arg{after}=0 if$arg{after}<0;
  my$cb=$arg{cb};
  $arg{cb}=sub{&$cb};
  bless\Event->timer(%arg,repeat=>$arg{interval}),__PACKAGE__
  }
  sub idle{
  my(undef,%arg)=@_;
  my$cb=$arg{cb};
  $arg{cb}=sub{&$cb};
  bless\Event->idle(repeat=>1,min=>0,%arg),__PACKAGE__
  }
  sub DESTROY{
  ${$_[0]}->cancel;
  }
  sub signal{
  my(undef,%arg)=@_;
  my$cb=$arg{cb};
  my$w=Event->signal(
  signal=>AnyEvent::Base::sig2name$arg{signal},
  cb=>sub{&$cb},
  );
  AnyEvent::Base::_sig_add;
  bless\$w,"AnyEvent::Impl::Event::signal"
  }
  sub AnyEvent::Impl::Event::signal::DESTROY{
  AnyEvent::Base::_sig_del;
  ${$_[0]}->cancel;
  }
  sub _poll{
  Event::one_event;
  }
  sub AnyEvent::CondVar::Base::_wait{
  Event::one_event until exists$_[0]{_ae_sent};
  }
  1
ANYEVENT_IMPL_EVENT

$fatpacked{"AnyEvent/Impl/EventLib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EVENTLIB';
  package AnyEvent::Impl::EventLib;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use Event::Lib;
  sub ccb{
  my$keep_it=$_[0];
  $_[2]();
  }
  my$ccb=\&ccb;
  sub io{
  my(undef,%arg)=@_;
  my($fh,$mode)=AnyEvent::_dupfh$arg{poll},$arg{fh},EV_READ,EV_WRITE;
  my$w=event_new$fh,$mode|EV_PERSIST,$ccb,$arg{cb};
  event_add$w;
  bless\\$w,__PACKAGE__
  }
  sub timer{
  my(undef,%arg)=@_;
  my$ival=$arg{interval};
  my$cb=$arg{cb};
  my$w;
  $w=
    timer_new$ccb,$ival
    ?sub{event_add$w,$ival;&$cb}
    :sub{undef$w;&$cb};
  event_add$w,$arg{after}||1e-10;
  bless\\$w,__PACKAGE__
  }
  sub DESTROY{
  local$@;
  ${${$_[0]}}->remove;
  }
  sub signal{
  my(undef,%arg)=@_;
  my$w=signal_new AnyEvent::Base::sig2num$arg{signal},$ccb,$arg{cb};
  event_add$w;
  AnyEvent::Base::_sig_add;
  bless\\$w,"AnyEvent::Impl::EventLib::signal"
  }
  sub AnyEvent::Impl::EventLib::signal::DESTROY{
  AnyEvent::Base::_sig_del;
  local$@;
  ${${$_[0]}}->remove;
  }
  sub _poll{
  event_one_loop;
  }
  sub AnyEvent::CondVar::Base::_wait{
  event_one_loop until exists$_[0]{_ae_sent};
  }
  1
ANYEVENT_IMPL_EVENTLIB

$fatpacked{"AnyEvent/Impl/FLTK.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_FLTK';
  package AnyEvent::Impl::FLTK;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use FLTK 0.532 ();
  use Scalar::Util ();
  sub timer_interval_cb{
  my$id=shift;
  $id->[0]=FLTK::add_timeout$id->[1],\&timer_interval_cb,$id;
  &{$id->[2]}
  }
  sub timer{
  my($class,%arg)=@_;
  my$cb=$arg{cb};
  if($arg{interval}){
  my$id=[undef,$arg{interval},$cb];
  $id->[0]=FLTK::add_timeout$arg{after},\&timer_interval_cb,$id;
  return bless$id,"AnyEvent::Impl::FLTK::timer"
  }
  else{
  return FLTK::add_timeout$arg{after},sub{&$cb}
  }
  }
  sub AnyEvent::Impl::FLTK::timer::DESTROY{
  undef$_[0][0];
  }
  sub io{
  my($class,%arg)=@_;
  my$cb=$arg{cb};
  my($fh,$ev)=AnyEvent::_dupfh$arg{poll},$arg{fh},FLTK::READ,FLTK::WRITE|(AnyEvent::WIN32?FLTK::EXCEPT:0);
  FLTK::add_fd$fh,$ev,sub{&$cb}
  }
  sub _poll{
  FLTK::wait;
  }
  sub AnyEvent::CondVar::Base::_wait{
  FLTK::wait until exists$_[0]{_ae_sent};
  }
  1
ANYEVENT_IMPL_FLTK

$fatpacked{"AnyEvent/Impl/Glib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_GLIB';
  package AnyEvent::Impl::Glib;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use Glib 1.210 ();
  our$mainloop=Glib::MainContext->default;
  my%io_cond=(
  r=>["in","hup"],
  w=>["out","hup"],
  );
  sub io{
  my($class,%arg)=@_;
  my$cb=$arg{cb};
  my$fd=fileno$arg{fh};
  defined$fd or$fd=$arg{fh};
  my$source=add_watch Glib::IO$fd,$io_cond{$arg{poll}},sub{&$cb;1};
  bless\\$source,$class
  }
  sub timer{
  my($class,%arg)=@_;
  my$cb=$arg{cb};
  my$ival=$arg{interval}*1000;
  my$source;
  $source=add Glib::Timeout$arg{after}<0?0:$arg{after}*1000,$ival?sub{
  remove Glib::Source$source;
  $source=add Glib::Timeout$ival,sub{&$cb;1};
  &$cb;
  1
    }
    :sub{
  remove Glib::Source$source;
  undef$source;
  &$cb;
  1
    };
  bless\\$source,$class
  }
  sub idle{
  my($class,%arg)=@_;
  my$cb=$arg{cb};
  my$source=add Glib::Idle sub{&$cb;1};
  bless\\$source,$class
  }
  sub DESTROY{
  remove Glib::Source$${$_[0]}
    if defined$${$_[0]};
  }
  our%pid_w;
  our%pid_cb;
  sub child{
  my($class,%arg)=@_;
  $arg{pid}>0
    or Carp::croak"Glib does not support watching for all pids (pid == 0) as attempted";
  my$pid=$arg{pid};
  my$cb=$arg{cb};
  $pid_cb{$pid}{$cb+0}=$cb;
  $pid_w{$pid}||=Glib::Child->watch_add(
  $pid,
  sub{
  undef$pid_w{$pid};
  $_->($_[0],$_[1])for values%{$pid_cb{$pid}};
  1
  }
  );
  bless[$pid,$cb+0],"AnyEvent::Impl::Glib::child"
  }
  sub AnyEvent::Impl::Glib::child::DESTROY{
  my($pid,$icb)=@{$_[0]};
  delete$pid_cb{$pid}{$icb};
  unless(%{$pid_cb{$pid}}){
  delete$pid_cb{$pid};
  my$source=delete$pid_w{$pid};
  remove Glib::Source if defined$source;
  }
  }
  sub _poll{
  $mainloop->iteration(1);
  }
  sub AnyEvent::CondVar::Base::_wait{
  $mainloop->iteration(1)until exists$_[0]{_ae_sent};
  }
  1
ANYEVENT_IMPL_GLIB

$fatpacked{"AnyEvent/Impl/IOAsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_IOASYNC';
  package AnyEvent::Impl::IOAsync;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use Time::HiRes ();
  use Scalar::Util ();
  use IO::Async::Loop 0.33;
  our$LOOP=new IO::Async::Loop;
  sub set_loop($){
  $LOOP=$_[0];
  }
  sub timer{
  my($class,%arg)=@_;
  my$cb=$arg{cb};
  my$id;
  if(my$ival=$arg{interval}){
  my$ival_cb;
  $ival_cb=sub{
  $id=$LOOP->enqueue_timer(delay=>$ival,code=>$ival_cb);
  &$cb;
  };
  $id=$LOOP->enqueue_timer(delay=>$arg{after},code=>$ival_cb);
  Scalar::Util::weaken$ival_cb;
  }
  else{
  $id=$LOOP->enqueue_timer(
  delay=>$arg{after},
  code=>sub{
  undef$id;
  &$cb;
  }
  );
  }
  bless\\$id,"AnyEvent::Impl::IOAsync::timer"
  }
  sub AnyEvent::Impl::IOAsync::timer::DESTROY{
  $LOOP->cancel_timer(${${$_[0]}})
    if defined${${$_[0]}};
  }
  sub io{
  my($class,%arg)=@_;
  my($fh)=AnyEvent::_dupfh$arg{poll},$arg{fh};
  my$event=$arg{poll}eq"r"?"on_read_ready":"on_write_ready";
  $LOOP->watch_io(
  handle=>$fh,
  $event=>$arg{cb},
  );
  bless[$fh,$event],"AnyEvent::Impl::IOAsync::io"
  }
  sub AnyEvent::Impl::IOAsync::io::DESTROY{
  $LOOP->unwatch_io(
  handle=>$_[0][0],
  $_[0][1]=>1,
  );
  }
  sub signal{
  my($class,%arg)=@_;
  my$signal=$arg{signal};
  my$id=$LOOP->attach_signal($arg{signal},$arg{cb});
  bless[$signal,$id],"AnyEvent::Impl::IOAsync::signal"
  }
  sub AnyEvent::Impl::IOAsync::signal::DESTROY{
  $LOOP->detach_signal(@{$_[0]});
  }
  our%pid_cb;
  sub child{
  my($class,%arg)=@_;
  my$pid=$arg{pid};
  $LOOP->watch_child($pid,$arg{cb});
  bless[$pid],"AnyEvent::Impl::IOAsync::child"
  }
  sub child{
  my($class,%arg)=@_;
  my$pid=$arg{pid};
  my$cb=$arg{cb};
  unless(%{$pid_cb{$pid}}){
  $LOOP->watch_child(
  $pid,
  sub{
  $_->($_[0],$_[1])for values%{$pid_cb{$pid}};
  }
  );
  }
  $pid_cb{$pid}{$cb+0}=$cb;
  bless[$pid,$cb+0],"AnyEvent::Impl::IOAsync::child"
  }
  sub AnyEvent::Impl::IOAsync::child::DESTROY{
  my($pid,$icb)=@{$_[0]};
  delete$pid_cb{$pid}{$icb};
  unless(%{$pid_cb{$pid}}){
  delete$pid_cb{$pid};
  $LOOP->unwatch_child($pid);
  }
  }
  sub _poll{
  $LOOP->loop_once;
  }
  sub AnyEvent::CondVar::Base::_wait{
  $LOOP->loop_once until exists$_[0]{_ae_sent};
  }
  1
ANYEVENT_IMPL_IOASYNC

$fatpacked{"AnyEvent/Impl/Irssi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_IRSSI';
  package AnyEvent::Impl::Irssi;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use Carp ();
  use Irssi ();
  our@ISA;
  sub init{
  my$pkg=caller;
  push@ISA,$pkg;
  local$/;
  eval"package $pkg; ".<DATA>;
  print"AnyEvent::Impl::Irssi fatal compilation error: $@" if$@;
  close DATA;
  }
  Irssi::command"/script exec -permanent AnyEvent::Impl::Irssi::init 'AnyEvent adaptor'";
  1;
  __DATA__
  
  BEGIN { AnyEvent::common_sense }
  use base "AnyEvent::Base";
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = Irssi::input_add
        $fd,
        $arg{poll} eq "r" ? Irssi::INPUT_READ : Irssi::INPUT_WRITE,
        $cb,
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::io"
  }
  
  sub AnyEvent::Impl::Irssi::io::DESTROY {
     Irssi::input_remove $${$_[0]};
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb    = $arg{cb};
     my $ival  = $arg{interval} * 1000;
     my $after = $arg{after} * 1000;
  
     my $source; $source = Irssi::timeout_add_once $after > 10 ? $after : 10,
        ($ival ? sub {
                   $source = Irssi::timeout_add $ival > 10 ? $ival : 10, $cb, undef;
                   &$cb;
                   0
                 }
               : $cb),
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::timer"
  }
  
  sub AnyEvent::Impl::Irssi::timer::DESTROY {
     Irssi::timeout_remove $${$_[0]};
  }
  
  my $_pidwait = sub {
     my ($rpid, $rstatus) = @_;
  
     AnyEvent::Base->_emit_childstatus ($rpid, $rstatus);
  };
  
  Irssi::signal_add pidwait => $_pidwait;
  
  sub _emit_childstatus {
     my ($self, $rpid, $rstatus) = @_;
     $self->SUPER::_emit_childstatus ($rpid, $rstatus);
  
     Irssi::signal_remove pidwait => $_pidwait;
     Irssi::signal_emit   pidwait => $rpid+0, $rstatus+0;
     Irssi::signal_add    pidwait => $_pidwait;
  }
  
  #sub loop {
  #   Carp::croak "Irssi does not support blocking waits";
  #}
  
  
  1
  
ANYEVENT_IMPL_IRSSI

$fatpacked{"AnyEvent/Impl/POE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_POE';
  package AnyEvent::Impl::POE;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use POE;
  ${POE::Kernel->new->[POE::Kernel::KR_RUN]}|=POE::Kernel::KR_RUN_CALLED;
  sub io{
  my($class,%arg)=@_;
  my($fh,$pee)=AnyEvent::_dupfh$arg{poll},$arg{fh},"select_read","select_write";
  my$cb=delete$arg{cb};
  my$cb=sub{&$cb};
  my$session=POE::Session->create(
  inline_states=>{
  _start=>sub{$_[KERNEL]->$pee($fh=>"ready")},
  ready=>sub{$cb->()},
  stop=>sub{$_[KERNEL]->$pee($fh)},
  },
  );
  bless\\$session,"AnyEvent::Impl::POE"
  }
  sub timer{
  my($class,%arg)=@_;
  my$after=delete$arg{after};
  my$ival=delete$arg{interval};
  my$cb=delete$arg{cb};
  my$cb=sub{&$cb};
  my$session=POE::Session->create(
  inline_states=>{
  _start=>sub{
  $_[KERNEL]->delay_set(timeout=>$after);
  },
  timeout=>$ival?sub{$_[KERNEL]->delay_set(timeout=>$ival);$cb->()}:$cb,
  stop=>sub{
  $_[KERNEL]->alarm_remove_all;
  },
  },
  );
  bless\\$session,"AnyEvent::Impl::POE"
  }
  sub signal{
  my($class,%arg)=@_;
  my$signal=AnyEvent::Base::sig2name delete$arg{signal};
  my$cb=delete$arg{cb};
  my$cb=sub{&$cb};
  my$session=POE::Session->create(
  inline_states=>{
  _start=>sub{
  },
  start=>sub{
  $_[KERNEL]->sig($signal=>"catch");
  $_[KERNEL]->refcount_increment($_[SESSION]->ID=>"poe");
  },
  catch=>sub{
  $cb->();
  $_[KERNEL]->sig_handled;
  },
  stop=>sub{
  $_[KERNEL]->refcount_decrement($_[SESSION]->ID=>"poe");
  $_[KERNEL]->sig($signal);
  },
  },
  );
  POE::Kernel->call($session,"start");
  bless\\$session,"AnyEvent::Impl::POE"
  }
  sub child{
  my($class,%arg)=@_;
  my$pid=delete$arg{pid};
  my$cb=delete$arg{cb};
  my$cb=sub{&$cb};
  my$session=POE::Session->create(
  inline_states=>{
  _start=>sub{
  },
  start=>sub{
  $_[KERNEL]->sig(CHLD=>"child");
  $_[KERNEL]->refcount_increment($_[SESSION]->ID=>"poe");
  },
  child=>sub{
  my($rpid,$status)=@_[ARG1,ARG2];
  $cb->($rpid,$status)if$rpid==$pid||$pid==0;
  },
  stop=>sub{
  $_[KERNEL]->refcount_decrement($_[SESSION]->ID=>"poe");
  $_[KERNEL]->sig("CHLD");
  },
  },
  );
  POE::Kernel->call($session,"start");
  bless\\$session,"AnyEvent::Impl::POE"
  }
  sub DESTROY{
  POE::Kernel->call(${${$_[0]}},"stop");
  }
  sub _poll{
  POE::Kernel->loop_do_timeslice;
  }
  sub AnyEvent::CondVar::Base::_wait{
  POE::Kernel->loop_do_timeslice until exists$_[0]{_ae_sent};
  }
  1
ANYEVENT_IMPL_POE

$fatpacked{"AnyEvent/Impl/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_PERL';
  package AnyEvent::Impl::Perl;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use AnyEvent::Loop;
  our$VERSION=$AnyEvent::VERSION;
  *AE::now=\&AnyEvent::Loop::now;
  *AE::now_update=\&AnyEvent::Loop::now_update;
  *AE::io=\&AnyEvent::Loop::io;
  *AE::timer=\&AnyEvent::Loop::timer;
  *AE::idle=\&AnyEvent::Loop::idle;
  *_poll=\&AnyEvent::Loop::one_event;
  *loop=\&AnyEvent::Loop::run;
  *now_update=\&AnyEvent::Loop::now_update;
  sub now{$AnyEvent::Loop::NOW}
  sub AnyEvent::CondVar::Base::_wait{
  AnyEvent::Loop::one_event until exists$_[0]{_ae_sent};
  }
  sub io{
  my(undef,%arg)=@_;
  AnyEvent::Loop::io$arg{fh},$arg{poll}eq"w",$arg{cb}
  }
  sub timer{
  my(undef,%arg)=@_;
  AnyEvent::Loop::timer$arg{after},$arg{interval},$arg{cb}
  }
  sub idle{
  my(undef,%arg)=@_;
  AnyEvent::Loop::idle$arg{cb}
  }
  1
ANYEVENT_IMPL_PERL

$fatpacked{"AnyEvent/Impl/Qt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_QT';
  package AnyEvent::Impl::Qt::Io;
  use Qt;
  use Qt::isa qw(Qt::SocketNotifier);
  use Qt::slots cb=>[];
  sub NEW{
  my($class,$fh,$mode,$cb)=@_;
  shift->SUPER::NEW(fileno$fh,$mode);
  this->{fh}=$fh;
  this->{cb}=$cb;
  this->connect(this,SIGNAL"activated(int)",SLOT"cb()");
  }
  sub cb{
  this->setEnabled(0);
  this->{cb}->();
  this->setEnabled(1);
  }
  package AnyEvent::Impl::Qt::Timer;
  use Qt;
  use Qt::isa qw(Qt::Timer);
  use Qt::slots cb=>[];
  sub NEW{
  my($class,$after,$interval,$cb)=@_;
  shift->SUPER::NEW();
  this->{interval}=$interval;
  this->{cb}=$cb;
  this->connect(this,SIGNAL"timeout()",SLOT"cb()");
  this->start($after,1);
  }
  sub cb{
  this->start(this->{interval},1)if defined this->{interval};
  this->{cb}->();
  }
  package AnyEvent::Impl::Qt;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use Qt;
  use AnyEvent::Impl::Qt::Timer;
  use AnyEvent::Impl::Qt::Io;
  our$app=Qt::Application\@ARGV;
  sub io{
  my($class,%arg)=@_;
  my($fh,$qt)=AnyEvent::_dupfh$arg{poll},$arg{fh},Qt::SocketNotifier::Read(),Qt::SocketNotifier::Write();
  AnyEvent::Impl::Qt::Io$fh,$qt,$arg{cb}
  }
  sub timer{
  my($class,%arg)=@_;
  AnyEvent::Impl::Qt::Timer$arg{after}*1000||1,$arg{interval}?$arg{interval}*1000||1:undef,$arg{cb}
  }
  sub _poll{
  Qt::app->processOneEvent;
  }
  sub AnyEvent::CondVar::Base::_wait{
  Qt::app->processOneEvent until exists$_[0]{_ae_sent};
  }
  1
ANYEVENT_IMPL_QT

$fatpacked{"AnyEvent/Impl/Tk.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_TK';
  package AnyEvent::Impl::Tk;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use Tk ();
  our$mw=new MainWindow -title=>"AnyEvent Dummy Window";
  $mw->withdraw;
  END{undef$mw}
  sub io{
  my(undef,%arg)=@_;
  my($fh,$tk)=AnyEvent::_dupfh$arg{poll},$arg{fh},"readable","writable";
  $mw->fileevent($fh,$tk=>$arg{cb});
  bless[$fh,$tk],"AnyEvent::Impl::Tk::io"
  }
  sub AnyEvent::Impl::Tk::io::DESTROY{
  my($fh,$tk)=@{$_[0]};
  $mw->fileevent($fh,$tk=>"");
  }
  sub timer{
  my(undef,%arg)=@_;
  my$after=$arg{after}<0?0:$arg{after}*1000;
  my$cb=$arg{cb};
  my$id;
  if($arg{interval}){
  my$ival=$arg{interval}*1000;
  my$rcb=sub{
  $id=Tk::after$mw,$ival,[$_[0],$_[0]];
  &$cb;
  };
  $id=Tk::after$mw,$after,[$rcb,$rcb];
  }
  else{
  $id=Tk::after$mw,$after,sub{&$cb};
  }
  bless\\$id,"AnyEvent::Impl::Tk::after"
  }
  sub idle{
  my(undef,%arg)=@_;
  my$cb=$arg{cb};
  my$id;
  my$rcb=sub{
  $id=Tk::after$mw,0=>[
  sub{
  $id=Tk::after$mw,idle=>[$_[0],$_[0]];
  },
  $_[0]
  ];
  &$cb;
  };
  $id=Tk::after$mw,idle=>[$rcb,$rcb];
  bless\\$id,"AnyEvent::Impl::Tk::after"
  }
  sub AnyEvent::Impl::Tk::after::DESTROY{
  Tk::after$mw,cancel=>$${$_[0]};
  }
  sub _poll{
  Tk::DoOneEvent(0);
  }
  sub AnyEvent::CondVar::Base::_wait{
  Tk::DoOneEvent(0)until exists$_[0]{_ae_sent};
  }
  1
ANYEVENT_IMPL_TK

$fatpacked{"AnyEvent/Impl/UV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_UV';
  package AnyEvent::Impl::UV;
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use UV 0.24;
  use Scalar::Util qw(weaken);
  sub warnlog{
  my$err=UV::last_error;
  AnyEvent::log warn=>"returned $_[0]: ".UV::err_name($err)."($err): ".UV::strerror($err);
  @_
  }
  my%io_watchers;
  sub io_watcher_cb{
  my$slaves=shift;
  my(undef,$events)=@_;
  return unless defined$slaves;
  foreach my $entry(keys%$slaves){
  my$slave=$slaves->{$entry};
  $slave->{cb}(@_)if$slave->{mode}&$events;
  }
  }
  sub AnyEvent::Impl::UV::io_slave::new{
  bless{parent=>$_[1]},$_[0]
  }
  sub AnyEvent::Impl::UV::io_slave::DESTROY{
  my$self=$_[0];
  my$master=$self->{parent};
  delete$master->{slaves}{$self};
  if(keys%{$master->{slaves}}==0){
  if(defined$master->{w}){
  my$rc=UV::poll_stop$master->{w};
  warnlog$rc if$rc;
  }
  delete$io_watchers{$master->{fd}};
  return;
  }
  my$mode=0;
  foreach my $entry(keys%{$master->{slaves}}){
  $mode|=$master->{slaves}{$entry}{mode};
  }
  if($master->{mode}!=$mode){
  $master->{mode}=$mode;
  my$rc=UV::poll_start$master->{w},$master->{mode},sub{
  io_watcher_cb$master->{slaves},@_;
  };
  warnlog$rc if$rc;
  }
  }
  sub io{
  my($class,%arg)=@_;
  my$fd=fileno$arg{fh};
  defined$fd or$fd=$arg{fh};
  my$master=$io_watchers{$fd}||={fd=>$fd};
  unless(defined$master->{w}){
  $master->{w}=UV::poll_init$fd;
  return warnlog$master->{w}unless defined$master->{w};
  $master->{slaves}={};
  }
  my$slave=AnyEvent::Impl::UV::io_slave->new($master);
  weaken($master->{slaves}->{$slave}=$slave);
  $slave->{mode}=$arg{poll}eq"r"?UV::READABLE:UV::WRITABLE;
  $master->{mode}=0 unless defined$master->{mode};
  $slave->{cb}=$arg{cb};
  unless($master->{mode}&$slave->{mode}){
  $master->{mode}|=$slave->{mode};
  my$rc=UV::poll_start$master->{w},$master->{mode},sub{
  io_watcher_cb$master->{slaves},@_;
  };
  warnlog$rc if$rc;
  }
  $slave
  }
  sub AnyEvent::Impl::UV::handle::new{
  my($class,$w,$start,$stop,@args)=@_;
  return warnlog$w unless defined$w;
  my$rc=$start->($w,@args);
  warnlog$rc if$rc;
  bless{w=>$w,stop=>$stop},$class
  }
  sub AnyEvent::Impl::UV::handle::DESTROY{
  my$h=$_[0];
  return unless$h->{w};
  my$rc=$h->{stop}($h->{w});
  warnlog$rc if$rc;
  UV::close$h->{w};
  }
  sub idle{
  my($class,%arg)=@_;
  AnyEvent::Impl::UV::handle->new(UV::timer_init,\&UV::idle_start,\&UV::idle_stop,$arg{cb});
  }
  sub timer{
  my($class,%arg)=@_;
  AnyEvent::Impl::UV::handle->new(UV::timer_init,\&UV::timer_start,\&UV::timer_stop,$arg{after}*1000,$arg{interval}*1000,$arg{cb});
  }
  sub now{UV::now}
  sub _poll{
  UV::run UV::RUN_ONCE;
  }
  sub AnyEvent::CondVar::Base::_wait{
  UV::run UV::RUN_NOWAIT until exists$_[0]{_ae_sent};
  }
  1
ANYEVENT_IMPL_UV

$fatpacked{"AnyEvent/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_LOG';
  package AnyEvent::Log;
  use Carp ();
  use POSIX ();
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  our$VERSION=$AnyEvent::VERSION;
  our($COLLECT,$FILTER,$LOG);
  our($now_int,$now_str1,$now_str2);
  sub format_time($){
  my$i=int$_[0];
  my$f=sprintf"%06d",1e6*($_[0]-$i);
  ($now_int,$now_str1,$now_str2)=($i,split/\x01/,POSIX::strftime"%Y-%m-%d %H:%M:%S.\x01 %z",localtime$i)
    if$now_int!=$i;
  "$now_str1$f$now_str2"
  }
  our%CTX;
  sub _pkg_ctx($){
  my$ctx=bless[$_[0],(1 <<10)-1-1,{}],"AnyEvent::Log::Ctx";
  my$parent=$_[0]=~/^(.+)::/
    ?$CTX{$1}||=&_pkg_ctx("$1")
    :$COLLECT;
  $ctx->[2]{$parent+0}=$parent;
  $ctx
  }
  our%STR2LEVEL=(
  fatal=>1,
  emerg=>1,
  exit=>1,
  alert=>2,
  critical=>3,
  crit=>3,
  error=>4,
  err=>4,
  die=>4,
  warn=>5,
  warning=>5,
  note=>6,
  notice=>6,
  info=>7,
  debug=>8,
  trace=>9,
  );
  our$TIME_EXACT;
  sub exact_time($){
  $TIME_EXACT=shift;
  *_ts=
     $AnyEvent::MODEL
    ?$TIME_EXACT
    ?\&AE::now
    :\&AE::time
    :sub (){
  $TIME_EXACT?do{require Time::HiRes;Time::HiRes::time()}:time
    };
  }
  BEGIN{
  exact_time 0;
  }
  AnyEvent::post_detect{
  exact_time$TIME_EXACT;
  };
  our@LEVEL2STR=qw(0 fatal alert crit error warn note info debug trace);
  sub default_format($$$$){
  my$ts=format_time$_[0];
  my$ct=" ";
  my@res;
  for(split/\n/,sprintf"%-5s %s: %s",$LEVEL2STR[$_[2]],$_[1][0],$_[3]){
  push@res,"$ts$ct$_\n";
  $ct=" + ";
  }
  join"",@res
  }
  sub fatal_exit(){
  exit 1;
  }
  sub _log{
  my($ctx,$level,$format,@args)=@_;
  $level=
     $level>0&&$level<=9
    ?$level+0
    :$STR2LEVEL{$level}||Carp::croak"$level: not a valid logging level, caught";
  my$mask=1 <<$level;
  my($success,%seen,@ctx,$now,@fmt);
  do{
  if(!ref$ctx){
  $level=$ctx;
  }
  elsif($ctx->[1]&$mask and!$seen{$ctx+0}++){
  if($ctx->[5]>$level){
  push@ctx,$level;
  $level=$ctx->[5];
  }
  if($ctx->[3]){
  local($!,$@);
  unless($now){
  $format=$format->()if ref$format;
  $format=sprintf$format,@args if@args;
  $format=~s/\n$//;
  $now=_ts;
  }
  my$str=
     $ctx->[4]
    ?$ctx->[4]($now,$_[0],$level,$format)
    :($fmt[$level]||=default_format$now,$_[0],$level,$format);
  $success=1;
  $ctx->[3]($str)
    or push@ctx,values%{$ctx->[2]};
  }
  else{
  push@ctx,values%{$ctx->[2]};
  }
  }
  }while$ctx=pop@ctx;
  fatal_exit if$level<=1;
  $success
  }
  sub log($$;@){
  _log$CTX{(caller)[0]}||=_pkg_ctx+(caller)[0],@_;
  }
  our%LOGGER;
  sub _reassess{
  local$SIG{__DIE__};
  my$die=sub{die};
  for(@_?$LOGGER{$_[0]}:values%LOGGER){
  my($ctx,$level,$renabled)=@$_;
  $$renabled=!eval{
  _log$ctx,$level,$die;
  1
  };
  }
  }
  sub _logger{
  my($ctx,$level,$renabled)=@_;
  $$renabled=1;
  my$logger=[$ctx,$level,$renabled];
  $LOGGER{$logger+0}=$logger;
  _reassess$logger+0;
  require AnyEvent::Util unless$AnyEvent::Util::VERSION;
  my$guard=AnyEvent::Util::guard(
  sub{
  delete$LOGGER{$logger+0};
  }
  );
  sub{
  $guard if 0;
  _log$ctx,$level,@_
    if$$renabled;
  }
  }
  sub logger($;$){
  _logger$CTX{(caller)[0]}||=_pkg_ctx+(caller)[0],@_
  }
  sub ctx(;$){
  my$pkg=@_?shift:(caller)[0];
  ref$pkg?$pkg
    :defined$pkg?$CTX{$pkg}||=AnyEvent::Log::_pkg_ctx$pkg
    :bless[undef,(1 <<10)-1-1],"AnyEvent::Log::Ctx"
  }
  our$ORIG_VERBOSE=$AnyEvent::VERBOSE;
  $AnyEvent::VERBOSE=9;
  sub reset{
  while(my($k,$v)=each%CTX){
  @$v=($k,(1 <<10)-1-1,{});
  $v->attach($k=~/^(.+)::/?$CTX{$1}:$AnyEvent::Log::COLLECT);
  }
  @$_=($_->[0],(1 <<10)-1-1)for$LOG,$FILTER,$COLLECT;
  $LOG->title('$AnyEvent::Log::LOG');
  $LOG->log_to_warn;
  $FILTER->slaves($LOG);
  $FILTER->title('$AnyEvent::Log::FILTER');
  $FILTER->level($ORIG_VERBOSE);
  $COLLECT->slaves($FILTER);
  $COLLECT->title('$AnyEvent::Log::COLLECT');
  _reassess;
  }
  *AnyEvent::log=*AE::log=\&log;
  *AnyEvent::logger=*AE::logger=\&logger;
  $_->[0]=ctx$_->[0]for values%LOGGER;
  $LOG=ctx undef;
  $FILTER=ctx undef;
  $COLLECT=ctx undef;
  AnyEvent::Log::reset;
  package AnyEvent::Log::LOG;
  package AE::Log::LOG;
  package AnyEvent::Log::FILTER;
  package AE::Log::FILTER;
  package AnyEvent::Log::COLLECT;
  package AE::Log::COLLECT;
  package AnyEvent::Log::Ctx;
  sub new{
  my$class=shift;
  my$ctx=AnyEvent::Log::ctx undef;
  while(@_){
  my($k,$v)=splice@_,0,2;
  $ctx->$k(ref$v eq"ARRAY"?@$v:$v);
  }
  bless$ctx,$class
  }
  sub title{
  $_[0][0]=$_[1]if@_>1;
  $_[0][0]
  }
  sub _lvl_lst{
  map{$_>0&&$_<=9?$_+0:$_ eq"all"?(1..9):$STR2LEVEL{$_}||Carp::croak"$_: not a valid logging level, caught"}@_
  }
  sub _lvl{
  $_[0]=~/^(?:0|off|none)$/?0:(_lvl_lst$_[0])[-1]
  }
  our$NOP_CB=sub{0};
  sub levels{
  my$ctx=shift;
  $ctx->[1]=0;
  $ctx->[1]|=1 <<$_ for&_lvl_lst;
  AnyEvent::Log::_reassess;
  }
  sub level{
  my$ctx=shift;
  $ctx->[1]=((1 <<&_lvl)-1) <<1;
  AnyEvent::Log::_reassess;
  }
  sub enable{
  my$ctx=shift;
  $ctx->[1]|=1 <<$_ for&_lvl_lst;
  AnyEvent::Log::_reassess;
  }
  sub disable{
  my$ctx=shift;
  $ctx->[1]&=~(1 <<$_)for&_lvl_lst;
  AnyEvent::Log::_reassess;
  }
  sub cap{
  my$ctx=shift;
  $ctx->[5]=&_lvl;
  }
  sub attach{
  my$ctx=shift;
  $ctx->[2]{$_+0}=$_ for map{AnyEvent::Log::ctx$_ }@_;
  }
  sub detach{
  my$ctx=shift;
  delete$ctx->[2]{$_+0}for map{AnyEvent::Log::ctx$_ }@_;
  }
  sub slaves{
  undef$_[0][2];
  &attach;
  }
  sub log_cb{
  my($ctx,$cb)=@_;
  $ctx->[3]=$cb;
  }
  sub fmt_cb{
  my($ctx,$cb)=@_;
  $ctx->[4]=$cb;
  }
  sub log_to_warn{
  my($ctx,$path)=@_;
  $ctx->log_cb(
  sub{
  warn shift;
  0
  }
  );
  }
  sub _log_to_disk{
  eval q{ # poor man's autoloading {}
        sub _log_to_disk {
           my ($ctx, $path, $keepopen) = @_;
  
           my $fh;
           my @queue;
           my $delay;
           my $disable;
  
           use AnyEvent::IO ();
  
           my $kick = sub {
              undef $delay;
              return unless @queue;
              $delay = 1;
  
              # we pass $kick to $kick, so $kick itself doesn't keep a reference to $kick.
              my $kick = shift;
  
              # write one or more messages
              my $write = sub {
                 # we write as many messages as have been queued
                 my $data = join "", @queue;
                 @queue = ();
  
                 AnyEvent::IO::aio_write $fh, $data, sub {
                    $disable = 1;
                    @_
                       ? ($_[0] == length $data or AE::log 4 => "unable to write to logfile '$path': short write")
                       :                           AE::log 4 => "unable to write to logfile '$path': $!";
                    undef $disable;
  
                    if ($keepopen) {
                       $kick->($kick);
                    } else {
                       AnyEvent::IO::aio_close ($fh, sub {
                          undef $fh;
                          $kick->($kick);
                       });
                    }
                 };
              };
  
              if ($fh) {
                 $write->();
              } else {
                 AnyEvent::IO::aio_open
                    $path,
                    AnyEvent::IO::O_CREAT | AnyEvent::IO::O_WRONLY | AnyEvent::IO::O_APPEND,
                    0666,
                    sub {
                       $fh = shift
                          or do {
                             $disable = 1;
                             AE::log 4 => "unable to open logfile '$path': $!";
                             undef $disable;
                             return;
                          };
  
                       $write->();
                    }
                 ;
              }
           };
  
           $ctx->log_cb (sub {
              return if $disable;
              push @queue, shift;
              $kick->($kick) unless $delay;
              0
           });
  
           $kick->($kick) if $keepopen; # initial open
        };
     };
  die if$@;
  &_log_to_disk
  }
  sub log_to_file{
  my($ctx,$path)=@_;
  _log_to_disk$ctx,$path,1;
  }
  sub log_to_path{
  my($ctx,$path)=@_;
  _log_to_disk$ctx,$path,0;
  }
  sub log_to_syslog{
  my($ctx,$facility)=@_;
  require Sys::Syslog;
  $ctx->fmt_cb(
  sub{
  my$str=$_[3];
  $str=~s/\n(?=.)/\n+ /g;
  [$_[2],"($_[1][0]) $str"]
  }
  );
  $facility||="user";
  $ctx->log_cb(
  sub{
  my$lvl=$_[0][0]<9?$_[0][0]:8;
  Sys::Syslog::syslog("$facility|".($lvl-1),$_)for split/\n/,$_[0][1];
  0
  }
  );
  }
  *log=\&AnyEvent::Log::_log;
  *logger=\&AnyEvent::Log::_logger;
  package AnyEvent::Log;
  for(my$spec=$ENV{PERL_ANYEVENT_LOG}){
  my%anon;
  my$pkg=sub{
     $_[0]eq"log"?$LOG
    :$_[0]eq"filter"?$FILTER
    :$_[0]eq"collect"?$COLLECT
    :$_[0]=~/^%(.+)$/?(
  $anon{$1}||=do{my$ctx=ctx undef;$ctx->[0]=$_[0];$ctx}
    )
    :$_[0]=~/^(.*?)(?:::)?$/?ctx"$1"
    :die
  };
  /\G[[:space:]]+/gc;
  while(/\G((?:[^:=[:space:]]+|::|\\.)+)=/gc){
  my$ctx=$pkg->($1);
  my$level="level";
  while(/\G((?:[^,:[:space:]]+|::|\\.)+)/gc){
  for("$1"){
  if($_ eq"stderr"){
  $ctx->log_to_warn;
  }
  elsif(/^file=(.+)/){
  $ctx->log_to_file("$1");
  }
  elsif(/^path=(.+)/){
  $ctx->log_to_path("$1");
  }
  elsif(/^syslog(?:=(.*))?/){
  require Sys::Syslog;
  $ctx->log_to_syslog("$1");
  }
  elsif($_ eq"nolog"){
  $ctx->log_cb(undef);
  }
  elsif(/^cap=(.+)/){
  $ctx->cap("$1");
  }
  elsif(/^\+(.+)$/){
  $ctx->attach($pkg->("$1"));
  }
  elsif($_ eq"+"){
  $ctx->slaves;
  }
  elsif($_ eq"off" or$_ eq"0"){
  $ctx->level(0);
  }
  elsif($_ eq"all"){
  $ctx->level("all");
  }
  elsif($_ eq"level"){
  $ctx->level("all");
  $level="level";
  }
  elsif($_ eq"only"){
  $ctx->level("off");
  $level="enable";
  }
  elsif($_ eq"except"){
  $ctx->level("all");
  $level="disable";
  }
  elsif(/^\d$/){
  $ctx->$level($_);
  }
  elsif(exists$STR2LEVEL{$_}){
  $ctx->$level($_);
  }
  else{
  die"PERL_ANYEVENT_LOG ($spec): parse error at '$_'\n";
  }
  }
  /\G,/gc or last;
  }
  /\G[:[:space:]]+/gc or last;
  }
  /\G[[:space:]]+/gc;
  if(/\G(.+)/g){
  die"PERL_ANYEVENT_LOG ($spec): parse error at '$1'\n";
  }
  }
  1
ANYEVENT_LOG

$fatpacked{"AnyEvent/Loop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_LOOP';
  package AnyEvent::Loop;
  use Scalar::Util qw(weaken);
  use List::Util ();
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use AnyEvent::Util ();
  our$VERSION=$AnyEvent::VERSION;
  our($NOW,$MNOW);
  sub MAXWAIT(){3600}
  BEGIN{
  local$SIG{__DIE__};
  my$time_hires=eval"use Time::HiRes (); 1";
  my$clk_tck=eval"use POSIX (); POSIX::sysconf (POSIX::_SC_CLK_TCK ())";
  my$round;
  if($time_hires&&eval"&Time::HiRes::clock_gettime (Time::HiRes::CLOCK_MONOTONIC ())"){
  AE::log 8=>"Using CLOCK_MONOTONIC as timebase.";
  *_update_clock=sub{
  $NOW=&Time::HiRes::time;
  $MNOW=Time::HiRes::clock_gettime(&Time::HiRes::CLOCK_MONOTONIC);
  };
  }
  elsif(100<=$clk_tck&&$clk_tck<=1000000&&eval{(POSIX::times())[0]!=-1}){
  AE::log 8=>"Using POSIX::times (monotonic) as timebase.";
  my$HZ1=1/$clk_tck;
  my$last=(POSIX::times())[0];
  my$next;
  *_update_clock=sub{
  $NOW=time;
  $next=(POSIX::times())[0];
  $last-=4294967296 if$last>$next;
  $MNOW+=($next-$last)*$HZ1;
  $last=$next;
  };
  $round=$HZ1;
  }
  elsif(eval"use Time::HiRes (); 1"){
  AE::log 8=>"Using Time::HiRes::time (non-monotonic) clock as timebase.";
  *_update_clock=sub{
  $NOW=$MNOW=&Time::HiRes::time;
  };
  }
  else{
  AE::log fatal=>"Unable to find sub-second time source (is this really perl 5.8.0 or later?)";
  }
  $round=0.001 if$round<0.001;
  $round-=$round*1e-2;
  eval"sub ROUNDUP() { $round }";
  }
  _update_clock;
  sub now (){$NOW}
  sub now_update(){_update_clock}
  my@fds=([],[]);
  sub V(){0}
  sub W(){1}
  my$need_sort=1e300;
  my@timer;
  my@idle;
  sub one_event{
  _update_clock;
  if($MNOW>=$need_sort){
  $need_sort=1e300;
  @timer=sort{$a->[0]<=>$b->[0]}@timer;
  }
  if(@timer&&$timer[0][0]<=$MNOW){
  do{
  my$timer=shift@timer;
  $timer->[1]&&$timer->[1]($timer);
  }while@timer&&$timer[0][0]<=$MNOW;
  }
  else{
  my($wait,@vec,$fds)=
    (@timer&&$timer[0][0]<$need_sort?$timer[0][0]:$need_sort)-$MNOW;
  $wait=$wait<MAXWAIT?$wait+ROUNDUP:MAXWAIT;
  $wait=0 if@idle;
  $fds=CORE::select
    $vec[0]=$fds[0][V],
    $vec[1]=$fds[1][V],
    AnyEvent::WIN32?$vec[2]=$fds[1][V]:undef,
    $wait;
  _update_clock;
  if($fds>0){
  $vec[1]|=$vec[2]if AnyEvent::WIN32;
  for(1,0){
  my$fds=$fds[$_];
  for(unpack"b*",$vec[$_]){
  while(/1/g){
  $_&&$_->[2]()for@{$fds->[W][(pos)-1]||[]};
  }
  }
  }
  }
  elsif(AnyEvent::WIN32&&$fds&&$!==AnyEvent::Util::WSAEINVAL){
  CORE::select undef,undef,undef,$wait if$wait;
  }
  elsif(!@timer||$timer[0][0]>$MNOW&&!$fds){
  $$$_&&$$$_->()for@idle=grep$$$_,@idle;
  }
  }
  }
  sub run{
  one_event while 1;
  }
  sub io($$$){
  my($fd,$write,$cb)=@_;
  defined($fd=fileno$fd)
    or$fd=$_[0];
  my$self=bless[$fd,$write,$cb,],"AnyEvent::Loop::io";
  my$fds=$fds[$self->[1]];
  my$q=$fds->[W][$fd]||=[];
  (vec$fds->[V],$fd,1)=1;
  $self->[3]=@$q;
  push@$q,$self;
  weaken$q->[-1];
  $self
  }
  sub AnyEvent::Loop::io::DESTROY{
  my($self)=@_;
  my$fds=$fds[$self->[1]];
  my$fd=$self->[0];
  if(@{$fds->[W][$fd]}==1){
  delete$fds->[W][$fd];
  (vec$fds->[V],$fd,1)=0;
  }
  else{
  my$q=$fds->[W][$fd];
  my$last=pop@$q;
  if($last!=$self){
  weaken($q->[$self->[3]]=$last);
  $last->[3]=$self->[3];
  }
  }
  }
  sub timer($$$){
  my($after,$interval,$cb)=@_;
  my$self;
  if($interval){
  $self=[
  $MNOW+$after,
  sub{
  $_[0][0]=List::Util::max$_[0][0]+$interval,$MNOW;
  push@timer,$_[0];
  weaken$timer[-1];
  $need_sort=$_[0][0]if$_[0][0]<$need_sort;
  &$cb;
  }
  ];
  }
  else{
  $self=[$MNOW+$after,$cb];
  }
  push@timer,$self;
  weaken$timer[-1];
  $need_sort=$self->[0]if$self->[0]<$need_sort;
  $self
  }
  sub idle($){
  my$cb=shift;
  push@idle,\\$cb;
  weaken${$idle[-1]};
  ${$idle[-1]}
  }
  1
ANYEVENT_LOOP

$fatpacked{"AnyEvent/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_SOCKET';
  package AnyEvent::Socket;
  use Carp ();
  use Errno ();
  use Socket qw(AF_INET AF_UNIX SOCK_STREAM SOCK_DGRAM SOL_SOCKET SO_REUSEADDR);
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use AnyEvent::Util qw(guard AF_INET6);
  use AnyEvent::DNS ();
  use base 'Exporter';
  our@EXPORT=qw(
    getprotobyname
    parse_hostport format_hostport
    parse_ipv4 parse_ipv6
    parse_ip parse_address
    format_ipv4 format_ipv6
    format_ip format_address
    address_family
    inet_aton
    tcp_server
    tcp_connect
  );
  our$VERSION=$AnyEvent::VERSION;
  sub parse_ipv4($){
  $_[0]=~/^      (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* )
                (?:\. (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* ) ){0,3}$/x
    or return undef;
  @_=map/^0/?oct:$_,split/\./,$_[0];
  return undef if grep$_>=256,@_[0..@_-2];
  return undef if$_[-1]>=2**(8*(4-$#_));
  pack"N",(pop)+($_[0] <<24)+($_[1] <<16)+($_[2] <<8);
  }
  sub parse_ipv6($){
  my$n=$_[0]=~y/://;
  return undef if$n<2||$n>8;
  my($h,$t)=split/::/,$_[0],2;
  unless(defined$t){
  ($h,$t)=(undef,$h);
  }
  my@h=split/:/,$h,-1;
  my@t=split/:/,$t,-1;
  if(@t&&$t[-1]=~/\./){
  return undef if$n>6;
  my$ipn=parse_ipv4 pop@t
    or return undef;
  push@t,map+(sprintf"%x",$_),unpack"nn",$ipn;
  }
  return undef unless@h+@t==8||$_[0]=~/::/;
  return undef if grep!/^[0-9a-fA-F]{1,4}$/,@h,@t;
  push@h,0 while@h+@t<8;
  pack"n*",map hex,@h,@t
  }
  sub parse_unix($){
  $_[0]eq"unix/"
    ?pack"S",AF_UNIX
    :undef
  }
  sub parse_address($){
  for(&parse_ipv6){
  if($_){
  s/^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff//;
  return$_;
  }
  else{
  return&parse_ipv4||&parse_unix
  }
  }
  }
  *aton=\&parse_address;
  our%PROTO_BYNAME;
  $PROTO_BYNAME{tcp}=Socket::IPPROTO_TCP()if defined&Socket::IPPROTO_TCP;
  $PROTO_BYNAME{udp}=Socket::IPPROTO_UDP()if defined&Socket::IPPROTO_UDP;
  $PROTO_BYNAME{icmp}=Socket::IPPROTO_ICMP()if defined&Socket::IPPROTO_ICMP;
  sub getprotobyname($){
  my$name=lc shift;
  defined(my$proton=$PROTO_BYNAME{$name}||(getprotobyname$name)[2])
    or return;
  ($name,uc$name,$proton)
  }
  sub parse_hostport($;$){
  my($host,$port);
  for("$_[0]"){
  return("unix/",$_)
    if m%^/%;
  unless(($host)=/^\s* ([0-9a-fA-F:]*:[0-9a-fA-F:]*:[0-9a-fA-F\.:]*)/xgc
  and parse_ipv6$host )
  {
  /^\s*/xgc;
  if(/^ \[ ([^\[\]]+) \]/xgc){
  $host=$1;
  }
  elsif(/^ ([^\[\]:\ ]+) /xgc){
  $host=$1;
  }
  else{
  return;
  }
  }
  if(/\G (?:\s+|:|\#) ([^:[:space:]]+) \s*$/xgc){
  $port=$1;
  }
  elsif(/\G\s*$/gc&&length$_[1]){
  $port=$_[1];
  }
  else{
  return;
  }
  }
  return if$host=~/:/&&!parse_ipv6$host;
  ($host,$port)
  }
  sub format_hostport($;$){
  my($host,$port)=@_;
  $port=":$port"  if length$port;
  $host="[$host]" if$host=~/:/;
  "$host$port"
  }
  sub address_family($){
     4==length$_[0]?AF_INET
    :16==length$_[0]?AF_INET6
    :unpack"S",$_[0]
  }
  sub format_ipv4($){
  join".",unpack"C4",$_[0]
  }
  sub format_ipv6($){
  if($_[0]=~/^\x00\x00\x00\x00\x00\x00\x00\x00/){
  if(v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 eq$_[0]){
  return"::";
  }
  elsif(v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1 eq$_[0]){
  return"::1";
  }
  elsif(v0.0.0.0.0.0.0.0.0.0.0.0 eq substr$_[0],0,12){
  return"::".format_ipv4 substr$_[0],12;
  }
  elsif(v0.0.0.0.0.0.0.0.0.0.255.255 eq substr$_[0],0,12){
  return"::ffff:".format_ipv4 substr$_[0],12;
  }
  elsif(v0.0.0.0.0.0.0.0.255.255.0.0 eq substr$_[0],0,12){
  return"::ffff:0:".format_ipv4 substr$_[0],12;
  }
  }
  my$ip=sprintf"%x:%x:%x:%x:%x:%x:%x:%x",unpack"n8",$_[0];
      $ip=~s/(?:^|:) 0:0:0:0:0:0:0 (?:$|:)/::/x
    or$ip=~s/(?:^|:)   0:0:0:0:0:0 (?:$|:)/::/x
    or$ip=~s/(?:^|:)     0:0:0:0:0 (?:$|:)/::/x
    or$ip=~s/(?:^|:)       0:0:0:0 (?:$|:)/::/x
    or$ip=~s/(?:^|:)         0:0:0 (?:$|:)/::/x
    or$ip=~s/(?:^|:)           0:0 (?:$|:)/::/x;
  $ip
  }
  sub format_address($){
  if(4==length$_[0]){
  return&format_ipv4;
  }
  elsif(16==length$_[0]){
  return$_[0]=~/^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff(....)$/s
    ?format_ipv4$1
    :&format_ipv6;
  }
  elsif(AF_UNIX==address_family$_[0]){
  return"unix/"
  }
  else{
  return undef
  }
  }
  *ntoa=\&format_address;
  sub inet_aton{
  my($name,$cb)=@_;
  if(my$ipn=&parse_ipv4){
  $cb->($ipn);
  }
  elsif(my$ipn=&parse_ipv6){
  $cb->($ipn);
  }
  elsif($name eq"localhost"){
  $cb->(v127.0.0.1,v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1);
  }
  else{
  require AnyEvent::DNS unless$AnyEvent::DNS::VERSION;
  my$ipv4=$AnyEvent::PROTOCOL{ipv4};
  my$ipv6=$AnyEvent::PROTOCOL{ipv6};
  my@res;
  my$cv=AE::cv{
  $cb->(map@$_,reverse@res);
  };
  $cv->begin;
  if($ipv4){
  $cv->begin;
  AnyEvent::DNS::a(
  $name,
  sub{
  $res[$ipv4]=[map{parse_ipv4$_ }@_];
  $cv->end;
  }
  );
  }
  if($ipv6){
  $cv->begin;
  AnyEvent::DNS::aaaa(
  $name,
  sub{
  $res[$ipv6]=[map{parse_ipv6$_ }@_];
  $cv->end;
  }
  );
  }
  $cv->end;
  }
  }
  BEGIN{
  *sockaddr_family=
     $Socket::VERSION>=1.75?\&Socket::sockaddr_family
    :(Socket::pack_sockaddr_in 0x5555,"\x55\x55\x55\x55"|eval{Socket::pack_sockaddr_un"U"})=~/^\x00/?sub{unpack"xC",$_[0]}
    :sub{unpack"S",$_[0]};
  }
  my$pack_family=0x55==sockaddr_family("\x55\x55")?"xC":"S";
  sub pack_sockaddr($$){
  my$af=address_family$_[1];
  if($af==AF_INET){
  Socket::pack_sockaddr_in$_[0],$_[1]
  }
  elsif($af==AF_INET6){
  pack"$pack_family nL a16 L",AF_INET6,$_[0],0,$_[1],0
  }
  elsif($af==AF_UNIX){
  Socket::pack_sockaddr_un$_[0]
  }
  else{
  Carp::croak"pack_sockaddr: invalid host";
  }
  }
  my$sa_un_zero=
    $Socket::VERSION>=2.011
    ?""
    :eval{Socket::pack_sockaddr_un""};
  $sa_un_zero^=$sa_un_zero;
  sub unpack_sockaddr($){
  my$af=sockaddr_family$_[0];
  if($af==AF_INET){
  Socket::unpack_sockaddr_in$_[0]
  }
  elsif($af==AF_INET6){
  unpack"x2 n x4 a16",$_[0]
  }
  elsif($af==AF_UNIX){
  ((Socket::unpack_sockaddr_un$_[0]^$sa_un_zero),pack"S",AF_UNIX)
  }
  else{
  Carp::croak"unpack_sockaddr: unsupported protocol family $af";
  }
  }
  our%HOSTS;
  our@HOSTS_CHECKING;
  our$HOSTS_MTIME;
  sub _parse_hosts($){
  %HOSTS=();
  for(split/\n/,$_[0]){
  s/#.*$//;
  s/^[ \t]+//;
  y/A-Z/a-z/;
  my($addr,@aliases)=split/[ \t]+/;
  next unless@aliases;
  if(my$ip=parse_ipv4$addr){
  ($ip)=$ip=~/^(.*)$/s if AnyEvent::TAINT;
  push@{$HOSTS{$_}[0]},$ip for@aliases;
  }
  elsif(my$ip=parse_ipv6$addr){
  ($ip)=$ip=~/^(.*)$/s if AnyEvent::TAINT;
  push@{$HOSTS{$_}[1]},$ip for@aliases;
  }
  }
  }
  sub _load_hosts_unless(&$@){
  my($cont,$cv,@dns)=@_;
  if(@dns){
  $cv->end;
  }
  else{
  my$etc_hosts=
     length$ENV{PERL_ANYEVENT_HOSTS}?$ENV{PERL_ANYEVENT_HOSTS}
    :AnyEvent::WIN32?"$ENV{SystemRoot}/system32/drivers/etc/hosts"
    :"/etc/hosts";
  push@HOSTS_CHECKING,sub{
  $cont->();
  $cv->end;
  };
  unless($#HOSTS_CHECKING){
  require AnyEvent::IO;
  AnyEvent::IO::aio_stat(
  $etc_hosts,
  sub{
  if((stat _)[9]ne$HOSTS_MTIME){
  AE::log 8=>"(re)loading $etc_hosts.";
  $HOSTS_MTIME=(stat _)[9];
  AnyEvent::IO::aio_load(
  $etc_hosts,
  sub{
  _parse_hosts$_[0];
  (shift@HOSTS_CHECKING)->()while@HOSTS_CHECKING;
  }
  );
  }
  else{
  (shift@HOSTS_CHECKING)->()while@HOSTS_CHECKING;
  }
  }
  );
  }
  }
  }
  sub resolve_sockaddr($$$$$$){
  my($node,$service,$proto,$family,$type,$cb)=@_;
  if($node eq"unix/"){
  return$cb->()if$family||$service!~/^\//;
  return$cb->([AF_UNIX,defined$type?$type:SOCK_STREAM,0,Socket::pack_sockaddr_un$service]);
  }
  unless(AF_INET6){
  $family!=6
    or return$cb->();
  $family=4;
  }
  $cb->()if$family==4&&!$AnyEvent::PROTOCOL{ipv4};
  $cb->()if$family==6&&!$AnyEvent::PROTOCOL{ipv6};
  $family||=4 unless$AnyEvent::PROTOCOL{ipv6};
  $family||=6 unless$AnyEvent::PROTOCOL{ipv4};
  $proto||="tcp";
  $type||=$proto eq"udp"?SOCK_DGRAM:SOCK_STREAM;
  my$proton=AnyEvent::Socket::getprotobyname$proto
    or Carp::croak"$proto: protocol unknown";
  my$port;
  if($service=~/^(\S+)=(\d+)$/){
  ($service,$port)=($1,$2);
  }
  elsif($service=~/^\d+$/){
  ($service,$port)=(undef,$service);
  }
  else{
  $port=(getservbyname$service,$proto)[2]
    or Carp::croak"$service/$proto: service unknown";
  }
  my$resolve=sub{
  my@target=@_;
  my@res;
  my$cv=AE::cv{
  $cb->(map$_->[2],sort{$AnyEvent::PROTOCOL{$b->[1]}<=>$AnyEvent::PROTOCOL{$a->[1]}or$a->[0]<=>$b->[0]}@res)
  };
  $cv->begin;
  for my $idx(0..$#target){
  my($node,$port)=@{$target[$idx]};
  if(my$noden=parse_address$node){
  my$af=address_family$noden;
  if($af==AF_INET&&$family!=6){
  push@res,[$idx,"ipv4",[AF_INET,$type,$proton,pack_sockaddr$port,$noden]]
  }
  if($af==AF_INET6&&$family!=4){
  push@res,[$idx,"ipv6",[AF_INET6,$type,$proton,pack_sockaddr$port,$noden]]
  }
  }
  else{
  $node=~y/A-Z/a-z/;
  if($family!=6){
  $cv->begin;
  AnyEvent::DNS::a$node,sub{
  push@res,[$idx,"ipv4",[AF_INET,$type,$proton,pack_sockaddr$port,parse_ipv4$_]]for@_;
  _load_hosts_unless{
  push@res,map[$idx,"ipv4",[AF_INET,$type,$proton,pack_sockaddr$port,$_]],@{($HOSTS{$node}||[])->[0]};
  }
  $cv,@_;
  };
  }
  if($family!=4){
  $cv->begin;
  AnyEvent::DNS::aaaa$node,sub{
  push@res,[$idx,"ipv6",[AF_INET6,$type,$proton,pack_sockaddr$port,parse_ipv6$_]]for@_;
  _load_hosts_unless{
  push@res,map[$idx+0.5,"ipv6",[AF_INET6,$type,$proton,pack_sockaddr$port,$_]],@{($HOSTS{$node}||[])->[1]}
  }
  $cv,@_;
  };
  }
  }
  }
  $cv->end;
  };
  $node=AnyEvent::Util::idn_to_ascii$node
    if$node=~/[^\x00-\x7f]/;
  if($node eq"localhost"){
  $resolve->(["127.0.0.1",$port],["::1",$port]);
  }
  elsif(defined$service&&!parse_address$node){
  AnyEvent::DNS::srv$service,$proto,$node,sub{
  my(@srv)=@_;
  if(@srv){
  $srv[0][2]ne""||$#srv
    or return$cb->();
  $resolve->(map["$_->[3].",$_->[2]],grep$_->[3]ne".",@srv);
  }
  else{
  $resolve->([$node,$port]);
  }
  };
  }
  else{
  $resolve->([$node,$port]);
  }
  }
  sub tcp_connect($$$;$){
  my($host,$port,$connect,$prepare)=@_;
  my%state=(fh=>undef);
  resolve_sockaddr$host,$port,0,0,undef,sub{
  my@target=@_;
  $state{next}=sub{
  return unless exists$state{fh};
  my$errno=$!;
  my$target=shift@target
    or return AE::postpone{
  return unless exists$state{fh};
  %state=();
  $!=$errno;
  $connect->();
    };
  my($domain,$type,$proto,$sockaddr)=@$target;
  socket$state{fh},$domain,$type,$proto
    or return$state{next}();
  AnyEvent::fh_unblock$state{fh};
  my$timeout=$prepare&&$prepare->($state{fh});
  $timeout||=30 if AnyEvent::WIN32;
  $state{to}=AE::timer$timeout,0,sub{
  $!=Errno::ETIMEDOUT;
  $state{next}();
    }
    if$timeout;
  if(
  (connect$state{fh},$sockaddr)
  ||($!==Errno::EINPROGRESS
  ||$!==Errno::EWOULDBLOCK
  ||$!==AnyEvent::Util::WSAEINVAL
  ||$!==AnyEvent::Util::WSAEWOULDBLOCK)
    )
  {
  $state{ww}=AE::io$state{fh},1,sub{
  if(my$sin=getpeername$state{fh}){
  my($port,$host)=unpack_sockaddr$sin;
  delete$state{ww};
  delete$state{to};
  my$guard=guard{%state=()};
  $connect->(
  delete$state{fh},
  format_address$host,
  $port,
  sub{
  $guard->cancel;
  $state{next}();
  }
  );
  }
  else{
  if($!==Errno::ENOTCONN){
  sysread$state{fh},my$buf,1;
  $!=(unpack"l",getsockopt$state{fh},Socket::SOL_SOCKET(),Socket::SO_ERROR())||Errno::EAGAIN
    if AnyEvent::CYGWIN&&$!==Errno::EAGAIN;
  }
  return if$!==Errno::EAGAIN;
  delete$state{ww};
  delete$state{to};
  $state{next}();
  }
  };
  }
  else{
  $state{next}();
  }
  };
  $!=Errno::ENXIO;
  $state{next}();
  };
  defined wantarray&&guard{%state=()}
  }
  sub _tcp_bind($$$;$){
  my($host,$service,$done,$prepare)=@_;
  $host=$AnyEvent::PROTOCOL{ipv4}<$AnyEvent::PROTOCOL{ipv6}&&AF_INET6?"::":"0"
    unless defined$host;
  my$ipn=parse_address$host
    or Carp::croak"tcp_bind: cannot parse '$host' as host address";
  my$af=address_family$ipn;
  my%state;
  Carp::croak"tcp_bind: AF_UNIX address family not supported on win32"
    if AnyEvent::WIN32&&$af==AF_UNIX;
  socket my$fh,$af,SOCK_STREAM,0
    or Carp::croak"tcp_bind: $!";
  $state{fh}=$fh;
  if($af==AF_INET||$af==AF_INET6){
  setsockopt$fh,SOL_SOCKET,SO_REUSEADDR,1
    or Carp::croak"tcp_bind: so_reuseaddr: $!"
    unless AnyEvent::WIN32;
  unless($service=~/^\d*$/){
  $service=(getservbyname$service,"tcp")[2]
    or Carp::croak"tcp_bind: unknown service '$service'"
  }
  }
  elsif($af==AF_UNIX){
  unlink$service;
  }
  bind$fh,pack_sockaddr$service,$ipn
    or Carp::croak"tcp_bind: $!";
  if($af==AF_UNIX and defined wantarray){
  my$ino=(lstat$service)[1];
  $state{unlink}=guard{
  unlink$service
    if(lstat$service)[1]==$ino;
  };
  }
  AnyEvent::fh_unblock$fh;
  my$len;
  if($prepare){
  my($service,$host)=unpack_sockaddr getsockname$fh;
  $len=$prepare&&$prepare->($fh,format_address$host,$service);
  }
  $len||=128;
  listen$fh,$len
    or Carp::croak"tcp_bind: $!";
  $done->(\%state);
  defined wantarray?guard{%state=()}:()
  }
  sub tcp_bind($$$;$){
  my($host,$service,$done,$prepare)=@_;
  _tcp_bind$host,$service,sub{
  $done->(delete shift->{fh});
    },$prepare
  }
  sub tcp_server($$$;$){
  my($host,$service,$accept,$prepare)=@_;
  _tcp_bind$host,$service,sub{
  my$rstate=shift;
  $rstate->{aw}=AE::io$rstate->{fh},0,sub{
  while($rstate->{fh}&&(my$peer=accept my$fh,$rstate->{fh})){
  AnyEvent::fh_unblock$fh;
  my($service,$host)=unpack_sockaddr$peer;
  $accept->($fh,format_address$host,$service);
  }
  };
    },$prepare
  }
  sub tcp_nodelay($$){
  my$onoff=int!!$_[1];
  setsockopt$_[0],Socket::IPPROTO_TCP(),Socket::TCP_NODELAY(),$onoff
  }
  sub tcp_congestion($$){
  defined TCP_CONGESTION
    ?setsockopt$_[0],Socket::IPPROTO_TCP(),TCP_CONGESTION,"$_[1]"
    :undef
  }
  1
ANYEVENT_SOCKET

$fatpacked{"AnyEvent/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL';
  package AnyEvent::Util;
  use Carp ();
  use Errno ();
  use Socket ();
  use AnyEvent ();
  BEGIN{AnyEvent::common_sense}
  use base 'Exporter';
  our@EXPORT=qw(fh_nonblocking guard fork_call portable_pipe portable_socketpair run_cmd);
  our@EXPORT_OK=qw(
    AF_INET6 WSAEWOULDBLOCK WSAEINPROGRESS WSAEINVAL
    close_all_fds_except
    punycode_encode punycode_decode idn_nameprep idn_to_ascii idn_to_unicode
  );
  our$VERSION=$AnyEvent::VERSION;
  BEGIN{
  if($AnyEvent::PROTOCOL{ipv6}&&_AF_INET6&&socket my$ipv6_socket,_AF_INET6,Socket::SOCK_DGRAM(),0){
  *AF_INET6=\&_AF_INET6;
  }
  else{
  *AF_INET6=sub (){0};
  delete$AnyEvent::PROTOCOL{ipv6};
  }
  my%ERR=(
  EBADMSG=>Errno::EDOM(),
  EPROTO=>Errno::ESPIPE(),
  );
  while(my($k,$v)=each%ERR){
  next if eval"Errno::$k ()";
  AE::log 8=>"Broken Errno module, adding Errno::$k.";
  eval"sub Errno::$k () { $v }";
  push@Errno::EXPORT_OK,$k;
  push@{$Errno::EXPORT_TAGS{POSIX}},$k;
  }
  }
  BEGIN{
  if(AnyEvent::WIN32){
  *_win32_socketpair=sub (){
  for(1..10){
  socket my$l,Socket::AF_INET(),Socket::SOCK_STREAM(),0
    or next;
  bind$l,Socket::pack_sockaddr_in 0,"\x7f\x00\x00\x01"
    or next;
  my$sa=getsockname$l
    or next;
  listen$l,1
    or next;
  socket my$r,Socket::AF_INET(),Socket::SOCK_STREAM(),0
    or next;
  bind$r,Socket::pack_sockaddr_in 0,"\x7f\x00\x00\x01"
    or next;
  connect$r,$sa
    or next;
  accept my$w,$l
    or next;
  (Socket::unpack_sockaddr_in getpeername$r)[0]==(Socket::unpack_sockaddr_in getsockname$w)[0]
    or(($!=WSAEINVAL),next);
  return($r,$w);
  }
  ()
  };
  *portable_socketpair=\&_win32_socketpair;
  *portable_pipe=\&_win32_socketpair;
  }
  else{
  *portable_pipe=sub (){
  my($r,$w);
  pipe$r,$w
    or return;
  ($r,$w);
  };
  *portable_socketpair=sub (){
  socketpair my$fh1,my$fh2,Socket::AF_UNIX(),Socket::SOCK_STREAM(),0
    or return;
  ($fh1,$fh2)
  };
  }
  }
  our$MAX_FORKS=int 1*$ENV{PERL_ANYEVENT_MAX_FORKS};
  $MAX_FORKS=10 if$MAX_FORKS<=0;
  my$forks;
  my@fork_queue;
  sub _fork_schedule;
  sub _fork_schedule{
  require Storable unless$Storable::VERSION;
  require POSIX    unless$POSIX::VERSION;
  while($forks<$MAX_FORKS){
  my$job=shift@fork_queue
    or last;
  ++$forks;
  my$coderef=shift@$job;
  my$cb=pop@$job;
  my($r,$w)=
      portable_pipe
    or($forks and last)
    or die"fork_call: $!";
  my$pid=fork;
  if($pid!=0){
  close$w;
  my$buf;
  my$ww;
  $ww=AE::io$r,0,sub{
  my$len=sysread$r,$buf,65536,length$buf;
  return unless defined$len or$!!=Errno::EINTR;
  if(!$len){
  undef$ww;
  close$r;
  --$forks;
  _fork_schedule;
  my$result=eval{Storable::thaw($buf)};
  $result=[$@]unless$result;
  $@=shift@$result;
  $cb->(@$result);
  kill 9,$pid if AnyEvent::WIN32;
  waitpid$pid,0;
  }
  };
  }
  elsif(defined$pid){
  close$r;
  my$result=eval{
  local$SIG{__DIE__};
  Storable::freeze([undef,$coderef->(@$job)])
  };
  $result=Storable::freeze(["$@"])
    if$@;
  my$ofs;
  while(){
  my$len=(length$result)-$ofs
    or last;
  $len=syswrite$w,$result,$len<65536?$len:65536,$ofs;
  last unless$len||(!defined$len&&$!==Errno::EINTR);
  $ofs+=$len;
  }
  if(AnyEvent::WIN32){
  shutdown$w,1;
  sleep 10;
  sysread$w,(my$buf),1;
  }
  POSIX::_exit(0);
  exit 1;
  }
  elsif(($!!=&Errno::EAGAIN&&$!!=&Errno::EWOULDBLOCK&&$!!=&Errno::ENOMEM)||!$forks){
  die"fork_call: $!";
  }
  }
  }
  sub fork_call(&@){
  push@fork_queue,[@_];
  _fork_schedule;
  }
  END{
  if(AnyEvent::WIN32){
  while($forks){
  @fork_queue=();
  AnyEvent->one_event;
  }
  }
  }
  sub dotted_quad($){
  $_[0]=~/^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)$/x
  }
  sub inet_aton{
  require AnyEvent::Socket;
  *inet_aton=\&AnyEvent::Socket::inet_aton;
  goto&inet_aton
  }
  BEGIN{
  *fh_nonblocking=\&AnyEvent::_fh_nonblocking;
  }
  BEGIN{
  if(!$ENV{PERL_ANYEVENT_AVOID_GUARD}&&eval{require Guard;$Guard::VERSION>=0.5}){
  *guard=\&Guard::guard;
  AE::log 8=>"Using Guard module to implement guards.";
  }
  else{
  *AnyEvent::Util::guard::DESTROY=sub{
  local$@;
  eval{
  local$SIG{__DIE__};
  ${$_[0]}->();
  };
  AE::log 4=>"Runtime error in AnyEvent::guard callback: $@" if$@;
  };
  *AnyEvent::Util::guard::cancel=sub ($){
  ${$_[0]}=sub{};
  };
  *guard=sub (&){
  bless\(my$cb=shift),"AnyEvent::Util::guard"
  };
  AE::log 8=>"Using pure-perl guard implementation.";
  }
  }
  sub close_all_fds_except{
  my%except;
  @except{@_}=();
  require POSIX unless$POSIX::VERSION;
  if($^O=~/(freebsd|cygwin|linux)/){
  my$dir;
  if(opendir$dir,"/dev/fd" or opendir$dir,"/proc/self/fd"){
  my@fds=sort{$a<=>$b}grep/^\d+$/,readdir$dir;
  if(@fds<20 or"@fds" ne join" ",0..$#fds){
  exists$except{$_}or POSIX::close($_)for@fds;
  return;
  }
  }
  }
  my$fd_max=eval{POSIX::sysconf(POSIX::_SC_OPEN_MAX())-1}||1023;
  exists$except{$_}or POSIX::close($_)for 0..$fd_max;
  }
  sub run_cmd{
  my$cmd=shift;
  require POSIX unless$POSIX::VERSION;
  my$cv=AE::cv;
  my%arg;
  my%redir;
  my@exe;
  while(@_){
  my($type,$ob)=splice@_,0,2;
  my$fd=$type=~s/^(\d+)//?$1:undef;
  if($type eq">"){
  $fd=1 unless defined$fd;
  if(defined eval{fileno$ob}){
  $redir{$fd}=$ob;
  }
  elsif(ref$ob){
  my($pr,$pw)=AnyEvent::Util::portable_pipe;
  $cv->begin;
  fcntl$pr,AnyEvent::F_SETFD,AnyEvent::FD_CLOEXEC;
  fh_nonblocking$pr,1;
  my$w;
  $w=AE::io$pr,0,"SCALAR" eq ref$ob
    ?sub{
  defined(sysread$pr,$$ob,16384,length$$ob and return)
    or($!==Errno::EINTR and return);
  undef$w;
  $cv->end;
    }
    :sub{
  my$buf;
  defined(sysread$pr,$buf,16384 and return$ob->($buf))
    or($!==Errno::EINTR and return);
  undef$w;
  $cv->end;
  $ob->();
    };
  $redir{$fd}=$pw;
  }
  else{
  push@exe,sub{
  open my$fh,">",$ob
    or POSIX::_exit(125);
  $redir{$fd}=$fh;
  };
  }
  }
  elsif($type eq"<"){
  $fd=0 unless defined$fd;
  if(defined eval{fileno$ob}){
  $redir{$fd}=$ob;
  }
  elsif(ref$ob){
  my($pr,$pw)=AnyEvent::Util::portable_pipe;
  $cv->begin;
  my$data;
  if("SCALAR" eq ref$ob){
  $data=$$ob;
  $ob=sub{};
  }
  else{
  $data=$ob->();
  }
  fcntl$pw,AnyEvent::F_SETFD,AnyEvent::FD_CLOEXEC;
  fh_nonblocking$pw,1;
  my$w;
  $w=AE::io$pw,1,sub{
  my$len=syswrite$pw,$data;
  return unless defined$len or$!!=Errno::EINTR;
  if(!$len){
  undef$w;
  $cv->end;
  }
  else{
  substr$data,0,$len,"";
  unless(length$data){
  $data=$ob->();
  unless(length$data){
  undef$w;
  $cv->end
  }
  }
  }
  };
  $redir{$fd}=$pr;
  }
  else{
  push@exe,sub{
  open my$fh,"<",$ob
    or POSIX::_exit(125);
  $redir{$fd}=$fh;
  };
  }
  }
  else{
  $arg{$type}=$ob;
  }
  }
  my$pid=fork;
  defined$pid
    or Carp::croak"fork: $!";
  unless($pid){
  $_->()for@exe;
  my(@oldfh,@close);
  for my $fh(values%redir){
  push@oldfh,$fh;
  $fh=fileno$fh;
  defined($fh=POSIX::dup($fh))or POSIX::_exit(124)while exists$redir{$fh};
  }
  while(my($k,$v)=each%redir){
  defined POSIX::dup2($v,$k)
    or POSIX::_exit(123);
  }
  if($arg{close_all}){
  close_all_fds_except 0,1,2,keys%redir
  }
  else{
  POSIX::close($_)for values%redir;
  }
  eval{$arg{on_prepare}();1}or POSIX::_exit(123)
    if exists$arg{on_prepare};
  ref$cmd
    ?exec{$cmd->[0]}@$cmd
    :exec$cmd;
  POSIX::_exit(126);
  }
  ${$arg{'$$'}}=$pid
    if$arg{'$$'};
  %redir=();
  my$status;
  $cv->begin(sub{shift->send($status)});
  my$cw;
  $cw=AE::child$pid,sub{
  $status=$_[1];
  undef$cw;
  $cv->end;
  };
  $cv
  }
  sub punycode_encode($){
  require"AnyEvent/Util/idna.pl";
  goto&punycode_encode;
  }
  sub punycode_decode($){
  require"AnyEvent/Util/idna.pl";
  goto&punycode_decode;
  }
  our($uts46_valid,$uts46_imap);
  sub idn_nameprep($;$){
  local$_=$_[0];
  y/A-Z/a-z/;
  if(/[^0-9a-z\-.]/){
  unless(defined$uts46_imap){
  require Unicode::Normalize;
  require"AnyEvent/Util/uts46data.pl";
  }
  s{
           ([^0-9a-z\-.])
        }{
           my $chr = $1;
           unless (vec $uts46_valid, ord $chr, 1) {
              # not in valid class, search for mapping
              utf8::encode $chr; # the imap table is in utf-8
              (my $rep = index $uts46_imap, "\x00$chr") >= 0
                 or Carp::croak "$_[0]: disallowed characters (U+" . (unpack "H*", $chr) . ") during idn_nameprep";
  
              (substr $uts46_imap, $rep, 128) =~ /\x00 .[\x80-\xbf]* ([^\x00]*) \x00/x
                 or die "FATAL: idn_nameprep imap table has unexpected contents";
  
              $rep = $1;
              $chr = $rep unless $rep =~ s/^\x01// && $_[1]; # replace unless deviation and display
              utf8::decode $chr;
           }
           $chr
        }gex;
  $_=Unicode::Normalize::NFKC($_);
  }
  s{
        (^|\.)(..)--([^\.]*)
     }{
        my ($pfx, $ace, $pc) = ($1, $2, $3);
  
        if ($ace eq "xn") {
           $pc = punycode_decode $pc; # will croak on error (we hope :)
  
           require Unicode::Normalize;
           $pc eq Unicode::Normalize::NFC ($pc)
              or Carp::croak "$_[0]: punycode label not in NFC detected during idn_nameprep";
  
           "$pfx$pc"
        } elsif ($ace !~ /^[a-z0-9]{2}$/) {
           "$pfx$ace--$pc"
        } else {
           Carp::croak "$_[0]: hyphens in 3rd/4th position of a label are not allowed";
        }
     }gex;
  /\.-|-\./
    and Carp::croak"$_[0]: invalid hyphens detected during idn_nameprep";
  if(/[^0-9a-z\-.]/){
  unless(defined$uts46_imap){
  require"AnyEvent/Util/uts46data.pl";
  }
  vec$uts46_valid,ord,1
    or$_[1]&&0<=index$uts46_imap,pack"C0U*",0,ord,1
    or Carp::croak"$_[0]: disallowed characters during idn_nameprep"
    for split//;
  }
  $_
  }
  sub idn_to_ascii($){
  return$_[0]
    unless$_[0]=~/[^\x00-\x7f]/;
  my@output;
  eval{
  for(split/\./,(idn_nameprep$_[0]),-1){
  if(/[^\x00-\x7f]/){
  eval{
  push@output,"xn--".punycode_encode$_;
  1;
  }or do{
  push@output,$_;
  };
  }
  else{
  push@output,$_;
  }
  }
  1
  }or return$_[0];
  shift@output while!length$output[0]&&@output>1;
  join".",@output
  }
  sub idn_to_unicode($){
  my$res=eval{idn_nameprep$_[0],1};
  defined$res?$res:$_[0]
  }
  1
ANYEVENT_UTIL

$fatpacked{"AnyEvent/constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_CONSTANTS';
  package AnyEvent;
  sub common_sense{}
  sub CYGWIN      (){ 0 }
  sub WIN32       (){ 0 }
  sub F_SETFD     (){ eval { Fcntl::F_SETFD() } || 2 }
  sub F_SETFL     (){ eval { Fcntl::F_SETFL() } || 4 }
  sub O_NONBLOCK  (){ eval { Fcntl::O_NONBLOCK() } || 04000 }
  sub FD_CLOEXEC  (){ eval { Fcntl::FD_CLOEXEC() } || 1 }
  package AnyEvent::Base;
  sub WNOHANG     (){ eval { POSIX::WNOHANG() } || 1 }
  package AnyEvent::IO;
  sub O_RDONLY    (){ eval { Fcntl::O_RDONLY() } || 0 }
  sub O_WRONLY    (){ eval { Fcntl::O_WRONLY() } || 1 }
  sub O_RDWR      (){ eval { Fcntl::O_RDWR  () } || 2 }
  sub O_CREAT     (){ eval { Fcntl::O_CREAT () } || 64 }
  sub O_EXCL      (){ eval { Fcntl::O_EXCL  () } || 128 }
  sub O_TRUNC     (){ eval { Fcntl::O_TRUNC () } || 512 }
  sub O_APPEND    (){ eval { Fcntl::O_APPEND() } || 1024 }
  package AnyEvent::Util;
  sub WSAEINVAL   (){ -1e99 }
  sub WSAEWOULDBLOCK(){ -1e99 }
  sub WSAEINPROGRESS(){ -1e99 }
  sub _AF_INET6   (){ 30 }
  1;
ANYEVENT_CONSTANTS

$fatpacked{"JE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE';
  package JE;
  use 5.008004;
  use strict;
  use warnings;
  no warnings 'utf8';
  our$VERSION='0.066';
  use Carp 'croak';
  use JE::Code 'add_line_number';
  use JE::_FieldHash;
  use Scalar::Util 1.09 qw'blessed refaddr weaken';
  our@ISA='JE::Object';
  require JE::Null;
  require JE::Number;
  require JE::Object;
  require JE::Object::Function;
  require JE::Parser;
  require JE::Scope;
  require JE::String;
  require JE::Undefined;
  our$s=qr.[\p{Zs}\s\ck]*.;
  sub new{
  my$class=shift;
  if(ref$class){
  croak"JE->new is a class method and cannot be called "."on a".('n' x ref($class)=~/^[aoeui]/i).' '.ref($class)." object."
  }
  my$self=bless\{
  keys=>[],
  props=>{
  Object=>bless(
  \{
  func_name=>'Object',
  func_argnames=>[],
  func_args=>['global','args'],
  function=>sub{
  return JE::Object->new(@_);
  },
  constructor_args=>['global','args'],
  constructor=>sub{
  return JE::Object->new(@_);
  },
  keys=>[],
  props=>{
  prototype=>bless(
  \{
  keys=>[],
  props=>{},
  },
  'JE::Object'
  )
  },
  prop_readonly=>{
  prototype=>1,
  length=>1,
  },
  prop_dontdel=>{
  prototype=>1,
  length=>1,
  },
  },
  'JE::Object::Function'
  ),
  Function=>bless(
  \{
  func_name=>'Function',
  func_argnames=>[],
  func_args=>['scope','args'],
  function=>sub{
  JE::Object::Function->new($${$_[0][0]}{global},@_[1..$#_]);
  },
  constructor_args=>['scope','args'],
  constructor=>sub{
  JE::Object::Function->new($${$_[0][0]}{global},@_[1..$#_]);
  },
  keys=>[],
  props=>{
  prototype=>bless(
  \{
  func_argnames=>[],
  func_args=>[],
  function=>'',
  keys=>[],
  props=>{},
  },
  'JE::Object::Function'
  )
  },
  prop_readonly=>{
  prototype=>1,
  length=>1,
  },
  prop_dontdel=>{
  prototype=>1,
  length=>1,
  },
  },
  'JE::Object::Function'
  ),
  },
  },$class;
  my$obj_proto=
    (my$obj_constr=$self->prop('Object'))->prop('prototype');
  my$func_proto=
    (my$func_constr=$self->prop('Function'))->prop('prototype');
  $self->prototype($obj_proto);
  $$$self{global}=$self;
  $obj_constr->prototype($func_proto);
  $$$obj_constr{global}=$self;
  my$scope=$$$obj_constr{scope}=bless[$self],'JE::Scope';
  $func_constr->prototype($func_proto);
  $$$func_constr{global}=$self;
  $$$func_constr{scope}=$scope;
  $$$obj_proto{global}=$self;
  $func_proto->prototype($obj_proto);
  $$$func_proto{global}=$self;
  $obj_constr->prop({name=>'length',dontenum=>1,value=>new JE::Number$self,1});
  $func_constr->prop({name=>'length',dontenum=>1,value=>new JE::Number$self,1});
  $func_proto->prop({name=>'length',value=>0,dontenum=>1});
  if($JE::Destroyer){
  JE::Destroyer'register($_)for$obj_constr,$func_constr;
  }
  @{$$self}{qw{ t f u n }}=(JE::Boolean->new($self,1),JE::Boolean->new($self,0),JE::Undefined->new($self),JE::Null->new($self),);
  $self->prototype_for('Object',$obj_proto);
  $self->prototype_for('Function',$func_proto);
  JE::Object::_init_proto($obj_proto);
  JE::Object::Function::_init_proto($func_proto);
  $self->prop(
  {
  name=>'Array',
  autoload=>'require JE::Object::Array;
  			 JE::Object::Array::_new_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'String',
  autoload=>'require JE::Object::String;
  			JE::Object::String::_new_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'Boolean',
  autoload=>'require JE::Object::Boolean;
  		    JE::Object::Boolean::_new_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'Number',
  autoload=>'require JE::Object::Number;
  			JE::Object::Number::_new_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'Date',
  autoload=>'require JE::Object::Date;
  			JE::Object::Date::_new_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'RegExp',
  autoload=>'require JE::Object::RegExp;
  			 JE::Object::RegExp->new_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'Error',
  autoload=>'require JE::Object::Error;
  			 JE::Object::Error::_new_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'RangeError',
  autoload=>'require JE::Object::Error::RangeError;
  		             JE::Object::Error::RangeError
  		              ->_new_subclass_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'ReferenceError',
  autoload=>'require JE::Object::Error::ReferenceError;
  		             JE::Object::Error::ReferenceError
  		              ->_new_subclass_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'SyntaxError',
  autoload=>'require JE::Object::Error::SyntaxError;
  		             JE::Object::Error::SyntaxError
  		              ->_new_subclass_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'TypeError',
  autoload=>'require JE::Object::Error::TypeError;
  		             JE::Object::Error::TypeError
  		              ->_new_subclass_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'URIError',
  autoload=>'require JE::Object::Error::URIError;
  		             JE::Object::Error::URIError
  		              ->_new_subclass_constructor($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'NaN',
  value=>JE::Number->new($self,'NaN'),
  dontenum=>1,
  dontdel=>1,
  }
  );
  $self->prop(
  {
  name=>'Infinity',
  value=>JE::Number->new($self,'Infinity'),
  dontenum=>1,
  dontdel=>1,
  }
  );
  $self->prop(
  {
  name=>'undefined',
  value=>$self->undefined,
  dontenum=>1,
  dontdel=>1,
  }
  );
  $self->prop(
  {
  name=>'eval',
  value=>JE::Object::Function->new(
  {
  scope=>$self,
  name=>'eval',
  argnames=>['x'],
  function_args=>[qw< args >],
  function=>sub{
  my($code)=@_;
  return$self->undefined unless defined$code;
  return$code if typeof$code ne 'string';
  my$old_at=$@;
  defined(my$tree=($JE::Code::parser||$self)->parse($code))
    or die;
  my$ret=execute$tree
    $JE::Code::this,
    $JE::Code::scope,1;
  ref$@ne '' and die;
  $@=$old_at;
  $ret;
  },
  no_proto=>1,
  }
  ),
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'parseInt',
  value=>JE::Object::Function->new(
  {
  scope=>$self,
  name=>'parseInt',
  argnames=>[qw/string radix/],
  no_proto=>1,
  function_args=>[qw< scope args >],
  function=>sub{
  my($scope,$str,$radix)=@_;
  $radix=
    defined$radix
    ?$radix->to_number->value
    :0;
  $radix==$radix and$radix!=$radix+1
    or$radix=0;
  if(defined$str){
  ($str=$str->to_string)=~s/^$s//;
  }
  else{$str='undefined'}
  my$sign=
    $str=~s/^([+-])//
    ?(-1,1)[$1 eq '+']
    :1;
  $radix=(int$radix)%2**32;
  $radix-=2**32 if$radix>=2**31;
  $radix||=
    $str=~/^0x/i
    ?16
    :10;
  $radix==16
    and$str=~s/^0x//i;
  $radix<2||$radix>36 and return JE::Number->new($self,'nan');
  my@digits=(0..9,'a'..'z')[0..$radix-1];
  my$digits=join '',@digits;
  $str=~/^([$digits]*)/i;
  $str=$1;
  my$ret;
  if(!length$str){
  $ret='nan';
  }
  elsif($radix==10){
  $ret=$sign*$str;
  }
  elsif($radix==16){
  $ret=$sign*hex$str;
  }
  elsif($radix==8){
  $ret=$sign*oct$str;
  }
  elsif($radix==2){
  $ret=$sign*eval"0b$str";
  }
  else{
  my($num,$place);
  for(reverse split//,$str){
  $num+=(
   $_=~/[0-9]/
  ?$_
  :ord(uc)-55
    )*
    $radix**$place++
  }
  $ret=$num*$sign;
  }
  return JE::Number->new($self,$ret);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'parseFloat',
  value=>JE::Object::Function->new(
  {
  scope=>$self,
  name=>'parseFloat',
  argnames=>[qw/string/],
  no_proto=>1,
  function_args=>[qw< scope args >],
  function=>sub{
  my($scope,$str,$radix)=@_;
  defined$str or$str='';
  ref$str eq 'JE::Number' and return$str;
  ref$str eq 'JE::Object::Number'
    and return$str->to_number;
  return JE::Number->new(
  $self,$str=~/^$s
  					  (
  					    [+-]?
  					    (?:
  					      (?=[0-9]|\.[0-9]) [0-9]*
  					      (?:\.[0-9]*)?
  					      (?:[Ee][+-]?[0-9]+)?
  					        |
  					      Infinity
  					    )
  					  )
  					/ox
  ?$1:'nan'
  );
  },
  }
  ),
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'isNaN',
  value=>JE::Object::Function->new(
  {
  scope=>$self,
  name=>'isNaN',
  argnames=>[qw/number/],
  no_proto=>1,
  function_args=>['args'],
  function=>sub{
  JE::Boolean->new($self,!defined$_[0]||shift->to_number->id eq 'num:nan');
  },
  }
  ),
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'isFinite',
  value=>JE::Object::Function->new(
  {
  scope=>$self,
  name=>'isFinite',
  argnames=>[qw/number/],
  no_proto=>1,
  function_args=>['args'],
  function=>sub{
  my$val=shift;
  JE::Boolean->new($self,defined$val&&($val=$val->to_number->value)==$val&&$val+1!=$val);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'decodeURI',
  autoload=>q{ require 'JE/escape.pl';
  		    JE::Object::Function->new({
  		        scope  => $global,
  		        name   => 'decodeURI',
  		        argnames => [qw/encodedURI/],
  		        no_proto => 1,
  		        function_args => ['scope','args'],
  		        function => \&JE'_decodeURI,
  		    })
  		},
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'decodeURIComponent',
  autoload=>q{ require 'JE/escape.pl';
  		    JE::Object::Function->new({
  			scope  => $global,
  			name   => 'decodeURIComponent',
  			argnames => [qw/encodedURIComponent/],
  			no_proto => 1,
  			function_args => ['scope','args'],
  			function => \&JE'_decodeURIComponent
  		    })
  		},
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'encodeURI',
  autoload=>q{ require 'JE/escape.pl';
  		    JE::Object::Function->new({
  			scope  => $global,
  			name   => 'encodeURI',
  			argnames => [qw/uri/],
  			no_proto => 1,
  			function_args => ['scope','args'],
  			function => \&JE'_encodeURI,
  		    })
  		},
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'encodeURIComponent',
  autoload=>q{ require 'JE/escape.pl';
  		    JE::Object::Function->new({
  			scope  => $global,
  			name   => 'encodeURIComponent',
  			argnames => [qw/uriComponent/],
  			no_proto => 1,
  			function_args => ['scope','args'],
  			function => \&JE'_encodeURIComponent,
  		    })
  		},
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'Math',
  autoload=>'require JE::Object::Math;
  		             JE::Object::Math->new($global)',
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'escape',
  autoload=>q{
  			require 'JE/escape.pl';
  			JE::Object::Function->new({
  				scope  => $global,
  				name   => 'escape',
  				argnames => [qw/string/],
  				no_proto => 1,
  				function_args => ['scope','args'],
  				function => \&JE'_escape,
  			})
  		},
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'unescape',
  autoload=>q{
  			require 'JE/escape.pl';
  			JE::Object::Function->new({
  				scope  => $global,
  				name   => 'unescape',
  				argnames => [qw/string/],
  				no_proto => 1,
  				function_args => ['scope','args'],
  				function => \&JE'_unescape,
  			})
  		},
  dontenum=>1,
  }
  );
  my%args=@_;
  $$$self{max_ops}=delete$args{max_ops};
  $$$self{html_mode}=delete$args{html_mode};
  $self;
  }
  sub parse{
  goto&JE::Code::parse;
  }
  *compile=\&parse;
  sub eval{
  my$code=shift->parse(@_);
  $@and return;
  $code->execute;
  }
  sub max_ops{
  my$self=shift;
  if(@_){$$$self{max_ops}=shift;return}
  else{return$$$self{max_ops}}
  }
  sub html_mode{
  my$self=shift;
  if(@_){$$$self{html_mode}=shift;return}
  else{return$$$self{html_mode}}
  }
  fieldhash my%wrappees;
  sub upgrade{
  my@__;
  my$self=shift;
  my($classes,$proxy_cache);
  for(@_){
  if(defined blessed$_){
  $classes or($classes,$proxy_cache)=@$$self{'classes','proxy_cache'};
  my$ident=refaddr$_;
  my$class=ref;
  push@__,exists$$classes{$class}
    ?exists$$proxy_cache{$ident}
    ?$$proxy_cache{$ident}
    :(
    $$proxy_cache{$ident}=exists$$classes{$class}{wrapper}
    ?do{
    weaken($wrappees{my$proxy=$$classes{$class}{wrapper}($self,$_)}=$_);
    $proxy
      }
    :JE::Object::Proxy->new($self,$_)
    )
    :$_;
  }
  else{
  push@__,
    !defined()?$self->undefined
    :ref($_)eq 'ARRAY'?JE::Object::Array->new($self,$_)
    :ref($_)eq 'HASH'?JE::Object->new($self,{value=>$_})
    :ref($_)eq 'CODE'?JE::Object::Function->new($self,$_)
    :$_ eq '0'||$_ eq '-0'?JE::Number->new($self,0)
    :JE::String->new($self,$_);
  }
  }
  @__>1?@__:@__==1?$__[0]:();
  }
  sub _upgr_def{
  return defined$_[1]?shift->upgrade(shift):undef
  }
  sub undefined{
  $${+shift}{u}
  }
  sub null{
  $${+shift}{n}
  }
  sub true{$${+shift}{t}}
  sub false{$${+shift}{f}}
  sub _split_meth{$_[0]=~/(.*[^:]):([^:].*)/s?($1,$2):$_[0]}
  sub _cast{
  my($self,$val,$type)=@_;
  return$self->upgrade($val)unless defined$type;
  if($type eq 'null'){
  defined$val?$self->upgrade($val):$self->null
  }
  else{
  $self->prop($type)->call($self->upgrade($val));
  }
  }
  sub _unwrap{
  my($self)=shift;
  my@ret;
  for(@_){
  push@ret,
     ref=~/^JE::(?:Object::Proxy(?:::Array)?|Undefined|Null)\z/?$_->value
    :exists$wrappees{$_}?$wrappees{$_}
    :$_
  }
  @ret;
  }
  sub bind_class{
  require JE::Object::Proxy;
  my$self=shift;
  my%opts=@_;
  $$$self{proxy_cache}||=&fieldhash({});
  if(exists$opts{wrapper}){
  my$pack=$opts{qw/name package/[exists$opts{package}]};
  $$$self{classes}{$pack}={wrapper=>$opts{wrapper}};
  return;
  }
  my($pack,$class);
  if(exists$opts{package}){
  $pack="$opts{package}";
  $class=exists$opts{name}?$opts{name}:$pack;
  }
  else{
  $class=$opts{name};
  $pack="$class";
  }
  my%class=(name=>$class);
  $$$self{classes}{$pack}=$$$self{classes_by_name}{$class}=
    \%class;
  my$unwrap=delete$opts{unwrap};
  my($constructor,$proto,$coderef);
  if(exists$opts{constructor}){
  my$c=$opts{constructor};
  $coderef=
    ref eq 'CODE'
    ?sub{$self->upgrade(scalar&$c(@_))}
    :sub{$self->upgrade(scalar$pack->$c(@_))};
  }
  else{
  $coderef=sub{
  die JE::Code::add_line_number("$class cannot be instantiated");
  };
  $constructor=$self->prop($class);
  defined$constructor
    and$constructor->typeof ne 'function'
    and$constructor=undef;
  }
  $class{prototype}=$proto=(
  $constructor||$self->prop(
  {
  name=>$class,
  value=>$constructor=JE::Object::Function->new(
  {
  name=>$class,
  scope=>$self,
  function=>$coderef,
  function_args=>['args'],
  constructor=>$coderef,
  constructor_args=>['args'],
  }
  ),
  }
  )
  )->prop('prototype');
  my$super;
  if(exists$opts{isa}){
  my$isa=$opts{isa};
  $proto->prototype(
  !defined$isa||defined blessed$isa
  ? $isa
  :do{
  $super=$isa;
  defined(my$super_constr=$self->prop($isa))
    ||croak("JE::bind_class: The $isa"." constructor does not exist");
  $super_constr->prop('prototype')
  }
  );
  }
  if(exists$opts{methods}){
  my$methods=$opts{methods};
  if(ref$methods eq 'ARRAY'){
  for(@$methods){
  my($m,$type)=_split_meth$_;
  if(defined$type){
  $proto->new_method(
  $m=>$unwrap
  ?sub{
  $self->_cast(scalar shift->value->$m($self->_unwrap(@_)),$type);
  }
  :sub{
  $self->_cast(scalar shift->value->$m(@_),$type);
  }
  );
  }
  else{
  $proto->new_method(
  $m=>$unwrap
  ?sub{
  shift->value->$m($self->_unwrap(@_))
  }
  :sub{shift->value->$m(@_)},
  );
  }
  }
  }
  else{
  while(my($name,$m)=each%$methods){
  if(ref$m eq 'CODE'){
  $proto->new_method(
  $name=>$unwrap
  ?sub{
  &$m($self->_unwrap(@_))
  }
  :sub{
  &$m($_[0]->value,@_[1..$#_])
  }
  );
  }
  else{
  my($method,$type)=_split_meth$m;
  $proto->new_method(
   $name=>defined$type
  ?$unwrap
    ?sub{
    $self->_cast(scalar shift->value->$method($self->_unwrap(@_)),$type);
    }
    :sub{
    $self->_cast(scalar shift->value->$method(@_),$type);
  }
    :$unwrap?sub{
  shift->value->$m($self->_unwrap(@_))
    }
  :sub{shift->value->$m(@_)},
  );
  }
  }
  }
  }
  if(exists$opts{static_methods}){
  my$methods=$opts{static_methods};
  if(ref$methods eq 'ARRAY'){
  for(@$methods){
  my($m,$type)=_split_meth$_;
  $constructor->new_function(
   $m=>defined$type
  ?$unwrap
    ?sub{
    $self->_cast(scalar$pack->$m($self->_unwrap(@_)),$type)
    }
    :sub{
    $self->_cast(scalar$pack->$m(@_),$type)
  }
    :$unwrap?sub{
  $pack->$m($self->_unwrap(@_))
    }
  :sub{$pack->$m(@_)}
  );
  $constructor->prop(
  {
  name=>$m,
  dontenum=>1
  }
  );
  }
  }
  else{
  while(my($name,$m)=each%$methods){
  if(ref$m eq 'CODE'){
  $constructor->new_function(
  $name=>$unwrap
  ?sub{
  @_=$self->_unwrap(@_);
  unshift@_,$pack;
  goto$m;
  }
  :sub{
  unshift@_,$pack;
  goto$m;
  }
  );
  }
  else{
  ($m,my$type)=_split_meth$m;
  $constructor->new_function(
  $name=>defined$type
  ?sub{
  $self->_cast(scalar$pack->$m,$type)
  }
  :$unwrap?sub{
  $pack->$m($self->_unwrap(@_))
  }
  :sub{$pack->$m(@_)},
  );
  }
  $constructor->prop(
  {
  name=>$name,
  dontenum=>1
  }
  );
  }
  }
  }
  for(qw/to_primitive to_string to_number/){
  exists$opts{$_}and$class{$_}=$opts{$_}
  }
  {
  my%props;
  if(exists$opts{props}){
  my$props=$opts{props};
  $class{props}=\%props;
  if(ref$props eq 'ARRAY'){
  for(@$props){
  my($p,$type)=_split_meth$_;
  $props{$p}=[
  fetch=>defined$type
  ?sub{
  $self->_cast(scalar$_[0]->value->$p,$type)
  }
  :sub{
  $self->upgrade(scalar$_[0]->value->$p)
  },
  store=>$unwrap
  ?sub{
  $_[0]->value->$p($self->_unwrap($_[1]))
  }
  :sub{$_[0]->value->$p($_[1])},
  ];
  }
  }
  else{
  while(my($name,$p)=each%$props){
  my@prop_args;
  if(ref$p eq 'HASH'){
  if(exists$$p{fetch}){
  my$fetch=$$p{fetch};
  @prop_args=(
  fetch=>ref$fetch eq 'CODE'
  ?sub{
  $self->upgrade(scalar&$fetch($_[0]->value))
  }
  :do{
  my($f,$t)=_split_meth$fetch;
  defined$t
    ?sub{
  $self->_cast(scalar shift->value->$f,$t)
    }
    :sub{
  $self->upgrade(scalar shift->value->$fetch)
  }
  }
  );
  }
  else{
  @prop_args=(value=>$self->undefined);
  }
  if(exists$$p{store}){
  my$store=$$p{store};
  push@prop_args,(
   store=>ref$store eq 'CODE'
  ?$unwrap
    ?sub{
    &$store($_[0]->value,$self->_unwrap($_[1]))
    }
    :sub{
    &$store($_[0]->value,$_[1])
  }
    :$unwrap?sub{
  $_[0]->value->$store($self->_unwrap($_[1]))
    }
  :sub{
  $_[0]->value->$store($_[1])
  }
  );
  }
  else{
  push@prop_args,readonly=>1;
  }
  }
  else{
  if(ref$p eq 'CODE'){
  @prop_args=(
  fetch=>sub{
  $self->upgrade(scalar&$p($_[0]->value))
  },
  store=>$unwrap
  ?sub{
  &$p(scalar$_[0]->value,$self->_unwrap($_[1]))
  }
  :sub{
  &$p(scalar$_[0]->value,$_[1])
  },
  );
  }
  else{
  ($p,my$t)=_split_meth($p);
  @prop_args=(
  fetch=>defined$t
  ?sub{
  $self->_cast(scalar$_[0]->value->$p,$t)
  }
  :sub{
  $self->upgrade(scalar$_[0]->value->$p)
  },
  store=>$unwrap
  ?sub{
  $_[0]->value->$p($self->_unwrap($_[1]))
  }
  :sub{
  $_[0]->value->$p($_[1])
  },
  );
  }
  }
  $props{$name}=\@prop_args;
  }
  }
  }
  if(defined$super){
  $class{props}||=\%props;
  {
  my$super_props=$$$self{classes_by_name}{$super}{props}
    ||last;
  for(keys%$super_props){
  exists$props{$_}
    or$props{$_}=$$super_props{$_}
  }
  }
  }
  }
  if(exists$opts{static_props}){
  my$props=$opts{static_props};
  if(ref$props eq 'ARRAY'){
  for(@$props){
  my($p,$t)=_split_meth$_;
  $constructor->prop(
  {
  name=>$p,
  fetch=>defined$t
  ?sub{
  $self->_cast(scalar$pack->$p,$t)
  }
  :sub{
  $self->upgrade(scalar$pack->$p)
  },
  store=>$unwrap
  ?sub{$pack->$p($self->_unwrap($_[1]))}
  :sub{$pack->$p($_[1])},
  }
  );
  }
  }
  else{
  while(my($name,$p)=each%$props){
  my@prop_args;
  if(ref$p eq 'HASH'){
  if(exists$$p{fetch}){
  my$fetch=$$p{fetch};
  @prop_args=(
  fetch=>ref$fetch eq 'CODE'
  ?sub{
  $self->upgrade(scalar&$fetch($pack))
  }
  :do{
  my($f,$t)=_split_meth$fetch;
  defined$t
    ?sub{
  $self->_cast(scalar$pack->$f,$t)
    }
    :sub{
  $self->upgrade(scalar$pack->$f)
  }
  }
  );
  }
  else{
  @prop_args=(value=>$self->undefined);
  }
  if(exists$$p{store}){
  my$store=$$p{store};
  push@prop_args,(
   store=>ref$store eq 'CODE'
  ?$unwrap
    ?sub{
    &$store($pack,$self->_unwrap($_[1]))
    }
    :sub{
    &$store($pack,$_[1])
  }
    :$unwrap?sub{
  $pack->$store($self->_unwrap($_[1]))
    }
  :sub{
  $pack->$store($_[1])
  }
  );
  }
  else{
  push@prop_args,readonly=>1;
  }
  }
  else{
  if(ref$p eq 'CODE'){
  @prop_args=(
  fetch=>sub{
  $self->upgrade(scalar&$p($pack))
  },
  store=>$unwrap
  ?sub{
  &$p($pack,$self->_unwrap($_[1]))
  }
  :sub{
  &$p($pack,$_[1])
  },
  );
  }
  else{
  ($p,my$t)=_split_meth$p;
  @prop_args=(
  fetch=>defined$t
  ?sub{
  $self->_cast(scalar$pack->$p,$t)
  }
  :sub{
  $self->upgrade(scalar$pack->$p)
  },
  store=>$unwrap
  ?sub{
  $pack->$p($self->_unwrap($_[1]))
  }
  :sub{
  $pack->$p($_[1])
  },
  );
  }
  }
  $constructor->prop({name=>$name,@prop_args});
  }
  }
  }
  if($opts{hash}){
  if(!ref$opts{hash}&&$opts{hash}=~/^(?:1|(2))/){
  $class{hash}={
  fetch=>sub{
  exists$_[0]{$_[1]}
    ?$self->upgrade($_[0]{$_[1]})
    :undef
  },
  store=>$1
  ?sub{$_[0]{$_[1]}=$_[2];1}
  :sub{
  exists$_[0]{$_[1]}
    and
    ($_[0]{$_[1]}=$_[2],1)
  },
  };
  $class{keys}||=sub{keys%{$_[0]}};
  }
  else{
  croak"Invalid value for the 'hash' option: $opts{hash}";
  }
  }
  if($opts{array}){
  if($opts{array}=~/^(?:1|(2))/){
  $class{array}={
  fetch=>sub{
  $_[1]<@{$_[0]}
    ?$self->upgrade($_[0][$_[1]])
    :undef
  },
  store=>$1
  ?sub{$_[0][$_[1]]=$_[2];1}
  :sub{
  $_[1]<@{$_[0]}
    and
    ($_[0]{$_[1]}=$_[2],1)
  },
  };
  }
  else{
  croak"Invalid value for the 'array' option: $opts{array}";
  }
  }
  weaken$self;
  return
  }
  sub new_parser{
  JE::Parser->new(shift);
  }
  sub prototype_for{
  my$self=shift;
  my$class=shift;
  if(@_){
  return$$$self{pf}{$class}=shift
  }
  else{
  return$$$self{pf}{$class}
    ||($self->prop($class)||return undef)->prop('prototype');
  }
  }
  1;
  __END__
  
JE

$fatpacked{"JE/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_BOOLEAN';
  package JE::Boolean;
  our$VERSION='0.066';
  use strict;
  use warnings;
  use overload
    fallback=>1,
    '""'=>sub{qw< false true >[shift->[0]]},
    bool=>sub{shift->[0]},
    '0+'=>sub{shift->[0]};
  require JE::Object::Boolean;
  require JE::Number;
  require JE::String;
  sub new{
  my($class,$global,$val)=@_;
  bless[!!$val,$global],$class;
  }
  sub prop{
  if(@_>2){return$_[2]}
  my($self,$name)=@_;
  $$self[1]->prototype_for('Boolean')->prop($name);
  }
  sub keys{
  my$self=shift;
  $$self[1]->prototype_for('Boolean')->keys;
  }
  sub delete{1}
  sub method{
  my$self=shift;
  $$self[1]->prototype_for('Boolean')->prop(shift)->apply($self,$$self[1]->upgrade(@_));
  }
  sub value{warn caller if!ref$_[0];shift->[0]}
  sub TO_JSON{\(0+shift->[0])}
  sub exists{!1}
  sub typeof{'boolean'}
  sub class{'Boolean'}
  sub id{'bool:'.shift->value}
  sub primitive{1}
  sub to_primitive{$_[0]}
  sub to_boolean{$_[0]}
  sub to_string{JE::String->_new($_[0][1],qw< false true >[shift->[0]])}
  sub to_number{JE::Number->new($_[0][1],shift->[0])}
  sub to_object{JE::Object::Boolean->new($_[0][1],shift)}
  sub global{$_[0][1]}
  1;
  __END__
  
JE_BOOLEAN

$fatpacked{"JE/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_CODE';
  package JE::Code;
  our$VERSION='0.066';
  use strict;
  use warnings;
  no warnings 'utf8','recursion';
  use Carp 1.01 'shortmess';
  use Exporter 5.57 'import';
  use Scalar::Util 'tainted';
  our@CARP_NOT='JE';
  our@EXPORT_OK='add_line_number';
  use constant T=>${^TAINT};
  require JE::Object::Error;
  require JE::Object::Error::ReferenceError;
  require JE::Object::Error::SyntaxError;
  require JE::Object::Error::TypeError;
  require JE::Object::Function;
  require JE::Object::Array;
  require JE::Boolean;
  require JE::Object;
  require JE::Parser;
  require JE::Number;
  require JE::LValue;
  require JE::String;
  require JE::Scope;
  sub add_line_number;
  sub parse{
  my($global,$src,$file,$line)=@_;
  ($src,my($tree,$vars))=JE::Parser::_parse(
  program=>$src,
  $global,$file,$line
  );
  $@and return;
  my$r=bless{
  global=>$global,
  (
  $JE::Parser::_parser
  ?(parser=>$JE::Parser::_parser)
  :()
  ),
  source=>\$src,
  file=>$file,
  line=>$line,
  vars=>$vars,
  tree=>$tree
  };
  $r->optimise
    if$ENV{'YES_I_WANT_JE_TO_OPTIMISE'}
    and$ENV{'YES_I_WANT_JE_TO_OPTIMISE'}ne 2;
  $r;
  }
  sub execute_till{
  (my$code,local our$counting)=(shift,shift);
  local our$ops=0;
  JE_Code_OP:{
  return$code->execute(@_);
  }
  $@=shortmess"max_ops ($counting) exceeded";
  return undef;
  }
  sub set_global{
  my$code=shift;
  my$old=$code->{global};
  $code->{global}=$_[0];
  {
  for(@{$code->{cache}||last}){
  ref eq 'JE::Code' and$_->set_global($_[0]);
  }
  }
  {
  for(@{$code->{vars}||last}){
  ref
    &&ref$$_[4]eq 'JE::Code'
    &&$$_[4]->set_global($_[0])
  }
  }
  defined$old or return;
  my@stack=$code->{tree};
  local*@;
  while(@stack){
  for(shift@stack){
  for(@$_[1..$#$_]){
  my$r=ref||next;
  $r=~/^(?:ARRAY\z|JE::Code::)/
    and push@stack,$_,=~next;
  $r eq 'JE::Boolean'
    and$_=qw(f t)[$_->value],next;
  $r eq 'JE::Number'
    and$_=$_->value,next;
  $r eq 'JE::String'
    and$_="s".$_->value16,next;
  $r eq 'JE::Null' and$_='n',next;
  $r eq 'JE::Object::RegExp'
    and$_=[$_->{source}->value,$$$_{regexp_flags}],
    next;
  }
  }
  }
  return;
  }
  sub optimise{
  require 'JE/toperl.pl';
  goto&{'optimise'};
  }
  our$code;
  our$this;
  our$scope;
  our$parser;
  our$pos;
  our$taint;
  our$ops;
  our$counting;
  our$global;
  our$return;
  our$cache;
  sub execute{
  local$code=shift;
  local$global=$$code{global};
  if(!defined our$ops and my$max_ops=$global->max_ops){
  unshift@_,$code,$max_ops;
  goto&execute_till;
  }
  local$this=defined$_[0]?$_[0]:$global;
  shift;
  local$scope=shift||bless[$global],'JE::Scope';
  my$code_type=shift||0;
  local our$taint=substr(${$$code{source}},0,0)if T;
  my$rv;
  eval{
  local$JE::Code::parser=$code->{parser};
  local our$pos;
  local our$code=$code;
  local$JE::Code::Expression::_eval=$code_type==1;
  package JE::Code::Statement;
  local our$_label;
  package JE::Code;
  local$return;
  local$cache=$$code{cache}||=[];
  RETURN:{
  BREAK:{
  CONT:{
  JE'Code'Statement'_create_vars();
     $$code{sub}?&{$$code{sub}}
    :$$code{psrc}?(($$code{psrc})=$$code{psrc}=~/(.*)/s,&{$$code{sub}=eval{eval("sub{$$code{psrc}}")||die}||die"Internal error that should never"." happen (please report this): $@: ".$$code{psrc}})
    :$$code{tree}->eval;
  $code_type==2
    or defined$return&&($rv=$return);
  goto FINISH;
  }
  if($JE::Code::Statement::_label){
  die new JE::Object::Error::SyntaxError$global,add_line_number"continue $JE::Code::Statement::_label: label "."'$JE::Code::Statement::_label' not found";
  }
  else{goto FINISH;}
  }
  if($JE::Code::Statement::_label){
  die new JE::Object::Error::SyntaxError$global,add_line_number"break $JE::Code::Statement::_label: label "."'$JE::Code::Statement::_label' not found";
  }
  else{goto FINISH;}
  }
  $rv=$return;
  FINISH:
  };
  T
    and defined$rv
    and tainted$taint
    and$rv->can('taint')
    and$rv=taint$rv $taint;
  if(ref$@eq '' and$@eq ''){
  !defined$rv and$rv=$scope->undefined;
  }
  else{
  $@=_objectify_error($@);
  }
  $rv;
  }
  sub add_line_number{
  my$msg=shift;
  my$code=@_?shift:$code;
  my$pos=@_?shift:$pos;
  $msg=~/\n\z/ and return$msg;
  defined(my$file=($code||return$msg)->{file})
    or defined$pos
    or return$msg;
  my$first_line=$code->{line};
  defined$first_line or$first_line=1;
  if(defined$pos){
  no warnings 'uninitialized';
  "$msg at $file".', ' x defined($file).'line '.($first_line+(()=substr(${$code->{source}},0,$pos)=~/\cm\cj?|[\cj\x{2028}\x{2029}]/g)).".\n";
  }
  else{
  "$msg in $file.\n"
  }
  }
  sub _objectify_error{
  my$msg=shift;
  ref$msg and return$global->upgrade($msg);
  my$class='JE::Object::Error';
  if(
  $msg=~/^Can't\ locate\ object\ method\ 
  	    "(?:c(?:all|onstruct)|apply|invoke_with)"/x
    )
  {
  $class='JE::Object::Error::TypeError';
  $msg="Argument to new is not a constructor";
  }
  new$class $global,add_line_number$msg;
  }
  sub DDS_freeze{
  my$self=shift;
  my$copy=bless{%$self},ref$self;
  delete$copy->{sub};
  $copy;
  }
  package JE::Code::Statement;
  our$VERSION='0.066';
  use subs qw'_eval_term';
  use List::Util 'first';
  our($_label);
  *_eval_term=*JE::Code::Expression::_eval_term;
  import JE::Code 'add_line_number';
  sub add_line_number;
  sub eval{
  my$stm=shift;
  my$type=$$stm[1];
  $type eq 'empty'||$type eq 'function' and return;
  my@labels;
  $pos=$$stm[0][0];
  if($type eq 'labelled'){
  @labels=@$stm[2..$#$stm-1];
  if($$stm[-1][1]=~/^(?:do|while|for|switch)\z/){
  $stm=$$stm[-1];
  $type=$$stm[1];
  no warnings 'deprecated';
  goto LOOPS;
  }
  BREAK:{
  my$returned=$$stm[-1]->eval;
  defined$returned and$return=$returned
  }
  if(!defined$_label||first{$_ eq$_label}@labels){
  undef$_label;
  return;
  }
  else{
  no warnings 'exiting';
  last BREAK;
  }
  }
  if($type eq 'statements'){
  my$returned;
  for(@$stm[2..$#$stm]){
  next if$_ eq 'empty';
  defined($returned=$_->eval)
    and$return=$returned,
    ref$return eq 'JE::LValue'&&get$return;
  }
  return;
  }
  if($type eq 'var'){
  for(@$stm[2..$#$stm]){
  if(@$_==2){
  my$ret=_eval_term$$_[1];
  ref$ret eq'JE::LValue' and$ret=get$ret;
  $scope->find_var($$_[0])->set($ret);
  }
  }
  return;
  }
  if($type eq 'if'){
  my$returned;
  if($$stm[2]->eval->to_boolean->value){
  $$stm[3]eq 'empty' or$returned=$$stm[3]->eval;
  }
  else{
  exists$$stm[4]&&$$stm[4]ne 'empty'
    and$returned=$$stm[4]->eval;
  }
  defined$returned and$return=$returned;
  return
  }
  if($type=~/^(?:do|while|for|switch)\z/){
  no warnings 'exiting';
  LOOPS:
  my$returned;
  BREAK:{
  if($type eq 'do'){
  do{
  CONT:{
  defined($returned=ref$$stm[2]?$$stm[2]->eval:undef)
    and$return=$returned;
  }
  if($_label
  and!first{$_ eq$_label}@labels)
  {
  goto NEXT;
  }
  undef$_label;
  }while$$stm[3]->eval->to_boolean->value;
  }
  elsif($type eq 'while'){
  CONT:while($$stm[2]->eval->to_boolean->value){
  defined($returned=ref$$stm[3]?$$stm[3]->eval:undef)
    and$return=$returned;
  }
  continue{
  if($_label
  and!first{$_ eq$_label}@labels)
  {
  goto NEXT;
  }
  }
  undef$_label;
  }
  elsif($type eq 'for' and$$stm[3]eq 'in'){
  my$left_side=$$stm[2];
  if($left_side->[1]eq 'var'){
  $left_side->eval;
  $left_side=$left_side->[2][0];
  }
  my$obj=$$stm[4]->eval;
  $obj=$obj->get if ref$obj eq 'JE::LValue';
  ref($obj)=~/^JE::(?:Undefined|Null)\z/
    and undef$_label,return;
  my@keys=$obj->keys;
  CONT:for(@keys){
  if($_label
  and!first{$_ eq$_label}@labels)
  {
  goto NEXT;
  }
  undef$_label;
  next if not defined$obj->prop($_);
  (
  ref$left_side
  ?$left_side->eval
  :$scope->find_var($left_side)
  )->set(_new JE::String$global,$_);
  defined($returned=ref$$stm[5]?$$stm[5]->eval:undef)
    and$return=$returned;
  }
  if($_label
  and!first{$_ eq$_label}@labels)
  {
  next CONT;
  }
  undef$_label;
  }
  elsif($type eq 'for'){
  my$tmp;
  CONT:
  for(
  $tmp=
  ref$$stm[2]&&$$stm[2]->eval,ref$tmp eq 'JE::LValue'&&get$tmp;
  ref$$stm[3]
  ?$$stm[3]->eval->to_boolean->value
  :1;
  do{
  if($_label
  and!first{$_ eq$_label}@labels)
  {
  goto NEXT;
  }
  undef$_label;
  },$tmp=ref$$stm[4]&&$$stm[4]->eval,ref$tmp eq 'JE::LValue'&&get$tmp
    )
  {
  defined($returned=ref$$stm[5]?$$stm[5]->eval:undef)
    and$return=$returned;
  }
  }
  else{
  my$given=$$stm[2]->eval;
  $given=get$given if ref$given eq 'JE::LValue';
  no strict 'refs';
  my($n,$default)=1;
  while(($n+=2)<@$stm){
  if($$stm[$n]eq 'default'){
  $default=$n;
  next;
  }
  if("JE::Code::Expression::in==="->($given,$$stm[$n]->eval)){
  $n++;
  do{
  $$stm[$n]->eval;
  }while($n+=2)<@$stm;
  undef$default;
  last;
  }
  }
  if(defined$default){
  $n=$default+1;
  do{$$stm[$n]->eval}while($n+=2)<@$stm;
  }
  }
  }
  if(!$_label||first{$_ eq$_label}@labels){
  undef$_label;
  return;
  }
  else{
  last BREAK;
  }
  NEXT:next CONT;
  }
  if($type eq 'continue'){
  no warnings 'exiting';
  $_label=exists$$stm[2]?$$stm[2]:'';
  next CONT;
  }
  if($type eq 'break'){
  no warnings 'exiting';
  $_label=exists$$stm[2]?$$stm[2]:'';
  last BREAK;
  }
  if($type eq 'return'){
  no warnings 'exiting';
  if(exists$$stm[2]){
  ref($return=$$stm[2]->eval)eq 'JE::LValue'
    and$return=get$return;
  }
  else{$return=undef}
  last RETURN;
  }
  if($type eq 'with'){
  local$scope=bless[@$scope,$$stm[2]->eval->to_object],'JE::Scope';
  my$returned=$$stm[3]->eval;
  defined$returned and$return=$returned;
  return;
  }
  if($type eq 'throw'){
  my$excep;
  if(exists$$stm[2]){
  ref($excep=$$stm[2]->eval)eq 'JE::LValue'
    and$excep=get$excep;
  }
  die defined$excep?$excep:$global->undefined;
  }
  if($type eq 'try'){
  my$result;
  my$propagate;
  eval{
  local$return;
  no warnings 'exiting';
  RETURN:{
  BREAK:{
  CONT:{
  $result=$$stm[2]->eval;
  goto SAVERESULT;
  }
  $propagate=sub{next CONT};
  goto SAVERESULT;
  }
  $propagate=sub{last BREAK};
  goto SAVERESULT;
  }
  $propagate=sub{last RETURN};
  goto SAVERESULT;
  SAVERESULT:
  defined$result or$result=$return;
  goto FINALLY;
  };
  if(ref$@||$@ne '' and!ref$$stm[3]){
  undef$result;
  $@=JE'Code'_objectify_error($@);
  (my$new_obj=new JE::Object$global)->prop(
  {
  name=>$$stm[3],
  value=>$@,
  dontdel=>1,
  }
  );
  local$scope=bless[@$scope,$new_obj],'JE::Scope';
  eval{
  local$return;
  no warnings 'exiting';
  RETURN:{
  BREAK:{
  CONT:{
  $result=$$stm[4]->eval;
  goto SAVE;
  }
  $propagate=sub{next CONT};
  goto SAVE;
  }
  $propagate=sub{last BREAK};
  goto SAVE;
  }
  $propagate=sub{last RETURN};
  goto SAVE;
  SAVE:
  defined$result or$result=$return;
  $@='';
  }
  }
  my$exception=$@;
  FINALLY:
  if($#$stm==3 or$#$stm==5){
  $$stm[-1]->eval;
  }
  defined$exception
    and ref$exception||$exception ne ''
    and die$exception;
  $return=$result if defined$result;
  $propagate and&$propagate();
  }
  }
  sub _create_vars{
  my$vars=$code->{vars};
  for(@$vars){
  if(ref){
  $scope->[-1]->delete($$_[2],1);
  my$new_code_obj;
  if(ref$$_[4]eq 'JE::Code'){
  $new_code_obj=$$_[4]
  }
  else{
  ($new_code_obj=bless{map+($_=>$code->{$_}),qw/global source file line/},'JE::Code')->{tree}=$$_[4];
  $new_code_obj->{vars}=$$_[5];
  }
  $scope->new_var(
  $$_[2],
  new JE::Object::Function{
  scope=>$scope,
  name=>$$_[2],
  argnames=>$$_[3],
  function=>$new_code_obj
  }
  );
  }
  else{
  $scope->new_var($_);
  }
  }
  }
  package JE::Code::Expression;
  our$VERSION='0.066';
  use constant nan=>sin 9**9**9;
  use constant inf=>9**9**9;
  use subs qw'_eval_term';
  use POSIX 'fmod';
  use Scalar::Util 'tainted';
  import JE::Code 'add_line_number';
  sub add_line_number;
  BEGIN{*T=*JE::Code::T;}
  {
  no strict 'refs';
  *{'predelete'}=sub{
  ref(my$term=shift)eq 'JE::LValue' or return new JE::Boolean$global,1;
  my$base=$term->base;
  new JE::Boolean$global,defined$base?$base->delete($term->property):1;
  };
  *{'prevoid'}=sub{
  my$term=shift;
  $term=get$term while ref$term eq 'JE::LValue';
  return$global->undefined;
  };
  *{'pretypeof'}=sub{
  my$term=shift;
  ref$term eq 'JE::LValue'
    and ref base$term eq ''
    and return _new JE::String$global,'undefined';
  _new JE::String$global,typeof$term;
  };
  *{'pre++'}=sub{
  my$term=shift;
  $term->set(new JE::Number$global,get$term->to_number+1);
  };
  *{'pre--'}=sub{
  my$term=shift;
  $term->set(new JE::Number$global,get$term->to_number->value-1);
  };
  *{'pre+'}=sub{
  shift->to_number;
  };
  *{'pre-'}=sub{
  new JE::Number$global,-shift->to_number->value;
  };
  *{'pre~'}=sub{
  my$num=shift->to_number->value;
  $num=
    $num!=$num||abs($num)==inf
    ?0
    :int($num)%2**32;
  $num-=2**32 if$num>=2**31;
  {
  use integer;
  $num= ~$num;
  }
  new JE::Number$global,$num;
  };
  *{'pre!'}=sub{
  new JE::Boolean$global,!shift->to_boolean->value
  };
  *{'in*'}=sub{
  new JE::Number$global,shift->to_number->value*shift->to_number->value;
  };
  *{'in/'}=sub{
  my($num,$denom)=map to_number$_->value,@_[0,1];
  new JE::Number$global,
     $denom?$num/$denom
    :$num&&$num==$num?$num*inf
    :nan;
  };
  *{'in%'}=sub{
  my($num,$denom)=map to_number$_->value,@_[0,1];
  new JE::Number$global,
     $num+1==$num?nan
    :$num==$num&&abs($denom)==inf?$num
    :fmod$num,$denom;
  };
  *{'in+'}=sub{
  my($x,$y)=@_;
  $x=$x->to_primitive;
  $y=$y->to_primitive;
  if($x->typeof eq 'string'
  or$y->typeof eq 'string')
  {
  return _new JE::String$global,$x->to_string->value16.$y->to_string->value16;
  }
  return new JE::Number$global,$x->to_number->value+$y->to_number->value;
  };
  *{'in-'}=sub{
  new JE::Number$global,shift->to_number->value-shift->to_number->value;
  };
  *{'in<<'}=sub{
  my$num=shift->to_number->value;
  $num=$num!=$num||abs($num)==inf
    ?$num=0
    :int($num)%2**32;
  $num-=2**32 if$num>=2**31;
  my$shift_by=shift->to_number->value;
  $shift_by=
    $shift_by!=$shift_by||abs($shift_by)==inf
    ?0
    :int($shift_by)%32;
  my$ret=($num <<$shift_by)%2**32;
  $ret-=2**32 if$ret>=2**31;
  new JE::Number$global,$ret;
  };
  *{'in>>'}=sub{
  my$num=shift->to_number->value;
  $num=$num!=$num||abs($num)==inf
    ?$num=0
    :int($num)%2**32;
  $num-=2**32 if$num>=2**31;
  my$shift_by=shift->to_number->value;
  $shift_by=
    $shift_by!=$shift_by||abs($shift_by)==inf
    ?0
    :int($shift_by)%32;
  use integer;
  new JE::Number$global,$num>>$shift_by;
  };
  *{'in>>>'}=sub{
  my$num=shift->to_number->value;
  $num=$num!=$num||abs($num)==inf
    ?$num=0
    :int($num)%2**32;
  my$shift_by=shift->to_number->value;
  $shift_by=
    $shift_by!=$shift_by||abs($shift_by)==inf
    ?0
    :int($shift_by)%32;
  new JE::Number$global,$num>>$shift_by;
  };
  *{'in<'}=sub{
  my($x,$y)=map to_primitive$_,@_[0,1];
  new JE::Boolean$global,$x->typeof eq 'string'&&$y->typeof eq 'string'
    ?$x->to_string->value16 lt$y->to_string->value16
    :$x->to_number->[0]<$y->to_number->[0];
  };
  *{'in>'}=sub{
  my($x,$y)=map to_primitive$_,@_[0,1];
  new JE::Boolean$global,$x->typeof eq 'string'&&$y->typeof eq 'string'
    ?$x->to_string->value16 gt$y->to_string->value16
    :$x->to_number->[0]>$y->to_number->[0];
  };
  *{'in<='}=sub{
  my($x,$y)=map to_primitive$_,@_[0,1];
  new JE::Boolean$global,$x->typeof eq 'string'&&$y->typeof eq 'string'
    ?$x->to_string->value16 le$y->to_string->value16
    :$x->to_number->[0]<=$y->to_number->[0];
  };
  *{'in>='}=sub{
  my($x,$y)=map to_primitive$_,@_[0,1];
  new JE::Boolean$global,$x->typeof eq 'string'&&$y->typeof eq 'string'
    ?$x->to_string->value16 ge$y->to_string->value16
    :$x->to_number->[0]>=$y->to_number->[0];
  };
  *{'ininstanceof'}=sub{
  my($obj,$func)=@_;
  die new JE::Object::Error::TypeError$global,add_line_number"$func is not an object"
    if$func->primitive;
  die new JE::Object::Error::TypeError$global,add_line_number"$func is not a function"
    if$func->typeof ne 'function';
  return new JE::Boolean$global,0 if$obj->primitive;
  my$proto_id=$func->prop('prototype');
  !defined$proto_id||$proto_id->primitive and die new
    JE::Object::Error::TypeError$global,
    add_line_number"Function $$$func{func_name} has no prototype property";
  $proto_id=$proto_id->id;
  0 while(defined($obj=$obj->prototype)or return new JE::Boolean$global,0),$obj->id ne$proto_id;
  new JE::Boolean$global,1;
  };
  *{'inin'}=sub{
  my($prop,$obj)=@_;
  die new JE::Object::Error::TypeError$global,add_line_number"$obj is not an object"
    if$obj->primitive;
  new JE::Boolean$global,defined$obj->prop($prop);
  };
  *{'in=='}=sub{
  my($x,$y)=@_;
  my($xt,$yt)=(typeof$x,typeof$y);
  my($xi,$yi)=(id$x,id$y);
  $xt eq$yt and return new JE::Boolean$global,$xi eq$yi&&$xi ne 'num:nan';
  $xi eq 'null'
    and return new JE::Boolean$global,
    $yi eq 'undef';
  $xi eq 'undef'
    and return new JE::Boolean$global,
    $yi eq 'null';
  $yi eq 'null'
    and return new JE::Boolean$global,
    $xi eq 'undef';
  $yi eq 'undef'
    and return new JE::Boolean$global,
    $xi eq 'null';
  if($xt eq 'boolean'){
  $x=to_number$x;
  $xt='number';
  }
  elsif($yt eq 'boolean'){
  $y=to_number$y;
  $yt='number';
  }
  if($xt eq 'string'||$xt eq 'number' and!primitive$y){$y=to_primitive$y;$yt=typeof$y }
  elsif($yt eq 'string'||$yt eq 'number' and!primitive$x){$x=to_primitive$x;$xt=typeof$x }
  ($xt eq 'number' and$yt eq 'string'||$yt eq 'number')||($yt eq 'number' and$xt eq 'string'||$xt eq 'number')
    and return new JE::Boolean$global,
    to_number$x->[0]==to_number$y->[0];
  $xt eq 'string'&&$yt eq 'string'
    and return new JE::Boolean$global,
    $x->value16 eq$y->value16;
  new JE::Boolean$global,0;
  };
  *{'in!='}=sub{
  new JE::Boolean$global,!&{'in=='}->[0];
  };
  *{'in==='}=sub{
  my($x,$y)=@_;
  my($xi,$yi)=(id$x,id$y);
  return new JE::Boolean$global,$xi eq$yi&&$xi ne 'num:nan';
  };
  *{'in!=='}=sub{
  new JE::Boolean$global,!&{'in==='}->[0];
  };
  *{'in&'}=sub{
  my$num=shift->to_number->[0];
  $num=
    $num!=$num||abs($num)==inf
    ?0
    :int($num)%2**32;
  $num-=2**32 if$num>=2**31;
  my$num2=shift->to_number->[0];
  $num2=
    $num2!=$num2||abs($num2)==inf
    ?0
    :int($num2)%2**32;
  $num2-=2**32 if$num2>=2**31;
  use integer;
  new JE::Number$global,$num&$num2;
  };
  *{'in^'}=sub{
  my$num=shift->to_number->[0];
  $num=
    $num!=$num||abs($num)==inf
    ?0
    :int($num)%2**32;
  $num-=2**32 if$num>=2**31;
  my$num2=shift->to_number->[0];
  $num2=
    $num2!=$num2||abs($num2)==inf
    ?0
    :int($num2)%2**32;
  $num2-=2**32 if$num2>=2**31;
  use integer;
  new JE::Number$global,$num^$num2;
  };
  *{'in|'}=sub{
  my$num=shift->to_number->[0];
  $num=
    $num!=$num||abs($num)==inf
    ?0
    :int($num)%2**32;
  $num-=2**32 if$num>=2**31;
  my$num2=shift->to_number->[0];
  $num2=
    $num2!=$num2||abs($num2)==inf
    ?0
    :int($num2)%2**32;
  $num2-=2**32 if$num2>=2**31;
  use integer;
  new JE::Number$global,$num|$num2;
  };
  }
  sub eval{
  no warnings 'exiting';
  ++$ops>$counting and last JE_Code_OP  if$counting;
  my$expr=shift;
  my$type=$$expr[1];
  my@labels;
  $pos=$$expr[0][0];
  if($type eq 'expr'){
  my$result;
  if(@$expr==3){
  return _eval_term$$expr[-1];
  }
  else{
  for(@$expr[2..$#$expr-1]){
  $result=_eval_term$_ ;
  get$result if ref$result eq 'JE::LValue';
  }
  $result=_eval_term$$expr[-1];
  return ref$result eq 'JE::LValue'
    ?get$result
    :$result;
  }
  }
  if($type eq 'assign'){
  my@copy=\(@$expr[2..$#$expr]);
  my@qc_terms=@copy>=3
    &&(ref${$copy[-2]}||${$copy[-2]}=~/^(?:[tfu]|[si0-9])/)?(pop@copy,pop@copy):();
  my@terms=_eval_term${shift@copy};
  my@ops;
  while(@copy){
  push@ops,${shift@copy};
  push@terms,_eval_term${shift@copy};
  }
  my$val=pop@terms;
  @qc_terms and$val=_eval_term${$qc_terms[$val->to_boolean->[0]]};
  for(reverse@ops){
  no strict 'refs';
  length>1 and$val=&{'in'.substr$_,0,-1}($terms[-1],$val);
  $val=$val->get if ref$val eq 'JE::LValue';
        T
    and tainted$taint
    and$val->can('taint')
    and$val=taint$val $taint;
  eval{(pop@terms)->set($val)};
  if(my$err=$@){
  die$err if UNIVERSAL::isa($err,'JE::Object::Error');
  die new JE::Object::Error::ReferenceError$global,add_line_number"Cannot assign to a non-lvalue";
  }
  }
  if(!@ops){
  $val=$val->get if ref$val eq 'JE::LValue';
  }
  return$val;
  }
  if($type eq 'lassoc'){
  my@copy=\(@$expr[2..$#$expr]);
  my$result=_eval_term${shift@copy};
  while(@copy){
  no strict 'refs';
  my$op=${$copy[0]};
  if($op eq '&&'){
  $result=_eval_term(${$copy[1]})
    if$result->to_boolean->[0];
  $result=$result->get
    if ref$result eq 'JE::LValue';
  }
  elsif($op eq '||'){
  $result=_eval_term(${$copy[1]})
    unless$result->to_boolean->[0];
  $result=$result->get
    if ref$result eq 'JE::LValue';
  }
  else{
  $result=$result->get
    if ref$result eq 'JE::LValue';
  $result=&{"in$op"}($result,_eval_term${$copy[1]});
  }
  splice@copy,0,2;
  }
  return$result;
  }
  if($type eq 'prefix'){
  my$term=_eval_term$$expr[-1];
  no strict 'refs';
  $term=&{"pre$_"}($term)for reverse@$expr[2..@$expr-2];
  return$term;
  }
  if($type eq 'postfix'){
  my$ret=(my$term=_eval_term$$expr[2])->to_number;
  $term->set(new JE::Number$global,$ret->value+(-1,1)[$$expr[3]eq '++']);
  return$ret;
  }
  if($type eq 'new'){
  return _eval_term($$expr[2])->construct(
   @$expr==4
  ?T&&tainted$taint
    ? map$_->can('taint')?taint$_ $taint:$_,$$expr[-1]->list
    :$$expr[-1]->list
  :()
  );
  }
  if($type eq 'member/call'){
  my$obj=_eval_term$$expr[2];
  for(@$expr[3..$#$expr]){
  if(ref eq 'JE::Code::Subscript'){
  $obj=get$obj
    if ref$obj eq 'JE::LValue';
  $obj=new JE::LValue$obj,$_->str_val;
  }
  else{
  $obj=$obj->call(
    T&&tainted$taint
  ? map$_->can('taint')
    ?taint$_ $taint
    :$_,$_->list
    :$_->list
  );
  }
  }
  return$obj;
  }
  if($type eq 'array'){
  my@ary;
  for(2..$#$expr){
  if(ref$$expr[$_]eq 'comma'){
  ref$$expr[$_-1]eq 'comma'||$_==2
    and ++$#ary
  }
  else{
  push@ary,_eval_term$$expr[$_];
  $ary[-1]=$ary[-1]->get
    if ref$ary[-1]eq 'JE::LValue';
  }
  }
  my$ary=new JE::Object::Array$global;
  $$$ary{array}=\@ary;
  return$ary;
  }
  if($type eq 'hash'){
  my$obj=new JE::Object$global;
  local@_=\(@$expr[2..$#$expr]);
  my(@keys,$key,$value);
  while(@_){
  $key=${+shift};
  $value=_eval_term${shift;};
  $value=get$value if ref$value eq 'JE::LValue';
  $obj->prop($key,$value);
  }
  return$obj;
  }
  if($type eq 'func'){
  my($name,$params,$statements)=ref$$expr[2]?(undef,@$expr[2,3]):@$expr[2..4];
  my$func_scope=
    $name
    ?bless([@$scope,my$obj=new JE::Object$global],'JE::Scope')
    :$scope;
  (my$new_code_obj=bless{map+($_=>$code->{$_}),qw/global source file line/},'JE::Code')->{tree}=$statements;
  $new_code_obj->{vars}=$$expr[-1];
  my$f=new JE::Object::Function{
  scope=>$func_scope,
  defined$name?(name=>$name):(),
  argnames=>$params,
  function=>$new_code_obj,
  };
  if($name){
  $obj->prop(
  {
  name=>$name,
  value=>$f,
  readonly=>1,
  dontdel=>1,
  }
  );
  }
  return$f;
  }
  }
  sub _eval_term{
  my$term=$_[0];
  return$term->eval if ref$term eq 'JE::Code::Expression';
  ref$term
    ?ref$term eq 'ARRAY'
    ?(require JE::Object::RegExp,return JE::Object::RegExp->new($global,@$term))
    :$term
    :$term eq'this'?$this
    :$term=~/^s/?$_[0]=
     JE::String->_new($global,substr$term,1)
    :$term=~/^i/?$scope->find_var(substr$term,1)
    :$term eq 't'?$global->true
    :$term eq 'f'?$global->false
    :$term eq 'n'?$global->null
    :($_[0]=JE::Number->new($global,$term));
  }
  package JE::Code::Subscript;
  our$VERSION='0.066';
  sub str_val{
  my$val=(my$self=shift)->[1];
  ref$val?''.$val->eval:$val;
  }
  package JE::Code::Arguments;
  our$VERSION='0.066';
  sub list{
  my$self=shift;
  if(1){
  my@result;
  for(@$self[1..$#$self]){
  my$val=JE::Code::Expression::_eval_term($_);
  push@result,ref$val eq 'JE::LValue'?$val->get:$val
  }
  @result;
  }
  else{
  map{
  my$val=JE::Code::Expression::_eval_term($_);
  ref$val eq 'JE::LValue'?$val->get:$val
  }@$self[1..$#$self];
  }
  }
  1;
  __END__
  
  
  
  
JE_CODE

$fatpacked{"JE/LValue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_LVALUE';
  package JE::LValue;
  our$VERSION='0.066';
  use strict;
  use warnings;
  no warnings 'utf8';
  use List::Util 'first';
  use Scalar::Util 'blessed';
  require JE::Code;
  require JE::Object::Error::TypeError;
  require JE::Object::Error::ReferenceError;
  import JE::Code 'add_line_number';
  sub add_line_number;
  our$ovl_infix=join ' ',@overload::ops{
  qw[
    with_assign assign num_comparison 3way_comparison str_comparison	binary
    ]
  };
  our$ovl_prefix=join ' ',grep!/^(?:neg|atan2)\z/,map split(/ /),@overload::ops{qw[ unary mutators func ]};
  use overload
    fallback=>!1,
    nomethod=>sub{
  my$at=$@;
  my($self,$other,$reversed,$symbol)=@_;
  return$self if$symbol eq '=';
  $self=$self->get;
  my$sym_regexp=qr/(?:^| )\Q$symbol\E(?:$| )/;
  my$val;
  if($overload::ops{conversion}=~$sym_regexp){
  return$self;
  }
  elsif($ovl_infix=~$sym_regexp){
  my$bits=(caller 0)[9];
  $val=eval 'BEGIN{${^WARNING_BITS} = $bits}'
    .(
  $reversed
  ?"\$other $symbol \$self"
  :"\$self $symbol \$other"
    );
  }
  elsif($ovl_prefix=~$sym_regexp){
  my$bits=(caller 0)[9];
  $val=eval"BEGIN{\${^WARNING_BITS} = \$bits}$symbol \$self";
  }
  elsif($symbol eq 'neg'){
  return-$self;
  }
  elsif($symbol eq 'atan2'){
  return atan2$self,$other;
  }
  elsif($symbol eq '<>'){
  return<$self>;
  }
  else{
  die"Oh no! Something is terribly wrong with "."JE::LValue's overloading mechanism. It can't deal "."with < $symbol >. Please send a bug report.";
  }
  $@and die$@;
  $@=$at;
  return$val;
    },
    '@{}'=>sub{
  caller eq __PACKAGE__ and return shift;
  $_[0]->get;
    },
    '%{}'=>'get',
    '&{}'=>'get',
    '*{}'=>'get',
    '${}'=>'get';
  sub new{
  my($class,$obj,$prop)=@_;
  if(defined blessed$obj &&can$obj 'id'){
  my$id=$obj->id;
  $id eq 'null'||$id eq 'undef' and die
    new JE::Object::Error::TypeError$obj->global,
    add_line_number$obj->to_string->value." has no properties".", not even one named $prop";
  }
  bless[$obj,$prop],$class;
  }
  sub get{
  my$base=(my$self=shift)->[0];
  defined blessed$base or die new JE::Object::Error::ReferenceError$$base,add_line_number"The variable $$self[1] has not been declared";
  my$val=$base->prop($self->[1]);
  defined$val?$val:$base->global->undefined;
  }
  sub set{
  my$obj=(my$self=shift)->[0];
  defined blessed$obj or$obj=$$self[0]=$$obj;
  $obj->prop($self->[1],shift);
  }
  sub call{
  my$base_obj=(my$self=shift)->[0];
  my$prop=$self->get;
  defined$prop
    or die new JE::Object::Error::TypeError$base_obj->global,
    add_line_number"The object's '".$self->[1]."' property (undefined) is not a function";
  $prop->can('apply')
    or die new JE::Object::Error::TypeError$base_obj->global,
    add_line_number"The object's '".$self->[1]."' property ($prop) is not a function";
  $prop->apply($base_obj,@_);
  }
  sub base{
  my$base=$_[0][0];
  defined blessed$base ? $base:()
  }
  sub property{shift->[1]}
  our$AUTOLOAD;
  sub AUTOLOAD{
  my($method)=$AUTOLOAD=~/([^:]+)\z/;
  return if$method eq 'DESTROY';
  no warnings 'uninitialized';
  return shift->get->$method(@_);
  }
  sub can{
  !ref$_[0]||$_[1]eq 'DESTROY' and goto&UNIVERSAL::can;
  &UNIVERSAL::can||do{
  my$sub=(my$obj=shift->get)->can(@_)
    or return undef;
  sub{splice@'_,0,1,$obj;goto&$sub}
  };
  }
  1;
JE_LVALUE

$fatpacked{"JE/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_NULL';
  package JE::Null;
  our$VERSION='0.066';
  use strict;
  use warnings;
  use overload
    fallback=>1,
    '0+'=>sub{0},
    '""'=>'id',
    bool=>sub{undef};
  require JE::String;
  require JE::Boolean;
  sub new{
  bless\do{my$thing=$_[1]},$_[0]
  }
  sub value{undef}
  *TO_JSON=*value;
  sub typeof{'object'}
  sub id{'null'}
  sub primitive{1}
  sub to_primitive{$_[0]}
  sub to_boolean{JE::Boolean->new(${+shift},'')}
  sub to_string{JE::String->_new(${+shift},'null')}
  sub to_number{JE::Number->new(${+shift},0)}
  sub global{${$_[0]}}
  "Do you really expect a module called 'null' to return a true value?!";
JE_NULL

$fatpacked{"JE/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_NUMBER';
  package JE::Number;
  our$VERSION='0.066';
  use strict;
  use warnings;
  no warnings 'utf8';
  use constant nan=>sin 9**9**9;
  use constant inf=>9**9**9;
  use overload
    fallback=>1,
    '""'=>sub{
  my$value=$_[0][0];
     $value==inf?'Infinity'
    :$value==-+inf?'-Infinity'
    :$value==$value?$value
    :'NaN'
    },
    '0+'=>'value',
    bool=>sub{
  my$value=$_[0][0];
  $value&&$value==$value;
    },
    '+'=>sub{$_[0]->value+$_[1]},
    ;
  use Scalar::Util qw 'blessed tainted';
  require JE::String;
  require JE::Boolean;
  require JE::Object::Number;
  sub new{
  my($class,$global,$val)=@_;
  if(defined blessed$val and can$val 'to_number'){
  my$new_val=$val->to_number;
  ref$new_val eq$class and return$new_val;
  eval{$new_val->isa(__PACKAGE__)}
    and$val=$new_val->[0],
    goto RETURN;
  }
  $val=_numify($val);
  RETURN:
  bless[$val,$global],$class;
  }
  sub _numify{
  my$val=shift||0;
  if($val=~/^\s*([+-]?)(inf|nan)/i){
  $val=
     lc$2 eq 'nan'?nan
    :$1 eq '-'?-(inf)
    :inf;
  }
  else{$val+=0}
  $val;
  }
  sub prop{
  if(@_>2){return$_[2]}
  my($self,$name)=@_;
  $$self[1]->prototype_for('Number')->prop($name);
  }
  sub keys{
  my$self=shift;
  $$self[1]->prototype_for('Number')->keys;
  }
  sub delete{1}
  sub method{
  my$self=shift;
  $$self[1]->prototype_for('Number')->prop(shift)->apply($self,$$self[1]->upgrade(@_));
  }
  sub value{
  shift->[0]
  }
  *TO_JSON=*value;
  sub exists{!1}
  sub typeof{'number'}
  sub class{'Number'}
  sub id{
  my$value=shift->value;
  'num:'
    .(
   $value!=$value?'nan'
  :$value==inf?'inf'
  :$value==-+inf?'-inf'
  :$value
    )
  }
  sub primitive{1}
  sub to_primitive{$_[0]}
  sub to_boolean{
  my$value=(my$self=shift)->[0];
  JE::Boolean->new($$self[1],$value&&$value==$value);
  }
  sub to_string{
  my$value=(my$self=shift)->[0];
  JE::String->_new(
  $$self[1],
  $value==inf?'Infinity'
  :$value==-(inf)?'-Infinity'
  :$value==$value?$value
  :'NaN'
  );
  }
  *to_number=\&to_primitive;
  sub to_object{
  my$self=shift;
  JE::Object::Number->new($$self[1],$self);
  }
  sub global{$_[0][1]}
  sub taint{
  my$self=shift;
  tainted$self->[0]and return$self;
  my$alter_ego=[@$self];
  no warnings 'numeric';
  $alter_ego->[0]+=shift();
  return bless$alter_ego,ref$self;
  }
JE_NUMBER

$fatpacked{"JE/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT';
  package JE::Object;
  sub evall{
  my$global=shift;
  my$r=eval 'local *_;'.shift;
  $@and die;
  $r
  }
  our$VERSION='0.066';
  use strict;
  use warnings;
  use overload
    fallback=>1,
    '%{}'=>\&_get_tie,
    '""'=>'to_string',
    '0+'=>'to_number',
    bool=>sub{1};
  use Scalar::Util qw'refaddr blessed';
  use List::Util 'first';
  use B 'svref_2object';
  require JE::Code;
  require JE::Object::Error::TypeError;
  require JE::Object::Function;
  require JE::Boolean;
  require JE::String;
  import JE::Code 'add_line_number';
  sub add_line_number;
  sub in_list{
  my$str=shift;
  shift eq$str and return 1 while@_;
  !1;
  }
  sub new{
  my($class,$global,$value)=@_;
  if(defined blessed$value
  and can$value 'to_object')
  {
  return to_object$value;
  }
  my$p;
  my%hash;
  my%opts;
  ref$value eq 'HASH' and(%opts=%$value),$value=$opts{value};
  local$@;
  if(!defined$value||!defined eval{$value->value}&&$@eq ''){
  $p=
    exists$opts{prototype}
    ?$opts{prototype}
    :$global->prototype_for("Object");
  }
  elsif(ref$value eq 'HASH'){
  %hash=%$value;
  $p=$global->prototype_for("Object");
  }
  else{
  return$global->upgrade($value);
  }
  my$self=bless\{
  prototype=>$p,
  global=>$global,
  props=>\%hash,
  keys=>[keys%hash]
  },$class;
  $JE::Destroyer&&JE::Destroyer'register($self);
  $self;
  }
  sub destroy{
  undef${$_[0]};
  }
  sub new_function{
  my$self=shift;
  my$f=JE::Object::Function->new(
  {
  scope=>$self->global,
  function=>pop,
  function_args=>['args'],
  @_?(name=>$_[0]):()
  }
  );
  @_ and$self->prop(
  {
  name=>shift,
  value=>$f,
  }
  );
  $f;
  }
  sub new_method{
  my$self=shift;
  my$f=JE::Object::Function->new(
  {
  scope=>$self->global,
  function=>pop,
  function_args=>['this','args'],
  @_?(name=>$_[0]):()
  }
  );
  @_ and$self->prop(
  {
  name=>shift,
  value=>$f,
  dontenum=>1
  }
  );
  $f;
  }
  sub prop{
  my($self,$opts)=(shift,shift);
  my$guts=$$self;
  if(ref$opts eq 'HASH'){
  my$name=$$opts{name};
  for(qw< dontdel readonly >){
  exists$$opts{$_}
    and$$guts{"prop_$_"}{$name}=$$opts{$_};
  }
  my$props=$$guts{props};
  my$dontenum;
  if(exists$$opts{dontenum}){
  if($$opts{dontenum}){
  @{$$guts{keys}}=
    grep$_ ne$name,@{$$guts{keys}};
  }
  else{
  push@{$$guts{keys}},$name
    unless first{$_ eq$name}@{$$guts{keys}};
  }
  }
  elsif(!exists$$props{$name}){
  push@{$$guts{keys}},$name
  }
  if(exists$$opts{fetch}){
  $$guts{fetch_handler}{$name}=$$opts{fetch};
  $$props{$name}=undef if!exists$$props{$name};
  }
  if(exists$$opts{store}){
  $$guts{store_handler}{$name}=$$opts{store};
  $$props{$name}=undef if!exists$$props{$name};
  }
  if(exists$$opts{value}){
  return$$props{$name}=$$opts{value};
  }
  elsif(!exists$$opts{fetch}&&exists$$opts{autoload}){
  my$auto=$$opts{autoload};
  $$props{$name}=
    ref$auto eq 'CODE'
    ?$auto
    :"package ".caller()."; $auto";
  return
  }
  return
     exists$$opts{fetch}?()
    :exists$$props{$name}?$$props{$name}
    :undef;
  }
  else{
  my$name=$opts;
  my$props=$$guts{props};
  if(@_){
  my($new_val)=shift;
  return$new_val if$self->is_readonly($name);
  my$exists=exists$$props{$name}
    &&defined$$props{$name};
  exists$$guts{store_handler}{$name}
    ?$$guts{store_handler}{$name}->($self,$new_val,$$props{$name})
    :($$props{$name}=$new_val);
  push@{$$guts{keys}},$name
    unless$exists;
  return$new_val;
  }
  elsif(exists$$props{$name}){
  if(exists$$guts{fetch_handler}{$name}){
  return$$guts{fetch_handler}{$name}->($self,$$props{$name});
  }
  my$val=$$props{$name};
  ref$val eq 'CODE'
    ?$val=$$props{$name}=&$val()
    :defined$val
    &&ref$val eq ''
    &&($val=$$props{$name}=evall$$guts{global},$val);
  return$val;
  }
  else{
  my$proto=$self->prototype;
  return$proto
    ?$proto->prop($name)
    :undef;
  }
  }
  }
  sub exists{
  my($self,$name)=@_;
  return exists$$$self{props}{$name}
  }
  sub is_readonly{
  my($self,$name)=(shift,@_);
  my$guts=$$self;
  my$props=$$guts{props};
  if(exists$$props{$name}){
  my$read_only_list=$$guts{prop_readonly};
  return exists$$read_only_list{$name}?$$read_only_list{$name}:!1;
  }
  if(my$proto=$self->prototype){
  return$proto->is_readonly(@_);
  }
  return!1;
  }
  sub is_enum{
  my($self,$name)=@_;
  $self=$$self;
  in_list$name,@{$$self{keys}};
  }
  sub keys{
  my$self=shift;
  my$proto=$self->prototype;
  @{$$self->{keys}},defined$proto?$proto->keys:();
  }
  sub delete{
  my($self,$name)=@_;
  my$guts=$$self;
  unless($_[2]){
  my$dontdel_list=$$guts{prop_dontdel};
  exists$$dontdel_list{$name}
    and$$dontdel_list{$name}
    and return!1;
  }
  delete$$guts{prop_dontdel}{$name};
  delete$$guts{prop_dontenum}{$name};
  delete$$guts{prop_readonly}{$name};
  delete$$guts{props}{$name};
  $$guts{keys}=[grep$_ ne$name,@{$$guts{keys}}];
  return 1;
  }
  sub method{
  my($self,$method)=(shift,shift);
  $self->prop($method)->apply($self,$self->global->upgrade(@_));
  }
  sub typeof{'object'}
  sub class{'Object'}
  sub value{
  my$self=shift;
  +{map+($_=>$self->prop($_)),$self->keys};
  }
  *TO_JSON=*value;
  sub id{
  refaddr shift;
  }
  sub primitive{!1}
  sub prototype{
  @_>1?(${+shift}->{prototype}=$_[1]):${+shift}->{prototype};
  }
  sub to_primitive{
  my($self,$hint)=@_;
  my@methods=('valueOf','toString');
  defined$hint&&$hint eq 'string' and@methods=reverse@methods;
  my$method;
  my$prim;
  for(@methods){
  defined($method=$self->prop($_))||next;
  ($prim=$method->apply($self))->primitive||next;
  return$prim;
  }
  die new JE::Object::Error::TypeError$self->global,add_line_number"An object of type ".(eval{$self->class}||ref$self)." cannot be converted to a primitive";
  }
  sub to_boolean{
  JE::Boolean->new($${+shift}{global},1);
  }
  sub to_string{
  shift->to_primitive('string')->to_string;
  }
  sub to_number{
  shift->to_primitive('number')->to_number;
  }
  sub to_object{$_[0]}
  sub global{${+shift}->{global}}
  sub _init_proto{
  my$proto=shift;
  my$global=$$proto->{global};
  $proto->prop(
  {
  dontenum=>1,
  name=>'constructor',
  value=>$global->prop('Object'),
  }
  );
  my$toString_sub=sub{
  my$self=shift;
  JE::String->new($global,'[object '.$self->class.']');
  };
  $proto->prop(
  {
  name=>'toString',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toString',
  length=>0,
  function_args=>['this'],
  function=>$toString_sub,
  no_proto=>1,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'toLocaleString',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toLocaleString',
  length=>0,
  function_args=>['this'],
  function=>sub{shift->method('toString')},
  no_proto=>1,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'valueOf',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'valueOf',
  length=>0,
  function_args=>['this'],
  function=>sub{$_[0]},
  no_proto=>1,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'hasOwnProperty',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'hasOwnProperty',
  argnames=>['V'],
  function_args=>['this','args'],
  function=>sub{
  JE::Boolean->new($global,shift->exists(defined$_[0]?$_[0]:'undefined'));
  },
  no_proto=>1,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'isPrototypeOf',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'isPrototypeOf',
  argnames=>['V'],
  function_args=>['this','args'],
  function=>sub{
  my($self,$obj)=@_;
  !defined$obj||$obj->primitive and return JE::Boolean->new($global,0);
  my$id=$self->id;
  my$proto=$obj;
  while(defined($proto=$proto->prototype)){
  $proto->id eq$id and return JE::Boolean->new($global,1);
  }
  return JE::Boolean->new($global,0);
  },
  no_proto=>1,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'propertyIsEnumerable',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'propertyIsEnumerable',
  argnames=>['V'],
  function_args=>['this','args'],
  function=>sub{
  return JE::Boolean->new($global,shift->is_enum(defined$_[0]?$_[0]:'undefined'));
  },
  no_proto=>1,
  }
  ),
  dontenum=>1,
  }
  );
  }
  sub _get_tie{
  my$self=shift;
  my$guts=$$self;
  $$guts{tie}or tie%{$$guts{tie}},__PACKAGE__,$self;
  $$guts{tie};
  }
  sub TIEHASH{$_[1]}
  sub FETCH{$_[0]->prop($_[1])}
  sub STORE{
  my($self,$key,$val)=@_;
  my$global=$self->global;
  if(ref$val eq 'HASH'
  &&!blessed$val
  &&!%$val
  &&svref_2object($val)->REFCNT==2)
  {
  $val=tie%$val,__PACKAGE__,__PACKAGE__->new($global);
  }
  elsif(ref$val eq 'ARRAY'
  &&!blessed$val
  &&!@$val
  &&svref_2object($val)->REFCNT==2)
  {
  require JE::Object::Array;
  $val=tie@$val,'JE::Object::Array',JE::Object::Array->new($global);
  }
  $self->prop($key=>$global->upgrade($val))
  }
  sub DELETE{
  my$val=$_[0]->prop($_[1]);
  $_[0]->delete($_[1]);
  $val;
  }
  sub EXISTS{$_[0]->exists($_[1])}
  sub FIRSTKEY{($_[0]->keys)[0]}
  sub NEXTKEY{
  my@keys=$_[0]->keys;
  my$last=$_[1];
  for(0..$#keys){
  if($last eq$keys[$_]){
  return$keys[$_+1]
  }
  }
  return$keys[0];
  }
  sub DDS_freeze{my$self=shift;delete$$$self{tie};$self}
  1;
JE_OBJECT

$fatpacked{"JE/Object/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ARRAY';
  package JE::Object::Array;
  our$VERSION='0.066';
  use strict;
  use warnings;
  no warnings 'utf8';
  use overload
    fallback=>1,
    '@{}'=>\&_get_tie;
  use List::Util qw/min max/;
  use Scalar::Util 'blessed';
  our@ISA='JE::Object';
  require JE::Code;
  require JE::Object;
  require JE::Object::Error::TypeError;
  require JE::Object::Function;
  require JE::String;
  require JE::Number;
  import JE::Code 'add_line_number';
  sub add_line_number;
  sub new{
  my($class,$global)=(shift,shift);
  my@array;
  if(ref$_[0]eq 'ARRAY'){
  @array=$global->upgrade(@{+shift});
  }
  elsif(@_==1&&UNIVERSAL::isa$_[0],'JE::Number'){
  my$num=0+shift;
  $num==int($num)%2**32
    or require JE::Object::Error::RangeError,
    die JE::Object::Error::RangeError->new($global,add_line_number"$num is not a valid array index");
  $#array=$num-1;
  }
  else{
  @array=$global->upgrade(@_);
  }
  my$self=SUPER::new$class $global,{prototype=>$global->prototype_for('Array')||$global->prop('Array')->prop('prototype')};
  my$guts=$$self;
  $$guts{array}=\@array;
  bless$self,$class;
  }
  sub prop{
  my($self,$name,$val)=(shift,@_);
  my$guts=$$self;
  if($name eq 'length'){
  if(@_>1){
  $val==int($val)%2**32
    or require JE::Object::Error::RangeError,
    die new JE::Object::Error::RangeError$$guts{global},
    add_line_number"$val is not a valid value for length";
  $#{$$guts{array}}=$val-1;
  return JE::Number->new($$guts{global},$val);
  }
  else{
  return JE::Number->new($$guts{global},$#{$$guts{array}}+1);
  }
  }
  elsif($name=~/^(?:0|[1-9]\d*)\z/ and$name<4294967295){
  if(@_>1){
  return$$guts{array}[$name]=$$guts{global}->upgrade($val);
  }
  else{
  return exists$$guts{array}[$name]?$$guts{array}[$name]:undef;
  }
  }
  $self->SUPER::prop(@_);
  }
  sub is_enum{
  my($self,$name)=@_;
  $name eq 'length' and return!1;
  if($name=~/^(?:0|[1-9]\d*)\z/ and$name<4294967295){
  my$array=$$$self{array};
  return$name<@$array&&defined$$array[$name];
  }
  SUPER::is_enum$self $name;
  }
  sub keys{
  my$self=shift;
  my$array=$$$self{array};
  grep(defined$$array[$_],0..$#$array),SUPER::keys$self;
  }
  sub delete{
  my($self,$name)=@_;
  $name eq 'length' and return!1;
  if($name=~/^(?:0|[1-9]\d*)\z/ and$name<4294967295){
  my$array=$$$self{array};
  $name<@$array and$$array[$name]=undef;
  return 1;
  }
  SUPER::delete$self $name;
  }
  sub value{[@{$${+shift}{array}}]}
  *TO_JSON=*value;
  sub exists{
  my($self,$name)=(shift,@_);
  my$guts=$$self;
  if($name eq 'length'){
  return 1
  }
  elsif($name=~/^(?:0|[1-9]\d*)\z/ and$name<4294967295){
  return exists$$guts{array}[$name]
    &&defined$$guts{array}[$name];
  }
  $self->SUPER::exists(@_);
  }
  sub class{'Array'}
  sub _new_constructor{
  my$global=shift;
  my$construct_cref=sub{
  __PACKAGE__->new(@_);
  };
  my$f=JE::Object::Function->new(
  {
  name=>'Array',
  scope=>$global,
  function=>$construct_cref,
  function_args=>['global','args'],
  length=>1,
  constructor=>$construct_cref,
  constructor_args=>['global','args'],
  }
  );
  my$proto=$f->prop(
  {
  name=>'prototype',
  dontenum=>1,
  readonly=>1,
  }
  );
  bless$proto,__PACKAGE__;
  $$$proto{array}=[];
  $global->prototype_for('Array',$proto);
  $proto->prop(
  {
  name=>'toString',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toString',
  length=>0,
  no_proto=>1,
  function_args=>['this'],
  function=>\&_toString,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'toLocaleString',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toLocaleString',
  length=>0,
  no_proto=>1,
  function_args=>['this'],
  function=>\&_toLocaleString,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'concat',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'concat',
  length=>1,
  no_proto=>1,
  function_args=>['this','args'],
  function=>\&_concat,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'join',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'join',
  argnames=>['separator'],
  no_proto=>1,
  function_args=>['this','args'],
  function=>\&_join,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'pop',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'pop',
  length=>0,
  no_proto=>1,
  function_args=>['this'],
  function=>\&_pop,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'push',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'push',
  length=>1,
  no_proto=>1,
  function_args=>['this','args'],
  function=>\&_push,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'reverse',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'reverse',
  length=>0,
  no_proto=>1,
  function_args=>['this'],
  function=>\&_reverse,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'shift',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'shift',
  length=>0,
  no_proto=>1,
  function_args=>['this'],
  function=>\&_shift,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'slice',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'shift',
  argnames=>[qw/start end/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>\&_slice,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'sort',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'sort',
  argnames=>[qw/comparefn/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>\&_sort,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'splice',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'splice',
  argnames=>[
  qw/start
    deleteCount/
  ],
  no_proto=>1,
  function_args=>['this','args'],
  function=>\&_splice,
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'unshift',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'unshift',
  length=>1,
  no_proto=>1,
  function_args=>['this','args'],
  function=>\&_unshift,
  }
  ),
  dontenum=>1,
  }
  );
  $f
  }
  sub _toString{
  my$self=shift;
  eval{$self->class}eq 'Array'
    or die JE::Object::Error::TypeError->new($self->global,add_line_number 'Object is not an Array');
  my$guts=$$self;
  JE::String->_new($$guts{global},join ',',map defined$_&&ref!~/^JE::(?:Undefined|Null)\z/?$_->to_string->value:'',@{$$guts{array}});
  }
  sub _toLocaleString{
  my$self=shift;
  eval{$self->class}eq 'Array'
    or die JE::Object::Error::TypeError->new($self->global,'Object is not an Array');
  my$guts=$$self;
  JE::String->_new($$guts{global},join ',',map defined$_&&defined$_->value?$_->method('toLocaleString')->value:'',@{$$guts{array}});
  }
  sub _concat{
  unshift@_,shift->to_object;
  my$thing;
  my$new=__PACKAGE__->new(my$global=$_[0]->global);
  my@new;
  while(@_){
  $thing=shift;
  if(eval{$thing->class}eq 'Array'){
  push@new,@{$$$thing{array}};
  }
  else{
  push@new,$thing;
  }
  }
  $$$new{array}=\@new;
  $new;
  }
  sub _join{
  my($self,$sep)=@_;
  !defined$sep||$sep->id eq 'undef' and$sep=',';
  my$length=$self->prop('length');
  if(defined$length){
  $length=$length->to_number->value%2**32;
  $length==$length or$length=0;
  }
  else{$length=0}
  my$val;
  JE::String->_new(
  $self->global,
  join$sep,
  map{
  my$val=$self->prop($_);
  defined$val&&defined$val->value?$val->to_string->value:''
  }0..$length-1
  );
  }
  sub _pop{
  my($self)=@_;
  my$length=$self->prop('length');
  if(defined$length){
  $length=(int$length->to_number->value)%2**32;
  $length==$length or$length=0;
  }
  else{$length=0}
  my$global=$self->global;
  $length
    or$self->prop('length',JE::Number->new($global,0)),
    return$global->undefined;
  $length--;
  my$val=$self->prop($length);
  $self->delete($length);
  $self->prop(length=>JE::Number->new($global,$length));
  $val;
  }
  sub _push{
  my($self)=shift;
  my$length=$self->prop('length');
  if(defined$length){
  $length=(int$length->to_number->value)%2**32;
  $length==$length or$length=0;
  }
  else{$length=0}
  while(@_){
  $self->prop($length++,shift);
  }
  $self->prop(length=>JE::Number->new($self->global,$length));
  }
  sub _reverse{
  my$self=shift;
  my$length=$self->prop('length');
  if(defined$length){
  $length=(int$length->to_number->value)%2**32;
  $length==$length or$length=0;
  }
  else{$length=0}
  my($elem1,$elem2,$indx2);
  for(0..int$length/2-1){
  $elem1=$self->prop($_);
  $elem2=$self->prop($indx2=$length-$_-1);
  defined$elem2
    ?$self->prop($_=>$elem2)
    :$self->delete($_);
  defined$elem1
    ?$self->prop($indx2=>$elem1)
    :$self->delete($indx2);
  }
  $self;
  }
  sub _shift{
  my($self)=@_;
  my$length=$self->prop('length');
  if(defined$length){
  $length=(int$length->to_number->value)%2**32;
  $length==$length or$length=0;
  }
  else{$length=0}
  $length
    or$self->prop('length',0),
    return$self->global->undefined;
  my$ret=$self->prop(0);
  my$val;
  for(0..$length-2){
  $val=$self->prop($_+1);
  defined$val
    ?$self->prop($_=>$val)
    :$self->delete($_);
  }
  $self->delete(--$length);
  $self->prop(length=>$length);
  $ret;
  }
  sub _slice{
  my($self,$start,$end)=@_;
  my$length=$self->prop('length');
  if(defined$length){
  $length=(int$length->to_number->value)%2**32;
  $length==$length or$length=0;
  }
  else{$length=0}
  my$new=__PACKAGE__->new(my$global=$self->global);
  my@new;
  if(defined$start){
  $start=int$start->to_number->value;
  $start=
     $start==$start
    ?$start<0
    ?max($start+$length,0)
    :min($start,$length)
    :0;
  }
  else{
  $start=0
  }
  if(defined$end and$end->id ne 'undef'){
  $end=$end->to_number->value;
  $end=
     $end==$end
    ?$end<0
    ?max($end+$length,0)
    :min($end,$length)
    :0;
  }
  else{
  $end=$length
  }
  for($start..$end-1){
  push@new,$self->prop($_);
  }
  $$$new{array}=\@new;
  $new;
  }
  sub _sort{
  my($self,$comp)=@_;
  my$length=$self->prop('length');
  if(defined$length){
  $length=(int$length->to_number->value)%2**32;
  $length==$length or$length=0;
  }
  else{$length=0}
  my(@sortable,@undef,$nonexistent,$val);
  for(0..$length-1){
  defined($val=$self->prop($_))
    ?$val->id eq 'undef'
    ?(push@undef,$val)
    :(push@sortable,$val)
    : ++$nonexistent;
  }
  my$comp_sub=
    defined$comp&&$comp->can('call')
    ?sub{0+$comp->call($a,$b)}
    :sub{$a->to_string->value16 cmp$b->to_string->value16};
  my@sorted=((sort$comp_sub @sortable),@undef);
  for(0..$#sorted){
  $self->prop($_=>$sorted[$_]);
  }
  no warnings 'uninitialized';
  for(@sorted..$#sorted+$nonexistent){
  $self->delete($_);
  }
  $self;
  }
  sub _splice{
  my($self,$start,$del_count)=(shift,shift,shift);
  my$global=$self->global;
  my$length=$self->prop('length');
  if(defined$length){
  $length=($length->to_number->value)%2**32;
  $length==$length or$length=0;
  }
  else{$length=0}
  if(defined$start){
  $start=int$start->to_number->value;
  $start=
     $start==$start
    ?$start<0
    ?max($start+$length,0)
    :min($start,$length)
    :0;
  }
  else{
  $start=0
  }
  if(defined$del_count){
  $del_count=int$del_count->to_number->value;
  $del_count=
    $del_count>=0
    ?min($del_count,$length-$start)
    :0;
  }
  else{
  $del_count=0
  }
  my@new=map$self->prop($_),$start..(my$end=$start+$del_count-1);
  my$val;
  if(@_<$del_count){
  my$diff=$del_count-@_;
  for($end+1..$length-1){
  defined($val=$self->prop($_))
    ?$self->prop($_-$diff=>$val)
    :$self->delete($_-$diff);
  }
  $self->prop(length=>JE::Number->new($global,$length-$diff));
  }
  elsif(@_>$del_count){
  my$diff=@_-$del_count;
  for(reverse$end+1..$length-1){
  defined($val=$self->prop($_))
    ?$self->prop($_+$diff=>$val)
    :$self->delete($_+$diff);
  }
  $self->prop(length=>JE::Number->new($global,$length+$diff));
  }
  else{
  $self->prop(length=>JE::Number->new($global,$length));
  }
  for(0..$#_){
  $self->prop($_+$start=>$_[$_]);
  }
  my$new=__PACKAGE__->new($self->global);
  $$new->{array}=\@new;
  $new;
  }
  sub _unshift{
  my($self)=(shift,);
  my$length=$self->prop('length');
  if(defined$length){
  $length=(int$length->to_number->value)%2**32;
  $length==$length or$length=0;
  }
  else{$length=0}
  my$val;
  for(reverse 0..$length-1){
  defined($val=$self->prop($_))
    ?$self->prop($_+@_=>$val)
    :$self->delete($_+@_);
  }
  for(0..$#_){
  $self->prop($_=>$_[$_]);
  }
  $self->prop(length=>$length+=@_);
  return JE::Number->new($self->global,$length);
  }
  sub _get_tie{
  my$self=shift;
  my$guts=$$self;
  $$guts{array_tie}or tie@{$$guts{array_tie}},__PACKAGE__,$self;
  $$guts{array_tie};
  }
  sub TIEARRAY{$_[1]}
  sub FETCHSIZE{$_[0]->prop('length')}
  sub STORESIZE{$_[0]->prop('length'=>$_[1])}
  sub PUSH{shift->method(push=>@_)}
  sub POP{$_[0]->method('pop')}
  sub SHIFT{$_[0]->method('shift')}
  sub UNSHIFT{shift->method(unshift=>@_)}
  sub SPLICE{@{shift->method(splice=>@_)->value}}
  sub DDS_freeze{
  my$self=shift;
  delete$$$self{array_tie};
  SUPER::DDS_freeze$self;
  }
  1;
JE_OBJECT_ARRAY

$fatpacked{"JE/Object/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_BOOLEAN';
  package JE::Object::Boolean;
  our$VERSION='0.066';
  use strict;
  use warnings;
  our@ISA='JE::Object';
  use Scalar::Util 'blessed';
  require JE::Code;
  require JE::Boolean;
  require JE::Object::Error::TypeError;
  require JE::Object::Function;
  require JE::String;
  import JE::Code 'add_line_number';
  sub add_line_number;
  sub new{
  my($class,$global,$val)=@_;
  my$self=$class->SUPER::new(
  $global,
  {
  prototype=>$global->prototype_for('Boolean')||$global->prop('Boolean')->prop('prototype')
  }
  );
  $$$self{value}=
     defined$val
    ?defined blessed$val &&$val->can('to_boolean')
    ?$val->to_boolean->[0]
    :!!$val
    :!1;
  $self;
  }
  sub value{$${$_[0]}{value}}
  sub class{'Boolean'}
  sub _new_constructor{
  my$global=shift;
  my$f=JE::Object::Function->new(
  {
  name=>'Boolean',
  scope=>$global,
  argnames=>[qw/value/],
  function=>sub{
  defined$_[0]
    ?$_[0]->to_boolean
    :JE::Boolean->new($global,0);
  },
  function_args=>['args'],
  constructor=>sub{
  unshift@_,__PACKAGE__;
  goto&new;
  },
  constructor_args=>['scope','args'],
  }
  );
  my$proto=bless$f->prop(
  {
  name=>'prototype',
  dontenum=>1,
  readonly=>1,
  }
    ),
    __PACKAGE__;
  $global->prototype_for('Boolean',$proto);
  $$$proto{value}=!1;
  $proto->prop(
  {
  name=>'toString',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'valueOf',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$self=shift;
  die JE::Object::Error::TypeError->new($global,add_line_number"Argument to "."Boolean.prototype.toString is not"." a "."Boolean object")unless$self->class eq 'Boolean';
  return JE::String->_new($global,qw/false true/[$self->value]);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'valueOf',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'valueOf',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$self=shift;
  die JE::Object::Error::TypeError->new($global,add_line_number"Argument to "."Boolean.prototype.valueOf is not"." a "."Boolean object")unless$self->class eq 'Boolean';
  return JE::Boolean->new($global,$$$self{value});
  },
  }
  ),
  dontenum=>1,
  }
  );
  $f;
  }
  return"a true value";
JE_OBJECT_BOOLEAN

$fatpacked{"JE/Object/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ERROR';
  package JE::Object::Error;
  our$VERSION='0.066';
  use strict;
  use warnings;
  our@ISA='JE::Object';
  require JE::Object;
  require JE::String;
  sub new{
  my($class,$global,$val)=@_;
  my($js_class)=$class->name;
  my$self=$class->SUPER::new(
  $global,
  {
  prototype=>$global->prototype_for($js_class)||$global->prop($js_class)->prop('prototype')
  }
  );
  $self->prop(
  {
  dontenum=>1,
  name=>'message',
  value=>JE::String->_new($global,$val),
  }
  )if defined$val and ref$val ne 'JE::Undefined';
  $self;
  }
  sub value{$_[0]->method('toString')->value}
  sub class{'Error'}
  *name=*class;
  sub _new_constructor{
  my$global=shift;
  my$con=sub{
  __PACKAGE__->new(@_);
  };
  my$args=['scope','args'];
  my$f=JE'Object'Function->new(
  {
  name=>'Error',
  scope=>$global,
  argnames=>['message'],
  function=>$con,
  function_args=>$args,
  constructor=>$con,
  constructor_args=>$args,
  }
  );
  my$proto=bless$f->prop(
  {
  name=>'prototype',
  dontenum=>1,
  readonly=>1
  }
  );
  $global->prototype_for('Error',$proto);
  $proto->prop(
  {
  name=>'toString',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toString',
  length=>0,
  function_args=>['this'],
  function=>sub{
  my$self=shift;
  JE::String->_new($$$self{global},$self->prop('name').': '.$self->prop('message'));
  }
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'name',
  value=>JE::String->_new($global,'Error'),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'message',
  value=>JE::String->_new($global,'Unknown error'),
  dontenum=>1,
  }
  );
  weaken$global;
  $f
  }
  sub _new_subclass_constructor{
  my($package,$global)=@_;
  my$f=JE::Object::Function->new(
  {
  name=>my$name=$package->name,
  scope=>$global,
  argnames=>['message'],
  function=>(
  sub{$package->new(@_)},
  function_args=>['scope','args'],
  constructor=>constructor_args=>
  )[0..3,0,4,2],
  }
  );
  my$proto=$f->prop(
  {
  name=>'prototype',
  dontenum=>1,
  readonly=>1,
  }
  );
  $global->prototype_for($name=>$proto);
  bless$proto,$package;
  $proto->prototype($global->prototype_for('Error')||$global->prop('Error')->prop('prototype'));
  $proto->prop(
  {
  name=>'name',
  value=>JE::String->_new($global,$name),
  dontenum=>1,
  }
  );
  (my$msg=$name)=~s/(?!^)([A-Z])(?![A-Z])/ \l$1/g;
  $proto->prop(
  {
  name=>'message',
  value=>JE::String->_new($global,$msg),
  dontenum=>1,
  }
  );
  weaken$global;
  $f;
  }
  return"a true value";
JE_OBJECT_ERROR

$fatpacked{"JE/Object/Error/ReferenceError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ERROR_REFERENCEERROR';
  package JE::Object::Error::ReferenceError;
  our$VERSION='0.066';
  use strict;
  use warnings;
  our@ISA='JE::Object::Error';
  require JE::Object::Error;
  require JE::String;
  sub name{'ReferenceError'}
  return"a true value";
JE_OBJECT_ERROR_REFERENCEERROR

$fatpacked{"JE/Object/Error/SyntaxError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ERROR_SYNTAXERROR';
  package JE::Object::Error::SyntaxError;
  our$VERSION='0.066';
  use strict;
  use warnings;
  our@ISA='JE::Object::Error';
  require JE::Object::Error;
  require JE::String;
  sub name{SyntaxError=>}
  return"a true value";
JE_OBJECT_ERROR_SYNTAXERROR

$fatpacked{"JE/Object/Error/TypeError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ERROR_TYPEERROR';
  package JE::Object::Error::TypeError;
  our$VERSION='0.066';
  use strict;
  use warnings;
  our@ISA='JE::Object::Error';
  require JE::Object::Error;
  require JE::String;
  sub name{'TypeError'}
  return"a true value";
JE_OBJECT_ERROR_TYPEERROR

$fatpacked{"JE/Object/Function.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_FUNCTION';
  package JE::Object::Function;
  our$VERSION='0.066';
  use strict;
  use warnings;
  no warnings 'utf8';
  use Carp;
  use Scalar::Util 'blessed';
  use overload
    fallback=>1,
    '&{}'=>sub{
  my$self=shift;
  sub{
  my$ret=$self->call($self->global->upgrade(@_));
  typeof$ret eq 'undefined'?undef:$ret
  }
    };
  our@ISA='JE::Object';
  require JE::Code;
  require JE::Number;
  require JE::Object;
  require JE::Object::Error::TypeError;
  require JE::Parser;
  require JE::Scope;
  import JE::Code 'add_line_number';
  sub add_line_number;
  sub new{
  my($class,$scope)=(shift,shift);
  my%opts;
  if(ref$scope eq 'HASH'){
  %opts=%$scope;
  $scope=$opts{scope};
  }
  else{
  %opts=
    @_==1
    ?(function=>shift)
    :(
  argnames=>do{
  my$src='('.join(',',@_[0..$#_-1]).')';
  $src=~s/\p{Cf}//g;
  my$params=JE::Parser::_parse(
  params=>$src,
  $scope
  );
  $@and die$@;
  $params;
  },
  function=>pop
    );
  }
  defined blessed$scope
    or croak"The 'scope' passed to JE::Object::Function->new (".(defined$scope?$scope:'undef').") is not an object";
  ref$scope ne 'JE::Scope' and$scope=bless[$scope],'JE::Scope';
  my$global=$$scope[0];
  my$self=$class->SUPER::new(
  $global,
  {
  prototype=>$global->prototype_for('Function')
  }
  );
  my$guts=$$self;
  $$guts{scope}=$scope;
  $opts{no_proto}or$self->prop(
  {
  name=>'prototype',
  dontdel=>1,
  value=>JE::Object->new($global),
  }
  )->prop(
  {
  name=>'constructor',
  dontenum=>1,
  value=>$self,
  }
  );
  {
  no warnings 'uninitialized';
  $$guts{function}=
    ref($opts{function})=~/^(?:JE::Code|CODE)\z/
    ?$opts{function}
    :length$opts{function}
    &&(parse$global $opts{function}or die);
  $self->prop(
  {
  name=>'length',
  value=>JE::Number->new($global,$opts{length}||(ref$opts{argnames}eq 'ARRAY'?scalar@{$opts{argnames}}:0)),
  dontenum=>1,
  dontdel=>1,
  readonly=>1,
  }
  );
  }
  $$guts{func_argnames}=[ref$opts{argnames}eq 'ARRAY'?@{$opts{argnames}}:()];
  $$guts{func_args}=[
  ref$opts{function_args}eq 'ARRAY'
  ?@{$opts{function_args}}
  :'args'
  ];
  if(exists$opts{constructor}){
  $$guts{constructor}=$opts{constructor};
  $$guts{constructor_args}=[ref$opts{constructor_args}eq 'ARRAY'?@{$opts{constructor_args}}:('scope','args')];
  }
  if(exists$opts{name}){
  $$guts{func_name}=$opts{name};
  }
  $self->prop({dontdel=>1,name=>'arguments',value=>$global->null});
  $self;
  }
  sub call_with{
  my$func=shift;
  my$ret=$func->apply($func->global->upgrade(@_));
  typeof$ret eq 'undefined'?undef:$ret
  }
  sub call{
  my$self=shift;
  $self->apply($$$self{global},@_);
  }
  sub construct{
  my$self=shift;
  my$guts=$$self;
  my$global=$$guts{global};
  if(exists$$guts{constructor}
  and ref$$guts{constructor}eq 'CODE')
  {
  my$code=$$guts{constructor};
  my@args;
  for(@{$$guts{constructor_args}}){
  push@args,
     $_ eq 'self'?$self
    :$_ eq 'scope'?_init_scope($self,$$guts{scope},[],@_)
    :$_ eq 'global'?$global
    :$_ eq 'args'?@_
    :$_ eq '[args]'?[@_]
    :undef;
  }
  return$global->upgrade($code->(@args));
  }
  else{
  defined(my$proto=$self->prop('prototype'))
    or die JE::Object::Error::TypeError->new($global,add_line_number+($$guts{func_name}||'The function')." cannot be called as a constructor");
  my$obj=JE::Object->new(
  $global,!$proto->primitive
  ?{prototype=>$proto}
  :()
  );
  my$return=$global->upgrade($self->apply($obj,@_));
  return$return->can('primitive')&&!$return->primitive
    ?$return
    :$obj;
  }
  }
  sub apply{
  my($self,$obj)=(shift,shift);
  my$guts=$$self;
  my$global=$$guts{global};
  if(!blessed$obj
  or ref$obj eq 'JE::Object::Function::Call'
  or ref($obj)=~/^JE::(?:Null|Undefined)\z/)
  {
  $obj=$global;
  }
  if(ref$$guts{function}eq 'CODE'){
  my@args;
  for(@{$$guts{func_args}}){
  push@args,
     $_ eq 'self'?$self
    :$_ eq 'scope'?_init_scope($self,$$guts{scope},$$guts{func_argnames},@_)
    :$_ eq 'global'?$global
    :$_ eq 'this'?$obj
    :$_ eq 'args'?@_
    :$_ eq '[args]'?[@_]
    :undef;
  }
  return$global->upgrade((scalar$$guts{function}->(@args))[0]);
  }
  elsif($$guts{function}){
  my$at=$@;
  my$scope=_init_scope($self,$$guts{scope},$$guts{func_argnames},@_);
  my$time_bomb=bless[$self,$self->prop('arguments')],'JE::Object::Function::_arg_wiper';
  $self->prop('arguments',$$scope[-1]{-arguments});
  my$ret=$$guts{function}->execute($obj->to_object,$scope,2);
  defined$ret or die;
  $@=$at;
  return$ret;
  }
  else{
  if(!defined$global){use Carp;Carp::cluck()}
  return$global->undefined;
  }
  }
  sub JE::Object::Function::_arg_wiper::DESTROY{
  $_[0][0]->prop('arguments',$_[0][1])
  }
  sub _init_scope{
  my($self,$scope,$argnames,@args)=@_;
  bless(
  [
  @$scope,
  JE::Object::Function::Call->new(
  {
  global=>$$$self{global},
  argnames=>$argnames,
  args=>[@args],
  function=>$self,
  }
  )
  ],
  'JE::Scope'
  );
  }
  sub typeof{'function'}
  sub class{'Function'}
  sub value{die"JE::Object::Function::value is not yet implemented."}
  sub _init_proto{
  my$proto=shift;
  my$scope=$$proto->{global};
  $proto->prop(
  {
  dontenum=>1,
  name=>'constructor',
  value=>$scope->prop('Function'),
  }
  );
  $proto->prop(
  {
  name=>'toString',
  value=>JE::Object::Function->new(
  {
  scope=>$scope,
  name=>'toString',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$self=shift;
  $self->isa(__PACKAGE__)or die new JE::Object::Error::TypeError$scope,add_line_number"Function."."prototype.toString can only be "."called on functions";
  my$guts=$$self;
  my$str='function ';
  JE::String->_new(
  $scope,
  'function '
    .(
  exists$$guts{func_name}
  ?$$guts{func_name}
  :'anon'.$self->id
    )
    .'('
    .join(',',@{$$guts{func_argnames}}).") {"
    .(
  ref$$guts{function}eq 'JE::Code'?do{
  my$code=$$guts{function};
  my$offsets=$$guts{function}{tree}[0];
  $code=substr${$$code{source}},$$offsets[0],$$offsets[1]-$$offsets[0];
  $code=~/[\cm\cj\x{2028}\x{2029}]\z/?$code:$code."\n"
    }
  :"\n    // [native code]\n"
    )
    .'}'
  );
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'apply',
  value=>JE::Object::Function->new(
  {
  scope=>$scope,
  name=>'apply',
  argnames=>[qw/thisArg argArray/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($self,$obj,$args)=@_;
  my$at=$@;
  no warnings 'uninitialized';
  if(
  defined$args
  and ref($args)!~/^JE::(Null|Undefined|
  					Object::Function::Arguments)\z/x
  and eval{$args->class}ne 'Array'
    )
  {
  die JE::Object::Error::TypeError->new($scope,add_line_number"Second argument to "."'apply' is of type '".(eval{$args->class}||eval{$args->typeof}||ref$args)."', not 'Arguments' or "."'Array'");
  }
  $@=$at;
  $args=$args->value if defined$args;
  $self->apply($obj,defined$args?@$args:());
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'call',
  value=>JE::Object::Function->new(
  {
  scope=>$scope,
  name=>'call',
  argnames=>['thisArg'],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  shift->apply(@_);
  },
  }
  ),
  dontenum=>1,
  }
  );
  }
  package JE::Object::Function::Call;
  our$VERSION='0.066';
  sub new{
  my($class,$opts)=@_;
  my@args=@{$$opts{args}};
  my(%self,$arg_val);
  for(@{$$opts{argnames}}){
  $arg_val=shift@args;
  $self{-dontdel}{$_}=1;
  $self{$_}=
    defined$arg_val
    ?$arg_val
    :$$opts{global}->undefined;
  }
  $self{-dontdel}{arguments}=1;
  $self{'-global'}=$$opts{global};
  $self{-arguments}=JE::Object::Function::Arguments->new($$opts{global},$$opts{function},\%self,$$opts{argnames},@{$$opts{args}},);
  unless(exists$self{arguments}){
  $self{arguments}=$self{-arguments}
  }
  return bless\%self,$class;
  }
  sub prop{
  my($self,$name)=(shift,shift);
  if(ref$name eq 'HASH'){
  my$opts=$name;
  $name=$$opts{name};
  @_=exists($$opts{value})?$$opts{value}:();
  $$self{'-dontdel'}{$name}=!!$$opts{dontdel}
    if exists$$opts{dontdel};
  }
  if(@_){
  return$$self{$name}=shift;
  }
  if(exists$$self{$name}){
  return$$self{$name};
  }
  return
  }
  sub delete{
  my($self,$varname)=@_;
  unless($_[2]){
  exists$$self{-dontdel}{$varname}
    &&$$self{-dontdel}{$varname}
    &&return!1;
  }
  delete$$self{-dontdel}{$varname};
  delete$$self{$varname};
  return 1;
  }
  sub exists{exists$_[0]{$_[1]}}
  sub prototype{}
  package JE::Object::Function::Arguments;
  our$VERSION='0.066';
  our@ISA='JE::Object';
  sub new{
  my($class,$global,$function,$call,$argnames,@args)=@_;
  my$self=$class->SUPER::new($global);
  my$guts=$$self;
  $$guts{args_call}=$call;
  $self->prop(
  {
  name=>'callee',
  value=>$function,
  dontenum=>1,
  }
  );
  $self->prop(
  {
  name=>'length',
  value=>JE::Number->new($global,scalar@args),
  dontenum=>1,
  }
  );
  $$guts{args_length}=@args;
  my(%seen,$name,$val);
  for(reverse 0..($#args,$#$argnames)[$#$argnames<$#args]){
  ($name,$val)=($$argnames[$_],$args[$_]);
  if($seen{$name}++){
  $self->prop(
  {
  name=>$_,
  value=>$val,
  dontenum=>1,
  }
  );
  }
  else{
  $$guts{args_magic}{$_}=$name;
  }
  }
  for(@$argnames..$#args){
  $self->prop(
  {
  name=>$_,
  value=>$args[$_],
  dontenum=>1,
  }
  );
  }
  $self;
  }
  sub prop{
  my($self,$name)=@_;
  my$guts=$$self;
  if(exists$$guts{args_magic}and exists$$guts{args_magic}{$name}){
  return$$guts{args_call}->prop($$guts{args_magic}{$name},@_[2..$#_]);
  }
  SUPER::prop$self @_[1..$#_];
  }
  sub delete{
  my($self,$name)=@_;
  my$guts=$$self;
  if(exists$$guts{args_magic}and exists$$guts{args_magic}{$name}){
  delete$$guts{args_magic}{$name}
  }
  SUPER::delete$self @_[1..$#_];
  }
  sub value{
  my$self=shift;
  [map$self->prop($_),0..$$$self{args_length}-1];
  }
  1;
JE_OBJECT_FUNCTION

$fatpacked{"JE/Object/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_NUMBER';
  package JE::Object::Number;
  our$VERSION='0.066';
  use strict;
  use warnings;
  use constant inf=>9**9**9;
  our@ISA='JE::Object';
  use Scalar::Util 'blessed';
  require JE::Code;
  require JE::Number;
  require JE::Object;
  require JE::Object::Function;
  require JE::String;
  import JE::Code 'add_line_number';
  sub add_line_number;
  sub new{
  my($class,$global,$val)=@_;
  my$self=$class->SUPER::new(
  $global,
  {
  prototype=>$global->prototype_for('Number')||$global->prop('Number')->prop('prototype')
  }
  );
  $$$self{value}=
    defined blessed$val &&$val->can('to_number')
    ?$val->to_number->[0]
    :JE::Number::_numify($val);
  $self;
  }
  sub value{$${$_[0]}{value}}
  sub class{'Number'}
  our@_digits=(0..9,'a'..'z');
  sub _new_constructor{
  my$global=shift;
  my$f=JE::Object::Function->new(
  {
  name=>'Number',
  scope=>$global,
  argnames=>[qw/value/],
  function=>sub{
  defined$_[0]
    ?$_[0]->to_number
    :JE'Number->new($global,0);
  },
  function_args=>['args'],
  constructor=>sub{
  unshift@_,__PACKAGE__;
  goto&new;
  },
  constructor_args=>['scope','args'],
  }
  );
  $f->prop(
  {
  name=>'MAX_VALUE',
  autoload=>'
  		  require "JE/Object/Number/maxvalue.pl";
  		  $JE::Object::Number::max_finite
  		',
  dontenum=>1,
  dontdel=>1,
  readonly=>1,
  }
  );
  $f->prop(
  {
  name=>'MIN_VALUE',
  autoload=>'
  		  require "JE/Object/Number/maxvalue.pl";
  		  $JE::Object::Number::min_finite
  		',
  dontenum=>1,
  dontdel=>1,
  readonly=>1,
  }
  );
  $f->prop(
  {
  name=>'NaN',
  value=>JE::Number->new($global,'nan'),
  dontenum=>1,
  dontdel=>1,
  readonly=>1,
  }
  );
  $f->prop(
  {
  name=>'NEGATIVE_INFINITY',
  value=>JE::Number->new($global,'-inf'),
  dontenum=>1,
  dontdel=>1,
  readonly=>1,
  }
  );
  $f->prop(
  {
  name=>'POSITIVE_INFINITY',
  value=>JE::Number->new($global,'inf'),
  dontenum=>1,
  dontdel=>1,
  readonly=>1,
  }
  );
  my$proto=bless$f->prop(
  {
  name=>'prototype',
  dontenum=>1,
  readonly=>1,
  }
    ),
    __PACKAGE__;
  $global->prototype_for(Number=>$proto);
  $$$proto{value}=0;
  $proto->prop(
  {
  name=>'toString',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toString',
  argnames=>['radix'],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my$self=shift;
  die JE::Object::Error::TypeError->new($global,add_line_number"Argument to "."Number.prototype.toString is not"." a "."Number object")unless$self->class eq 'Number';
  my$radix=shift;
  !defined$radix||$radix->id eq 'undef'
    and return$self->to_primitive->to_string;
  ($radix=$radix->to_number->value)==10||$radix<2||$radix>36||$radix=~/\./
    and return$self->to_string;
  if($radix==2){
  return JE::String->new($global,sprintf '%b',$self->value);
  }
  elsif($radix==8){
  return JE::String->new($global,sprintf '%o',$self->value);
  }
  elsif($radix==16){
  return JE::String->new($global,sprintf '%x',$self->value);
  }
  my$num=$self->value;
  my$result='';
  while($num>=1){
  substr($result,0,0)=$_digits[$num%$radix];
  $num/=$radix;
  }
  return JE::String->new($global,$result);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'toLocaleString',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toLocaleString',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$self=shift;
  die JE::Object::Error::TypeError->new($global,add_line_number"Argument to "."Number.prototype.toLocaleString "."is not"." a "."Number object")unless$self->class eq 'Number';
  return JE::String->_new($global,$self->value);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'valueOf',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'valueOf',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$self=shift;
  die JE::Object::Error::TypeError->new($global,add_line_number"Argument to "."Number.prototype.valueOf is not"." a "."Number object")unless$self->class eq 'Number';
  return ref$self eq 'JE::Number'
    ?$self
    :JE::Number->new($global,$$$self{value});
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'toFixed',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toFixed',
  no_proto=>1,
  argnames=>['fractionDigits'],
  function_args=>['this','args'],
  function=>sub{
  my$self=shift;
  die JE::Object::Error::TypeError->new($global,add_line_number"Argument to "."Number.prototype.toFixed is not"." a "."Number object")unless$self->class eq 'Number';
  my$places=shift;
  if(defined$places){
  $places=($places=int$places->to_number)==$places&&$places;
  }
  else{$places=0}
  $places<0 and throw JE::Object::Error::RangeError->new($global,"Invalid number of decimal places: $places "."(negative numbers not supported)");
  my$num=$self->value;
  $num==$num or return JE::String->_new($global,'NaN');
  abs$num>=1000000000000000000000
    and return JE::String->_new($global,$num);
  if((my$sprintfed=sprintf"%.".($places+1).'f',$num)=~/5\z/){
  (my$upper=$sprintfed)=~s/\.?.\z//;
  my$lower=$upper;
  ++substr$upper,-1,1;
  return JE::String->_new($global,$upper-$num<=$num-$lower?$upper:$lower);
  }
  return JE::String->_new($global,sprintf"%.${places}f",$num);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'toExponential',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toExponential',
  no_proto=>1,
  argnames=>['fractionDigits'],
  function_args=>['this','args'],
  function=>sub{
  my$self=shift;
  die JE::Object::Error::TypeError->new($global,add_line_number"Argument to "."Number.prototype. toExponential is not"." a "."Number object")unless$self->class eq 'Number';
  my$num=$self->value;
  $num==$num or return JE::String->_new($global,'NaN');
  abs$num==inf&&return JE::String->_new($global,($num<0&&'-').'Infinity');
  my$places=shift;
  if(defined$places){
  $places=0+(($places=int$places->to_number)==$places)&&$places;
  }
  else{$places=!1}
  $places<0 and throw JE::Object::Error::RangeError->new($global,"Invalid number of decimal places: $places "."(negative numbers not supported)");
  if((my$sprintfed=sprintf"%.".($places+1).'e',$num)=~/5e/){
  (my$upper=$sprintfed)=~s/\.?.(e.*)\z//;
  my$lower=$upper;
  ++substr$upper,-1,1;
  (my$ret=($upper-$num<=$num-$lower?$upper:$lower).$1)=~s/\.?0*e([+-])0*(?!\z)/e$1/;
  return JE::String->_new($global,$ret);
  }
  my$result=sprintf"%"."."x!!length($places)."${places}e",$num;
  $result=~s/\.?0*e([+-])0*(?!\z)/e$1/;
  return JE::String->_new($global,$result);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'toPrecision',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toPrecision',
  no_proto=>1,
  argnames=>['precision'],
  function_args=>['this','args'],
  function=>sub{
  my$self=shift;
  die JE::Object::Error::TypeError->new($global,add_line_number"Argument to "."Number.prototype. toPrecision is not"." a "."Number object")unless$self->class eq 'Number';
  my$num=$self->value;
  $num==$num or return JE::String->_new($global,'NaN');
  abs$num==inf&&return JE::String->_new($global,($num<0&&'-').'Infinity');
  my$prec=shift;
  if(!defined$prec||$prec->id eq 'undef'){
  return JE::String->_new($global,$num);
  }
  $prec=($prec=int$prec->to_number)==$prec&&$prec;
  $prec<1 and throw JE::Object::Error::RangeError->new($global,"Precision out of range: $prec "."(must be >= 1)");
  if($num==0){
  $prec==1 or$num='0.'.'0' x($prec-1);
  }
  else{
  $num=sprintf"%.${prec}g",$num;
  my($e)=sprintf"%.0e",$num,=~/e(.*)/;
  if($e<-6||$e>=$prec){
  ($num=sprintf"%.".($prec-1)."e",$num)=~s/(?<=e[+-])0+(?!\z)//;
  $num=~/\./ or$num=~s/e/.e/;
  }
  else{$num=sprintf"%.".($prec-1-$e).'f',$num}
  }
  return JE::String->_new($global,$num);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $f;
  }
  return"a true value";
JE_OBJECT_NUMBER

$fatpacked{"JE/Object/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_STRING';
  package JE::Object::String;
  our$VERSION='0.066';
  use strict;
  use warnings;
  no warnings 'utf8';
  sub surrogify($);
  sub desurrogify($);
  our@ISA='JE::Object';
  use POSIX qw 'floor ceil';
  use Scalar::Util 'blessed';
  require JE::Code;
  require JE::Number;
  require JE::Object;
  require JE::Object::Error::TypeError;
  require JE::Object::Function;
  require JE::String;
  JE::String->import(qw/surrogify desurrogify/);
  JE::Code->import('add_line_number');
  sub add_line_number;
  sub new{
  my($class,$global,$val)=@_;
  my$self=$class->SUPER::new(
  $global,
  {
  prototype=>$global->prototype_for('String')||$global->prop('String')->prop('prototype')
  }
  );
  $$$self{value}=
     defined$val
    ?defined blessed$val &&$val->can('to_string')
    ?$val->to_string->value16
    :surrogify$val
    :'';
  $self;
  }
  sub prop{
  my$self=shift;
  if($_[0]eq 'length'){
  return JE::Number->new($$$self{global},length$$$self{value});
  }
  SUPER::prop$self @_;
  }
  sub delete{
  my$self=shift;
  $_[0]eq 'length' and return!1;
  SUPER::delete$self @_;
  }
  sub value{desurrogify${+shift}->{value}}
  sub value16{${+shift}->{value}}
  sub is_readonly{
  my$self=shift;
  $_[0]eq 'length' and return 1;
  SUPER::is_readonly$self @_;
  }
  sub class{'String'}
  no warnings 'qw';
  our%_replace=qw/
    $	\$
    &	".substr($str,$-[0],$+[0]-$-[0])."
    `	".substr($str,0,$-[0])."
    '	".substr($str,$+[0])."
    /;
  sub _new_constructor{
  my$global=shift;
  my$f=JE::Object::Function->new(
  {
  name=>'String',
  scope=>$global,
  function=>sub{
  my$arg=shift;
  defined$arg
    ?$arg->to_string
    :JE::String->_new($global,'');
  },
  function_args=>['args'],
  argnames=>['value'],
  constructor=>sub{
  unshift@_,__PACKAGE__;
  goto&new;
  },
  constructor_args=>['scope','args'],
  }
  );
  $f->prop(
  {
  name=>'fromCharCode',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'fromCharCode',
  length=>1,
  no_proto=>1,
  function_args=>['args'],
  function=>sub{
  my$str='';
  my$num;
  for(@_){
  $num=$_->to_number->value;
  $num=($num<0?ceil$num :floor$num)%2**16;
  $str.=chr($num==$num&&$num);
  }
  JE::String->_new($global,$str);
  },
  }
  ),
  dontenum=>1,
  }
  );
  my$proto=bless$f->prop(
  {
  name=>'prototype',
  dontenum=>1,
  readonly=>1,
  }
    ),
    __PACKAGE__;
  $$$proto{value}='';
  $global->prototype_for('String',$proto);
  $proto->prop(
  {
  name=>'toString',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toString',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$self=shift;
  die JE::Object::Error::TypeError->new($global,add_line_number"Argument to toString is not a "."String object")unless$self->class eq 'String';
  return$self if ref$self eq 'JE::String';
  JE::String->_new($global,$$$self{value});
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'valueOf',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'valueOf',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$self=shift;
  die JE::Object::Error::TypeError->new($global,add_line_number"Argument to valueOf is not a "."String object")unless$self->class eq 'String';
  ref$self eq 'JE::String'
    ?$self
    :JE::String->_new($global,$$$self{value});
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'charAt',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'charAt',
  argnames=>['pos'],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($self,$pos)=@_;
  my$str=$self->to_string->value16;
  if(defined$pos){
  $pos=int$pos->to_number->[0];
  $pos=0 unless$pos==$pos;
  }
  JE::String->_new(
  $global,$pos<0||$pos>=length$str
  ?''
  :substr$str,$pos,1
  );
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'charCodeAt',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'charCodeAt',
  argnames=>['pos'],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($self,$pos)=@_;
  my$str=$self->to_string->value16;
  if(defined$pos){
  $pos=int$pos->to_number->[0];
  $pos=0 unless$pos==$pos;
  }
  JE::Number->new(
  $global,$pos<0||$pos>=length$str
  ?'nan'
  :ord substr$str,$pos,1
  );
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'concat',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'concat',
  length=>1,
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my$str='';
  for(@_){
  $str.=$_->to_string->value16
  }
  JE::String->_new($global,$str);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'indexOf',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'indexOf',
  length=>1,
  argnames=>[qw/searchString position/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my$str=shift->to_string->value16;
  my$find=
    defined$_[0]
    ?$_[0]->to_string->value16
    :'undefined';
  my$start=
    defined$_[1]
    ?$_[1]->to_number->value
    :0;
  JE::Number->new(
   $global,$start>length$str
  ?length$find
    ?-1
    :length$str
    :index$str,$find,$start
  );
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'lastIndexOf',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'lastIndexOf',
  length=>1,
  argnames=>[qw/searchString position/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my$string=shift->to_string->value16;
  my$pos=length$string;
  if(defined$_[1]&&$_[1]->id ne 'undef'){
  my$p=$_[1]->to_number->value;
  $p<$pos and$pos=$p
  }
  JE::Number->new(
   $global,rindex$string,defined$_[0]
  ?$_[0]->to_string->value16
  :'undefined',$pos
  );
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'localeCompare',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'localeCompare',
  argnames=>[qw/that/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($this,$that)=@_;
  JE::Number->new(
   $global,$this->to_string->value	cmp defined$that
  ?$that->to_string->value
  :'undefined'
  );
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'match',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'match',
  argnames=>[qw/regexp/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($str,$re_obj)=@_;
  $str=$str->to_string;
  !defined$re_obj||(eval{$re_obj->class}||'')ne 'RegExp'
    and do{
  require JE::Object::RegExp;
  $re_obj=JE::Object::RegExp->new($global,$re_obj);
    };
  my$re=$re_obj->value;
  if(not$re_obj->prop('global')->value){
  return$global->prototype_for('RegExp')->prop('exec')->apply($re_obj,$str);
  }
  $str=$str->value16;
  my@ary;
  while($str=~/$re/g){
  push@ary,JE::String->_new($global,substr$str,$-[0],$+[0]-$-[0]);
  }
  JE::Object::Array->new($global,\@ary);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'replace',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'replace',
  argnames=>[qw/searchValue replaceValue/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($str,$foo,$bar)=@_;
  $str=$str->to_string->value16;
  my$g;
  if(defined$foo
  &&$foo->can('class')
  &&$foo->class eq 'RegExp')
  {
  $g=$foo->prop('global')->value;
  $foo=$$$foo{value};
  }
  else{
  $g=!1;
  $foo=
    defined$foo
    ?quotemeta$foo->to_string->value16
    :'undefined';
  }
  if(defined$bar
  &&$bar->can('class')
  &&$bar->class eq 'Function')
  {
  my$replace=sub{
  $global->prototype_for('RegExp')->prop('constructor')->capture_re_vars($str);
  $_[0]->call(JE::String->_new($global,substr$str,$-[0],$+[0]-$-[0]),map(JE::String->_new($global,$JE'Object'RegExp'Match[$_]),1..$#+),JE::Number->new($global,$-[0]),$_[1])->to_string->value16
  };
  my$je_str=JE::String->_new($global,$str);
  $g
    ?$str=~s/$foo/
  					    &$replace($bar, $je_str)
  					/ge
    :$str=~s/$foo/
  					    &$replace($bar, $je_str)
  					/e
  }
  else{
  $bar=defined$bar
    ?do{
  $bar->to_string->value16=~/(.*)/s;
  quotemeta$1
    }
    :'undefined';
  $bar=~s/\\\$(?:
  						\\([\$&`'])
  						  |
  						([1-9][0-9]?|0[0-9])
  					)/
  						defined $1 ? $_replace{$1}
  						: "\$JE::Object::RegExp::"
  						. "Match[$2]";
  					/gex;
  my$orig_str=$str;
  no warnings 'uninitialized';
  $g
    ?$str=~s/$foo/qq'"$bar"'/gee
    :$str=~s/$foo/qq'"$bar"'/ee
    and$global->prototype_for('RegExp')->prop('constructor')->capture_re_vars($orig_str);
  }
  JE::String->_new($global,$str);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'search',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'search',
  argnames=>[qw/regexp/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($str,$re)=@_;
  $re=
     defined$re
    ?(eval{$re->class}||'')eq 'RegExp'
    ?$re->value
    :do{
    require JE::Object::RegExp;
    JE::Object::RegExp->new($global,$re)->value
  }
    :qr//;
  return JE::Number->new(
  $global,($str=$str->to_string->value16)=~$re
  ?scalar($global->prototype_for('RegExp')->prop('constructor')->capture_re_vars($str),$-[0])
  :-1
  );
  }
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'slice',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'slice',
  argnames=>[qw/start end/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($str,$start,$end)=@_;
  $str=$str->to_string->value16;
  my$length=length$str;
  if(defined$start){
  $start=int$start->to_number->value;
  $start=$start==$start&&$start;
  $start>=$length and return JE::String->_new($global,'');
  }
  else{$start=0;}
  if(defined$end&&$end->id ne 'undef'){
  $end=int$end->to_number->value;
  $end=$end==$end&&$end;
  $end>0 and$end-=$start+$length*($start<0);
  }
  else{$end=$length}
  return  JE::String->_new($global,substr$str,$start,$end);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'split',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'split',
  argnames=>[qw/separator limit/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($str,$sep,$limit)=@_;
  $str=(my$je_str=$str->to_string)->value16;
  if(!defined$limit
  ||$limit->id eq 'undef')
  {
  $limit=-2;
  }
  elsif(defined$limit){
  $limit=int($limit->to_number->value)%2**32;
  $limit=$limit==$limit&&$limit;
  }
  if(defined$sep){
  if($sep->can('class')
  &&$sep->class eq 'RegExp')
  {
  $sep=$sep->value;
  }
  elsif($sep->id eq 'undef'){
  return JE::Object::Array->new($global,$je_str);
  }
  else{
  $sep=$sep->to_string->value16;
  }
  }
  else{
  return JE::Object::Array->new($global,$je_str);
  }
  my@split;
  if(!ref$sep){
  $sep=
    length$sep
    ?quotemeta$sep
    :qr/(?!\z)/;
  @split=split$sep,$str,$limit+1;
  goto returne;
  }
  !length$str
    and ''=~$sep||(@split=''),
    goto returne;
  my$pos=0;
  while($str=~/$sep/gc){
  $pos==pos$str and ++pos$str,next;
  $-[0]==length$str and last;
  push@split,substr($str,$pos,$-[0]-$pos),@JE::Object::RegExp::Match[1..$#JE::Object::RegExp::Match];
  $pos=pos$str=pos$str;
  }
  push@split,substr($str,$pos);
  returne:
  JE::Object::Array->new($global,$limit==-2?@split:@split?@split[0..(@split>$limit?$limit-1:$#split)]:@split);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'substring',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'substring',
  argnames=>[qw/start end/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($str,$start,$end)=@_;
  $str=$str->to_string->value16;
  my$length=length$str;
  if(defined$start){
  $start=int$start->to_number->value;
  $start>=0 or$start=0;
  }
  else{$start=0;}
  if(!defined$end||$end->id eq 'undef'){
  $end=$length;
  }
  else{
  $end=int$end->to_number->value;
  $end>=0 or$end=0;
  }
  $start>$end and($start,$end)=($end,$start);
  no warnings 'substr';
  my$x=substr$str,$start,$end-$start;
  return  JE::String->_new($global,defined$x?$x:'');
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'toLowerCase',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toLowerCase',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$str=shift;
  JE::String->_new($global,lc$str->to_string->value16);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'toLocaleLowerCase',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toLocaleLowerCase',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$str=shift;
  JE::String->_new($global,lc$str->to_string->value);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'toUpperCase',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toUpperCase',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$str=shift;
  JE::String->_new($global,uc$str->to_string->value16);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'toLocaleUpperCase',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'toLocaleUpperCase',
  no_proto=>1,
  function_args=>['this'],
  function=>sub{
  my$str=shift;
  JE::String->_new($global,uc$str->to_string->value);
  },
  }
  ),
  dontenum=>1,
  }
  );
  $proto->prop(
  {
  name=>'substr',
  value=>JE::Object::Function->new(
  {
  scope=>$global,
  name=>'substr',
  argnames=>[qw/start length/],
  no_proto=>1,
  function_args=>['this','args'],
  function=>sub{
  my($str,$start,$len)=@_;
  $str=$str->to_string->value16;
  if(defined$start){
  $start=int$start->to_number->value;
  }
  else{$start=0;}
  if(!defined$len||$len->id eq 'undef'){
  $len=undef;
  }
  else{
  $len=int$len->to_number->value;
  }
  return  JE::String->_new(
  $global,defined$len
  ?(substr$str,$start,$len)
  :(substr$str,$start)
  );
  },
  }
  ),
  dontenum=>1,
  }
  );
  $f;
  }
  return"a true value";
JE_OBJECT_STRING

$fatpacked{"JE/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_PARSER';
  package JE::Parser;
  our$VERSION='0.066';
  use strict;
  use warnings;
  no warnings 'utf8';
  use Scalar::Util 'blessed';
  require JE::Code;
  require JE::Number;
  import JE::Code 'add_line_number';
  sub add_line_number;
  our($_parser,$global,@_decls,@_stms,$_vars);
  sub new{
  my%self=(
  stm_names=>[
  qw[
    -function block empty if while with for switch try
    labelled var do continue break return throw expr
    ]
  ],
  stm=>{
  -function=>\&function,
  block=>\&block,
  empty=>\&empty,
  if=>\&if,
  while=>\&while,
  with=>\&with,
  for=>\&for,
  switch=>\&switch,
  try=>\&try,
  labelled=>\&labelled,
  var=>\&var,
  do=>\&do,
  continue=>\&continue,
  break=>\&break,
  return=>\&return,
  throw=>\&throw,
  expr=>\&expr_statement,
  },
  global=>pop,
  );
  return bless\%self,shift;
  }
  sub add_statement{
  my($self,$name,$parser)=shift;
  my$in_list;
  grep$_ eq$name&& ++$in_list&&goto END_GREP,@{$$self{stm_names}};
  END_GREP:
  $in_list or unshift@{$$self{stm_names}},$name;
  $$self{stm}{$name}=$parser;
  return;
  }
  sub delete_statement{
  my$self=shift;
  for my $name(@_){
  delete$$self{stm}{$name};
  @{$$self{stm_names}}=
    grep$_ ne$name,@{$$self{stm_names}};
  }
  return$self;
  }
  sub statement_list{
  $_[0]{stm_names};
  }
  sub parse{
  local$_parser=shift;
  local(@_decls,@_stms);
  for(@{$_parser->{stm_names}}){
  push@{/^-/?\@_decls:\@_stms},$_parser->{stm}{$_};
  }
  JE::Code::parse($_parser->{global},@_);
  }
  sub eval{
  shift->parse(@_)->execute
  }
  use Exporter 5.57 'import';
  our@EXPORT_OK=qw/ $h $n $optional_sc $ss $s $S $id_cont
    str num skip ident expr expr_noin statement
    statements expected optional_sc/;
  our@EXPORT_TAGS=(
  vars=>[qw/ $h $n $optional_sc $ss $s $S $id_cont/],
  functions=>[
  qw/ str num skip ident expr expr_noin statement
    statements expected optional_sc /
  ],
  );
  use re 'taint';
  use constant JECE=>'JE::Code::Expression';
  use constant JECS=>'JE::Code::Statement';
  require JE::String;
  import JE::String 'desurrogify';
  import JE::String 'surrogify';
  sub desurrogify($);
  sub surrogify($);
  sub expected($){
  die\shift
  }
  our$h=qr(
  	(?> [ \t\x0b\f\xa0\p{Zs}]* ) 
  	(?> (?>/\*[^\cm\cj\x{2028}\x{2029}]*?\*/) [ \t\x0b\f\xa0\p{Zs}]* )?
  )x;
  our$n=qr((?>[\cm\cj\x{2028}\x{2029}]));
  our$ss=qr((?>[\p{Zs}\s\ck\x{2028}\x{2029}]));
  our$s=qr((?>
  	(?> $ss* )
  	(?> (?> //[^\cm\cj\x{2028}\x{2029}]* (?>$n|\z) | /\*.*?\*/ )
  	    (?> $ss* )
  	) *
  ))sx;
  our$S=qr(
  	(?>
  	  $ss
  	    |
  	  //[^\cm\cj\x{2028}\x{2029}]*
  	    |
  	  /\*.*?\*/
  	)
  	$s
  )xs;
  our$id_cont=qr(
  	(?>
  	  \\u([0-9A-Fa-f]{4})
  	    |
  	  [\p{ID_Continue}\$_]
  	)
  )x;
  sub str(){
  use constant old_perl=>$]<5.01;
  my$yarn;
  if(old_perl){
  my$qt=substr($_,pos($_),1);
  $qt=~/['"]/ or return;
  pos($_)++;
  my$done=0;
  while(defined(substr($_,pos($_),1))){
  my($part)=/\G([^\\$qt]*)/xcgs;
  defined($part)or$part="";
  $yarn.=$part;
  my$next=substr($_,pos($_)++,1);
  if($next eq"\\"){
  $next=substr($_,pos($_)++,1);
  $yarn.="\\$next";
  }
  else{
  $done=1;
  last;
  }
  }
  return if!$done;
  }
  else{
  /\G (?: '([^'\\]*(?:\\.[^'\\]*)*)'
  		          |
  		        "([^"\\]*(?:\\.[^"\\]*)*)"  )/xcgs or return;
  $yarn=$+;
  }
  BEGIN{no strict;delete${__PACKAGE__.'::'}{old_perl};}
  no re 'taint';
  $yarn=~s/\\(?:
  		u([0-9a-fA-F]{4})
  		 |
  		x([0-9a-fA-F]{2})
  		 |
                  (\r\n?|[\n\x{2028}\x{2029}])
  		 |
  		([bfnrt])
  		 |
  		(v)
  		 |
  		([0-3][0-7]{0,2}|[4-7][0-7]?) # actually slightly looser
  		 |                    # than what ECMAScript v3 has in its
  		(.)           # addendum (it forbids \0 when followed by 8)
  	)/
  		$1 ? chr(hex $1) :
  		$2 ? chr(hex $2) :
                  $3 ? "" :               # escaped line feed disappears
  		$4 ? eval "qq-\\$4-" :
  		$5 ? "\cK" :
  		defined $6 ? chr oct $6 :
  		$7
  	/sgex;
  "s$yarn";
  }
  sub num(){
  /\G (?:
  	  0[Xx] ([A-Fa-f0-9]+)
  	    |
  	  0 ([01234567]+)
  	    |
  	  (?=[0-9]|\.[0-9])
  	  (
  	    (?:0|[1-9][0-9]*)?
  	    (?:\.[0-9]*)?
  	    (?:[Ee][+-]?[0-9]+)?
  	  )
  	) /xcg
    or return;
  return defined$1?hex$1:defined$2?oct$2:$3;
  }
  our$ident=qr(
            (?! (?: case | default )  (?!$id_cont) )
  	  (?:
  	    \\u[0-9A-Fa-f]{4}
  	      |
  	    [\p{ID_Start}\$_]
  	  )
  	  (?> $id_cont* )
  )x;
  sub unescape_ident($){
  my$ident=shift;
  $ident=~s/\\u([0-9a-fA-F]{4})/chr hex $1/ge;
  $ident=desurrogify$ident;
  $ident=~/^[\p{ID_Start}\$_]
  	            [\p{ID_Continue}\$_]*
  	          \z/x
    or die\\"'$ident' is not a valid identifier";
  $ident;
  }
  sub skip(){/\G$s/g}
  sub ident(){
  return unless my($ident)=/\G($ident)/cgox;
  unescape_ident$ident;
  }
  sub params(){
  my@ret;
  /\G\(/gc or expected"'('";
  &skip;
  if(@ret!=push@ret,&ident){
  while(/\G$s,$s/gc){
  @ret!=push@ret,&ident or expected 'identifier';
  }
  &skip;
  }
  /\G\)/gc or expected"')'";
  \@ret;
  }
  sub term(){
  my$pos=pos;
  my$tmp;
  if(/\Gfunction(?!$id_cont)$s/cg){
  my@ret=(func=>ident);
  @ret==2 and&skip;
  push@ret,&params;
  &skip;
  /\G \{ /gcx or expected"'{'";
  {
  local$_vars=[];
  push@ret,&statements,$_vars;
  }
  /\G \} /gocx or expected"'}'";
  return bless[[$pos,pos],@ret],JECE;
  }
  elsif(($tmp)=/\G($ident)/cgox){
  $tmp=~/^(?:(?:tru|fals)e|null)\z/&&return$global->$tmp;
  $tmp eq 'this' and return$tmp;
  return"i".unescape_ident$tmp;
  }
  elsif(defined($tmp=&str)
  or defined($tmp=&num))
  {
  return$tmp;
  }
  elsif(
  m-\G
  		/
  		( (?:[^/*\\[] | \\. | \[ (?>(?:[^]\\] | \\.)*) \] )
  		  (?>(?:[^/\\[] | \\. | \[ (?>(?:[^]\\] | \\.)*) \] )*) )
  		/
  	  	($id_cont*)
  	      -cogx
    )
  {
  {local*_;require JE::Object::RegExp;}
  return JE::Object::RegExp->new($global,$1,$2);
  }
  elsif(/\G\[$s/cg){
  my$anon;
  my@ret;
  my$length;
  while(){
  @ret!=($length=push@ret,&assign)and&skip;
  push@ret,bless\$anon,'comma' while/\G,$s/cg;
  $length==@ret and last;
  }
  /\G]/cg or expected"']'";
  return bless[[$pos,pos],array=>@ret],JECE;
  }
  elsif(/\G\{$s/cg){
  my@ret;
  if($tmp=
     &ident
  or defined($tmp=&str)&&$tmp=~s/^s//
  or defined($tmp=&num))
  {
  push@ret,$tmp;
  &skip;
  /\G:$s/cggg or expected 'colon';
  @ret!=push@ret,&assign
    or expected\'expression';
  &skip;
  while(/\G,$s/cg){
  $tmp=
       ident
    or defined($tmp=&str)&&$tmp=~s/^s//
    or defined($tmp=&num)
    or do{
  /\G}/cg or expected"'}', identifier, or string or "." number literal";
  return bless[[$pos,pos],hash=>@ret],JECE;
    };
  push@ret,$tmp;
  &skip;
  /\G:$s/cggg or expected 'colon';
  @ret!=push@ret,&assign
    or expected 'expression';
  &skip;
  }
  }
  /\G}/cg or expected"'}'";
  return bless[[$pos,pos],hash=>@ret],JECE;
  }
  elsif(/\G\($s/cg){
  my$ret=&expr or expected 'expression';
  &skip;
  /\G\)/cg or expected"')'";
  return$ret;
  }
  return
  }
  sub subscript(){
  my$pos=pos;
  my$subscript;
  if(/\G$s\[$s/cg){
  $subscript=&expr or expected 'expression';
  &skip;
  /\G]/cog or expected"']'";
  }
  elsif(/\G$s\.$s/cg){
  $subscript=&ident or expected 'identifier';
  }
  else{return}
  return bless[[$pos,pos],$subscript],'JE::Code::Subscript';
  }
  sub args(){
  my$pos=pos;
  my@ret;
  /\G$s\($s/gc or return;
  if(@ret!=push@ret,&assign){
  while(/\G$s,$s/gc){
  @ret!=push@ret,&assign
    or expected 'expression';
  }
  &skip;
  }
  /\G\)/gc or expected"')'";
  return bless[[$pos,pos],@ret],'JE::Code::Arguments';
  }
  sub new_expr(){
  /\G new(?!$id_cont) $s /cgx or return;
  my$ret=bless[[pos],'new'],JECE;
  my$pos=pos;
  my@member_expr=
      &new_expr
    ||&term
    ||expected"identifier, literal, 'new' or '('";
  0 while@member_expr!=push@member_expr,&subscript;
  push@$ret,@member_expr==1
    ?@member_expr
    :bless[[$pos,pos],'member/call',@member_expr],
    JECE;
  push@$ret,args;
  $ret;
  }
  sub left_expr(){
  my($pos,@ret)=pos;
  @ret!=push@ret,&new_expr||&term or return;
  0 while@ret!=push@ret,&subscript,&args;
  @ret
    ?@ret==1
    ?@ret
    :bless([[$pos,pos],'member/call',@ret],JECE)
    :return;
  }
  sub postfix(){
  my($pos,@ret)=pos;
  @ret!=push@ret,&left_expr or return;
  push@ret,$1 while/\G $h ( \+\+ | -- ) /cogx;
  @ret==1?@ret:bless[[$pos,pos],'postfix',@ret],JECE;
  }
  sub unary(){
  my($pos,@ret)=pos;
  push@ret,$1 while/\G $s (
  	    (?: delete | void | typeof )(?!$id_cont)
  	      |
  	    \+\+? | --? | ~ | !
  	) $s /cgx;
  @ret!=push@ret,
    &postfix
    or(
  @ret
  ?expected"expression"
  :return
    );
  @ret==1?@ret:bless[[$pos,pos],'prefix',@ret],JECE;
  }
  sub multi(){
  my($pos,@ret)=pos;
  @ret!=push@ret,&unary or return;
  while(m-\G $s ( [*%](?!=) | / (?![*/=]) ) $s -cgx){
  push@ret,$1;
  @ret==push@ret,&unary and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub add(){
  my($pos,@ret)=pos;
  @ret!=push@ret,&multi or return;
  while(/\G $s ( \+(?![+=]) | -(?![-=]) ) $s /cgx){
  push@ret,$1;
  @ret==push@ret,&multi and expected 'expression'
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub bitshift(){
  my($pos,@ret)=pos;
  @ret==push@ret,&add and return;
  while(/\G $s (>>> | >>(?!>) | <<)(?!=) $s /cgx){
  push@ret,$1;
  @ret==push@ret,&add and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub rel(){
  my($pos,@ret)=pos;
  @ret==push@ret,&bitshift and return;
  while(
  /\G $s ( ([<>])(?!\2|=) | [<>]= |
  	               in(?:stanceof)?(?!$id_cont) ) $s /cgx
    )
  {
  push@ret,$1;
  @ret==push@ret,&bitshift and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub rel_noin(){
  my($pos,@ret)=pos;
  @ret==push@ret,&bitshift and return;
  while(
  /\G $s ( ([<>])(?!\2|=) | [<>]= | instanceof(?!$id_cont) )
  	          $s /cgx
    )
  {
  push@ret,$1;
  @ret==push@ret,&bitshift and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub equal(){
  my($pos,@ret)=pos;
  @ret==push@ret,&rel and return;
  while(/\G $s ([!=]==?) $s /cgx){
  push@ret,$1;
  @ret==push@ret,&rel and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub equal_noin(){
  my($pos,@ret)=pos;
  @ret==push@ret,&rel_noin and return;
  while(/\G $s ([!=]==?) $s /cgx){
  push@ret,$1;
  @ret==push@ret,&rel_noin and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub bit_and(){
  my($pos,@ret)=pos;
  @ret==push@ret,&equal and return;
  while(/\G $s &(?![&=]) $s /cgx){
  @ret==push@ret,'&',&equal and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub bit_and_noin(){
  my($pos,@ret)=pos;
  @ret==push@ret,&equal_noin and return;
  while(/\G $s &(?![&=]) $s /cgx){
  @ret==push@ret,'&',&equal_noin
    and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub bit_or(){
  my($pos,@ret)=pos;
  @ret==push@ret,&bit_and and return;
  while(/\G $s \|(?![|=]) $s /cgx){
  @ret==push@ret,'|',&bit_and and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub bit_or_noin(){
  my($pos,@ret)=pos;
  @ret==push@ret,&bit_and_noin and return;
  while(/\G $s \|(?![|=]) $s /cgx){
  @ret==push@ret,'|',&bit_and_noin
    and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub bit_xor(){
  my($pos,@ret)=pos;
  @ret==push@ret,&bit_or and return;
  while(/\G $s \^(?!=) $s /cgx){
  @ret==push@ret,'^',&bit_or and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub bit_xor_noin(){
  my($pos,@ret)=pos;
  @ret==push@ret,&bit_or_noin and return;
  while(/\G $s \^(?!=) $s /cgx){
  @ret==push@ret,'^',&bit_or_noin
    and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub and_expr(){
  my($pos,@ret)=pos;
  @ret==push@ret,&bit_xor and return;
  while(/\G $s && $s /cgx){
  @ret==push@ret,'&&',&bit_xor
    and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub and_noin(){
  my($pos,@ret)=pos;
  @ret==push@ret,&bit_xor_noin and return;
  while(/\G $s && $s /cgx){
  @ret==push@ret,'&&',&bit_xor_noin
    and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub or_expr(){
  my($pos,@ret)=pos;
  @ret==push@ret,&and_expr and return;
  while(/\G $s \|\| $s /cgx){
  @ret==push@ret,'||',&and_expr
    and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub or_noin(){
  my($pos,@ret)=pos;
  @ret==push@ret,&and_noin and return;
  while(/\G $s \|\| $s /cgx){
  @ret==push@ret,'||',&and_noin
    and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'lassoc',@ret],JECE;
  }
  sub assign(){
  my($pos,@ret)=pos;
  @ret==push@ret,&or_expr and return;
  while(m@\G $s ((?>(?: [-*/%+&^|] | << | >>>? )?)=) $s @cgx){
  push@ret,$1;
  @ret==push@ret,&or_expr and expected 'expression';
  }
  if(/\G$s\?$s/cg){
  @ret==push@ret,&assign and expected 'expression';
  &skip;
  /\G:$s/cg or expected"colon";
  @ret==push@ret,&assign and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'assign',@ret],JECE;
  }
  sub assign_noin(){
  my($pos,@ret)=pos;
  @ret==push@ret,&or_noin and return;
  while(m~\G $s ((?>(?: [-*/%+&^|] | << | >>>? )?)=) $s ~cgx){
  push@ret,$1;
  @ret==push@ret,&or_noin and expected 'expression';
  }
  if(/\G$s\?$s/cg){
  @ret==push@ret,&assign and expected 'expression';
  &skip;
  /\G:$s/cg or expected"colon";
  @ret==push@ret,&assign_noin and expected 'expression';
  }
  @ret==1?@ret:bless[[$pos,pos],'assign',@ret],JECE;
  }
  sub expr(){
  my$ret=bless[[pos],'expr'],JECE;
  @$ret==push@$ret,&assign and return;
  while(/\G$s,$s/cg){
  @$ret==push@$ret,&assign and expected 'expression';
  }
  push@{$$ret[0]},pos;
  $ret;
  }
  sub expr_noin(){
  my$ret=bless[[pos],'expr'],JECE;
  @$ret==push@$ret,&assign_noin and return;
  while(/\G$s,$s/cg){
  @$ret==push@$ret,&assign_noin
    and expected 'expression';
  }
  push@{$$ret[0]},pos;
  $ret;
  }
  sub vardecl(){
  my@ret;
  @ret==push@ret,&ident and expected 'identifier';
  /\G$s=$s/cg
    and(@ret!=push@ret,&assign or expected 'expression');
  push@$_vars,$ret[0];
  \@ret;
  }
  sub vardecl_noin(){
  my@ret;
  @ret==push@ret,&ident and expected 'identifier';
  /\G$s=$s/cg
    and(@ret!=push@ret,&assign_noin or expected 'expression');
  push@$_vars,$ret[0];
  \@ret;
  }
  sub finish_for_sc_sc(){
  my@ret;
  my$msg;
  if(@ret!=push@ret,expr){
  $msg='';
  &skip
  }
  else{
  push@ret,'empty';
  $msg='expression or '
  }
  /\G;$s/cg or expected"${msg}semicolon";
  if(@ret!=push@ret,expr){
  $msg='';
  &skip
  }
  else{
  push@ret,'empty';
  $msg='expression or '
  }
  /\G\)$s/cg or expected"${msg}')'";
  @ret;
  }
  our$optional_sc=qr-\G (?:
  		    $s (?: \z | ; $s | (?=\}) )
  		      |
  
  		    # optional horizontal whitespace
  		    # then a line terminator or a comment containing one
  		    # then optional trailing whitespace
  		    $h
  		    (?: $n | //[^\cm\cj\x{2028}\x{2029}]* $n |
  		        /\* [^*\cm\cj\x{2028}\x{2029}]* 
  			    (?: \*(?!/) [^*\cm\cj\x{2028}\x{2029}] )*
  			  $n
  		          (?s:.)*?
  		        \*/
  		    )
  		    $s
  		)-x;
  sub optional_sc(){
  /$optional_sc/gc or expected"semicolon, '}' or end of line";
  }
  sub block(){
  /\G\{/gc or return;
  my$ret=[[pos()-1],'statements'];
  &skip;
  while(){
  @$ret==push@$ret,&statement and last;
  }
  expected"'}'" unless/\G\}$s/gc;
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub empty(){
  my$pos=pos;
  /\G;$s/cg or return;
  bless[[$pos,pos],'empty'],JECS;
  }
  sub function(){
  my$pos=pos;
  /\Gfunction$S/cg or return;
  my$ret=[[$pos],'function'];
  @$ret==push@$ret,&ident
    and expected"identifier";
  &skip;
  push@$ret,&params;
  &skip;
  /\G \{ /gcx or expected"'{'";
  {
  local$_vars=[];
  push@$ret,&statements,$_vars;
  }
  /\G \}$s /gcx or expected"'}'";
  push@{$$ret[0]},pos;
  push@$_vars,$ret;
  bless$ret,JECS;
  }
  sub if(){
  my$pos=pos;
  /\Gif$s\($s/cg or return;
  my$ret=[[$pos],'if'];
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G\)$s/gc or expected"')'";
  @$ret!=push@$ret,&statement
    or expected 'statement';
  if(/\Gelse(?!$id_cont)$s/cg){
  @$ret==push@$ret,&statement
    and expected 'statement';
  }
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub while(){
  my$pos=pos;
  /\Gwhile$s\($s/cg or return;
  my$ret=[[$pos],'while'];
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G\)$s/gc or expected"')'";
  @$ret!=push@$ret,&statement
    or expected 'statement';
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub for(){
  my$pos=pos;
  /\Gfor$s\($s/cg or return;
  my$ret=[[$pos],'for'];
  if(/\G var$S/cgx){
  push@$ret,my$var=bless[[pos()-length$1],'var'],'JE::Code::Statement';
  push@$var,&vardecl_noin;
  &skip;
  if(/\G([;,])$s/gc){
  if($1 eq ','){
  do{
  @$var==push@$var,&vardecl
    and expected 'identifier'
  }while(/\G$s,$s/gc);
  &skip;
  /\G;$s/cg
    or expected 'semicolon';
  }
  push@$ret,&finish_for_sc_sc;
  }
  else{
  /\Gin$s/cg or expected"'in', comma or semicolon";
  push@$ret,'in';
  @$ret==push@$ret,&expr
    and expected 'expresssion';
  &skip;
  /\G\)$s/cg or expected"')'";
  }
  }
  elsif(@$ret!=push@$ret,&expr_noin){
  &skip;
  if(/\G;$s/gc){
  push@$ret,&finish_for_sc_sc;
  }
  else{
  /\Gin$s/cg or expected"'in' or semicolon";
  push@$ret,'in';
  @$ret==push@$ret,&expr
    and expected 'expresssion';
  &skip;
  /\G\)$s/cg or expected"')'";
  }
  }
  else{
  push@$ret,'empty';
  /\G;$s/cg
    or expected 'expression or semicolon';
  push@$ret,&finish_for_sc_sc;
  }
  @$ret!=push@$ret,&statement
    or expected 'statement';
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub with(){
  my$pos=pos;
  /\Gwith$s\($s/cg or return;
  my$ret=[[$pos],'with'];
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G\)$s/gc or expected"')'";
  @$ret!=push@$ret,&statement
    or expected 'statement';
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub switch(){
  my$pos=pos;
  /\Gswitch$s\($s/cg or return;
  my$ret=[[$pos],'switch'];
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G\)$s/gc or expected"')'";
  /\G\{$s/gc or expected"'{'";
  while(/\G case(?!$id_cont) $s/cgx){
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G:$s/cg or expected 'colon';
  push@$ret,&statements;
  }
  my$default=0;
  if(/\G default(?!$id_cont) $s/cgx){
  /\G : $s /cgx or expected 'colon';
  push@$ret,default=>&statements;
  ++$default;
  }
  while(/\G case(?!$id_cont) $s/cgx){
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G:$s/cg or expected 'colon';
  push@$ret,&statements;
  }
  /\G \} $s /cgx or expected(
  $default
  ?"'}' or 'case'"
  :"'}', 'case' or 'default'"
  );
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub try(){
  my$pos=pos;
  /\Gtry$s\{$s/cg or return;
  my$ret=[[$pos],'try',&statements];
  /\G \} $s /cgx or expected"'}'";
  $pos=pos;
  if(/\Gcatch$s/cg){
  /\G \( $s /cgx or expected"'('";
  @$ret==push@$ret,&ident
    and expected 'identifier';
  &skip;
  /\G \) $s /cgx or expected"')'";
  /\G \{ $s /cgx or expected"'{'";
  push@$ret,&statements;
  /\G \} $s /cgx or expected"'}'";
  }
  if(/\Gfinally$s/cg){
  /\G \{ $s /cgx or expected"'{'";
  push@$ret,&statements;
  /\G \} $s /cgx or expected"'}'";
  }
  pos eq$pos and expected"'catch' or 'finally'";
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub labelled(){
  my$pos=pos;
  /\G ($ident) $s : $s/cgx or return;
  my$ret=[[$pos],'labelled',unescape_ident$1];
  while(/\G($ident)$s:$s/cg){
  push@$ret,unescape_ident$1;
  }
  @$ret!=push@$ret,&statement
    or expected 'statement';
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub var(){
  my$pos=pos;
  /\G var $S/cgx or return;
  my$ret=[[$pos],'var'];
  do{
  push@$ret,&vardecl;
  }while(/\G$s,$s/gc);
  optional_sc;
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub do(){
  my$pos=pos;
  /\G do(?!$id_cont)$s/cgx or return;
  my$ret=[[$pos],'do'];
  @$ret!=push@$ret,&statement
    or expected 'statement';
  /\Gwhile$s/cg               or expected"'while'";
  /\G\($s/cg                or expected"'('";
  @$ret!=push@$ret,&expr
    or expected 'expression';
  &skip;
  /\G\)/cog or expected"')'";
  optional_sc;
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub continue(){
  my$pos=pos;
  /\G continue(?!$id_cont)/cogx or return;
  my$ret=[[$pos],'continue'];
  /\G$h($ident)/cog
    and push@$ret,unescape_ident$1;
  optional_sc;
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub break(){
  my$pos=pos;
  /\G break(?!$id_cont)/cogx or return;
  my$ret=[[$pos],'break'];
  /\G$h($ident)/cog
    and push@$ret,unescape_ident$1;
  optional_sc;
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub return(){
  my$pos=pos;
  /\G return(?!$id_cont)/cogx or return;
  my$ret=[[$pos],'return'];
  $pos=pos;
  /\G$h/g;
  @$ret==push@$ret,&expr and pos=$pos;
  optional_sc;
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub throw(){
  my$pos=pos;
  /\G throw(?!$id_cont)/cogx
    or return;
  my$ret=[[$pos],'throw'];
  /\G$h/g;
  @$ret==push@$ret,&expr and expected 'expression';
  optional_sc;
  push@{$$ret[0]},pos;
  bless$ret,JECS;
  }
  sub expr_statement(){
  my$ret=&expr or return;
  optional_sc;
  $ret;
  }
  sub statement_default(){
  my$ret=[[pos]];
  if(
  /\G (?:
  		( \{ | ; )
  		  |
  		(function)$S
  		  |
  		( if | w(?:hile|ith) | for | switch ) $s \( $s
  		  |
  		( try $s \{ $s )
  		  |
  		($ident) $s : $s
  	   ) /xgc
    )
  {
  no warnings 'uninitialized';
  if($1 eq '{'){
  push@$ret,'statements';
  &skip;
  while(){
  @$ret==push@$ret,&statement_default and last;
  }
  expected"'}'" unless/\G\}$s/gc;
  }
  elsif($1 eq ';'){
  push@$ret,'empty';
  &skip;
  }
  elsif($2){
  push@$ret,'function';
  @$ret==push@$ret,&ident
    and expected"identifier";
  &skip;
  push@$ret,&params;
  &skip;
  /\G \{ /gcx or expected"'{'";
  {
  local$_vars=[];
  push@$ret,&statements,$_vars;
  }
  /\G \}$s /gcx or expected"'}'";
  push@$_vars,$ret;
  }
  elsif($3 eq 'if'){
  push@$ret,'if';
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G\)$s/gc or expected"')'";
  @$ret!=push@$ret,&statement_default
    or expected 'statement';
  if(/\Gelse(?!$id_cont)$s/cg){
  @$ret==push@$ret,&statement_default
    and expected 'statement';
  }
  }
  elsif($3 eq 'while'){
  push@$ret,'while';
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G\)$s/gc or expected"')'";
  @$ret!=push@$ret,&statement_default
    or expected 'statement';
  }
  elsif($3 eq 'for'){
  push@$ret,'for';
  if(/\G var$S/cgx){
  push@$ret,my$var=bless[[pos()-length$1],'var'],'JE::Code::Statement';
  push@$var,&vardecl_noin;
  &skip;
  if(/\G([;,])$s/gc){
  if($1 eq ','){
  do{
  @$var==push@$var,&vardecl
    and expected 'identifier'
  }while(/\G$s,$s/gc);
  &skip;
  /\G;$s/cg
    or expected 'semicolon';
  }
  push@$ret,&finish_for_sc_sc;
  }
  else{
  /\Gin$s/cg or expected"'in', comma or semicolon";
  push@$ret,'in';
  @$ret==push@$ret,&expr
    and expected 'expresssion';
  &skip;
  /\G\)$s/cg or expected"')'";
  }
  }
  elsif(@$ret!=push@$ret,&expr_noin){
  &skip;
  if(/\G;$s/gc){
  push@$ret,&finish_for_sc_sc;
  }
  else{
  /\Gin$s/cg or expected"'in' or semicolon";
  push@$ret,'in';
  @$ret==push@$ret,&expr
    and expected 'expresssion';
  &skip;
  /\G\)$s/cg or expected"')'";
  }
  }
  else{
  push@$ret,'empty';
  /\G;$s/cg
    or expected 'expression or semicolon';
  push@$ret,&finish_for_sc_sc;
  }
  @$ret!=push@$ret,&statement_default
    or expected 'statement';
  }
  elsif($3 eq 'with'){
  push@$ret,'with';
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G\)$s/gc or expected"')'";
  @$ret!=push@$ret,&statement_default
    or expected 'statement';
  }
  elsif($3 eq 'switch'){
  push@$ret,'switch';
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G\)$s/gc or expected"')'";
  /\G\{$s/gc or expected"'{'";
  while(/\G case(?!$id_cont) $s/cgx){
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G:$s/cg or expected 'colon';
  push@$ret,&statements;
  }
  my$default=0;
  if(/\G default(?!$id_cont) $s/cgx){
  /\G : $s /cgx or expected 'colon';
  push@$ret,default=>&statements;
  ++$default;
  }
  while(/\G case(?!$id_cont) $s/cgx){
  @$ret==push@$ret,&expr
    and expected 'expression';
  &skip;
  /\G:$s/cg or expected 'colon';
  push@$ret,&statements;
  }
  /\G \} $s /cgx or expected(
  $default
  ?"'}' or 'case'"
  :"'}', 'case' or 'default'"
  );
  }
  elsif($4){
  push@$ret,'try',&statements;
  /\G \} $s /cgx or expected"'}'";
  my$pos=pos;
  if(/\Gcatch$s/cg){
  /\G \( $s /cgx or expected"'('";
  @$ret==push@$ret,&ident
    and expected 'identifier';
  &skip;
  /\G \) $s /cgx or expected"')'";
  /\G \{ $s /cgx or expected"'{'";
  push@$ret,&statements;
  /\G \} $s /cgx or expected"'}'";
  }
  if(/\Gfinally$s/cg){
  /\G \{ $s /cgx or expected"'{'";
  push@$ret,&statements;
  /\G \} $s /cgx or expected"'}'";
  }
  pos eq$pos and expected"'catch' or 'finally'";
  }
  else{
  push@$ret,'labelled',unescape_ident$5;
  while(/\G($ident)$s:$s/cg){
  push@$ret,unescape_ident$1;
  }
  @$ret!=push@$ret,&statement_default
    or expected 'statement';
  }
  }
  else{
  if(/\G var$S/xcg){
  push@$ret,'var';
  do{
  push@$ret,&vardecl;
  }while(/\G$s,$s/gc);
  }
  elsif(/\Gdo(?!$id_cont)$s/cg){
  push@$ret,'do';
  @$ret!=push@$ret,&statement_default
    or expected 'statement';
  /\Gwhile$s/cg               or expected"'while'";
  /\G\($s/cg                or expected"'('";
  @$ret!=push@$ret,&expr
    or expected 'expression';
  &skip;
  /\G\)/cog or expected"')'";
  }
  elsif(/\G(continue|break)(?!$id_cont)/cog){
  push@$ret,$1;
  /\G$h($ident)/cog
    and push@$ret,unescape_ident$1;
  }
  elsif(/\Greturn(?!$id_cont)/cog){
  push@$ret,'return';
  my$pos=pos;
  /\G$h/g;
  @$ret==push@$ret,&expr and pos=$pos;
  }
  elsif(/\Gthrow(?!$id_cont)/cog){
  push@$ret,'throw';
  /\G$h/g;
  @$ret==push@$ret,&expr
    and expected 'expression';
  }
  else{
  $ret=&expr or return;
  }
  m-$optional_sc-cgx
    or expected"semicolon, '}' or end of line";
  }
  push@{$$ret[0]},pos unless@{$$ret[0]}==2;
  ref$ret eq 'ARRAY' and bless$ret,'JE::Code::Statement';
  return$ret;
  }
  sub statement(){
  my$ret;
  for my $sub(@_stms){
  defined($ret=&$sub)
    and last;
  }
  defined$ret?$ret:()
  }
  sub statements(){
  my$ret=bless[[pos],'statements'],'JE::Code::Statement';
  /\G$s/g;
  while(){
  @$ret!=push@$ret,$_parser?&statement:&statement_default
    or last;
  }
  push@{$$ret[0]},pos;
  return$ret;
  }
  sub program(){
  my$ret=bless[[pos],'statements'],'JE::Code::Statement';
  /\G$s/g;
  if($_parser){
  while(){
  DECL:{
  for my $sub(@_decls){
  @$ret!=push@$ret,&$sub
    and redo DECL;
  }
  }
  @$ret!=push@$ret,&statement or last;
  }
  }
  else{
  while(){
  while(){
  @$ret==push@$ret,&function and last;
  }
  @$ret!=push@$ret,&statement_default or last;
  }
  }
  push@{$$ret[0]},pos;
  return$ret;
  }
  sub _parse($$$;$$){
  my($rule,$src,$my_global,$file,$line)=@_;
  local our($_source,$_file,$_line)=($src,$file,$line);
  $src=
    defined blessed$src &&$src->isa("JE::String")
    ?$src->value16
    :surrogify("$src");
  $src=~s/\p{Cf}//g;
  $my_global->html_mode
    and local$s=qr((?>
  	  (?> [ \t\x0b\f\xa0\p{Zs}]* )
  	  (?> (?>
  	       $n
  	       (?>(?:
  	        (?>[ \t\x0b\f\xa0\p{Zs}]*) -->
  	        (?>[^\cm\cj\x{2028}\x{2029}]*)(?>$n|\z)
  	       )?)
  	        |
  	       ^
  	       (?>[ \t\x0b\f\xa0\p{Zs}]*) -->
  	       (?>[^\cm\cj\x{2028}\x{2029}]*)(?>$n|\z)
  	        |
  	       (?>//|<!--)(?>[^\cm\cj\x{2028}\x{2029}]*)(?>$n|\z)
  	        |
  	       /\*.*?\*/
  	      )
  	      (?> [ \t\x0b\f\xa0\p{Zs}]* )
  	  ) *
  	 ))sx,local$S=qr(
  	  (?>
  	   $ss
  	    |
  	   (?>//|<!--)[^\cm\cj\x{2028}\x{2029}]*
  	    |
  	   /\*.*?\*/
  	  )
  	  $s
  	 )xs,local$optional_sc=qr _\G (?:
  	    $s (?: \z | ; $s | (?=\}) )
  	      |
  	    # optional horizontal whitespace
  	    # then a line terminator or a comment containing one
  	    # then optional trailing whitespace
  	    $h
  	    (?:
  	        $n
  	         |
  	        (?>//|<!--)[^\cm\cj\x{2028}\x{2029}]* $n
  	         |
  	        /\* [^*\cm\cj\x{2028}\x{2029}]* 
  	            (?: \*(?!/) [^*\cm\cj\x{2028}\x{2029}] )*
  	          $n
  	          (?s:.)*?
  	        \*/
  	    )
  	    $s
  	 )_x;
  my$tree;
  local$_vars=[];
  $rule eq 'program'
    and!$_parser
    and($ENV{'YES_I_WANT_JE_TO_OPTIMISE'}||'')eq 2
    and do{require 'JE/parsetoperl.pl',$rule=\&ptp_program};
  for($src){
  pos=0;
  eval{
  local$global=$my_global;
  $tree=(\&$rule)->();
  !defined pos
    or pos==length
    or expected 'statement or function declaration';
  };
  if(ref$@ne ''){
  defined blessed$@
    and$@->isa('JE::Object::Error')?last:die;
  ref($@)=~/^(?:SCALAR|REF)\z/ or die;
  $@=
    ref${$@}eq 'SCALAR'
    ?JE::Object::Error::SyntaxError->new($my_global,add_line_number($${$@},{file=>$file,line=>$line,source=>\$src},pos))
    :JE::Object::Error::SyntaxError->new($my_global,add_line_number"Expected ${$@} but found '".substr($_,pos,10)."'",{file=>$file,line=>$line,source=>\$src},pos);
  return;
  }
  elsif($@){die}
  }
  wantarray?($src,$tree,$_vars):$tree;
  }
  !!!0;
JE_PARSER

$fatpacked{"JE/Scope.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_SCOPE';
  package JE::Scope;
  our$VERSION='0.066';
  use strict;
  use warnings;
  no warnings 'utf8';
  require JE::LValue;
  our$AUTOLOAD;
  sub find_var{
  my($self,$var)=@_;
  my$lvalue;
  for(reverse@$self){
  my$p=$_;
  defined($p=$p->prototype)or next  while!$p->exists($var);
  return new JE::LValue$_,$var;
  }
  new JE::LValue\$self->[0],$var;
  }
  sub new_var{
  my($self,$var)=(shift,shift);
  my$var_obj;
  for(reverse@$self[1..$#$self]){
  ref$_ eq 'JE::Object::Function::Call'
    and$var_obj=$_,
    last;
  }
  defined$var_obj or$var_obj=$$self[0];
  if(defined$var_obj->prop($var)){
  $var_obj->prop($var,shift)if@_;
  }
  else{
  $var_obj->prop(
  $var,@_
  ?shift
  :$$self[0]->undefined
  );
  $JE::Code::Expression::_eval or$var_obj->prop(
  {
  name=>$var,
  dontdel=>1,
  }
  );
  }
  return new JE::LValue$var_obj,$var
    unless not defined wantarray;
  }
  sub AUTOLOAD{
  my($method)=$AUTOLOAD=~/([^:]+)\z/;
  if($method=~/^[A-Z]+\z/){
  substr($method,0,0)='SUPER::';
  local*@;
  return eval{shift->$method(@_)};
  }
  shift->[0]->$method(@_);
  }
  sub DESTROY{}
  1;
JE_SCOPE

$fatpacked{"JE/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_STRING';
  package JE::String;
  our$VERSION='0.066';
  use strict;
  use warnings;
  no warnings 'utf8';
  use overload
    fallback=>1,
    '""'=>'value',
    ;
  use Carp;
  use Scalar::Util qw 'blessed tainted';
  use Exporter 5.57 'import';
  our@EXPORT_OK=qw'surrogify desurrogify';
  require JE::Object::String;
  require JE::Boolean;
  require JE::Number;
  sub new{
  my($class,$global,$val)=@_;
  defined blessed$global
    or croak"First argument to JE::String->new is not an object";
  my$self;
  if(defined blessed$val and$val->can('to_string')){
  $self=bless[$val->to_string->[0],undef,$global],$class;
  }
  else{
  $self=bless[undef,$val,$global],$class;
  }
  $self;
  }
  sub _new{
  bless[defined$_[2]?$_[2]:'',undef,$_[1]],$_[0];
  }
  sub prop{
  my$self=shift;
  if($_[0]eq 'length'){
  return JE::Number->new(
  $$self[2],
  length(
  defined$$self[0]
  ?$$self[0]
  :($$self[0]=surrogify($$self[1]))
  )
  );
  }
  $$self[2]->prototype_for('String')->prop(@_);
  }
  sub keys{
  my$self=shift;
  $$self[2]->prototype_for('String')->keys;
  }
  sub delete{
  return$_[1]ne 'length'
  }
  sub method{
  my$self=shift;
  $$self[2]->prototype_for('String')->prop(shift)->apply($self,$$self[2]->upgrade(@_));
  }
  sub value{
  defined$_[0][1]?$_[0][1]:($_[0][1]=desurrogify($_[0][0]));
  }
  *TO_JSON=*value;
  sub value16{
  defined$_[0][0]?$_[0][0]:($_[0][0]=surrogify($_[0][1]));
  }
  sub typeof{'string'}
  sub id{'str:'.$_[0]->value16}
  sub class{'String'}
  sub primitive{1}
  sub to_primitive{$_[0]}
  sub to_string{$_[0]}
  sub to_boolean{
  JE::Boolean->new($_[0][2],length defined$_[0][0]?$_[0][0]:$_[0][1])
  }
  sub to_object{JE::Object::String->new($_[0][2],shift)}
  our$s=qr.[\p{Zs}\s\ck\x{2028}\x{2029}]*.;
  sub to_number{
  my$value=(my$self=shift)->[0];
  defined$value or$value=$$self[1];
  JE::Number->new(
  $self->[2],
  $value=~/^$s
  		  (
  		    [+-]?
  		    (?:
  		      (?=[0-9]|\.[0-9]) [0-9]* (?:\.[0-9]*)?
  		      (?:[Ee][+-]?[0-9]+)?
  		        |
  		      Infinity
  		    )
  		    $s
  		  )?
  		  \z
  		/ox
  ?defined$1
    ?$value
    :0
    :$value=~/^$s   0[Xx] ([A-Fa-f0-9]+)   $s\z/ox?hex$1
  :'NaN'
  );
  }
  sub global{$_[0][2]}
  sub taint{
  my$self=shift;
  tainted$self->[0]||tainted$self->[1]and return$self;
  my$alter_ego=[@$self];
  $alter_ego->[defined$alter_ego->[0]?0:1].=shift();
  return bless$alter_ego,ref$self;
  }
  sub desurrogify($){
  my$ret=shift;
  my($ord1,$ord2);
  for(my$n=0;$n<length$ret;++$n){
  ($ord1=ord substr$ret,$n,1)>=0xd800
    and$ord1<=0xdbff
    and($ord2=ord substr$ret,$n+1,1)>=0xdc00
    and$ord2<=0xdfff
    and substr($ret,$n,2)=chr 0x10000+($ord1-0xD800)*0x400+($ord2-0xDC00);
  }
  $ret;
  }
  sub surrogify($){
  my$ret=shift;
  no warnings 'utf8';
  $ret=~s<([^\0-\x{ffff}])><
  		  chr((ord($1) - 0x10000) / 0x400 + 0xD800)
  		. chr((ord($1) - 0x10000) % 0x400 + 0xDC00)
  	>eg;
  $ret;
  }
  1;
  __END__
  
JE_STRING

$fatpacked{"JE/Undefined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_UNDEFINED';
  package JE::Undefined;
  our$VERSION='0.066';
  use strict;
  use warnings;
  use overload
    fallback=>1,
    '""'=>'typeof',
    bool=>\&value,
    '0+'=>sub{sin 9**9**9};
  require JE::String;
  require JE::Boolean;
  sub new{
  bless\do{my$thing=$_[1]},$_[0]
  }
  sub value{undef}
  *TO_JSON=*value;
  sub typeof{'undefined'}
  sub id{'undef'}
  sub primitive{1}
  sub to_primitive{$_[0]}
  sub to_boolean{JE::Boolean->new(${+shift},0)}
  sub to_string{JE::String->_new(${+shift},'undefined')}
  sub to_number{JE::Number->new(${+shift},'NaN')}
  sub global{${$_[0]}}
  return"undef";
  __END__
  
JE_UNDEFINED

$fatpacked{"JE/_FieldHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE__FIELDHASH';
  package JE::_FieldHash;
  our$VERSION='0.066';
  use strict;
  use warnings;
  BEGIN{
  eval{
  require Hash::Util::FieldHash;
  import  Hash::Util::FieldHash 'fieldhash';
  };
  if($@){
  require Tie::RefHash::Weak;
  eval 'sub fieldhash(\%) {
  			tie %{$_[0]}, "Tie::RefHash::Weak";
  			$_[0];
  		}';
  }
  }
  use Exporter 5.57 'import';
  our@EXPORT='fieldhash';
  __END__
  
JE__FIELDHASH

$fatpacked{"common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMON_SENSE';
  package common::sense;
  our$VERSION=3.74;
  sub import{
  local$^W;
  ${^WARNING_BITS}^=${^WARNING_BITS}^"\x0c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\x0c\x00\x00\x00";
  $^H|=0x1c820fc0;
  @^H{qw(feature_say feature_switch feature_evalbytes feature_unicode feature_fc feature___SUB__ feature_state)}=(1)x 7;
  }
  1
COMMON_SENSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use 5.010;
use strict;
use warnings qw(all);
# CORE dependencies
use Getopt::Long;
use IO::Socket;
use Net::Domain;
use POSIX;
# external dependencies
use AnyEvent::HTTP;
use AnyEvent::Log;
use AnyEvent::Socket;
use JE;

main();

sub _help {
    return print <<'END_HELP';
Usage: depac [options]
    --help              This screen
    --stop              Stop the running instance
    --reload            Reload the running instance
    --status            Output the environment settings if an instance is running
    --wpad_file URL     Manually specify the URL of the "wpad.dat" file (default: DNS autodiscovery)
                        Alternatively: --wpad_file=skip to short-circuit the relay proxy
    --env_file FILE     File for environment persistence (default: ~/.depac.env)
    --log_file FILE     File for the log (default: ~/.depac.log; /dev/null to disable :)
    --log_level LEVEL   fatal/warn/info/debug/trace (default: warn)
    --nodetach          Do not daemonize
    --bind_host ADDR    Accept connection at this host address (default: 127.0.0.1)
    --bind_port PORT    Accept connection at this port (default: random port)
    --custom DEST,REGEX Custom routes AKA "poor man's WPAD"; overrides for the WPAD rules.
                        DEST is the destination proxy address (or "direct"),
                        REGEX is a regular expression that matches the hostname.
                        Multiple custom routes can be defined adding --custom ...
                        as much as necessary.
                        Example: --custom '192.168.253.15:8080,dev\.company\.com$'

 * Add this line to your ~/.profile file to start the relay proxy in background
   and update HTTP_PROXY environment variables appropriately:

    eval $(depac)

 * To gracefully terminate the relay proxy and unset HTTP_PROXY environment:

    eval $(depac --stop)
END_HELP
}

# shamelessly stolen from https://metacpan.org/source/MACKENNA/HTTP-ProxyPAC-0.31/lib/HTTP/ProxyPAC/Functions.pm
sub _validIP {
    return ($_[0] =~ m{^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$}x
        && $1 <= 255 && $2 <= 255 && $3 <= 255 && $4 <= 255);
}

our %memoize;
sub _process_wpad {
    my ($wpad_file) = @_;
    return () if $wpad_file && $wpad_file eq 'skip';
    my $je = JE->new;
    for my $stub (qw(alert weekDayRange dateRange timeRange)) {
        $je->new_function($stub => sub {
            AE::log warn => 'WPAD CALLED: %s("%s")',
                $stub,
                join '","', map { quotemeta } @_;
        });
    }
    $je->new_function(dnsDomainIs => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            my $host_len = length $_[0];
            my $domain_len = length $_[1];
            my $d = length($_[0]) - length($_[1]);
            ($d >= 0) && (substr($_[0], $d) eq $_[1]);
        };
    });
    $je->new_function(dnsDomainLevels => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            $#{[ split m{\.}x, $_[0] ]};
        };
    });
    $je->new_function(dnsResolve => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            my $addr = Socket::inet_aton($_[0]);
            $addr ? inet_ntoa($addr) : ();
        };
    });
    $je->new_function(isInNet => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            $_[0] = dnsResolve($_[0]) unless _validIP($_[0]);
            (!$_[0] || !_validIP($_[1]) || !_validIP($_[2]))
                ? () : (Socket::inet_aton($_[0]) & Socket::inet_aton($_[2])) eq (Socket::inet_aton($_[1]) & Socket::inet_aton($_[2]));
        };
    });
    $je->new_function(isPlainHostName => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            index($_[0], '.') == -1;
        };
    });
    $je->new_function(isResolvable => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            defined(gethostbyname($_[0]));
        };
    });
    $je->new_function(localHostOrDomainIs => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            ($_[0] eq $_[1]) || rindex($_[1], $_[0] . '.') == 0;
        };
    });
    $je->new_function(myIpAddress => sub {
        $memoize{myIpAddress} //= do {
            my $addr = Socket::inet_aton(Net::Domain::hostname);
            $addr ? inet_ntoa($addr) : '127.0.0.1';
        };
    });
    $je->new_function(shExpMatch => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            $_[1] =~ s{ \* }{.*?}gx;
            !!($_[0] =~ m{$_[1]}ix);
        };
    });
    my $cv = AnyEvent->condvar;
    if ($wpad_file) {
        AE::log info => 'fetching %s', $wpad_file;
        http_get $wpad_file,
            proxy => undef,
            timeout => 1.0,
            sub {
                my ($body, $hdr) = @_;
                if (($hdr->{Status} != 200) || !length($body)) {
                    AE::log fatal => "couldn't GET %s", $wpad_file;
                } else {
                    $cv->send([$body, "$wpad_file"]);
                }
            };
    } else {
        my $hostdomain  = Net::Domain::hostdomain;
        AE::log info => 'searching domain %s', $hostdomain;
        my @hostdomain = split m{\.}x, $hostdomain;
        while ($#hostdomain) {
            my $wpad = 'http://wpad.' . join('.', @hostdomain) . '/wpad.dat';
            AE::log info => 'fetching %s', $wpad;
            $cv->begin;
            http_get $wpad,
                proxy => undef,
                timeout => 1.0,
                sub {
                    my ($body, $hdr) = @_;
                    $cv->end;
                    if (($hdr->{Status} != 200) || !length($body)) {
                        AE::log debug => "couldn't GET %s", $wpad;
                    } else {
                        $cv->send([$body, "$wpad"]);
                    }
                };
            shift @hostdomain;
        }
    }
    (my $body, $je->{last_working_wpad_file}) = @{ $cv->recv || [''] };
    AE::log fatal => "COULDN'T FIND WPAD" unless $body;
    $je->eval($body);
    AE::log fatal => "COULDN'T EVALUATE WPAD: $@" if $@;
    AE::log info => 'using WPAD %s', $je->{last_working_wpad_file};
    return $je;
}

sub _ping_pid {
    my ($proxy) = @_;
    my $cv = AnyEvent->condvar;
    AE::log info => 'pinging %s:%d', @$proxy;
    http_get 'http://depac/pid',
        proxy   => $proxy,
        timeout => 1.0,
        sub {
            my ($body, $hdr) = @_;
            if (($hdr->{Status} != 200) || !length($body)) {
                AE::log info => "couldn't GET /pid from %s:%d", @$proxy;
                $cv->send(0);
            } else {
                chomp $body;
                $cv->send($body);
            }
        };
    return $cv->recv;
}

our ($sigint, $sighup); # keep the reference
sub run {
    my ($bind_host, $bind_port, $je, $routes, $cb) = @_;
    my (%pool, %status);
    my $cv = AnyEvent->condvar;
    $sighup = AnyEvent->signal(signal => 'HUP', cb => sub {
        AE::log info => 'cleaning up caches...';
        %pool = ();
        %status = ();
        %memoize = ();
        AE::log info => 'reprocessing WPAD %s', $je->{last_working_wpad_file};
        http_get $je->{last_working_wpad_file},
            proxy => undef,
            timeout => 1.0,
            sub {
                my ($body, $hdr) = @_;
                if (($hdr->{Status} != 200) || !length($body)) {
                    AE::log fatal => "couldn't GET %s", $je->{last_working_wpad_file};
                } else {
                    $je->eval($body);
                    AE::log fatal => "COULDN'T EVALUATE WPAD: $@" if $@;
                }
            };
    });
    $sigint = AnyEvent->signal(signal => 'INT', cb => sub {
        AE::log info => 'shutting down...';
        $cv->send;
    });
    tcp_server $bind_host, $bind_port, sub {
        my ($fh, $host, $port) = @_;
        AE::log info => 'new connection from %s:%d (%d in pool)', $host, $port, scalar keys %pool;
        my $h = AnyEvent::Handle->new(
            fh          => $fh,
            on_eof    => sub {
                $_[0]->destroy;
                delete $pool{ fileno($fh) };
            },
            on_error    => sub {
                $_[0]->destroy;
                delete $pool{ fileno($fh) };
            },
        );
        $pool{ fileno($fh) } = $h;
        $status{connections}++;
        $h->push_read(line => sub {
            my ($_h, $line, $eol) = @_;
            AE::log debug => '[from %s:%d] %s', $host, $port, $line;
            my ($verb, $peer_host, $peer_port, $proto, $uri);
            if ($line =~ m{^CONNECT\s+([\w\.\-]+):([0-9]+)\s+(HTTP/1\.[01])$}ix) {
                ($verb, $peer_host, $peer_port, $proto) = ('CONNECT', $1, $2, $3);
            } elsif ($line =~ m{^(DELETE|GET|HEAD|OPTIONS|POST|PUT|TRACE)\s+(https?)://([\w\.\-]+)(?::([0-9]+))?(\S*)\s+(HTTP/1\.[01])$}ix) {
                ($verb, my $scheme, $peer_host, $peer_port, $uri, $proto) = (uc($1), lc($2), $3, $4, $5, $6);
                $peer_port ||= $scheme eq 'http' ? 80 : 443;
            } else {
                AE::log warn => 'bad request from %s:%d', $host, $port;
                $_h->push_write(
                    'HTTP/1.0 400 Bad request' . $eol .
                    'Cache-Control: no-cache' . $eol .
                    'Connection: close' . $eol .
                    'Content-Type: text/html' . $eol . $eol .
                    '<html><body><h1>400 Bad request</h1></body></html>'
                );
                $_h->push_shutdown;
                delete $pool{ fileno($fh) };
                return;
            }
            if ($peer_host eq 'depac') {
                $status{cache} = keys %memoize;
                $status{pool} = keys %pool;
                if (my $response = {
                        '/pid'      => sub { $$ },
                        '/status'   => sub { join $eol => map { $_ . "\t" . $status{$_} } sort keys %status },
                    }->{ $uri }) {
                    AE::log info => '%s request from %s:%d (OK)', $uri, $host, $port;
                    $_h->push_write(
                        'HTTP/1.0 200 OK' . $eol .
                        'Cache-Control: no-cache' . $eol .
                        'Connection: close' . $eol .
                        'Content-Type: text/plain' . $eol . $eol .
                        $response->() . $eol
                    );
                } else {
                    AE::log warn => '%s request from %s:%d (Not found)', $uri, $host, $port;
                    $_h->push_write(
                        'HTTP/1.0 404 Not found' . $eol .
                        'Cache-Control: no-cache' . $eol .
                        'Connection: close' . $eol .
                        'Content-Type: text/html' . $eol . $eol .
                        '<html><body><h1>404 Not found</h1></body></html>'
                    );
                }
                $_h->push_shutdown;
                delete $pool{ fileno($fh) };
                return;
            }

            my ($proxy) = map {
                ($peer_host =~ $_->[0]) ? $_->[1] : ()
            } @$routes;
            AE::log debug => 'overriding with %s', $proxy if $proxy;
            $proxy ||= $je ? $je->{FindProxyForURL}->(
                ($verb eq 'CONNECT' ? 'https' : 'http') . '://' . $peer_host, # HACK!
                $peer_host,
            ) : 'DIRECT';
            AE::log debug => 'selected proxy %s', $proxy;

            my $peer_h;
            if ($proxy =~ m{^DIRECT\b}ix) {
                AE::log debug => 'connecting directly to %s:%d', $peer_host, $peer_port;
                $peer_h = AnyEvent::Handle->new(
                    connect     => [$peer_host => $peer_port],
                    on_eof      => sub { $_[0]->destroy },
                    on_error    => sub { $_[0]->destroy },
                    on_connect  => sub {
                        if ($verb eq 'CONNECT') {
                            AE::log debug => '[to %s:%d]', $peer_host, $peer_port;
                            $_h->push_read(regex => qr{(?:\015?\012){2}}x, sub {
                                AE::log debug => 'skipping headers on CONNECT';
                                $_h->push_write('HTTP/1.0 200 Connection established' . $eol . $eol);
                            });
                        } else {
                            $line = join ' ', $verb, $uri, $proto;
                            AE::log debug => '[to %s:%d] %s', $peer_host, $peer_port, $line;
                            $peer_h->push_write($line . $eol);
                        }
                        $_h->on_read(sub {
                            my $l = length $_[0]->rbuf;
                            $status{sent_bytes} += $l;
                            AE::log trace => 'send %d bytes to %s:%d', $l, $peer_host, $peer_port;
                            $peer_h->push_write($_[0]->rbuf);
                            $_[0]->rbuf = '';
                        });
                        $peer_h->on_read(sub {
                            my $l = length $_[0]->rbuf;
                            $status{recv_bytes} += $l;
                            AE::log trace => 'recv %d bytes from %s:%d', $l, $peer_host, $peer_port;
                            $_h->push_write($_[0]->rbuf);
                            $_[0]->rbuf = '';
                        });
                    }
                );
            } else {
                my ($proxy_host, $proxy_port) = ($proxy =~ m{^PROXY\s+([\w\.]+):([0-9]+)}ix);
                AE::log debug => 'connecting to %s:%d via %s:%d', $peer_host, $peer_port, $proxy_host, $proxy_port;
                $peer_h = AnyEvent::Handle->new(
                    connect     => [$proxy_host => $proxy_port],
                    on_eof      => sub { $_[0]->destroy },
                    on_error    => sub { $_[0]->destroy },
                    on_connect  => sub {
                        AE::log debug => '[to %s:%d] %s', $proxy_host, $proxy_port, $line;
                        $peer_h->push_write($line . $eol);
                        $_h->on_read(sub {
                            my $l = length $_[0]->rbuf;
                            $status{sent_bytes} += $l;
                            AE::log trace => 'send %d bytes to %s:%d', $l, $proxy_host, $proxy_port;
                            $peer_h->push_write($_[0]->rbuf);
                            $_[0]->rbuf = '';
                        });
                        $peer_h->on_read(sub {
                            my $l = length $_[0]->rbuf;
                            $status{recv_bytes} += $l;
                            AE::log trace => 'recv %d bytes from %s:%d', $l, $proxy_host, $proxy_port;
                            $_h->push_write($_[0]->rbuf);
                            $_[0]->rbuf = '';
                        });
                    }
                );
            }
        });
    }, $cb;
    return $cv;
}

sub _daemonize {
    open(\*STDOUT, '>', '/dev/null') || AE::log fatal => "open >/dev/null: $@";
    open(\*STDIN,  '<', '/dev/null') || AE::log fatal => "open </dev/null: $@";
    open(\*STDERR, '>', '/dev/null') || AE::log fatal => "dup stdout > stderr: $@";
    my $pid;
    POSIX::_exit(0) if $pid = fork;
    AE::log fatal => "couldn't fork: $@" unless defined $pid;
    POSIX::setsid();
    return;
}

sub main {
    my $bind_host = '127.0.0.1';
    my $env_file = $ENV{HOME} . '/.depac.env';
    my $log_file = $ENV{HOME} . '/.depac.log';
    my $log_level = 'warn';
    my $detach = 1;
    my ($bind_port, $wpad_file, $help, $stop, $reload, $status, @custom);
    GetOptions(
        'bind_host=s'   => \$bind_host,
        'bind_port=i'   => \$bind_port,
        'detach!'       => \$detach,
        'env_file=s'    => \$env_file,
        'log_file=s'    => \$log_file,
        'log_level=s'   => \$log_level,
        'help'          => \$help,
        'reload'        => \$reload,
        'status'        => \$status,
        'stop'          => \$stop,
        'wpad_file=s'   => \$wpad_file,
        'custom=s'      => \@custom,
    );
    _help && exit if $help;

    $AnyEvent::Log::FILTER->level($log_level);
    $AnyEvent::Log::FILTER->attach(AnyEvent::Log::Ctx->new(
        log_to_file => $log_file,
    ));

    my $routes = [];
    for (@custom) {
        my ($dest, $regex) = /^([\w\.:]+),(.+)$/x;
        AE::log fatal => "Bad route: $_" if !$dest || !$regex;
        AE::log debug => 'Custom route [ qr/%s/ix => "%s" ]', $regex, quotemeta $dest;
        push @$routes => [ qr/$regex/ix => $dest ];
    }

    my $proxy;
    if (-e $env_file) {
        AE::log debug => 'checking previous environment at %s', $env_file;
        open(my $fh, '<', $env_file)
            || AE::log fatal => "can't read from %s: %s", $env_file, $@;
        my @env;
        while (my $line = <$fh>) {
            $proxy = [$1, $2] if $line =~ m{^export\s+https?_proxy="http://([\w\.\-]+):([0-9]+)"}isx;
            push @env => $line;
        }
        close $fh;
        AE::log fatal => "couldn't find running process address in %s", $env_file
            unless $proxy;
        if (my $pid = _ping_pid($proxy)) {
            AE::log info => 'running proxy has PID %d', $pid;
            if ($stop) {
                AE::log debug => 'sending SIGINT to PID %d', $pid;
                kill INT => $pid;
            } elsif ($reload) {
                AE::log debug => 'sending SIGHUP to PID %d', $pid;
                kill HUP => $pid;
            } else {
                print for @env;
            }
            exit;
        }
    }
    exit if $status || $stop; # not running
    my $je = _process_wpad($wpad_file);
    run($bind_host, $bind_port, $je, $routes, sub {
        my (undef, $this_host, $this_port) = @_;
        my @env;
        AE::log info => 'STARTED THE SERVER AT %s:%d', $this_host, $this_port;
        $proxy = 'http://' . $this_host . ':' . $this_port;
        AE::log info => 'writing environment proxy settings to %s', $env_file;
        push @env => qq(export $_="$proxy"\n) for map { $_ => uc } qw(http_proxy https_proxy);
        print for @env;
        umask 077;
        unlink $env_file;
        open(my $fh, '>', $env_file)
            || AE::log fatal => "can't write to %s: %s", $env_file, $@;
        print $fh $_ for @env;
        close $fh;
        _daemonize if $detach;
    })->recv;
    exit;
}
