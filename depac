#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"AE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AE';
  =head1 NAME
  
  AE - simpler/faster/newer/cooler AnyEvent API
  
  =head1 SYNOPSIS
  
    use AnyEvent; # not AE
  
    # file handle or descriptor readable
    my $w = AE::io $fh, 0, sub { ...  };
  
    # one-shot or repeating timers
    my $w = AE::timer $seconds,         0, sub { ... }; # once
    my $w = AE::timer $seconds, $interval, sub { ... }; # repeated
  
    print AE::now;  # prints current event loop time
    print AE::time; # think Time::HiRes::time or simply CORE::time.
  
    # POSIX signal
    my $w = AE::signal TERM => sub { ... };
  
    # child process exit
    my $w = AE::child $pid, sub {
       my ($pid, $status) = @_;
       ...
    };
  
    # called when event loop idle (if applicable)
    my $w = AE::idle sub { ... };
  
    my $cv = AE::cv; # stores whether a condition was flagged
    $cv->send; # wake up current and all future recv's
    $cv->recv; # enters "main loop" till $condvar gets ->send
    # use a condvar in callback mode:
    $cv->cb (sub { $_[0]->recv });
  
  
  =head1 DESCRIPTION
  
  This module documents the new simpler AnyEvent API.
  
  The rationale for the new API is that experience with L<EV> shows that
  this API actually "works", despite its lack of extensibility, leading to
  a shorter, easier and faster API.
  
  The main differences from AnyEvent is that function calls are used
  instead of method calls, and that no named arguments are used.
  
  This makes calls to watcher creation functions really short, which can
  make a program more readable despite the lack of named parameters.
  Function calls also allow more static type checking than method calls, so
  many mistakes are caught at compile-time with this API.
  
  Also, some backends (Perl and EV) are so fast that the method call
  overhead is very noticeable (with EV it increases the execution time five-
  to six-fold, with Perl the method call overhead is about a factor of two).
  
  Note that the C<AE> API is an alternative to, not the future version of,
  the AnyEvent API. Both APIs can be used interchangeably and there are
  no plans to "switch", so if in doubt, feel free to use the L<AnyEvent>
  API in new code.
  
  As the AE API is complementary, not everything in the AnyEvent API is
  available, and you still need to use AnyEvent for the finer stuff. Also,
  you should not C<use AE> directly, C<use AnyEvent> will provide the AE
  namespace.
  
  At the moment, these functions will become slower then their method-call
  counterparts when using L<AnyEvent::Strict> or L<AnyEvent::Debug>::wrap.
  
  =head2 FUNCTIONS
  
  This section briefly describes the alternative watcher constructors and
  other functions available inside the C<AE> namespace. Semantics are not
  described here; please refer to the description of the function or method
  with the same name in the L<AnyEvent> manpage for the details.
  
  =over 4
  
  =cut
  
  package AE;
  
  use AnyEvent (); # BEGIN { AnyEvent::common_sense }
  
  our $VERSION = $AnyEvent::VERSION;
  
  =item $w = AE::io $fh_or_fd, $watch_write, $cb
  
  Creates an I/O watcher that listens for read events (C<$watch_write>
  false) or write events (C<$watch_write> is true) on the file handle or
  file descriptor C<$fh_or_fd>.
  
  The callback C<$cb> is invoked as soon and as long as I/O of the type
  specified by C<$watch_write>) can be done on the file handle/descriptor.
  
  Example: wait until STDIN becomes readable.
  
    $stdin_ready = AE::io *STDIN, 0, sub { scalar <STDIN> };
  
  Example: wait until STDOUT becomes writable and print something.
  
    $stdout_ready = AE::io *STDOUT, 1, sub { print STDOUT "woaw\n" };
  
  =item $w = AE::timer $after, $interval, $cb
  
  Creates a timer watcher that invokes the callback C<$cb> after at least
  C<$after> second have passed (C<$after> can be negative or C<0>).
  
  If C<$interval> is C<0>, then the callback will only be invoked once,
  otherwise it must be a positive number of seconds that specifies the
  interval between successive invocations of the callback.
  
  Example: print "too late" after at least one second has passed.
  
    $timer_once = AE::timer 1, 0, sub { print "too late\n" };
  
  Example: print "blubb" once a second, starting as soon as possible.
  
    $timer_repeated = AE::timer 0, 1, sub { print "blubb\n" };
  
  =item $w = AE::signal $signame, $cb
  
  Invoke the callback C<$cb> each time one or more occurrences of the
  named signal C<$signame> are detected.
  
  =item $w = AE::child $pid, $cb
  
  Invokes the callback C<$cb> when the child with the given C<$pid> exits
  (or all children, when C<$pid> is zero).
  
  The callback will get the actual pid and exit status as arguments.
  
  =item $w = AE::idle $cb
  
  Invoke the callback C<$cb> each time the event loop is "idle" (has no
  events outstanding), but do not prevent the event loop from polling for
  more events.
  
  =item $cv = AE::cv
  
  =item $cv = AE::cv { BLOCK }
  
  Create a new condition variable. The first form is identical to C<<
  AnyEvent->condvar >>, the second form additionally sets the callback (as
  if the C<cb> method is called on the condition variable).
  
  =item AE::now
  
  Returns the current event loop time (may be cached by the event loop).
  
  =item AE::now_update
  
  Ensures that the current event loop time is up to date.
  
  =item AE::time
  
  Return the current time (not cached, always consults a hardware clock).
  
  =item AE::postpone { BLOCK }
  
  Exactly the same as C<AnyEvent:::postpone>.
  
  =item AE::log $level, $msg[, @args]
  
  Exactly the same as C<AnyEvent::log> (or C<AnyEvent::Log::log>).
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
AE

$fatpacked{"AnyEvent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT';
  =head1 NAME
  
  AnyEvent - the DBI of event loop programming
  
  EV, Event, Glib, Tk, UV, Perl, Event::Lib, Irssi, rxvt-unicode, IO::Async,
  Qt, FLTK and POE are various supported event loops/environments.
  
  =head1 SYNOPSIS
  
     use AnyEvent;
  
     # if you prefer function calls, look at the AE manpage for
     # an alternative API.
  
     # file handle or descriptor readable
     my $w = AnyEvent->io (fh => $fh, poll => "r", cb => sub { ...  });
  
     # one-shot or repeating timers
     my $w = AnyEvent->timer (after => $seconds, cb => sub { ...  });
     my $w = AnyEvent->timer (after => $seconds, interval => $seconds, cb => ...);
  
     print AnyEvent->now;  # prints current event loop time
     print AnyEvent->time; # think Time::HiRes::time or simply CORE::time.
  
     # POSIX signal
     my $w = AnyEvent->signal (signal => "TERM", cb => sub { ... });
  
     # child process exit
     my $w = AnyEvent->child (pid => $pid, cb => sub {
        my ($pid, $status) = @_;
        ...
     });
  
     # called when event loop idle (if applicable)
     my $w = AnyEvent->idle (cb => sub { ... });
  
     my $w = AnyEvent->condvar; # stores whether a condition was flagged
     $w->send; # wake up current and all future recv's
     $w->recv; # enters "main loop" till $condvar gets ->send
     # use a condvar in callback mode:
     $w->cb (sub { $_[0]->recv });
  
  =head1 INTRODUCTION/TUTORIAL
  
  This manpage is mainly a reference manual. If you are interested
  in a tutorial or some gentle introduction, have a look at the
  L<AnyEvent::Intro> manpage.
  
  =head1 SUPPORT
  
  An FAQ document is available as L<AnyEvent::FAQ>.
  
  There also is a mailinglist for discussing all things AnyEvent, and an IRC
  channel, too.
  
  See the AnyEvent project page at the B<Schmorpforge Ta-Sa Software
  Repository>, at L<http://anyevent.schmorp.de>, for more info.
  
  =head1 WHY YOU SHOULD USE THIS MODULE (OR NOT)
  
  Glib, POE, IO::Async, Event... CPAN offers event models by the dozen
  nowadays. So what is different about AnyEvent?
  
  Executive Summary: AnyEvent is I<compatible>, AnyEvent is I<free of
  policy> and AnyEvent is I<small and efficient>.
  
  First and foremost, I<AnyEvent is not an event model> itself, it only
  interfaces to whatever event model the main program happens to use, in a
  pragmatic way. For event models and certain classes of immortals alike,
  the statement "there can only be one" is a bitter reality: In general,
  only one event loop can be active at the same time in a process. AnyEvent
  cannot change this, but it can hide the differences between those event
  loops.
  
  The goal of AnyEvent is to offer module authors the ability to do event
  programming (waiting for I/O or timer events) without subscribing to a
  religion, a way of living, and most importantly: without forcing your
  module users into the same thing by forcing them to use the same event
  model you use.
  
  For modules like POE or IO::Async (which is a total misnomer as it is
  actually doing all I/O I<synchronously>...), using them in your module is
  like joining a cult: After you join, you are dependent on them and you
  cannot use anything else, as they are simply incompatible to everything
  that isn't them. What's worse, all the potential users of your
  module are I<also> forced to use the same event loop you use.
  
  AnyEvent is different: AnyEvent + POE works fine. AnyEvent + Glib works
  fine. AnyEvent + Tk works fine etc. etc. but none of these work together
  with the rest: POE + EV? No go. Tk + Event? No go. Again: if your module
  uses one of those, every user of your module has to use it, too. But if
  your module uses AnyEvent, it works transparently with all event models it
  supports (including stuff like IO::Async, as long as those use one of the
  supported event loops. It is easy to add new event loops to AnyEvent, too,
  so it is future-proof).
  
  In addition to being free of having to use I<the one and only true event
  model>, AnyEvent also is free of bloat and policy: with POE or similar
  modules, you get an enormous amount of code and strict rules you have to
  follow. AnyEvent, on the other hand, is lean and to the point, by only
  offering the functionality that is necessary, in as thin as a wrapper as
  technically possible.
  
  Of course, AnyEvent comes with a big (and fully optional!) toolbox
  of useful functionality, such as an asynchronous DNS resolver, 100%
  non-blocking connects (even with TLS/SSL, IPv6 and on broken platforms
  such as Windows) and lots of real-world knowledge and workarounds for
  platform bugs and differences.
  
  Now, if you I<do want> lots of policy (this can arguably be somewhat
  useful) and you want to force your users to use the one and only event
  model, you should I<not> use this module.
  
  =head1 DESCRIPTION
  
  L<AnyEvent> provides a uniform interface to various event loops. This
  allows module authors to use event loop functionality without forcing
  module users to use a specific event loop implementation (since more
  than one event loop cannot coexist peacefully).
  
  The interface itself is vaguely similar, but not identical to the L<Event>
  module.
  
  During the first call of any watcher-creation method, the module tries
  to detect the currently loaded event loop by probing whether one of the
  following modules is already loaded: L<EV>, L<AnyEvent::Loop>,
  L<Event>, L<Glib>, L<Tk>, L<Event::Lib>, L<Qt>, L<POE>. The first one
  found is used. If none are detected, the module tries to load the first
  four modules in the order given; but note that if L<EV> is not
  available, the pure-perl L<AnyEvent::Loop> should always work, so
  the other two are not normally tried.
  
  Because AnyEvent first checks for modules that are already loaded, loading
  an event model explicitly before first using AnyEvent will likely make
  that model the default. For example:
  
     use Tk;
     use AnyEvent;
  
     # .. AnyEvent will likely default to Tk
  
  The I<likely> means that, if any module loads another event model and
  starts using it, all bets are off - this case should be very rare though,
  as very few modules hardcode event loops without announcing this very
  loudly.
  
  The pure-perl implementation of AnyEvent is called C<AnyEvent::Loop>. Like
  other event modules you can load it explicitly and enjoy the high
  availability of that event loop :)
  
  =head1 WATCHERS
  
  AnyEvent has the central concept of a I<watcher>, which is an object that
  stores relevant data for each kind of event you are waiting for, such as
  the callback to call, the file handle to watch, etc.
  
  These watchers are normal Perl objects with normal Perl lifetime. After
  creating a watcher it will immediately "watch" for events and invoke the
  callback when the event occurs (of course, only when the event model
  is in control).
  
  Note that B<callbacks must not permanently change global variables>
  potentially in use by the event loop (such as C<$_> or C<$[>) and that B<<
  callbacks must not C<die> >>. The former is good programming practice in
  Perl and the latter stems from the fact that exception handling differs
  widely between event loops.
  
  To disable a watcher you have to destroy it (e.g. by setting the
  variable you store it in to C<undef> or otherwise deleting all references
  to it).
  
  All watchers are created by calling a method on the C<AnyEvent> class.
  
  Many watchers either are used with "recursion" (repeating timers for
  example), or need to refer to their watcher object in other ways.
  
  One way to achieve that is this pattern:
  
     my $w; $w = AnyEvent->type (arg => value ..., cb => sub {
        # you can use $w here, for example to undef it
        undef $w;
     });
  
  Note that C<my $w; $w => combination. This is necessary because in Perl,
  my variables are only visible after the statement in which they are
  declared.
  
  =head2 I/O WATCHERS
  
     $w = AnyEvent->io (
        fh   => <filehandle_or_fileno>,
        poll => <"r" or "w">,
        cb   => <callback>,
     );
  
  You can create an I/O watcher by calling the C<< AnyEvent->io >> method
  with the following mandatory key-value pairs as arguments:
  
  C<fh> is the Perl I<file handle> (or a naked file descriptor) to watch
  for events (AnyEvent might or might not keep a reference to this file
  handle). Note that only file handles pointing to things for which
  non-blocking operation makes sense are allowed. This includes sockets,
  most character devices, pipes, fifos and so on, but not for example files
  or block devices.
  
  C<poll> must be a string that is either C<r> or C<w>, which creates a
  watcher waiting for "r"eadable or "w"ritable events, respectively.
  
  C<cb> is the callback to invoke each time the file handle becomes ready.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to I/O watcher callbacks.
  
  The I/O watcher might use the underlying file descriptor or a copy of it.
  You must not close a file handle as long as any watcher is active on the
  underlying file descriptor.
  
  Some event loops issue spurious readiness notifications, so you should
  always use non-blocking calls when reading/writing from/to your file
  handles.
  
  Example: wait for readability of STDIN, then read a line and disable the
  watcher.
  
     my $w; $w = AnyEvent->io (fh => \*STDIN, poll => 'r', cb => sub {
        chomp (my $input = <STDIN>);
        warn "read: $input\n";
        undef $w;
     });
  
  =head2 TIME WATCHERS
  
     $w = AnyEvent->timer (after => <seconds>, cb => <callback>);
  
     $w = AnyEvent->timer (
        after    => <fractional_seconds>,
        interval => <fractional_seconds>,
        cb       => <callback>,
     );
  
  You can create a time watcher by calling the C<< AnyEvent->timer >>
  method with the following mandatory arguments:
  
  C<after> specifies after how many seconds (fractional values are
  supported) the callback should be invoked. C<cb> is the callback to invoke
  in that case.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to time watcher callbacks.
  
  The callback will normally be invoked only once. If you specify another
  parameter, C<interval>, as a strictly positive number (> 0), then the
  callback will be invoked regularly at that interval (in fractional
  seconds) after the first invocation. If C<interval> is specified with a
  false value, then it is treated as if it were not specified at all.
  
  The callback will be rescheduled before invoking the callback, but no
  attempt is made to avoid timer drift in most backends, so the interval is
  only approximate.
  
  Example: fire an event after 7.7 seconds.
  
     my $w = AnyEvent->timer (after => 7.7, cb => sub {
        warn "timeout\n";
     });
  
     # to cancel the timer:
     undef $w;
  
  Example 2: fire an event after 0.5 seconds, then roughly every second.
  
     my $w = AnyEvent->timer (after => 0.5, interval => 1, cb => sub {
        warn "timeout\n";
     });
  
  =head3 TIMING ISSUES
  
  There are two ways to handle timers: based on real time (relative, "fire
  in 10 seconds") and based on wallclock time (absolute, "fire at 12
  o'clock").
  
  While most event loops expect timers to specified in a relative way, they
  use absolute time internally. This makes a difference when your clock
  "jumps", for example, when ntp decides to set your clock backwards from
  the wrong date of 2014-01-01 to 2008-01-01, a watcher that is supposed to
  fire "after a second" might actually take six years to finally fire.
  
  AnyEvent cannot compensate for this. The only event loop that is conscious
  of these issues is L<EV>, which offers both relative (ev_timer, based
  on true relative time) and absolute (ev_periodic, based on wallclock time)
  timers.
  
  AnyEvent always prefers relative timers, if available, matching the
  AnyEvent API.
  
  AnyEvent has two additional methods that return the "current time":
  
  =over 4
  
  =item AnyEvent->time
  
  This returns the "current wallclock time" as a fractional number of
  seconds since the Epoch (the same thing as C<time> or C<Time::HiRes::time>
  return, and the result is guaranteed to be compatible with those).
  
  It progresses independently of any event loop processing, i.e. each call
  will check the system clock, which usually gets updated frequently.
  
  =item AnyEvent->now
  
  This also returns the "current wallclock time", but unlike C<time>, above,
  this value might change only once per event loop iteration, depending on
  the event loop (most return the same time as C<time>, above). This is the
  time that AnyEvent's timers get scheduled against.
  
  I<In almost all cases (in all cases if you don't care), this is the
  function to call when you want to know the current time.>
  
  This function is also often faster then C<< AnyEvent->time >>, and
  thus the preferred method if you want some timestamp (for example,
  L<AnyEvent::Handle> uses this to update its activity timeouts).
  
  The rest of this section is only of relevance if you try to be very exact
  with your timing; you can skip it without a bad conscience.
  
  For a practical example of when these times differ, consider L<Event::Lib>
  and L<EV> and the following set-up:
  
  The event loop is running and has just invoked one of your callbacks at
  time=500 (assume no other callbacks delay processing). In your callback,
  you wait a second by executing C<sleep 1> (blocking the process for a
  second) and then (at time=501) you create a relative timer that fires
  after three seconds.
  
  With L<Event::Lib>, C<< AnyEvent->time >> and C<< AnyEvent->now >> will
  both return C<501>, because that is the current time, and the timer will
  be scheduled to fire at time=504 (C<501> + C<3>).
  
  With L<EV>, C<< AnyEvent->time >> returns C<501> (as that is the current
  time), but C<< AnyEvent->now >> returns C<500>, as that is the time the
  last event processing phase started. With L<EV>, your timer gets scheduled
  to run at time=503 (C<500> + C<3>).
  
  In one sense, L<Event::Lib> is more exact, as it uses the current time
  regardless of any delays introduced by event processing. However, most
  callbacks do not expect large delays in processing, so this causes a
  higher drift (and a lot more system calls to get the current time).
  
  In another sense, L<EV> is more exact, as your timer will be scheduled at
  the same time, regardless of how long event processing actually took.
  
  In either case, if you care (and in most cases, you don't), then you
  can get whatever behaviour you want with any event loop, by taking the
  difference between C<< AnyEvent->time >> and C<< AnyEvent->now >> into
  account.
  
  =item AnyEvent->now_update
  
  Some event loops (such as L<EV> or L<AnyEvent::Loop>) cache the current
  time for each loop iteration (see the discussion of L<< AnyEvent->now >>,
  above).
  
  When a callback runs for a long time (or when the process sleeps), then
  this "current" time will differ substantially from the real time, which
  might affect timers and time-outs.
  
  When this is the case, you can call this method, which will update the
  event loop's idea of "current time".
  
  A typical example would be a script in a web server (e.g. C<mod_perl>) -
  when mod_perl executes the script, then the event loop will have the wrong
  idea about the "current time" (being potentially far in the past, when the
  script ran the last time). In that case you should arrange a call to C<<
  AnyEvent->now_update >> each time the web server process wakes up again
  (e.g. at the start of your script, or in a handler).
  
  Note that updating the time I<might> cause some events to be handled.
  
  =back
  
  =head2 SIGNAL WATCHERS
  
     $w = AnyEvent->signal (signal => <uppercase_signal_name>, cb => <callback>);
  
  You can watch for signals using a signal watcher, C<signal> is the signal
  I<name> in uppercase and without any C<SIG> prefix, C<cb> is the Perl
  callback to be invoked whenever a signal occurs.
  
  Although the callback might get passed parameters, their value and
  presence is undefined and you cannot rely on them. Portable AnyEvent
  callbacks cannot use arguments passed to signal watcher callbacks.
  
  Multiple signal occurrences can be clumped together into one callback
  invocation, and callback invocation will be synchronous. Synchronous means
  that it might take a while until the signal gets handled by the process,
  but it is guaranteed not to interrupt any other callbacks.
  
  The main advantage of using these watchers is that you can share a signal
  between multiple watchers, and AnyEvent will ensure that signals will not
  interrupt your program at bad times.
  
  This watcher might use C<%SIG> (depending on the event loop used),
  so programs overwriting those signals directly will likely not work
  correctly.
  
  Example: exit on SIGINT
  
     my $w = AnyEvent->signal (signal => "INT", cb => sub { exit 1 });
  
  =head3 Restart Behaviour
  
  While restart behaviour is up to the event loop implementation, most will
  not restart syscalls (that includes L<Async::Interrupt> and AnyEvent's
  pure perl implementation).
  
  =head3 Safe/Unsafe Signals
  
  Perl signals can be either "safe" (synchronous to opcode handling)
  or "unsafe" (asynchronous) - the former might delay signal delivery
  indefinitely, the latter might corrupt your memory.
  
  AnyEvent signal handlers are, in addition, synchronous to the event loop,
  i.e. they will not interrupt your running perl program but will only be
  called as part of the normal event handling (just like timer, I/O etc.
  callbacks, too).
  
  =head3 Signal Races, Delays and Workarounds
  
  Many event loops (e.g. Glib, Tk, Qt, IO::Async) do not support
  attaching callbacks to signals in a generic way, which is a pity,
  as you cannot do race-free signal handling in perl, requiring
  C libraries for this. AnyEvent will try to do its best, which
  means in some cases, signals will be delayed. The maximum time
  a signal might be delayed is 10 seconds by default, but can
  be overriden via C<$ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY}> or
  C<$AnyEvent::MAX_SIGNAL_LATENCY> - see the L<ENVIRONMENT VARIABLES>
  section for details.
  
  All these problems can be avoided by installing the optional
  L<Async::Interrupt> module, which works with most event loops. It will not
  work with inherently broken event loops such as L<Event> or L<Event::Lib>
  (and not with L<POE> currently). For those, you just have to suffer the
  delays.
  
  =head2 CHILD PROCESS WATCHERS
  
     $w = AnyEvent->child (pid => <process id>, cb => <callback>);
  
  You can also watch for a child process exit and catch its exit status.
  
  The child process is specified by the C<pid> argument (on some backends,
  using C<0> watches for any child process exit, on others this will
  croak). The watcher will be triggered only when the child process has
  finished and an exit status is available, not on any trace events
  (stopped/continued).
  
  The callback will be called with the pid and exit status (as returned by
  waitpid), so unlike other watcher types, you I<can> rely on child watcher
  callback arguments.
  
  This watcher type works by installing a signal handler for C<SIGCHLD>,
  and since it cannot be shared, nothing else should use SIGCHLD or reap
  random child processes (waiting for specific child processes, e.g. inside
  C<system>, is just fine).
  
  There is a slight catch to child watchers, however: you usually start them
  I<after> the child process was created, and this means the process could
  have exited already (and no SIGCHLD will be sent anymore).
  
  Not all event models handle this correctly (neither POE nor IO::Async do,
  see their AnyEvent::Impl manpages for details), but even for event models
  that I<do> handle this correctly, they usually need to be loaded before
  the process exits (i.e. before you fork in the first place). AnyEvent's
  pure perl event loop handles all cases correctly regardless of when you
  start the watcher.
  
  This means you cannot create a child watcher as the very first
  thing in an AnyEvent program, you I<have> to create at least one
  watcher before you C<fork> the child (alternatively, you can call
  C<AnyEvent::detect>).
  
  As most event loops do not support waiting for child events, they will be
  emulated by AnyEvent in most cases, in which case the latency and race
  problems mentioned in the description of signal watchers apply.
  
  Example: fork a process and wait for it
  
     my $done = AnyEvent->condvar;
    
     # this forks and immediately calls exit in the child. this
     # normally has all sorts of bad consequences for your parent,
     # so take this as an example only. always fork and exec,
     # or call POSIX::_exit, in real code.
     my $pid = fork or exit 5;
    
     my $w = AnyEvent->child (
        pid => $pid,
        cb  => sub {
           my ($pid, $status) = @_;
           warn "pid $pid exited with status $status";
           $done->send;
        },
     );
    
     # do something else, then wait for process exit
     $done->recv;
  
  =head2 IDLE WATCHERS
  
     $w = AnyEvent->idle (cb => <callback>);
  
  This will repeatedly invoke the callback after the process becomes idle,
  until either the watcher is destroyed or new events have been detected.
  
  Idle watchers are useful when there is a need to do something, but it
  is not so important (or wise) to do it instantly. The callback will be
  invoked only when there is "nothing better to do", which is usually
  defined as "all outstanding events have been handled and no new events
  have been detected". That means that idle watchers ideally get invoked
  when the event loop has just polled for new events but none have been
  detected. Instead of blocking to wait for more events, the idle watchers
  will be invoked.
  
  Unfortunately, most event loops do not really support idle watchers (only
  EV, Event and Glib do it in a usable fashion) - for the rest, AnyEvent
  will simply call the callback "from time to time".
  
  Example: read lines from STDIN, but only process them when the
  program is otherwise idle:
  
     my @lines; # read data
     my $idle_w;
     my $io_w = AnyEvent->io (fh => \*STDIN, poll => 'r', cb => sub {
        push @lines, scalar <STDIN>;
  
        # start an idle watcher, if not already done
        $idle_w ||= AnyEvent->idle (cb => sub {
           # handle only one line, when there are lines left
           if (my $line = shift @lines) {
              print "handled when idle: $line";
           } else {
              # otherwise disable the idle watcher again
              undef $idle_w;
           }
        });
     });
  
  =head2 CONDITION VARIABLES
  
     $cv = AnyEvent->condvar;
  
     $cv->send (<list>);
     my @res = $cv->recv;
  
  If you are familiar with some event loops you will know that all of them
  require you to run some blocking "loop", "run" or similar function that
  will actively watch for new events and call your callbacks.
  
  AnyEvent is slightly different: it expects somebody else to run the event
  loop and will only block when necessary (usually when told by the user).
  
  The tool to do that is called a "condition variable", so called because
  they represent a condition that must become true.
  
  Now is probably a good time to look at the examples further below.
  
  Condition variables can be created by calling the C<< AnyEvent->condvar
  >> method, usually without arguments. The only argument pair allowed is
  C<cb>, which specifies a callback to be called when the condition variable
  becomes true, with the condition variable as the first argument (but not
  the results).
  
  After creation, the condition variable is "false" until it becomes "true"
  by calling the C<send> method (or calling the condition variable as if it
  were a callback, read about the caveats in the description for the C<<
  ->send >> method).
  
  Since condition variables are the most complex part of the AnyEvent API, here are
  some different mental models of what they are - pick the ones you can connect to:
  
  =over 4
  
  =item * Condition variables are like callbacks - you can call them (and pass them instead
  of callbacks). Unlike callbacks however, you can also wait for them to be called.
  
  =item * Condition variables are signals - one side can emit or send them,
  the other side can wait for them, or install a handler that is called when
  the signal fires.
  
  =item * Condition variables are like "Merge Points" - points in your program
  where you merge multiple independent results/control flows into one.
  
  =item * Condition variables represent a transaction - functions that start
  some kind of transaction can return them, leaving the caller the choice
  between waiting in a blocking fashion, or setting a callback.
  
  =item * Condition variables represent future values, or promises to deliver
  some result, long before the result is available.
  
  =back
  
  Condition variables are very useful to signal that something has finished,
  for example, if you write a module that does asynchronous http requests,
  then a condition variable would be the ideal candidate to signal the
  availability of results. The user can either act when the callback is
  called or can synchronously C<< ->recv >> for the results.
  
  You can also use them to simulate traditional event loops - for example,
  you can block your main program until an event occurs - for example, you
  could C<< ->recv >> in your main program until the user clicks the Quit
  button of your app, which would C<< ->send >> the "quit" event.
  
  Note that condition variables recurse into the event loop - if you have
  two pieces of code that call C<< ->recv >> in a round-robin fashion, you
  lose. Therefore, condition variables are good to export to your caller, but
  you should avoid making a blocking wait yourself, at least in callbacks,
  as this asks for trouble.
  
  Condition variables are represented by hash refs in perl, and the keys
  used by AnyEvent itself are all named C<_ae_XXX> to make subclassing
  easy (it is often useful to build your own transaction class on top of
  AnyEvent). To subclass, use C<AnyEvent::CondVar> as base class and call
  its C<new> method in your own C<new> method.
  
  There are two "sides" to a condition variable - the "producer side" which
  eventually calls C<< -> send >>, and the "consumer side", which waits
  for the send to occur.
  
  Example: wait for a timer.
  
     # condition: "wait till the timer is fired"
     my $timer_fired = AnyEvent->condvar;
  
     # create the timer - we could wait for, say
     # a handle becomign ready, or even an
     # AnyEvent::HTTP request to finish, but
     # in this case, we simply use a timer:
     my $w = AnyEvent->timer (
        after => 1,
        cb    => sub { $timer_fired->send },
     );
  
     # this "blocks" (while handling events) till the callback
     # calls ->send
     $timer_fired->recv;
  
  Example: wait for a timer, but take advantage of the fact that condition
  variables are also callable directly.
  
     my $done = AnyEvent->condvar;
     my $delay = AnyEvent->timer (after => 5, cb => $done);
     $done->recv;
  
  Example: Imagine an API that returns a condvar and doesn't support
  callbacks. This is how you make a synchronous call, for example from
  the main program:
  
     use AnyEvent::CouchDB;
  
     ...
  
     my @info = $couchdb->info->recv;
  
  And this is how you would just set a callback to be called whenever the
  results are available:
  
     $couchdb->info->cb (sub {
        my @info = $_[0]->recv;
     });
  
  =head3 METHODS FOR PRODUCERS
  
  These methods should only be used by the producing side, i.e. the
  code/module that eventually sends the signal. Note that it is also
  the producer side which creates the condvar in most cases, but it isn't
  uncommon for the consumer to create it as well.
  
  =over 4
  
  =item $cv->send (...)
  
  Flag the condition as ready - a running C<< ->recv >> and all further
  calls to C<recv> will (eventually) return after this method has been
  called. If nobody is waiting the send will be remembered.
  
  If a callback has been set on the condition variable, it is called
  immediately from within send.
  
  Any arguments passed to the C<send> call will be returned by all
  future C<< ->recv >> calls.
  
  Condition variables are overloaded so one can call them directly (as if
  they were a code reference). Calling them directly is the same as calling
  C<send>.
  
  =item $cv->croak ($error)
  
  Similar to send, but causes all calls to C<< ->recv >> to invoke
  C<Carp::croak> with the given error message/object/scalar.
  
  This can be used to signal any errors to the condition variable
  user/consumer. Doing it this way instead of calling C<croak> directly
  delays the error detection, but has the overwhelming advantage that it
  diagnoses the error at the place where the result is expected, and not
  deep in some event callback with no connection to the actual code causing
  the problem.
  
  =item $cv->begin ([group callback])
  
  =item $cv->end
  
  These two methods can be used to combine many transactions/events into
  one. For example, a function that pings many hosts in parallel might want
  to use a condition variable for the whole process.
  
  Every call to C<< ->begin >> will increment a counter, and every call to
  C<< ->end >> will decrement it.  If the counter reaches C<0> in C<< ->end
  >>, the (last) callback passed to C<begin> will be executed, passing the
  condvar as first argument. That callback is I<supposed> to call C<< ->send
  >>, but that is not required. If no group callback was set, C<send> will
  be called without any arguments.
  
  You can think of C<< $cv->send >> giving you an OR condition (one call
  sends), while C<< $cv->begin >> and C<< $cv->end >> giving you an AND
  condition (all C<begin> calls must be C<end>'ed before the condvar sends).
  
  Let's start with a simple example: you have two I/O watchers (for example,
  STDOUT and STDERR for a program), and you want to wait for both streams to
  close before activating a condvar:
  
     my $cv = AnyEvent->condvar;
  
     $cv->begin; # first watcher
     my $w1 = AnyEvent->io (fh => $fh1, cb => sub {
        defined sysread $fh1, my $buf, 4096
           or $cv->end;
     });
  
     $cv->begin; # second watcher
     my $w2 = AnyEvent->io (fh => $fh2, cb => sub {
        defined sysread $fh2, my $buf, 4096
           or $cv->end;
     });
  
     $cv->recv;
  
  This works because for every event source (EOF on file handle), there is
  one call to C<begin>, so the condvar waits for all calls to C<end> before
  sending.
  
  The ping example mentioned above is slightly more complicated, as the
  there are results to be passed back, and the number of tasks that are
  begun can potentially be zero:
  
     my $cv = AnyEvent->condvar;
  
     my %result;
     $cv->begin (sub { shift->send (\%result) });
  
     for my $host (@list_of_hosts) {
        $cv->begin;
        ping_host_then_call_callback $host, sub {
           $result{$host} = ...;
           $cv->end;
        };
     }
  
     $cv->end;
  
     ...
  
     my $results = $cv->recv;
  
  This code fragment supposedly pings a number of hosts and calls
  C<send> after results for all then have have been gathered - in any
  order. To achieve this, the code issues a call to C<begin> when it starts
  each ping request and calls C<end> when it has received some result for
  it. Since C<begin> and C<end> only maintain a counter, the order in which
  results arrive is not relevant.
  
  There is an additional bracketing call to C<begin> and C<end> outside the
  loop, which serves two important purposes: first, it sets the callback
  to be called once the counter reaches C<0>, and second, it ensures that
  C<send> is called even when C<no> hosts are being pinged (the loop
  doesn't execute once).
  
  This is the general pattern when you "fan out" into multiple (but
  potentially zero) subrequests: use an outer C<begin>/C<end> pair to set
  the callback and ensure C<end> is called at least once, and then, for each
  subrequest you start, call C<begin> and for each subrequest you finish,
  call C<end>.
  
  =back
  
  =head3 METHODS FOR CONSUMERS
  
  These methods should only be used by the consuming side, i.e. the
  code awaits the condition.
  
  =over 4
  
  =item $cv->recv
  
  Wait (blocking if necessary) until the C<< ->send >> or C<< ->croak
  >> methods have been called on C<$cv>, while servicing other watchers
  normally.
  
  You can only wait once on a condition - additional calls are valid but
  will return immediately.
  
  If an error condition has been set by calling C<< ->croak >>, then this
  function will call C<croak>.
  
  In list context, all parameters passed to C<send> will be returned,
  in scalar context only the first one will be returned.
  
  Note that doing a blocking wait in a callback is not supported by any
  event loop, that is, recursive invocation of a blocking C<< ->recv >> is
  not allowed and the C<recv> call will C<croak> if such a condition is
  detected. This requirement can be dropped by relying on L<Coro::AnyEvent>
  , which allows you to do a blocking C<< ->recv >> from any thread
  that doesn't run the event loop itself. L<Coro::AnyEvent> is loaded
  automatically when L<Coro> is used with L<AnyEvent>, so code does not need
  to do anything special to take advantage of that: any code that would
  normally block your program because it calls C<recv>, be executed in an
  C<async> thread instead without blocking other threads.
  
  Not all event models support a blocking wait - some die in that case
  (programs might want to do that to stay interactive), so I<if you are
  using this from a module, never require a blocking wait>. Instead, let the
  caller decide whether the call will block or not (for example, by coupling
  condition variables with some kind of request results and supporting
  callbacks so the caller knows that getting the result will not block,
  while still supporting blocking waits if the caller so desires).
  
  You can ensure that C<< ->recv >> never blocks by setting a callback and
  only calling C<< ->recv >> from within that callback (or at a later
  time). This will work even when the event loop does not support blocking
  waits otherwise.
  
  =item $bool = $cv->ready
  
  Returns true when the condition is "true", i.e. whether C<send> or
  C<croak> have been called.
  
  =item $cb = $cv->cb ($cb->($cv))
  
  This is a mutator function that returns the callback set (or C<undef> if
  not) and optionally replaces it before doing so.
  
  The callback will be called when the condition becomes "true", i.e. when
  C<send> or C<croak> are called, with the only argument being the
  condition variable itself. If the condition is already true, the
  callback is called immediately when it is set. Calling C<recv> inside
  the callback or at any later time is guaranteed not to block.
  
  Additionally, when the callback is invoked, it is also removed from the
  condvar (reset to C<undef>), so the condvar does not keep a reference to
  the callback after invocation.
  
  =back
  
  =head1 SUPPORTED EVENT LOOPS/BACKENDS
  
  The following backend classes are part of the AnyEvent distribution (every
  class has its own manpage):
  
  =over 4
  
  =item Backends that are autoprobed when no other event loop can be found.
  
  EV is the preferred backend when no other event loop seems to be in
  use. If EV is not installed, then AnyEvent will fall back to its own
  pure-perl implementation, which is available everywhere as it comes with
  AnyEvent itself.
  
     AnyEvent::Impl::EV        based on EV (interface to libev, best choice).
     AnyEvent::Impl::Perl      pure-perl AnyEvent::Loop, fast and portable.
  
  =item Backends that are transparently being picked up when they are used.
  
  These will be used if they are already loaded when the first watcher
  is created, in which case it is assumed that the application is using
  them. This means that AnyEvent will automatically pick the right backend
  when the main program loads an event module before anything starts to
  create watchers. Nothing special needs to be done by the main program.
  
     AnyEvent::Impl::Event     based on Event, very stable, few glitches.
     AnyEvent::Impl::Glib      based on Glib, slow but very stable.
     AnyEvent::Impl::Tk        based on Tk, very broken.
     AnyEvent::Impl::UV        based on UV, innovated square wheels.
     AnyEvent::Impl::EventLib  based on Event::Lib, leaks memory and worse.
     AnyEvent::Impl::POE       based on POE, very slow, some limitations.
     AnyEvent::Impl::Irssi     used when running within irssi.
     AnyEvent::Impl::IOAsync   based on IO::Async.
     AnyEvent::Impl::Cocoa     based on Cocoa::EventLoop.
     AnyEvent::Impl::FLTK      based on FLTK (fltk 2 binding).
  
  =item Backends with special needs.
  
  Qt requires the Qt::Application to be instantiated first, but will
  otherwise be picked up automatically. As long as the main program
  instantiates the application before any AnyEvent watchers are created,
  everything should just work.
  
     AnyEvent::Impl::Qt        based on Qt.
  
  =item Event loops that are indirectly supported via other backends.
  
  Some event loops can be supported via other modules:
  
  There is no direct support for WxWidgets (L<Wx>) or L<Prima>.
  
  B<WxWidgets> has no support for watching file handles. However, you can
  use WxWidgets through the POE adaptor, as POE has a Wx backend that simply
  polls 20 times per second, which was considered to be too horrible to even
  consider for AnyEvent.
  
  B<Prima> is not supported as nobody seems to be using it, but it has a POE
  backend, so it can be supported through POE.
  
  AnyEvent knows about both L<Prima> and L<Wx>, however, and will try to
  load L<POE> when detecting them, in the hope that POE will pick them up,
  in which case everything will be automatic.
  
  =item Known event loops outside the AnyEvent distribution
  
  The following event loops or programs support AnyEvent by providing their
  own AnyEvent backend. They will be picked up automatically.
  
     urxvt::anyevent           available to rxvt-unicode extensions
  
  =back
  
  =head1 GLOBAL VARIABLES AND FUNCTIONS
  
  These are not normally required to use AnyEvent, but can be useful to
  write AnyEvent extension modules.
  
  =over 4
  
  =item $AnyEvent::MODEL
  
  Contains C<undef> until the first watcher is being created, before the
  backend has been autodetected.
  
  Afterwards it contains the event model that is being used, which is the
  name of the Perl class implementing the model. This class is usually one
  of the C<AnyEvent::Impl::xxx> modules, but can be any other class in the
  case AnyEvent has been extended at runtime (e.g. in I<rxvt-unicode> it
  will be C<urxvt::anyevent>).
  
  =item AnyEvent::detect
  
  Returns C<$AnyEvent::MODEL>, forcing autodetection of the event model
  if necessary. You should only call this function right before you would
  have created an AnyEvent watcher anyway, that is, as late as possible at
  runtime, and not e.g. during initialisation of your module.
  
  The effect of calling this function is as if a watcher had been created
  (specifically, actions that happen "when the first watcher is created"
  happen when calling detetc as well).
  
  If you need to do some initialisation before AnyEvent watchers are
  created, use C<post_detect>.
  
  =item $guard = AnyEvent::post_detect { BLOCK }
  
  Arranges for the code block to be executed as soon as the event model is
  autodetected (or immediately if that has already happened).
  
  The block will be executed I<after> the actual backend has been detected
  (C<$AnyEvent::MODEL> is set), so it is possible to do some initialisation
  only when AnyEvent is actually initialised - see the sources of
  L<AnyEvent::AIO> to see how this is used.
  
  The most common usage is to create some global watchers, without forcing
  event module detection too early. For example, L<AnyEvent::AIO> creates
  and installs the global L<IO::AIO> watcher in a C<post_detect> block to
  avoid autodetecting the event module at load time.
  
  If called in scalar or list context, then it creates and returns an object
  that automatically removes the callback again when it is destroyed (or
  C<undef> when the hook was immediately executed). See L<AnyEvent::AIO> for
  a case where this is useful.
  
  Example: Create a watcher for the IO::AIO module and store it in
  C<$WATCHER>, but do so only do so after the event loop is initialised.
  
     our WATCHER;
  
     my $guard = AnyEvent::post_detect {
        $WATCHER = AnyEvent->io (fh => IO::AIO::poll_fileno, poll => 'r', cb => \&IO::AIO::poll_cb);
     };
  
     # the ||= is important in case post_detect immediately runs the block,
     # as to not clobber the newly-created watcher. assigning both watcher and
     # post_detect guard to the same variable has the advantage of users being
     # able to just C<undef $WATCHER> if the watcher causes them grief.
  
     $WATCHER ||= $guard;
  
  =item @AnyEvent::post_detect
  
  This is a lower level interface then C<AnyEvent::post_detect> (the
  function). This variable is mainly useful for modules that can do
  something useful when AnyEvent is used and thus want to know when it
  is initialised, but do not need to even load it by default. This array
  provides the means to hook into AnyEvent passively, without loading it.
  
  Here is how it works: If there are any code references in this array (you
  can C<push> to it before or after loading AnyEvent), then they will be
  called directly after the event loop has been chosen.
  
  You should check C<$AnyEvent::MODEL> before adding to this array, though:
  if it is defined then the event loop has already been detected, and the
  array will be ignored.
  
  Best use C<AnyEvent::post_detect { BLOCK }> when your application allows
  it, as it takes care of these details.
  
  Example: To load Coro::AnyEvent whenever Coro and AnyEvent are used
  together, you could put this into Coro (this is the actual code used by
  Coro to accomplish this):
  
     if (defined $AnyEvent::MODEL) {
        # AnyEvent already initialised, so load Coro::AnyEvent
        require Coro::AnyEvent;
     } else {
        # AnyEvent not yet initialised, so make sure to load Coro::AnyEvent
        # as soon as it is
        push @AnyEvent::post_detect, sub { require Coro::AnyEvent };
     }
  
  =item AnyEvent::postpone { BLOCK }
  
  Arranges for the block to be executed as soon as possible, but not before
  the call itself returns. In practise, the block will be executed just
  before the event loop polls for new events, or shortly afterwards.
  
  This function never returns anything (to make the C<return postpone { ...
  }> idiom more useful.
  
  To understand the usefulness of this function, consider a function that
  asynchronously does something for you and returns some transaction
  object or guard to let you cancel the operation. For example,
  C<AnyEvent::Socket::tcp_connect>:
  
     # start a connection attempt unless one is active
     $self->{connect_guard} ||= AnyEvent::Socket::tcp_connect "www.example.net", 80, sub {
        delete $self->{connect_guard};
        ...
     };
  
  Imagine that this function could instantly call the callback, for
  example, because it detects an obvious error such as a negative port
  number. Invoking the callback before the function returns causes problems
  however: the callback will be called and will try to delete the guard
  object. But since the function hasn't returned yet, there is nothing to
  delete. When the function eventually returns it will assign the guard
  object to C<< $self->{connect_guard} >>, where it will likely never be
  deleted, so the program thinks it is still trying to connect.
  
  This is where C<AnyEvent::postpone> should be used. Instead of calling the
  callback directly on error:
  
     $cb->(undef), return # signal error to callback, BAD!
        if $some_error_condition;
  
  It should use C<postpone>:
  
     AnyEvent::postpone { $cb->(undef) }, return # signal error to callback, later
        if $some_error_condition;
  
  =item AnyEvent::log $level, $msg[, @args]
  
  Log the given C<$msg> at the given C<$level>.
  
  If L<AnyEvent::Log> is not loaded then this function makes a simple test
  to see whether the message will be logged. If the test succeeds it will
  load AnyEvent::Log and call C<AnyEvent::Log::log> - consequently, look at
  the L<AnyEvent::Log> documentation for details.
  
  If the test fails it will simply return. Right now this happens when a
  numerical loglevel is used and it is larger than the level specified via
  C<$ENV{PERL_ANYEVENT_VERBOSE}>.
  
  If you want to sprinkle loads of logging calls around your code, consider
  creating a logger callback with the C<AnyEvent::Log::logger> function,
  which can reduce typing, codesize and can reduce the logging overhead
  enourmously.
  
  =item AnyEvent::fh_block $filehandle
  
  =item AnyEvent::fh_unblock $filehandle
  
  Sets blocking or non-blocking behaviour for the given filehandle.
  
  =back
  
  =head1 WHAT TO DO IN A MODULE
  
  As a module author, you should C<use AnyEvent> and call AnyEvent methods
  freely, but you should not load a specific event module or rely on it.
  
  Be careful when you create watchers in the module body - AnyEvent will
  decide which event module to use as soon as the first method is called, so
  by calling AnyEvent in your module body you force the user of your module
  to load the event module first.
  
  Never call C<< ->recv >> on a condition variable unless you I<know> that
  the C<< ->send >> method has been called on it already. This is
  because it will stall the whole program, and the whole point of using
  events is to stay interactive.
  
  It is fine, however, to call C<< ->recv >> when the user of your module
  requests it (i.e. if you create a http request object ad have a method
  called C<results> that returns the results, it may call C<< ->recv >>
  freely, as the user of your module knows what she is doing. Always).
  
  =head1 WHAT TO DO IN THE MAIN PROGRAM
  
  There will always be a single main program - the only place that should
  dictate which event model to use.
  
  If the program is not event-based, it need not do anything special, even
  when it depends on a module that uses an AnyEvent. If the program itself
  uses AnyEvent, but does not care which event loop is used, all it needs
  to do is C<use AnyEvent>. In either case, AnyEvent will choose the best
  available loop implementation.
  
  If the main program relies on a specific event model - for example, in
  Gtk2 programs you have to rely on the Glib module - you should load the
  event module before loading AnyEvent or any module that uses it: generally
  speaking, you should load it as early as possible. The reason is that
  modules might create watchers when they are loaded, and AnyEvent will
  decide on the event model to use as soon as it creates watchers, and it
  might choose the wrong one unless you load the correct one yourself.
  
  You can chose to use a pure-perl implementation by loading the
  C<AnyEvent::Loop> module, which gives you similar behaviour
  everywhere, but letting AnyEvent chose the model is generally better.
  
  =head2 MAINLOOP EMULATION
  
  Sometimes (often for short test scripts, or even standalone programs who
  only want to use AnyEvent), you do not want to run a specific event loop.
  
  In that case, you can use a condition variable like this:
  
     AnyEvent->condvar->recv;
  
  This has the effect of entering the event loop and looping forever.
  
  Note that usually your program has some exit condition, in which case
  it is better to use the "traditional" approach of storing a condition
  variable somewhere, waiting for it, and sending it when the program should
  exit cleanly.
  
  
  =head1 OTHER MODULES
  
  The following is a non-exhaustive list of additional modules that use
  AnyEvent as a client and can therefore be mixed easily with other
  AnyEvent modules and other event loops in the same program. Some of the
  modules come as part of AnyEvent, the others are available via CPAN (see
  L<http://search.cpan.org/search?m=module&q=anyevent%3A%3A*> for
  a longer non-exhaustive list), and the list is heavily biased towards
  modules of the AnyEvent author himself :)
  
  =over 4
  
  =item L<AnyEvent::Util> (part of the AnyEvent distribution)
  
  Contains various utility functions that replace often-used blocking
  functions such as C<inet_aton> with event/callback-based versions.
  
  =item L<AnyEvent::Socket> (part of the AnyEvent distribution)
  
  Provides various utility functions for (internet protocol) sockets,
  addresses and name resolution. Also functions to create non-blocking tcp
  connections or tcp servers, with IPv6 and SRV record support and more.
  
  =item L<AnyEvent::Handle> (part of the AnyEvent distribution)
  
  Provide read and write buffers, manages watchers for reads and writes,
  supports raw and formatted I/O, I/O queued and fully transparent and
  non-blocking SSL/TLS (via L<AnyEvent::TLS>).
  
  =item L<AnyEvent::DNS> (part of the AnyEvent distribution)
  
  Provides rich asynchronous DNS resolver capabilities.
  
  =item L<AnyEvent::HTTP>, L<AnyEvent::IRC>, L<AnyEvent::XMPP>, L<AnyEvent::GPSD>, L<AnyEvent::IGS>, L<AnyEvent::FCP>
  
  Implement event-based interfaces to the protocols of the same name (for
  the curious, IGS is the International Go Server and FCP is the Freenet
  Client Protocol).
  
  =item L<AnyEvent::AIO> (part of the AnyEvent distribution)
  
  Truly asynchronous (as opposed to non-blocking) I/O, should be in the
  toolbox of every event programmer. AnyEvent::AIO transparently fuses
  L<IO::AIO> and AnyEvent together, giving AnyEvent access to event-based
  file I/O, and much more.
  
  =item L<AnyEvent::Fork>, L<AnyEvent::Fork::RPC>, L<AnyEvent::Fork::Pool>, L<AnyEvent::Fork::Remote>
  
  These let you safely fork new subprocesses, either locally or
  remotely (e.g.v ia ssh), using some RPC protocol or not, without
  the limitations normally imposed by fork (AnyEvent works fine for
  example). Dynamically-resized worker pools are obviously included as well.
  
  And they are quite tiny and fast as well - "abusing" L<AnyEvent::Fork>
  just to exec external programs can easily beat using C<fork> and C<exec>
  (or even C<system>) in most programs.
  
  =item L<AnyEvent::Filesys::Notify>
  
  AnyEvent is good for non-blocking stuff, but it can't detect file or
  path changes (e.g. "watch this directory for new files", "watch this
  file for changes"). The L<AnyEvent::Filesys::Notify> module promises to
  do just that in a portbale fashion, supporting inotify on GNU/Linux and
  some weird, without doubt broken, stuff on OS X to monitor files. It can
  fall back to blocking scans at regular intervals transparently on other
  platforms, so it's about as portable as it gets.
  
  (I haven't used it myself, but it seems the biggest problem with it is
  it quite bad performance).
  
  =item L<AnyEvent::DBI>
  
  Executes L<DBI> requests asynchronously in a proxy process for you,
  notifying you in an event-based way when the operation is finished.
  
  =item L<AnyEvent::FastPing>
  
  The fastest ping in the west.
  
  =item L<Coro>
  
  Has special support for AnyEvent via L<Coro::AnyEvent>, which allows you
  to simply invert the flow control - don't call us, we will call you:
  
     async {
        Coro::AnyEvent::sleep 5; # creates a 5s timer and waits for it
        print "5 seconds later!\n";
  
        Coro::AnyEvent::readable *STDIN; # uses an I/O watcher
        my $line = <STDIN>; # works for ttys
  
        AnyEvent::HTTP::http_get "url", Coro::rouse_cb;
        my ($body, $hdr) = Coro::rouse_wait;
     };
  
  =back
  
  =cut
  
  package AnyEvent;
  
  BEGIN {
     require "AnyEvent/constants.pm";
     &AnyEvent::common_sense;
  }
  
  use Carp ();
  
  our $VERSION = 7.17;
  our $MODEL;
  our @ISA;
  our @REGISTRY;
  our $VERBOSE;
  our %PROTOCOL; # (ipv4|ipv6) => (1|2), higher numbers are preferred
  our $MAX_SIGNAL_LATENCY = $ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY} || 10; # executes after the BEGIN block below (tainting!)
  
  BEGIN {
     eval "sub TAINT (){" . (${^TAINT}*1) . "}";
  
     delete @ENV{grep /^PERL_ANYEVENT_/, keys %ENV}
        if ${^TAINT};
  
     $ENV{"PERL_ANYEVENT_$_"} = $ENV{"AE_$_"}
        for grep s/^AE_// && !exists $ENV{"PERL_ANYEVENT_$_"}, keys %ENV;
  
     @ENV{grep /^PERL_ANYEVENT_/, keys %ENV} = ()
        if ${^TAINT};
  
     # $ENV{PERL_ANYEVENT_xxx} now valid
  
     $VERBOSE = length $ENV{PERL_ANYEVENT_VERBOSE} ? $ENV{PERL_ANYEVENT_VERBOSE}*1 : 4;
  
     my $idx;
     $PROTOCOL{$_} = ++$idx
        for reverse split /\s*,\s*/,
               $ENV{PERL_ANYEVENT_PROTOCOLS} || "ipv4,ipv6";
  }
  
  our @post_detect;
  
  sub post_detect(&) {
     my ($cb) = @_;
  
     push @post_detect, $cb;
  
     defined wantarray
        ? bless \$cb, "AnyEvent::Util::postdetect"
        : ()
  }
  
  sub AnyEvent::Util::postdetect::DESTROY {
     @post_detect = grep $_ != ${$_[0]}, @post_detect;
  }
  
  our $POSTPONE_W;
  our @POSTPONE;
  
  sub _postpone_exec {
     undef $POSTPONE_W;
  
     &{ shift @POSTPONE }
        while @POSTPONE;
  }
  
  sub postpone(&) {
     push @POSTPONE, shift;
  
     $POSTPONE_W ||= AE::timer (0, 0, \&_postpone_exec);
  
     ()
  }
  
  sub log($$;@) {
     # only load the big bloated module when we actually are about to log something
     if ($_[0] <= ($VERBOSE || 1)) { # also catches non-numeric levels(!) and fatal
        local ($!, $@);
        require AnyEvent::Log; # among other things, sets $VERBOSE to 9
        # AnyEvent::Log overwrites this function
        goto &log;
     }
  
     0 # not logged
  }
  
  sub _logger($;$) {
     my ($level, $renabled) = @_;
  
     $$renabled = $level <= $VERBOSE;
  
     my $logger = [(caller)[0], $level, $renabled];
  
     $AnyEvent::Log::LOGGER{$logger+0} = $logger;
  
  #   return unless defined wantarray;
  # 
  #   require AnyEvent::Util;
  #   my $guard = AnyEvent::Util::guard (sub {
  #      # "clean up"
  #      delete $LOGGER{$logger+0};
  #   });
  # 
  #   sub {
  #      return 0 unless $$renabled;
  # 
  #      $guard if 0; # keep guard alive, but don't cause runtime overhead
  #      require AnyEvent::Log unless $AnyEvent::Log::VERSION;
  #      package AnyEvent::Log;
  #      _log ($logger->[0], $level, @_) # logger->[0] has been converted at load time
  #   }
  }
  
  if (length $ENV{PERL_ANYEVENT_LOG}) {
     require AnyEvent::Log; # AnyEvent::Log does the thing for us
  }
  
  BEGIN {
     *_fh_nonblocking = AnyEvent::WIN32
        ? sub($$) {
            ioctl $_[0], 0x8004667e, pack "L", $_[1]; # FIONBIO
          }
        : sub($$) {
            fcntl $_[0], AnyEvent::F_SETFL, $_[1] ? AnyEvent::O_NONBLOCK : 0;
          }
     ;
  }
  
  sub fh_block($) {
     _fh_nonblocking shift, 0
  }
  
  sub fh_unblock($) {
     _fh_nonblocking shift, 1
  }
  
  our @models = (
     [EV::                   => AnyEvent::Impl::EV::],
     [AnyEvent::Loop::       => AnyEvent::Impl::Perl::],
     # everything below here will not (normally) be autoprobed
     # as the pure perl backend should work everywhere
     # and is usually faster
     [Irssi::                => AnyEvent::Impl::Irssi::],    # Irssi has a bogus "Event" package, so msut be near the top
     [Event::                => AnyEvent::Impl::Event::],    # slow, stable
     [Glib::                 => AnyEvent::Impl::Glib::],     # becomes extremely slow with many watchers
     # everything below here should not be autoloaded
     [Event::Lib::           => AnyEvent::Impl::EventLib::], # too buggy
     [Tk::                   => AnyEvent::Impl::Tk::],       # crashes with many handles
     [UV::                   => AnyEvent::Impl::UV::],       # switched from libev, added back all bugs imaginable
     [Qt::                   => AnyEvent::Impl::Qt::],       # requires special main program
     [POE::Kernel::          => AnyEvent::Impl::POE::],      # lasciate ogni speranza
     [Wx::                   => AnyEvent::Impl::POE::],
     [Prima::                => AnyEvent::Impl::POE::],
     [IO::Async::Loop::      => AnyEvent::Impl::IOAsync::],  # a bitch to autodetect
     [Cocoa::EventLoop::     => AnyEvent::Impl::Cocoa::],
     [FLTK::                 => AnyEvent::Impl::FLTK::],
  );
  
  our @isa_hook;
  
  sub _isa_set {
     my @pkg = ("AnyEvent", (map $_->[0], grep defined, @isa_hook), $MODEL);
  
     @{"$pkg[$_-1]::ISA"} = $pkg[$_]
        for 1 .. $#pkg;
  
     grep $_ && $_->[1], @isa_hook
        and AE::_reset ();
  }
  
  # used for hooking AnyEvent::Strict and AnyEvent::Debug::Wrap into the class hierarchy
  sub _isa_hook($$;$) {
     my ($i, $pkg, $reset_ae) = @_;
  
     $isa_hook[$i] = $pkg ? [$pkg, $reset_ae] : undef;
  
     _isa_set;
  }
  
  # all autoloaded methods reserve the complete glob, not just the method slot.
  # due to bugs in perls method cache implementation.
  our @methods = qw(io timer time now now_update signal child idle condvar);
  
  sub detect() {
     return $MODEL if $MODEL; # some programs keep references to detect
  
     # IO::Async::Loop::AnyEvent is extremely evil, refuse to work with it
     # the author knows about the problems and what it does to AnyEvent as a whole
     # (and the ability of others to use AnyEvent), but simply wants to abuse AnyEvent
     # anyway.
     AnyEvent::log fatal => "IO::Async::Loop::AnyEvent detected - that module is broken by\n"
                          . "design, abuses internals and breaks AnyEvent - will not continue."
        if exists $INC{"IO/Async/Loop/AnyEvent.pm"};
  
     local $!; # for good measure
     local $SIG{__DIE__}; # we use eval
  
     # free some memory
     *detect = sub () { $MODEL };
     # undef &func doesn't correctly update the method cache. grmbl.
     # so we delete the whole glob. grmbl.
     # otoh, perl doesn't let me undef an active usb, but it lets me free
     # a glob with an active sub. hrm. i hope it works, but perl is
     # usually buggy in this department. sigh.
     delete @{"AnyEvent::"}{@methods};
     undef @methods;
  
     if ($ENV{PERL_ANYEVENT_MODEL} =~ /^([a-zA-Z0-9:]+)$/) {
        my $model = $1;
        $model = "AnyEvent::Impl::$model" unless $model =~ s/::$//;
        if (eval "require $model") {
           AnyEvent::log 7 => "Loaded model '$model' (forced by \$ENV{PERL_ANYEVENT_MODEL}), using it.";
           $MODEL = $model;
        } else {
           AnyEvent::log 4 => "Unable to load model '$model' (from \$ENV{PERL_ANYEVENT_MODEL}):\n$@";
        }
     }
  
     # check for already loaded models
     unless ($MODEL) {
        for (@REGISTRY, @models) {
           my ($package, $model) = @$_;
           if (${"$package\::VERSION"} > 0) {
              if (eval "require $model") {
                 AnyEvent::log 7 => "Autodetected model '$model', using it.";
                 $MODEL = $model;
                 last;
              } else {
                 AnyEvent::log 8 => "Detected event loop $package, but cannot load '$model', skipping: $@";
              }
           }
        }
  
        unless ($MODEL) {
           # try to autoload a model
           for (@REGISTRY, @models) {
              my ($package, $model) = @$_;
              if (
                 eval "require $package"
                 and ${"$package\::VERSION"} > 0
                 and eval "require $model"
              ) {
                 AnyEvent::log 7 => "Autoloaded model '$model', using it.";
                 $MODEL = $model;
                 last;
              }
           }
  
           $MODEL
             or AnyEvent::log fatal => "Backend autodetection failed - did you properly install AnyEvent?";
        }
     }
  
     # free memory only needed for probing
     undef @models;
     undef @REGISTRY;
  
     push @{"$MODEL\::ISA"}, "AnyEvent::Base";
  
     # now nuke some methods that are overridden by the backend.
     # SUPER usage is not allowed in these.
     for (qw(time signal child idle)) {
        undef &{"AnyEvent::Base::$_"}
           if defined &{"$MODEL\::$_"};
     }
  
     _isa_set;
  
     # we're officially open!
  
     if ($ENV{PERL_ANYEVENT_STRICT}) {
        require AnyEvent::Strict;
     }
  
     if ($ENV{PERL_ANYEVENT_DEBUG_WRAP}) {
        require AnyEvent::Debug;
        AnyEvent::Debug::wrap ($ENV{PERL_ANYEVENT_DEBUG_WRAP});
     }
  
     if (length $ENV{PERL_ANYEVENT_DEBUG_SHELL}) {
        require AnyEvent::Socket;
        require AnyEvent::Debug;
  
        my $shell = $ENV{PERL_ANYEVENT_DEBUG_SHELL};
        $shell =~ s/\$\$/$$/g;
  
        my ($host, $service) = AnyEvent::Socket::parse_hostport ($shell);
        $AnyEvent::Debug::SHELL = AnyEvent::Debug::shell ($host, $service);
     }
  
     # now the anyevent environment is set up as the user told us to, so
     # call the actual user code - post detects
  
     (shift @post_detect)->() while @post_detect;
     undef @post_detect;
  
     *post_detect = sub(&) {
        shift->();
  
        undef
     };
  
     $MODEL
  }
  
  for my $name (@methods) {
     *$name = sub {
        detect;
        # we use goto because
        # a) it makes the thunk more transparent
        # b) it allows us to delete the thunk later
        goto &{ UNIVERSAL::can AnyEvent => "SUPER::$name" }
     };
  }
  
  # utility function to dup a filehandle. this is used by many backends
  # to support binding more than one watcher per filehandle (they usually
  # allow only one watcher per fd, so we dup it to get a different one).
  sub _dupfh($$;$$) {
     my ($poll, $fh, $r, $w) = @_;
  
     # cygwin requires the fh mode to be matching, unix doesn't
     my ($rw, $mode) = $poll eq "r" ? ($r, "<&") : ($w, ">&");
  
     open my $fh2, $mode, $fh
        or die "AnyEvent->io: cannot dup() filehandle in mode '$poll': $!,";
  
     # we assume CLOEXEC is already set by perl in all important cases
  
     ($fh2, $rw)
  }
  
  =head1 SIMPLIFIED AE API
  
  Starting with version 5.0, AnyEvent officially supports a second, much
  simpler, API that is designed to reduce the calling, typing and memory
  overhead by using function call syntax and a fixed number of parameters.
  
  See the L<AE> manpage for details.
  
  =cut
  
  package AE;
  
  our $VERSION = $AnyEvent::VERSION;
  
  sub _reset() {
     eval q{
        # fall back to the main API by default - backends and AnyEvent::Base
        # implementations can overwrite these.
  
        sub io($$$) {
           AnyEvent->io (fh => $_[0], poll => $_[1] ? "w" : "r", cb => $_[2])
        }
  
        sub timer($$$) {
           AnyEvent->timer (after => $_[0], interval => $_[1], cb => $_[2])
        }
  
        sub signal($$) {
           AnyEvent->signal (signal => $_[0], cb => $_[1])
        }
  
        sub child($$) {
           AnyEvent->child (pid => $_[0], cb => $_[1])
        }
  
        sub idle($) {
           AnyEvent->idle (cb => $_[0]);
        }
  
        sub cv(;&) {
           AnyEvent->condvar (@_ ? (cb => $_[0]) : ())
        }
  
        sub now() {
           AnyEvent->now
        }
  
        sub now_update() {
           AnyEvent->now_update
        }
  
        sub time() {
           AnyEvent->time
        }
  
        *postpone = \&AnyEvent::postpone;
        *log      = \&AnyEvent::log;
     };
     die if $@;
  }
  
  BEGIN { _reset }
  
  package AnyEvent::Base;
  
  # default implementations for many methods
  
  sub time {
     eval q{ # poor man's autoloading {}
        # probe for availability of Time::HiRes
        if (eval "use Time::HiRes (); Time::HiRes::time (); 1") {
           *time     = sub { Time::HiRes::time () };
           *AE::time = \&    Time::HiRes::time     ;
           *now      = \&time;
           AnyEvent::log 8 => "using Time::HiRes for sub-second timing accuracy.";
           # if (eval "use POSIX (); (POSIX::times())...
        } else {
           *time     = sub   { CORE::time };
           *AE::time = sub (){ CORE::time };
           *now      = \&time;
           AnyEvent::log 3 => "Using built-in time(), no sub-second resolution!";
        }
     };
     die if $@;
  
     &time
  }
  
  *now = \&time;
  sub now_update { }
  
  sub _poll {
     Carp::croak "$AnyEvent::MODEL does not support blocking waits. Caught";
  }
  
  # default implementation for ->condvar
  # in fact, the default should not be overwritten
  
  sub condvar {
     eval q{ # poor man's autoloading {}
        *condvar = sub {
           bless { @_ == 3 ? (_ae_cb => $_[2]) : () }, "AnyEvent::CondVar"
        };
  
        *AE::cv = sub (;&) {
           bless { @_ ? (_ae_cb => shift) : () }, "AnyEvent::CondVar"
        };
     };
     die if $@;
  
     &condvar
  }
  
  # default implementation for ->signal
  
  our $HAVE_ASYNC_INTERRUPT;
  
  sub _have_async_interrupt() {
     $HAVE_ASYNC_INTERRUPT = 1*(!$ENV{PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT}
                                && eval "use Async::Interrupt 1.02 (); 1")
        unless defined $HAVE_ASYNC_INTERRUPT;
  
     $HAVE_ASYNC_INTERRUPT
  }
  
  our ($SIGPIPE_R, $SIGPIPE_W, %SIG_CB, %SIG_EV, $SIG_IO);
  our (%SIG_ASY, %SIG_ASY_W);
  our ($SIG_COUNT, $SIG_TW);
  
  # install a dummy wakeup watcher to reduce signal catching latency
  # used by Impls
  sub _sig_add() {
     unless ($SIG_COUNT++) {
        # try to align timer on a full-second boundary, if possible
        my $NOW = AE::now;
  
        $SIG_TW = AE::timer
           $MAX_SIGNAL_LATENCY - ($NOW - int $NOW),
           $MAX_SIGNAL_LATENCY,
           sub { } # just for the PERL_ASYNC_CHECK
        ;
     }
  }
  
  sub _sig_del {
     undef $SIG_TW
        unless --$SIG_COUNT;
  }
  
  our $_sig_name_init; $_sig_name_init = sub {
     eval q{ # poor man's autoloading {}
        undef $_sig_name_init;
  
        if (_have_async_interrupt) {
           *sig2num  = \&Async::Interrupt::sig2num;
           *sig2name = \&Async::Interrupt::sig2name;
        } else {
           require Config;
  
           my %signame2num;
           @signame2num{ split ' ', $Config::Config{sig_name} }
                          = split ' ', $Config::Config{sig_num};
  
           my @signum2name;
           @signum2name[values %signame2num] = keys %signame2num;
  
           *sig2num = sub($) {
              $_[0] > 0 ? shift : $signame2num{+shift}
           };
           *sig2name = sub ($) {
              $_[0] > 0 ? $signum2name[+shift] : shift
           };
        }
     };
     die if $@;
  };
  
  sub sig2num ($) { &$_sig_name_init; &sig2num  }
  sub sig2name($) { &$_sig_name_init; &sig2name }
  
  sub signal {
     eval q{ # poor man's autoloading {}
        # probe for availability of Async::Interrupt 
        if (_have_async_interrupt) {
           AnyEvent::log 8 => "Using Async::Interrupt for race-free signal handling.";
  
           $SIGPIPE_R = new Async::Interrupt::EventPipe;
           $SIG_IO = AE::io $SIGPIPE_R->fileno, 0, \&_signal_exec;
  
        } else {
           AnyEvent::log 8 => "Using emulated perl signal handling with latency timer.";
  
           if (AnyEvent::WIN32) {
              require AnyEvent::Util;
  
              ($SIGPIPE_R, $SIGPIPE_W) = AnyEvent::Util::portable_pipe ();
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_R, 1) if $SIGPIPE_R;
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_W, 1) if $SIGPIPE_W; # just in case
           } else {
              pipe $SIGPIPE_R, $SIGPIPE_W;
              fcntl $SIGPIPE_R, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_R;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_W; # just in case
  
              # not strictly required, as $^F is normally 2, but let's make sure...
              fcntl $SIGPIPE_R, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
           }
  
           $SIGPIPE_R
              or Carp::croak "AnyEvent: unable to create a signal reporting pipe: $!\n";
  
           $SIG_IO = AE::io $SIGPIPE_R, 0, \&_signal_exec;
        }
  
        *signal = $HAVE_ASYNC_INTERRUPT
           ? sub {
                my (undef, %arg) = @_;
  
                # async::interrupt
                my $signal = sig2num $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG_ASY{$signal} ||= new Async::Interrupt
                   cb             => sub { undef $SIG_EV{$signal} },
                   signal         => $signal,
                   pipe           => [$SIGPIPE_R->filenos],
                   pipe_autodrain => 0,
                ;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
           : sub {
                my (undef, %arg) = @_;
  
                # pure perl
                my $signal = sig2name $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG{$signal} ||= sub {
                   local $!;
                   syswrite $SIGPIPE_W, "\x00", 1 unless %SIG_EV;
                   undef $SIG_EV{$signal};
                };
  
                # can't do signal processing without introducing races in pure perl,
                # so limit the signal latency.
                _sig_add;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
        ;
  
        *AnyEvent::Base::signal::DESTROY = sub {
           my ($signal, $cb) = @{$_[0]};
  
           _sig_del;
  
           delete $SIG_CB{$signal}{$cb};
  
           $HAVE_ASYNC_INTERRUPT
              ? delete $SIG_ASY{$signal}
              : # delete doesn't work with older perls - they then
                # print weird messages, or just unconditionally exit
                # instead of getting the default action.
                undef $SIG{$signal}
              unless keys %{ $SIG_CB{$signal} };
        };
  
        *_signal_exec = sub {
           $HAVE_ASYNC_INTERRUPT
              ? $SIGPIPE_R->drain
              : sysread $SIGPIPE_R, (my $dummy), 9;
  
           while (%SIG_EV) {
              for (keys %SIG_EV) {
                 delete $SIG_EV{$_};
                 &$_ for values %{ $SIG_CB{$_} || {} };
              }
           }
        };
     };
     die if $@;
  
     &signal
  }
  
  # default implementation for ->child
  
  our %PID_CB;
  our $CHLD_W;
  our $CHLD_DELAY_W;
  
  # used by many Impl's
  sub _emit_childstatus($$) {
     my (undef, $rpid, $rstatus) = @_;
  
     $_->($rpid, $rstatus)
        for values %{ $PID_CB{$rpid} || {} },
            values %{ $PID_CB{0}     || {} };
  }
  
  sub child {
     eval q{ # poor man's autoloading {}
        *_sigchld = sub {
           my $pid;
  
           AnyEvent->_emit_childstatus ($pid, $?)
              while ($pid = waitpid -1, WNOHANG) > 0;
        };
  
        *child = sub {
           my (undef, %arg) = @_;
  
           my $pid = $arg{pid};
           my $cb  = $arg{cb};
  
           $PID_CB{$pid}{$cb+0} = $cb;
  
           unless ($CHLD_W) {
              $CHLD_W = AE::signal CHLD => \&_sigchld;
              # child could be a zombie already, so make at least one round
              &_sigchld;
           }
  
           bless [$pid, $cb+0], "AnyEvent::Base::child"
        };
  
        *AnyEvent::Base::child::DESTROY = sub {
           my ($pid, $icb) = @{$_[0]};
  
           delete $PID_CB{$pid}{$icb};
           delete $PID_CB{$pid} unless keys %{ $PID_CB{$pid} };
  
           undef $CHLD_W unless keys %PID_CB;
        };
     };
     die if $@;
  
     &child
  }
  
  # idle emulation is done by simply using a timer, regardless
  # of whether the process is idle or not, and not letting
  # the callback use more than 50% of the time.
  sub idle {
     eval q{ # poor man's autoloading {}
        *idle = sub {
           my (undef, %arg) = @_;
  
           my ($cb, $w, $rcb) = $arg{cb};
  
           $rcb = sub {
              if ($cb) {
                 $w = AE::time;
                 &$cb;
                 $w = AE::time - $w;
  
                 # never use more then 50% of the time for the idle watcher,
                 # within some limits
                 $w = 0.0001 if $w < 0.0001;
                 $w = 5      if $w > 5;
  
                 $w = AE::timer $w, 0, $rcb;
              } else {
                 # clean up...
                 undef $w;
                 undef $rcb;
              }
           };
  
           $w = AE::timer 0.05, 0, $rcb;
  
           bless \\$cb, "AnyEvent::Base::idle"
        };
  
        *AnyEvent::Base::idle::DESTROY = sub {
           undef $${$_[0]};
        };
     };
     die if $@;
  
     &idle
  }
  
  package AnyEvent::CondVar;
  
  our @ISA = AnyEvent::CondVar::Base::;
  
  # only to be used for subclassing
  sub new {
     my $class = shift;
     bless AnyEvent->condvar (@_), $class
  }
  
  package AnyEvent::CondVar::Base;
  
  #use overload
  #   '&{}'    => sub { my $self = shift; sub { $self->send (@_) } },
  #   fallback => 1;
  
  # save 300+ kilobytes by dirtily hardcoding overloading
  ${"AnyEvent::CondVar::Base::OVERLOAD"}{dummy}++; # Register with magic by touching.
  *{'AnyEvent::CondVar::Base::()'}   = sub { }; # "Make it findable via fetchmethod."
  *{'AnyEvent::CondVar::Base::(&{}'} = sub { my $self = shift; sub { $self->send (@_) } }; # &{}
  ${'AnyEvent::CondVar::Base::()'}   = 1; # fallback
  
  our $WAITING;
  
  sub _send {
     # nop
  }
  
  sub _wait {
     AnyEvent->_poll until $_[0]{_ae_sent};
  }
  
  sub send {
     my $cv = shift;
     $cv->{_ae_sent} = [@_];
     (delete $cv->{_ae_cb})->($cv) if $cv->{_ae_cb};
     $cv->_send;
  }
  
  sub croak {
     $_[0]{_ae_croak} = $_[1];
     $_[0]->send;
  }
  
  sub ready {
     $_[0]{_ae_sent}
  }
  
  sub recv {
     unless ($_[0]{_ae_sent}) {
        $WAITING
           and Carp::croak "AnyEvent::CondVar: recursive blocking wait attempted";
  
        local $WAITING = 1;
        $_[0]->_wait;
     }
  
     $_[0]{_ae_croak}
        and Carp::croak $_[0]{_ae_croak};
  
     wantarray
        ? @{ $_[0]{_ae_sent} }
        : $_[0]{_ae_sent}[0]
  }
  
  sub cb {
     my $cv = shift;
  
     @_
        and $cv->{_ae_cb} = shift
        and $cv->{_ae_sent}
        and (delete $cv->{_ae_cb})->($cv);
  
     $cv->{_ae_cb}
  }
  
  sub begin {
     ++$_[0]{_ae_counter};
     $_[0]{_ae_end_cb} = $_[1] if @_ > 1;
  }
  
  sub end {
     return if --$_[0]{_ae_counter};
     &{ $_[0]{_ae_end_cb} || sub { $_[0]->send } };
  }
  
  # undocumented/compatibility with pre-3.4
  *broadcast = \&send;
  *wait      = \&recv;
  
  =head1 ERROR AND EXCEPTION HANDLING
  
  In general, AnyEvent does not do any error handling - it relies on the
  caller to do that if required. The L<AnyEvent::Strict> module (see also
  the C<PERL_ANYEVENT_STRICT> environment variable, below) provides strict
  checking of all AnyEvent methods, however, which is highly useful during
  development.
  
  As for exception handling (i.e. runtime errors and exceptions thrown while
  executing a callback), this is not only highly event-loop specific, but
  also not in any way wrapped by this module, as this is the job of the main
  program.
  
  The pure perl event loop simply re-throws the exception (usually
  within C<< condvar->recv >>), the L<Event> and L<EV> modules call C<<
  $Event/EV::DIED->() >>, L<Glib> uses C<< install_exception_handler >> and
  so on.
  
  =head1 ENVIRONMENT VARIABLES
  
  AnyEvent supports a number of environment variables that tune the
  runtime behaviour. They are usually evaluated when AnyEvent is
  loaded, initialised, or a submodule that uses them is loaded. Many of
  them also cause AnyEvent to load additional modules - for example,
  C<PERL_ANYEVENT_DEBUG_WRAP> causes the L<AnyEvent::Debug> module to be
  loaded.
  
  All the environment variables documented here start with
  C<PERL_ANYEVENT_>, which is what AnyEvent considers its own
  namespace. Other modules are encouraged (but by no means required) to use
  C<PERL_ANYEVENT_SUBMODULE> if they have registered the AnyEvent::Submodule
  namespace on CPAN, for any submodule. For example, L<AnyEvent::HTTP> could
  be expected to use C<PERL_ANYEVENT_HTTP_PROXY> (it should not access env
  variables starting with C<AE_>, see below).
  
  All variables can also be set via the C<AE_> prefix, that is, instead
  of setting C<PERL_ANYEVENT_VERBOSE> you can also set C<AE_VERBOSE>. In
  case there is a clash btween anyevent and another program that uses
  C<AE_something> you can set the corresponding C<PERL_ANYEVENT_something>
  variable to the empty string, as those variables take precedence.
  
  When AnyEvent is first loaded, it copies all C<AE_xxx> env variables
  to their C<PERL_ANYEVENT_xxx> counterpart unless that variable already
  exists. If taint mode is on, then AnyEvent will remove I<all> environment
  variables starting with C<PERL_ANYEVENT_> from C<%ENV> (or replace them
  with C<undef> or the empty string, if the corresaponding C<AE_> variable
  is set).
  
  The exact algorithm is currently:
  
     1. if taint mode enabled, delete all PERL_ANYEVENT_xyz variables from %ENV
     2. copy over AE_xyz to PERL_ANYEVENT_xyz unless the latter alraedy exists
     3. if taint mode enabled, set all PERL_ANYEVENT_xyz variables to undef.
  
  This ensures that child processes will not see the C<AE_> variables.
  
  The following environment variables are currently known to AnyEvent:
  
  =over 4
  
  =item C<PERL_ANYEVENT_VERBOSE>
  
  By default, AnyEvent will log messages with loglevel C<4> (C<error>) or
  higher (see L<AnyEvent::Log>). You can set this environment variable to a
  numerical loglevel to make AnyEvent more (or less) talkative.
  
  If you want to do more than just set the global logging level
  you should have a look at C<PERL_ANYEVENT_LOG>, which allows much more
  complex specifications.
  
  When set to C<0> (C<off>), then no messages whatsoever will be logged with
  everything else at defaults.
  
  When set to C<5> or higher (C<warn>), AnyEvent warns about unexpected
  conditions, such as not being able to load the event model specified by
  C<PERL_ANYEVENT_MODEL>, or a guard callback throwing an exception - this
  is the minimum recommended level for use during development.
  
  When set to C<7> or higher (info), AnyEvent reports which event model it
  chooses.
  
  When set to C<8> or higher (debug), then AnyEvent will report extra
  information on which optional modules it loads and how it implements
  certain features.
  
  =item C<PERL_ANYEVENT_LOG>
  
  Accepts rather complex logging specifications. For example, you could log
  all C<debug> messages of some module to stderr, warnings and above to
  stderr, and errors and above to syslog, with:
  
     PERL_ANYEVENT_LOG=Some::Module=debug,+log:filter=warn,+%syslog:%syslog=error,syslog
  
  For the rather extensive details, see L<AnyEvent::Log>.
  
  This variable is evaluated when AnyEvent (or L<AnyEvent::Log>) is loaded,
  so will take effect even before AnyEvent has initialised itself.
  
  Note that specifying this environment variable causes the L<AnyEvent::Log>
  module to be loaded, while C<PERL_ANYEVENT_VERBOSE> does not, so only
  using the latter saves a few hundred kB of memory unless a module
  explicitly needs the extra features of AnyEvent::Log.
  
  =item C<PERL_ANYEVENT_STRICT>
  
  AnyEvent does not do much argument checking by default, as thorough
  argument checking is very costly. Setting this variable to a true value
  will cause AnyEvent to load C<AnyEvent::Strict> and then to thoroughly
  check the arguments passed to most method calls. If it finds any problems,
  it will croak.
  
  In other words, enables "strict" mode.
  
  Unlike C<use strict> (or its modern cousin, C<< use L<common::sense>
  >>, it is definitely recommended to keep it off in production. Keeping
  C<PERL_ANYEVENT_STRICT=1> in your environment while developing programs
  can be very useful, however.
  
  =item C<PERL_ANYEVENT_DEBUG_SHELL>
  
  If this env variable is nonempty, then its contents will be interpreted by
  C<AnyEvent::Socket::parse_hostport> and C<AnyEvent::Debug::shell> (after
  replacing every occurance of C<$$> by the process pid). The shell object
  is saved in C<$AnyEvent::Debug::SHELL>.
  
  This happens when the first watcher is created.
  
  For example, to bind a debug shell on a unix domain socket in
  F<< /tmp/debug<pid>.sock >>, you could use this:
  
     PERL_ANYEVENT_DEBUG_SHELL=/tmp/debug\$\$.sock perlprog
     # connect with e.g.: socat readline /tmp/debug123.sock
  
  Or to bind to tcp port 4545 on localhost:
  
     PERL_ANYEVENT_DEBUG_SHELL=127.0.0.1:4545 perlprog
     # connect with e.g.: telnet localhost 4545
  
  Note that creating sockets in F</tmp> or on localhost is very unsafe on
  multiuser systems.
  
  =item C<PERL_ANYEVENT_DEBUG_WRAP>
  
  Can be set to C<0>, C<1> or C<2> and enables wrapping of all watchers for
  debugging purposes. See C<AnyEvent::Debug::wrap> for details.
  
  =item C<PERL_ANYEVENT_MODEL>
  
  This can be used to specify the event model to be used by AnyEvent, before
  auto detection and -probing kicks in.
  
  It normally is a string consisting entirely of ASCII letters (e.g. C<EV>
  or C<IOAsync>). The string C<AnyEvent::Impl::> gets prepended and the
  resulting module name is loaded and - if the load was successful - used as
  event model backend. If it fails to load then AnyEvent will proceed with
  auto detection and -probing.
  
  If the string ends with C<::> instead (e.g. C<AnyEvent::Impl::EV::>) then
  nothing gets prepended and the module name is used as-is (hint: C<::> at
  the end of a string designates a module name and quotes it appropriately).
  
  For example, to force the pure perl model (L<AnyEvent::Loop::Perl>) you
  could start your program like this:
  
     PERL_ANYEVENT_MODEL=Perl perl ...
  
  =item C<PERL_ANYEVENT_IO_MODEL>
  
  The current file I/O model - see L<AnyEvent::IO> for more info.
  
  At the moment, only C<Perl> (small, pure-perl, synchronous) and
  C<IOAIO> (truly asynchronous) are supported. The default is C<IOAIO> if
  L<AnyEvent::AIO> can be loaded, otherwise it is C<Perl>.
  
  =item C<PERL_ANYEVENT_PROTOCOLS>
  
  Used by both L<AnyEvent::DNS> and L<AnyEvent::Socket> to determine preferences
  for IPv4 or IPv6. The default is unspecified (and might change, or be the result
  of auto probing).
  
  Must be set to a comma-separated list of protocols or address families,
  current supported: C<ipv4> and C<ipv6>. Only protocols mentioned will be
  used, and preference will be given to protocols mentioned earlier in the
  list.
  
  This variable can effectively be used for denial-of-service attacks
  against local programs (e.g. when setuid), although the impact is likely
  small, as the program has to handle connection and other failures anyways.
  
  Examples: C<PERL_ANYEVENT_PROTOCOLS=ipv4,ipv6> - prefer IPv4 over IPv6,
  but support both and try to use both.  C<PERL_ANYEVENT_PROTOCOLS=ipv4>
  - only support IPv4, never try to resolve or contact IPv6
  addresses. C<PERL_ANYEVENT_PROTOCOLS=ipv6,ipv4> support either IPv4 or
  IPv6, but prefer IPv6 over IPv4.
  
  =item C<PERL_ANYEVENT_HOSTS>
  
  This variable, if specified, overrides the F</etc/hosts> file used by
  L<AnyEvent::Socket>C<::resolve_sockaddr>, i.e. hosts aliases will be read
  from that file instead.
  
  =item C<PERL_ANYEVENT_EDNS0>
  
  Used by L<AnyEvent::DNS> to decide whether to use the EDNS0 extension for
  DNS. This extension is generally useful to reduce DNS traffic, especially
  when DNSSEC is involved, but some (broken) firewalls drop such DNS
  packets, which is why it is off by default.
  
  Setting this variable to C<1> will cause L<AnyEvent::DNS> to announce
  EDNS0 in its DNS requests.
  
  =item C<PERL_ANYEVENT_MAX_FORKS>
  
  The maximum number of child processes that C<AnyEvent::Util::fork_call>
  will create in parallel.
  
  =item C<PERL_ANYEVENT_MAX_OUTSTANDING_DNS>
  
  The default value for the C<max_outstanding> parameter for the default DNS
  resolver - this is the maximum number of parallel DNS requests that are
  sent to the DNS server.
  
  =item C<PERL_ANYEVENT_MAX_SIGNAL_LATENCY>
  
  Perl has inherently racy signal handling (you can basically choose between
  losing signals and memory corruption) - pure perl event loops (including
  C<AnyEvent::Loop>, when C<Async::Interrupt> isn't available) therefore
  have to poll regularly to avoid losing signals.
  
  Some event loops are racy, but don't poll regularly, and some event loops
  are written in C but are still racy. For those event loops, AnyEvent
  installs a timer that regularly wakes up the event loop.
  
  By default, the interval for this timer is C<10> seconds, but you can
  override this delay with this environment variable (or by setting
  the C<$AnyEvent::MAX_SIGNAL_LATENCY> variable before creating signal
  watchers).
  
  Lower values increase CPU (and energy) usage, higher values can introduce
  long delays when reaping children or waiting for signals.
  
  The L<AnyEvent::Async> module, if available, will be used to avoid this
  polling (with most event loops).
  
  =item C<PERL_ANYEVENT_RESOLV_CONF>
  
  The absolute path to a F<resolv.conf>-style file to use instead of
  F</etc/resolv.conf> (or the OS-specific configuration) in the default
  resolver, or the empty string to select the default configuration.
  
  =item C<PERL_ANYEVENT_CA_FILE>, C<PERL_ANYEVENT_CA_PATH>.
  
  When neither C<ca_file> nor C<ca_path> was specified during
  L<AnyEvent::TLS> context creation, and either of these environment
  variables are nonempty, they will be used to specify CA certificate
  locations instead of a system-dependent default.
  
  =item C<PERL_ANYEVENT_AVOID_GUARD> and C<PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT>
  
  When these are set to C<1>, then the respective modules are not
  loaded. Mostly good for testing AnyEvent itself.
  
  =back
  
  =head1 SUPPLYING YOUR OWN EVENT MODEL INTERFACE
  
  This is an advanced topic that you do not normally need to use AnyEvent in
  a module. This section is only of use to event loop authors who want to
  provide AnyEvent compatibility.
  
  If you need to support another event library which isn't directly
  supported by AnyEvent, you can supply your own interface to it by
  pushing, before the first watcher gets created, the package name of
  the event module and the package name of the interface to use onto
  C<@AnyEvent::REGISTRY>. You can do that before and even without loading
  AnyEvent, so it is reasonably cheap.
  
  Example:
  
     push @AnyEvent::REGISTRY, [urxvt => urxvt::anyevent::];
  
  This tells AnyEvent to (literally) use the C<urxvt::anyevent::>
  package/class when it finds the C<urxvt> package/module is already loaded.
  
  When AnyEvent is loaded and asked to find a suitable event model, it
  will first check for the presence of urxvt by trying to C<use> the
  C<urxvt::anyevent> module.
  
  The class should provide implementations for all watcher types. See
  L<AnyEvent::Impl::EV> (source code), L<AnyEvent::Impl::Glib> (Source code)
  and so on for actual examples. Use C<perldoc -m AnyEvent::Impl::Glib> to
  see the sources.
  
  If you don't provide C<signal> and C<child> watchers than AnyEvent will
  provide suitable (hopefully) replacements.
  
  The above example isn't fictitious, the I<rxvt-unicode> (a.k.a. urxvt)
  terminal emulator uses the above line as-is. An interface isn't included
  in AnyEvent because it doesn't make sense outside the embedded interpreter
  inside I<rxvt-unicode>, and it is updated and maintained as part of the
  I<rxvt-unicode> distribution.
  
  I<rxvt-unicode> also cheats a bit by not providing blocking access to
  condition variables: code blocking while waiting for a condition will
  C<die>. This still works with most modules/usages, and blocking calls must
  not be done in an interactive application, so it makes sense.
  
  =head1 EXAMPLE PROGRAM
  
  The following program uses an I/O watcher to read data from STDIN, a timer
  to display a message once per second, and a condition variable to quit the
  program when the user enters quit:
  
     use AnyEvent;
  
     my $cv = AnyEvent->condvar;
  
     my $io_watcher = AnyEvent->io (
        fh   => \*STDIN,
        poll => 'r',
        cb   => sub {
           warn "io event <$_[0]>\n";   # will always output <r>
           chomp (my $input = <STDIN>); # read a line
           warn "read: $input\n";       # output what has been read
           $cv->send if $input =~ /^q/i; # quit program if /^q/i
        },
     );
  
     my $time_watcher = AnyEvent->timer (after => 1, interval => 1, cb => sub {
        warn "timeout\n"; # print 'timeout' at most every second
     });
  
     $cv->recv; # wait until user enters /^q/i
  
  =head1 REAL-WORLD EXAMPLE
  
  Consider the L<Net::FCP> module. It features (among others) the following
  API calls, which are to freenet what HTTP GET requests are to http:
  
     my $data = $fcp->client_get ($url); # blocks
  
     my $transaction = $fcp->txn_client_get ($url); # does not block
     $transaction->cb ( sub { ... } ); # set optional result callback
     my $data = $transaction->result; # possibly blocks
  
  The C<client_get> method works like C<LWP::Simple::get>: it requests the
  given URL and waits till the data has arrived. It is defined to be:
  
     sub client_get { $_[0]->txn_client_get ($_[1])->result }
  
  And in fact is automatically generated. This is the blocking API of
  L<Net::FCP>, and it works as simple as in any other, similar, module.
  
  More complicated is C<txn_client_get>: It only creates a transaction
  (completion, result, ...) object and initiates the transaction.
  
     my $txn = bless { }, Net::FCP::Txn::;
  
  It also creates a condition variable that is used to signal the completion
  of the request:
  
     $txn->{finished} = AnyAvent->condvar;
  
  It then creates a socket in non-blocking mode.
  
     socket $txn->{fh}, ...;
     fcntl $txn->{fh}, F_SETFL, O_NONBLOCK;
     connect $txn->{fh}, ...
        and !$!{EWOULDBLOCK}
        and !$!{EINPROGRESS}
        and Carp::croak "unable to connect: $!\n";
  
  Then it creates a write-watcher which gets called whenever an error occurs
  or the connection succeeds:
  
     $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'w', cb => sub { $txn->fh_ready_w });
  
  And returns this transaction object. The C<fh_ready_w> callback gets
  called as soon as the event loop detects that the socket is ready for
  writing.
  
  The C<fh_ready_w> method makes the socket blocking again, writes the
  request data and replaces the watcher by a read watcher (waiting for reply
  data). The actual code is more complicated, but that doesn't matter for
  this example:
  
     fcntl $txn->{fh}, F_SETFL, 0;
     syswrite $txn->{fh}, $txn->{request}
        or die "connection or write error";
     $txn->{w} = AnyEvent->io (fh => $txn->{fh}, poll => 'r', cb => sub { $txn->fh_ready_r });
  
  Again, C<fh_ready_r> waits till all data has arrived, and then stores the
  result and signals any possible waiters that the request has finished:
  
     sysread $txn->{fh}, $txn->{buf}, length $txn->{$buf};
  
     if (end-of-file or data complete) {
       $txn->{result} = $txn->{buf};
       $txn->{finished}->send;
       $txb->{cb}->($txn) of $txn->{cb}; # also call callback
     }
  
  The C<result> method, finally, just waits for the finished signal (if the
  request was already finished, it doesn't wait, of course, and returns the
  data:
  
     $txn->{finished}->recv;
     return $txn->{result};
  
  The actual code goes further and collects all errors (C<die>s, exceptions)
  that occurred during request processing. The C<result> method detects
  whether an exception as thrown (it is stored inside the $txn object)
  and just throws the exception, which means connection errors and other
  problems get reported to the code that tries to use the result, not in a
  random callback.
  
  All of this enables the following usage styles:
  
  1. Blocking:
  
     my $data = $fcp->client_get ($url);
  
  2. Blocking, but running in parallel:
  
     my @datas = map $_->result,
                    map $fcp->txn_client_get ($_),
                       @urls;
  
  Both blocking examples work without the module user having to know
  anything about events.
  
  3a. Event-based in a main program, using any supported event module:
  
     use EV;
  
     $fcp->txn_client_get ($url)->cb (sub {
        my $txn = shift;
        my $data = $txn->result;
        ...
     });
  
     EV::run;
  
  3b. The module user could use AnyEvent, too:
  
     use AnyEvent;
  
     my $quit = AnyEvent->condvar;
  
     $fcp->txn_client_get ($url)->cb (sub {
        ...
        $quit->send;
     });
  
     $quit->recv;
  
  
  =head1 BENCHMARKS
  
  To give you an idea of the performance and overheads that AnyEvent adds
  over the event loops themselves and to give you an impression of the speed
  of various event loops I prepared some benchmarks.
  
  =head2 BENCHMARKING ANYEVENT OVERHEAD
  
  Here is a benchmark of various supported event models used natively and
  through AnyEvent. The benchmark creates a lot of timers (with a zero
  timeout) and I/O watchers (watching STDOUT, a pty, to become writable,
  which it is), lets them fire exactly once and destroys them again.
  
  Source code for this benchmark is found as F<eg/bench> in the AnyEvent
  distribution. It uses the L<AE> interface, which makes a real difference
  for the EV and Perl backends only.
  
  =head3 Explanation of the columns
  
  I<watcher> is the number of event watchers created/destroyed. Since
  different event models feature vastly different performances, each event
  loop was given a number of watchers so that overall runtime is acceptable
  and similar between tested event loop (and keep them from crashing): Glib
  would probably take thousands of years if asked to process the same number
  of watchers as EV in this benchmark.
  
  I<bytes> is the number of bytes (as measured by the resident set size,
  RSS) consumed by each watcher. This method of measuring captures both C
  and Perl-based overheads.
  
  I<create> is the time, in microseconds (millionths of seconds), that it
  takes to create a single watcher. The callback is a closure shared between
  all watchers, to avoid adding memory overhead. That means closure creation
  and memory usage is not included in the figures.
  
  I<invoke> is the time, in microseconds, used to invoke a simple
  callback. The callback simply counts down a Perl variable and after it was
  invoked "watcher" times, it would C<< ->send >> a condvar once to
  signal the end of this phase.
  
  I<destroy> is the time, in microseconds, that it takes to destroy a single
  watcher.
  
  =head3 Results
  
            name watchers bytes create invoke destroy comment
           EV/EV   100000   223   0.47   0.43    0.27 EV native interface
          EV/Any   100000   223   0.48   0.42    0.26 EV + AnyEvent watchers
    Coro::EV/Any   100000   223   0.47   0.42    0.26 coroutines + Coro::Signal
        Perl/Any   100000   431   2.70   0.74    0.92 pure perl implementation
     Event/Event    16000   516  31.16  31.84    0.82 Event native interface
       Event/Any    16000  1203  42.61  34.79    1.80 Event + AnyEvent watchers
     IOAsync/Any    16000  1911  41.92  27.45   16.81 via IO::Async::Loop::IO_Poll
     IOAsync/Any    16000  1726  40.69  26.37   15.25 via IO::Async::Loop::Epoll
        Glib/Any    16000  1118  89.00  12.57   51.17 quadratic behaviour
          Tk/Any     2000  1346  20.96  10.75    8.00 SEGV with >> 2000 watchers
         POE/Any     2000  6951 108.97 795.32   14.24 via POE::Loop::Event
         POE/Any     2000  6648  94.79 774.40  575.51 via POE::Loop::Select
  
  =head3 Discussion
  
  The benchmark does I<not> measure scalability of the event loop very
  well. For example, a select-based event loop (such as the pure perl one)
  can never compete with an event loop that uses epoll when the number of
  file descriptors grows high. In this benchmark, all events become ready at
  the same time, so select/poll-based implementations get an unnatural speed
  boost.
  
  Also, note that the number of watchers usually has a nonlinear effect on
  overall speed, that is, creating twice as many watchers doesn't take twice
  the time - usually it takes longer. This puts event loops tested with a
  higher number of watchers at a disadvantage.
  
  To put the range of results into perspective, consider that on the
  benchmark machine, handling an event takes roughly 1600 CPU cycles with
  EV, 3100 CPU cycles with AnyEvent's pure perl loop and almost 3000000 CPU
  cycles with POE.
  
  C<EV> is the sole leader regarding speed and memory use, which are both
  maximal/minimal, respectively. When using the L<AE> API there is zero
  overhead (when going through the AnyEvent API create is about 5-6 times
  slower, with other times being equal, so still uses far less memory than
  any other event loop and is still faster than Event natively).
  
  The pure perl implementation is hit in a few sweet spots (both the
  constant timeout and the use of a single fd hit optimisations in the perl
  interpreter and the backend itself). Nevertheless this shows that it
  adds very little overhead in itself. Like any select-based backend its
  performance becomes really bad with lots of file descriptors (and few of
  them active), of course, but this was not subject of this benchmark.
  
  The C<Event> module has a relatively high setup and callback invocation
  cost, but overall scores in on the third place.
  
  C<IO::Async> performs admirably well, about on par with C<Event>, even
  when using its pure perl backend.
  
  C<Glib>'s memory usage is quite a bit higher, but it features a
  faster callback invocation and overall ends up in the same class as
  C<Event>. However, Glib scales extremely badly, doubling the number of
  watchers increases the processing time by more than a factor of four,
  making it completely unusable when using larger numbers of watchers
  (note that only a single file descriptor was used in the benchmark, so
  inefficiencies of C<poll> do not account for this).
  
  The C<Tk> adaptor works relatively well. The fact that it crashes with
  more than 2000 watchers is a big setback, however, as correctness takes
  precedence over speed. Nevertheless, its performance is surprising, as the
  file descriptor is dup()ed for each watcher. This shows that the dup()
  employed by some adaptors is not a big performance issue (it does incur a
  hidden memory cost inside the kernel which is not reflected in the figures
  above).
  
  C<POE>, regardless of underlying event loop (whether using its pure perl
  select-based backend or the Event module, the POE-EV backend couldn't
  be tested because it wasn't working) shows abysmal performance and
  memory usage with AnyEvent: Watchers use almost 30 times as much memory
  as EV watchers, and 10 times as much memory as Event (the high memory
  requirements are caused by requiring a session for each watcher). Watcher
  invocation speed is almost 900 times slower than with AnyEvent's pure perl
  implementation.
  
  The design of the POE adaptor class in AnyEvent can not really account
  for the performance issues, though, as session creation overhead is
  small compared to execution of the state machine, which is coded pretty
  optimally within L<AnyEvent::Impl::POE> (and while everybody agrees that
  using multiple sessions is not a good approach, especially regarding
  memory usage, even the author of POE could not come up with a faster
  design).
  
  =head3 Summary
  
  =over 4
  
  =item * Using EV through AnyEvent is faster than any other event loop
  (even when used without AnyEvent), but most event loops have acceptable
  performance with or without AnyEvent.
  
  =item * The overhead AnyEvent adds is usually much smaller than the overhead of
  the actual event loop, only with extremely fast event loops such as EV
  does AnyEvent add significant overhead.
  
  =item * You should avoid POE like the plague if you want performance or
  reasonable memory usage.
  
  =back
  
  =head2 BENCHMARKING THE LARGE SERVER CASE
  
  This benchmark actually benchmarks the event loop itself. It works by
  creating a number of "servers": each server consists of a socket pair, a
  timeout watcher that gets reset on activity (but never fires), and an I/O
  watcher waiting for input on one side of the socket. Each time the socket
  watcher reads a byte it will write that byte to a random other "server".
  
  The effect is that there will be a lot of I/O watchers, only part of which
  are active at any one point (so there is a constant number of active
  fds for each loop iteration, but which fds these are is random). The
  timeout is reset each time something is read because that reflects how
  most timeouts work (and puts extra pressure on the event loops).
  
  In this benchmark, we use 10000 socket pairs (20000 sockets), of which 100
  (1%) are active. This mirrors the activity of large servers with many
  connections, most of which are idle at any one point in time.
  
  Source code for this benchmark is found as F<eg/bench2> in the AnyEvent
  distribution. It uses the L<AE> interface, which makes a real difference
  for the EV and Perl backends only.
  
  =head3 Explanation of the columns
  
  I<sockets> is the number of sockets, and twice the number of "servers" (as
  each server has a read and write socket end).
  
  I<create> is the time it takes to create a socket pair (which is
  nontrivial) and two watchers: an I/O watcher and a timeout watcher.
  
  I<request>, the most important value, is the time it takes to handle a
  single "request", that is, reading the token from the pipe and forwarding
  it to another server. This includes deleting the old timeout and creating
  a new one that moves the timeout into the future.
  
  =head3 Results
  
       name sockets create  request 
         EV   20000  62.66     7.99 
       Perl   20000  68.32    32.64 
    IOAsync   20000 174.06   101.15 epoll
    IOAsync   20000 174.67   610.84 poll
      Event   20000 202.69   242.91 
       Glib   20000 557.01  1689.52 
        POE   20000 341.54 12086.32 uses POE::Loop::Event
  
  =head3 Discussion
  
  This benchmark I<does> measure scalability and overall performance of the
  particular event loop.
  
  EV is again fastest. Since it is using epoll on my system, the setup time
  is relatively high, though.
  
  Perl surprisingly comes second. It is much faster than the C-based event
  loops Event and Glib.
  
  IO::Async performs very well when using its epoll backend, and still quite
  good compared to Glib when using its pure perl backend.
  
  Event suffers from high setup time as well (look at its code and you will
  understand why). Callback invocation also has a high overhead compared to
  the C<< $_->() for .. >>-style loop that the Perl event loop uses. Event
  uses select or poll in basically all documented configurations.
  
  Glib is hit hard by its quadratic behaviour w.r.t. many watchers. It
  clearly fails to perform with many filehandles or in busy servers.
  
  POE is still completely out of the picture, taking over 1000 times as long
  as EV, and over 100 times as long as the Perl implementation, even though
  it uses a C-based event loop in this case.
  
  =head3 Summary
  
  =over 4
  
  =item * The pure perl implementation performs extremely well.
  
  =item * Avoid Glib or POE in large projects where performance matters.
  
  =back
  
  =head2 BENCHMARKING SMALL SERVERS
  
  While event loops should scale (and select-based ones do not...) even to
  large servers, most programs we (or I :) actually write have only a few
  I/O watchers.
  
  In this benchmark, I use the same benchmark program as in the large server
  case, but it uses only eight "servers", of which three are active at any
  one time. This should reflect performance for a small server relatively
  well.
  
  The columns are identical to the previous table.
  
  =head3 Results
  
      name sockets create request 
        EV      16  20.00    6.54 
      Perl      16  25.75   12.62 
     Event      16  81.27   35.86 
      Glib      16  32.63   15.48 
       POE      16 261.87  276.28 uses POE::Loop::Event
  
  =head3 Discussion
  
  The benchmark tries to test the performance of a typical small
  server. While knowing how various event loops perform is interesting, keep
  in mind that their overhead in this case is usually not as important, due
  to the small absolute number of watchers (that is, you need efficiency and
  speed most when you have lots of watchers, not when you only have a few of
  them).
  
  EV is again fastest.
  
  Perl again comes second. It is noticeably faster than the C-based event
  loops Event and Glib, although the difference is too small to really
  matter.
  
  POE also performs much better in this case, but is is still far behind the
  others.
  
  =head3 Summary
  
  =over 4
  
  =item * C-based event loops perform very well with small number of
  watchers, as the management overhead dominates.
  
  =back
  
  =head2 THE IO::Lambda BENCHMARK
  
  Recently I was told about the benchmark in the IO::Lambda manpage, which
  could be misinterpreted to make AnyEvent look bad. In fact, the benchmark
  simply compares IO::Lambda with POE, and IO::Lambda looks better (which
  shouldn't come as a surprise to anybody). As such, the benchmark is
  fine, and mostly shows that the AnyEvent backend from IO::Lambda isn't
  very optimal. But how would AnyEvent compare when used without the extra
  baggage? To explore this, I wrote the equivalent benchmark for AnyEvent.
  
  The benchmark itself creates an echo-server, and then, for 500 times,
  connects to the echo server, sends a line, waits for the reply, and then
  creates the next connection. This is a rather bad benchmark, as it doesn't
  test the efficiency of the framework or much non-blocking I/O, but it is a
  benchmark nevertheless.
  
     name                    runtime
     Lambda/select           0.330 sec
        + optimized          0.122 sec
     Lambda/AnyEvent         0.327 sec
        + optimized          0.138 sec
     Raw sockets/select      0.077 sec
     POE/select, components  0.662 sec
     POE/select, raw sockets 0.226 sec
     POE/select, optimized   0.404 sec
  
     AnyEvent/select/nb      0.085 sec
     AnyEvent/EV/nb          0.068 sec
        +state machine       0.134 sec
  
  The benchmark is also a bit unfair (my fault): the IO::Lambda/POE
  benchmarks actually make blocking connects and use 100% blocking I/O,
  defeating the purpose of an event-based solution. All of the newly
  written AnyEvent benchmarks use 100% non-blocking connects (using
  AnyEvent::Socket::tcp_connect and the asynchronous pure perl DNS
  resolver), so AnyEvent is at a disadvantage here, as non-blocking connects
  generally require a lot more bookkeeping and event handling than blocking
  connects (which involve a single syscall only).
  
  The last AnyEvent benchmark additionally uses L<AnyEvent::Handle>, which
  offers similar expressive power as POE and IO::Lambda, using conventional
  Perl syntax. This means that both the echo server and the client are 100%
  non-blocking, further placing it at a disadvantage.
  
  As you can see, the AnyEvent + EV combination even beats the
  hand-optimised "raw sockets benchmark", while AnyEvent + its pure perl
  backend easily beats IO::Lambda and POE.
  
  And even the 100% non-blocking version written using the high-level (and
  slow :) L<AnyEvent::Handle> abstraction beats both POE and IO::Lambda
  higher level ("unoptimised") abstractions by a large margin, even though
  it does all of DNS, tcp-connect and socket I/O in a non-blocking way.
  
  The two AnyEvent benchmarks programs can be found as F<eg/ae0.pl> and
  F<eg/ae2.pl> in the AnyEvent distribution, the remaining benchmarks are
  part of the IO::Lambda distribution and were used without any changes.
  
  
  =head1 SIGNALS
  
  AnyEvent currently installs handlers for these signals:
  
  =over 4
  
  =item SIGCHLD
  
  A handler for C<SIGCHLD> is installed by AnyEvent's child watcher
  emulation for event loops that do not support them natively. Also, some
  event loops install a similar handler.
  
  Additionally, when AnyEvent is loaded and SIGCHLD is set to IGNORE, then
  AnyEvent will reset it to default, to avoid losing child exit statuses.
  
  =item SIGPIPE
  
  A no-op handler is installed for C<SIGPIPE> when C<$SIG{PIPE}> is C<undef>
  when AnyEvent gets loaded.
  
  The rationale for this is that AnyEvent users usually do not really depend
  on SIGPIPE delivery (which is purely an optimisation for shell use, or
  badly-written programs), but C<SIGPIPE> can cause spurious and rare
  program exits as a lot of people do not expect C<SIGPIPE> when writing to
  some random socket.
  
  The rationale for installing a no-op handler as opposed to ignoring it is
  that this way, the handler will be restored to defaults on exec.
  
  Feel free to install your own handler, or reset it to defaults.
  
  =back
  
  =cut
  
  undef $SIG{CHLD}
     if $SIG{CHLD} eq 'IGNORE';
  
  $SIG{PIPE} = sub { }
     unless defined $SIG{PIPE};
  
  =head1 RECOMMENDED/OPTIONAL MODULES
  
  One of AnyEvent's main goals is to be 100% Pure-Perl(tm): only perl (and
  its built-in modules) are required to use it.
  
  That does not mean that AnyEvent won't take advantage of some additional
  modules if they are installed.
  
  This section explains which additional modules will be used, and how they
  affect AnyEvent's operation.
  
  =over 4
  
  =item L<Async::Interrupt>
  
  This slightly arcane module is used to implement fast signal handling: To
  my knowledge, there is no way to do completely race-free and quick
  signal handling in pure perl. To ensure that signals still get
  delivered, AnyEvent will start an interval timer to wake up perl (and
  catch the signals) with some delay (default is 10 seconds, look for
  C<$AnyEvent::MAX_SIGNAL_LATENCY>).
  
  If this module is available, then it will be used to implement signal
  catching, which means that signals will not be delayed, and the event loop
  will not be interrupted regularly, which is more efficient (and good for
  battery life on laptops).
  
  This affects not just the pure-perl event loop, but also other event loops
  that have no signal handling on their own (e.g. Glib, Tk, Qt).
  
  Some event loops (POE, Event, Event::Lib) offer signal watchers natively,
  and either employ their own workarounds (POE) or use AnyEvent's workaround
  (using C<$AnyEvent::MAX_SIGNAL_LATENCY>). Installing L<Async::Interrupt>
  does nothing for those backends.
  
  =item L<EV>
  
  This module isn't really "optional", as it is simply one of the backend
  event loops that AnyEvent can use. However, it is simply the best event
  loop available in terms of features, speed and stability: It supports
  the AnyEvent API optimally, implements all the watcher types in XS, does
  automatic timer adjustments even when no monotonic clock is available,
  can take avdantage of advanced kernel interfaces such as C<epoll> and
  C<kqueue>, and is the fastest backend I<by far>. You can even embed
  L<Glib>/L<Gtk2> in it (or vice versa, see L<EV::Glib> and L<Glib::EV>).
  
  If you only use backends that rely on another event loop (e.g. C<Tk>),
  then this module will do nothing for you.
  
  =item L<Guard>
  
  The guard module, when used, will be used to implement
  C<AnyEvent::Util::guard>. This speeds up guards considerably (and uses a
  lot less memory), but otherwise doesn't affect guard operation much. It is
  purely used for performance.
  
  =item L<JSON> and L<JSON::XS>
  
  One of these modules is required when you want to read or write JSON data
  via L<AnyEvent::Handle>. L<JSON> is also written in pure-perl, but can take
  advantage of the ultra-high-speed L<JSON::XS> module when it is installed.
  
  =item L<Net::SSLeay>
  
  Implementing TLS/SSL in Perl is certainly interesting, but not very
  worthwhile: If this module is installed, then L<AnyEvent::Handle> (with
  the help of L<AnyEvent::TLS>), gains the ability to do TLS/SSL.
  
  =item L<Time::HiRes>
  
  This module is part of perl since release 5.008. It will be used when the
  chosen event library does not come with a timing source of its own. The
  pure-perl event loop (L<AnyEvent::Loop>) will additionally load it to
  try to use a monotonic clock for timing stability.
  
  =item L<AnyEvent::AIO> (and L<IO::AIO>)
  
  The default implementation of L<AnyEvent::IO> is to do I/O synchronously,
  stopping programs while they access the disk, which is fine for a lot of
  programs.
  
  Installing AnyEvent::AIO (and its IO::AIO dependency) makes it switch to
  a true asynchronous implementation, so event processing can continue even
  while waiting for disk I/O.
  
  =back
  
  
  =head1 FORK
  
  Most event libraries are not fork-safe. The ones who are usually are
  because they rely on inefficient but fork-safe C<select> or C<poll> calls
  - higher performance APIs such as BSD's kqueue or the dreaded Linux epoll
  are usually badly thought-out hacks that are incompatible with fork in
  one way or another. Only L<EV> is fully fork-aware and ensures that you
  continue event-processing in both parent and child (or both, if you know
  what you are doing).
  
  This means that, in general, you cannot fork and do event processing in
  the child if the event library was initialised before the fork (which
  usually happens when the first AnyEvent watcher is created, or the library
  is loaded).
  
  If you have to fork, you must either do so I<before> creating your first
  watcher OR you must not use AnyEvent at all in the child OR you must do
  something completely out of the scope of AnyEvent (see below).
  
  The problem of doing event processing in the parent I<and> the child
  is much more complicated: even for backends that I<are> fork-aware or
  fork-safe, their behaviour is not usually what you want: fork clones all
  watchers, that means all timers, I/O watchers etc. are active in both
  parent and child, which is almost never what you want. Using C<exec>
  to start worker children from some kind of manage prrocess is usually
  preferred, because it is much easier and cleaner, at the expense of having
  to have another binary.
  
  In addition to logical problems with fork, there are also implementation
  problems. For example, on POSIX systems, you cannot fork at all in Perl
  code if a thread (I am talking of pthreads here) was ever created in the
  process, and this is just the tip of the iceberg. In general, using fork
  from Perl is difficult, and attempting to use fork without an exec to
  implement some kind of parallel processing is almost certainly doomed.
  
  To safely fork and exec, you should use a module such as
  L<Proc::FastSpawn> that let's you safely fork and exec new processes.
  
  If you want to do multiprocessing using processes, you can
  look at the L<AnyEvent::Fork> module (and some related modules
  such as L<AnyEvent::Fork::RPC>, L<AnyEvent::Fork::Pool> and
  L<AnyEvent::Fork::Remote>). This module allows you to safely create
  subprocesses without any limitations - you can use X11 toolkits or
  AnyEvent in the children created by L<AnyEvent::Fork> safely and without
  any special precautions.
  
  
  =head1 SECURITY CONSIDERATIONS
  
  AnyEvent can be forced to load any event model via
  $ENV{PERL_ANYEVENT_MODEL}. While this cannot (to my knowledge) be used to
  execute arbitrary code or directly gain access, it can easily be used to
  make the program hang or malfunction in subtle ways, as AnyEvent watchers
  will not be active when the program uses a different event model than
  specified in the variable.
  
  You can make AnyEvent completely ignore this variable by deleting it
  before the first watcher gets created, e.g. with a C<BEGIN> block:
  
     BEGIN { delete $ENV{PERL_ANYEVENT_MODEL} }
    
     use AnyEvent;
  
  Similar considerations apply to $ENV{PERL_ANYEVENT_VERBOSE}, as that can
  be used to probe what backend is used and gain other information (which is
  probably even less useful to an attacker than PERL_ANYEVENT_MODEL), and
  $ENV{PERL_ANYEVENT_STRICT}.
  
  Note that AnyEvent will remove I<all> environment variables starting with
  C<PERL_ANYEVENT_> from C<%ENV> when it is loaded while taint mode is
  enabled.
  
  
  =head1 BUGS
  
  Perl 5.8 has numerous memleaks that sometimes hit this module and are hard
  to work around. If you suffer from memleaks, first upgrade to Perl 5.10
  and check wether the leaks still show up. (Perl 5.10.0 has other annoying
  memleaks, such as leaking on C<map> and C<grep> but it is usually not as
  pronounced).
  
  
  =head1 SEE ALSO
  
  Tutorial/Introduction: L<AnyEvent::Intro>.
  
  FAQ: L<AnyEvent::FAQ>.
  
  Utility functions: L<AnyEvent::Util> (misc. grab-bag), L<AnyEvent::Log>
  (simply logging).
  
  Development/Debugging: L<AnyEvent::Strict> (stricter checking),
  L<AnyEvent::Debug> (interactive shell, watcher tracing).
  
  Supported event modules: L<AnyEvent::Loop>, L<EV>, L<EV::Glib>,
  L<Glib::EV>, L<Event>, L<Glib::Event>, L<Glib>, L<Tk>, L<Event::Lib>,
  L<Qt>, L<POE>, L<FLTK>, L<Cocoa::EventLoop>, L<UV>.
  
  Implementations: L<AnyEvent::Impl::EV>, L<AnyEvent::Impl::Event>,
  L<AnyEvent::Impl::Glib>, L<AnyEvent::Impl::Tk>, L<AnyEvent::Impl::Perl>,
  L<AnyEvent::Impl::EventLib>, L<AnyEvent::Impl::Qt>,
  L<AnyEvent::Impl::POE>, L<AnyEvent::Impl::IOAsync>, L<AnyEvent::Impl::Irssi>,
  L<AnyEvent::Impl::FLTK>, L<AnyEvent::Impl::Cocoa>, L<AnyEvent::Impl::UV>.
  
  Non-blocking handles, pipes, stream sockets, TCP clients and
  servers: L<AnyEvent::Handle>, L<AnyEvent::Socket>, L<AnyEvent::TLS>.
  
  Asynchronous File I/O: L<AnyEvent::IO>.
  
  Asynchronous DNS: L<AnyEvent::DNS>.
  
  Thread support: L<Coro>, L<Coro::AnyEvent>, L<Coro::EV>, L<Coro::Event>.
  
  Nontrivial usage examples: L<AnyEvent::GPSD>, L<AnyEvent::IRC>,
  L<AnyEvent::HTTP>.
  
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT

$fatpacked{"AnyEvent/DNS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_DNS';
  =head1 NAME
  
  AnyEvent::DNS - fully asynchronous DNS resolution
  
  =head1 SYNOPSIS
  
     use AnyEvent::DNS;
     
     my $cv = AnyEvent->condvar;
     AnyEvent::DNS::a "www.google.de", $cv;
     # ... later
     my @addrs = $cv->recv;
  
  =head1 DESCRIPTION
  
  This module offers both a number of DNS convenience functions as well
  as a fully asynchronous and high-performance pure-perl stub resolver.
  
  The stub resolver supports DNS over IPv4 and IPv6, UDP and TCP, optional
  EDNS0 support for up to 4kiB datagrams and automatically falls back to
  virtual circuit mode for large responses.
  
  =head2 CONVENIENCE FUNCTIONS
  
  =over 4
  
  =cut
  
  package AnyEvent::DNS;
  
  use Carp ();
  use Socket qw(AF_INET SOCK_DGRAM SOCK_STREAM);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(AF_INET6);
  
  our $VERSION = $AnyEvent::VERSION;
  our @DNS_FALLBACK; # some public dns servers as fallback
  
  {
     my $prep = sub {
        $_ = $_->[rand @$_] for @_;
        push @_, splice @_, rand $_, 1 for reverse 1..@_; # shuffle
        $_ = pack "H*", $_ for @_;
        \@_
     };
  
     my $ipv4 = $prep->(
        ["08080808", "08080404"], # 8.8.8.8, 8.8.4.4 - google public dns
        ["01010101", "01000001"], # 1.1.1.1, 1.0.0.1 - cloudflare public dns
        ["50505050", "50505151"], # 80.80.80.80, 80.80.81.81 - freenom.world
  ##      ["d1f40003", "d1f30004"], # v209.244.0.3/4 - resolver1/2.level3.net - status unknown
  ##      ["04020201", "04020203", "04020204", "04020205", "04020206"], # v4.2.2.1/3/4/5/6 - vnsc-pri.sys.gtei.net - effectively public
  ##      ["cdd22ad2", "4044c8c8"], # 205.210.42.205, 64.68.200.200 - cache1/2.dnsresolvers.com - verified public
  #      ["8d010101"], # 141.1.1.1 - cable&wireless, now vodafone - status unknown
  # 84.200.69.80      # dns.watch
  # 84.200.70.40      # dns.watch
  # 37.235.1.174      # freedns.zone
  # 37.235.1.177      # freedns.zone
  # 213.73.91.35      # dnscache.berlin.ccc.de
  # 194.150.168.168   # dns.as250.net; Berlin/Frankfurt
  # 85.214.20.141     # FoeBud (digitalcourage.de)
  # 77.109.148.136    # privacyfoundation.ch
  # 77.109.148.137    # privacyfoundation.ch
  # 91.239.100.100    # anycast.censurfridns.dk
  # 89.233.43.71      # ns1.censurfridns.dk
  # 204.152.184.76    # f.6to4-servers.net, ISC, USA
     );
  
     my $ipv6 = $prep->(
        ["20014860486000000000000000008888", "20014860486000000000000000008844"], # 2001:4860:4860::8888/8844 - google ipv6
        ["26064700470000000000000000001111", "26064700470000000000000000001001"], # 2606:4700:4700::1111/1001 - cloudflare dns
     );
  
     undef $ipv4 unless $AnyEvent::PROTOCOL{ipv4};
     undef $ipv6 unless $AnyEvent::PROTOCOL{ipv6};
  
     ($ipv6, $ipv4) = ($ipv4, $ipv6)
        if $AnyEvent::PROTOCOL{ipv6} > $AnyEvent::PROTOCOL{ipv4};
  
     @DNS_FALLBACK = (@$ipv4, @$ipv6);
  }
  
  =item AnyEvent::DNS::a $domain, $cb->(@addrs)
  
  Tries to resolve the given domain to IPv4 address(es).
  
  =item AnyEvent::DNS::aaaa $domain, $cb->(@addrs)
  
  Tries to resolve the given domain to IPv6 address(es).
  
  =item AnyEvent::DNS::mx $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain into a sorted (lower preference value
  first) list of domain names.
  
  =item AnyEvent::DNS::ns $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain name into a list of name servers.
  
  =item AnyEvent::DNS::txt $domain, $cb->(@hostnames)
  
  Tries to resolve the given domain name into a list of text records. Only
  the first text string per record will be returned. If you want all
  strings, you need to call the resolver manually:
  
     resolver->resolve ($domain => "txt", sub {
        for my $record (@_) {
           my (undef, undef, undef, @txt) = @$record;
           # strings now in @txt
        }
     });
  
  =item AnyEvent::DNS::srv $service, $proto, $domain, $cb->(@srv_rr)
  
  Tries to resolve the given service, protocol and domain name into a list
  of service records.
  
  Each C<$srv_rr> is an array reference with the following contents:
  C<[$priority, $weight, $transport, $target]>.
  
  They will be sorted with lowest priority first, then randomly
  distributed by weight as per RFC 2782.
  
  Example:
  
     AnyEvent::DNS::srv "sip", "udp", "schmorp.de", sub { ...
     # @_ = ( [10, 10, 5060, "sip1.schmorp.de" ] )
  
  =item AnyEvent::DNS::any $domain, $cb->(@rrs)
  
  Tries to resolve the given domain and passes all resource records found
  to the callback. Note that this uses a DNS C<ANY> query, which, as of RFC
  8482, are officially deprecated.
  
  =item AnyEvent::DNS::ptr $domain, $cb->(@hostnames)
  
  Tries to make a PTR lookup on the given domain. See C<reverse_lookup>
  and C<reverse_verify> if you want to resolve an IP address to a hostname
  instead.
  
  =item AnyEvent::DNS::reverse_lookup $ipv4_or_6, $cb->(@hostnames)
  
  Tries to reverse-resolve the given IPv4 or IPv6 address (in textual form)
  into its hostname(s). Handles V4MAPPED and V4COMPAT IPv6 addresses
  transparently.
  
  =item AnyEvent::DNS::reverse_verify $ipv4_or_6, $cb->(@hostnames)
  
  The same as C<reverse_lookup>, but does forward-lookups to verify that
  the resolved hostnames indeed point to the address, which makes spoofing
  harder.
  
  If you want to resolve an address into a hostname, this is the preferred
  method: The DNS records could still change, but at least this function
  verified that the hostname, at one point in the past, pointed at the IP
  address you originally resolved.
  
  Example:
  
     AnyEvent::DNS::reverse_verify "2001:500:2f::f", sub { print shift };
     # => f.root-servers.net
  
  =cut
  
  sub MAX_PKT() { 4096 } # max packet size we advertise and accept
  
  sub DOMAIN_PORT() { 53 } # if this changes drop me a note
  
  sub resolver ();
  
  sub a($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "a", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub aaaa($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "aaaa", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub mx($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "mx", sub {
        $cb->(map $_->[5], sort { $a->[4] <=> $b->[4] } @_);
     });
  }
  
  sub ns($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "ns", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub txt($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "txt", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub srv($$$$) {
     my ($service, $proto, $domain, $cb) = @_;
  
     # todo, ask for any and check glue records
     resolver->resolve ("_$service._$proto.$domain" => "srv", sub {
        my @res;
  
        # classify by priority
        my %pri;
        push @{ $pri{$_->[4]} }, [ @$_[4,5,6,7] ]
           for @_;
  
        # order by priority
        for my $pri (sort { $a <=> $b } keys %pri) {
           # order by weight
           my @rr = sort { $a->[1] <=> $b->[1] } @{ delete $pri{$pri} };
  
           my $sum; $sum += $_->[1] for @rr;
  
           while (@rr) {
              my $w = int rand $sum + 1;
              for (0 .. $#rr) {
                 if (($w -= $rr[$_][1]) <= 0) {
                    $sum -= $rr[$_][1];
                    push @res, splice @rr, $_, 1, ();
                    last;
                 }
              }
           }
        }
  
        $cb->(@res);
     });
  }
  
  sub ptr($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "ptr", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub any($$) {
     my ($domain, $cb) = @_;
  
     resolver->resolve ($domain => "*", $cb);
  }
  
  # convert textual ip address into reverse lookup form
  sub _munge_ptr($) {
     my $ipn = $_[0]
        or return;
  
     my $ptr;
  
     my $af = AnyEvent::Socket::address_family ($ipn);
  
     if ($af == AF_INET6) {
        $ipn = substr $ipn, 0, 16; # anticipate future expansion
  
        # handle v4mapped and v4compat
        if ($ipn =~ s/^\x00{10}(?:\xff\xff|\x00\x00)//) {
           $af = AF_INET;
        } else {
           $ptr = join ".", (reverse split //, unpack "H32", $ipn), "ip6.arpa.";
        }
     }
  
     if ($af == AF_INET) {
        $ptr = join ".", (reverse unpack "C4", $ipn), "in-addr.arpa.";
     }
  
     $ptr
  }
  
  sub reverse_lookup($$) {
     my ($ip, $cb) = @_;
  
     $ip = _munge_ptr AnyEvent::Socket::parse_address ($ip)
        or return $cb->();
  
     resolver->resolve ($ip => "ptr", sub {
        $cb->(map $_->[4], @_);
     });
  }
  
  sub reverse_verify($$) {
     my ($ip, $cb) = @_;
     
     my $ipn = AnyEvent::Socket::parse_address ($ip)
        or return $cb->();
  
     my $af = AnyEvent::Socket::address_family ($ipn);
  
     my @res;
     my $cnt;
  
     my $ptr = _munge_ptr $ipn
        or return $cb->();
  
     $ip = AnyEvent::Socket::format_address ($ipn); # normalise into the same form
  
     ptr $ptr, sub {
        for my $name (@_) {
           ++$cnt;
           
           # () around AF_INET to work around bug in 5.8
           resolver->resolve ("$name." => ($af == (AF_INET) ? "a" : "aaaa"), sub {
              for (@_) {
                 push @res, $name
                    if $_->[4] eq $ip;
              }
              $cb->(@res) unless --$cnt;
           });
        }
  
        $cb->() unless $cnt;
     };
  }
  
  #################################################################################
  
  =back
  
  =head2 LOW-LEVEL DNS EN-/DECODING FUNCTIONS
  
  =over 4
  
  =item $AnyEvent::DNS::EDNS0
  
  This variable decides whether dns_pack automatically enables EDNS0
  support. By default, this is disabled (C<0>), unless overridden by
  C<$ENV{PERL_ANYEVENT_EDNS0}>, but when set to C<1>, AnyEvent::DNS will use
  EDNS0 in all requests.
  
  =cut
  
  our $EDNS0 = $ENV{PERL_ANYEVENT_EDNS0}*1; # set to 1 to enable (partial) edns0
  
  our %opcode_id = (
     query  => 0,
     iquery => 1,
     status => 2,
     notify => 4,
     update => 5,
     map +($_ => $_), 3, 6..15
  );
  
  our %opcode_str = reverse %opcode_id;
  
  our %rcode_id = (
     noerror  =>  0,
     formerr  =>  1,
     servfail =>  2,
     nxdomain =>  3,
     notimp   =>  4,
     refused  =>  5,
     yxdomain =>  6, # Name Exists when it should not     [RFC 2136]
     yxrrset  =>  7, # RR Set Exists when it should not   [RFC 2136]
     nxrrset  =>  8, # RR Set that should exist does not  [RFC 2136]
     notauth  =>  9, # Server Not Authoritative for zone  [RFC 2136]
     notzone  => 10, # Name not contained in zone         [RFC 2136]
  # EDNS0  16    BADVERS   Bad OPT Version                    [RFC 2671]
  # EDNS0  16    BADSIG    TSIG Signature Failure             [RFC 2845]
  # EDNS0  17    BADKEY    Key not recognized                 [RFC 2845]
  # EDNS0  18    BADTIME   Signature out of time window       [RFC 2845]
  # EDNS0  19    BADMODE   Bad TKEY Mode                      [RFC 2930]
  # EDNS0  20    BADNAME   Duplicate key name                 [RFC 2930]
  # EDNS0  21    BADALG    Algorithm not supported            [RFC 2930]
     map +($_ => $_), 11..15
  );
  
  our %rcode_str = reverse %rcode_id;
  
  our %type_id = (
     a     =>   1,
     ns    =>   2,
     md    =>   3,
     mf    =>   4,
     cname =>   5,
     soa   =>   6,
     mb    =>   7,
     mg    =>   8,
     mr    =>   9,
     null  =>  10,
     wks   =>  11,
     ptr   =>  12,
     hinfo =>  13,
     minfo =>  14,
     mx    =>  15,
     txt   =>  16,
     sig   =>  24,
     key   =>  25,
     gpos  =>  27, # rfc1712
     aaaa  =>  28,
     loc   =>  29, # rfc1876
     srv   =>  33,
     naptr =>  35, # rfc2915
     dname =>  39, # rfc2672
     opt   =>  41,
     ds    =>  43, # rfc4034
     sshfp =>  44, # rfc4255
     rrsig =>  46, # rfc4034
     nsec  =>  47, # rfc4034
     dnskey=>  48, # rfc4034
     smimea=>  53, # rfc8162
     cds   =>  59, # rfc7344
     cdnskey=> 60, # rfc7344
     openpgpkey=> 61, # rfc7926
     csync =>  62, # rfc7929
     spf   =>  99,
     tkey  => 249,
     tsig  => 250,
     ixfr  => 251,
     axfr  => 252,
     mailb => 253,
     "*"   => 255,
     uri   => 256,
     caa   => 257, # rfc6844
  );
  
  our %type_str = reverse %type_id;
  
  our %class_id = (
     in   =>   1,
     ch   =>   3,
     hs   =>   4,
     none => 254,
     "*"  => 255,
  );
  
  our %class_str = reverse %class_id;
  
  sub _enc_name($) {
     pack "(C/a*)*", (split /\./, shift), ""
  }
  
  if ($] < 5.008) {
     # special slower 5.6 version
     *_enc_name = sub ($) {
        join "", map +(pack "C/a*", $_), (split /\./, shift), ""
     };
  }
  
  sub _enc_qd() {
     (_enc_name $_->[0]) . pack "nn",
       ($_->[1] > 0 ? $_->[1] : $type_id {$_->[1]}),
       ($_->[3] > 0 ? $_->[2] : $class_id{$_->[2] || "in"})
  }
  
  sub _enc_rr() {
     die "encoding of resource records is not supported";
  }
  
  =item $pkt = AnyEvent::DNS::dns_pack $dns
  
  Packs a perl data structure into a DNS packet. Reading RFC 1035 is strongly
  recommended, then everything will be totally clear. Or maybe not.
  
  Resource records are not yet encodable.
  
  Examples:
  
     # very simple request, using lots of default values:
     { rd => 1, qd => [ [ "host.domain", "a"] ] }
    
     # more complex example, showing how flags etc. are named:
    
     {
        id => 10000,
        op => "query",
        rc => "nxdomain",
    
        # flags
        qr => 1,
        aa => 0,
        tc => 0,
        rd => 0,
        ra => 0,
        ad => 0,
        cd => 0,
    
        qd => [@rr], # query section
        an => [@rr], # answer section
        ns => [@rr], # authority section
        ar => [@rr], # additional records section
     }
  
  =cut
  
  sub dns_pack($) {
     my ($req) = @_;
  
     pack "nn nnnn a* a* a* a* a*",
        $req->{id},
  
        ! !$req->{qr}   * 0x8000
        + $opcode_id{$req->{op}} * 0x0800
        + ! !$req->{aa} * 0x0400
        + ! !$req->{tc} * 0x0200
        + ! !$req->{rd} * 0x0100
        + ! !$req->{ra} * 0x0080
        + ! !$req->{ad} * 0x0020
        + ! !$req->{cd} * 0x0010
        + $rcode_id{$req->{rc}} * 0x0001,
  
        scalar @{ $req->{qd} || [] },
        scalar @{ $req->{an} || [] },
        scalar @{ $req->{ns} || [] },
        $EDNS0 + scalar @{ $req->{ar} || [] }, # EDNS0 option included here
  
        (join "", map _enc_qd, @{ $req->{qd} || [] }),
        (join "", map _enc_rr, @{ $req->{an} || [] }),
        (join "", map _enc_rr, @{ $req->{ns} || [] }),
        (join "", map _enc_rr, @{ $req->{ar} || [] }),
  
        ($EDNS0 ? pack "C nnNn", 0, 41, MAX_PKT, 0, 0 : "") # EDNS0 option
  }
  
  our $ofs;
  our $pkt;
  
  # bitches
  sub _dec_name {
     my @res;
     my $redir;
     my $ptr = $ofs;
     my $cnt;
  
     while () {
        return undef if ++$cnt >= 256; # to avoid DoS attacks
  
        my $len = ord substr $pkt, $ptr++, 1;
  
        if ($len >= 0xc0) {
           $ptr++;
           $ofs = $ptr if $ptr > $ofs;
           $ptr = (unpack "n", substr $pkt, $ptr - 2, 2) & 0x3fff;
        } elsif ($len) {
           push @res, substr $pkt, $ptr, $len;
           $ptr += $len;
        } else {
           $ofs = $ptr if $ptr > $ofs;
           return join ".", @res;
        }
     }
  }
  
  sub _dec_qd {
     my $qname = _dec_name;
     my ($qt, $qc) = unpack "nn", substr $pkt, $ofs; $ofs += 4;
     [$qname, $type_str{$qt} || $qt, $class_str{$qc} || $qc]
  }
  
  our %dec_rr = (
       1 => sub { join ".", unpack "C4", $_ }, # a
       2 => sub { local $ofs = $ofs - length; _dec_name }, # ns
       5 => sub { local $ofs = $ofs - length; _dec_name }, # cname
       6 => sub { 
               local $ofs = $ofs - length;
               my $mname = _dec_name;
               my $rname = _dec_name;
               ($mname, $rname, unpack "NNNNN", substr $pkt, $ofs)
            }, # soa
      11 => sub { ((join ".", unpack "C4", $_), unpack "C a*", substr $_, 4) }, # wks
      12 => sub { local $ofs = $ofs - length; _dec_name }, # ptr
      13 => sub { unpack "C/a* C/a*", $_ }, # hinfo
      15 => sub { local $ofs = $ofs + 2 - length; ((unpack "n", $_), _dec_name) }, # mx
      16 => sub { unpack "(C/a*)*", $_ }, # txt
      28 => sub { AnyEvent::Socket::format_ipv6 ($_) }, # aaaa
      33 => sub { local $ofs = $ofs + 6 - length; ((unpack "nnn", $_), _dec_name) }, # srv
      35 => sub { # naptr
         # requires perl 5.10, sorry
         my ($order, $preference, $flags, $service, $regexp, $offset) = unpack "nn C/a* C/a* C/a* .", $_;
         local $ofs = $ofs + $offset - length;
         ($order, $preference, $flags, $service, $regexp, _dec_name)
      },
      39 => sub { local $ofs = $ofs - length; _dec_name }, # dname
      99 => sub { unpack "(C/a*)*", $_ }, # spf
     257 => sub { unpack "CC/a*a*", $_ }, # caa
  );
  
  sub _dec_rr {
     my $name = _dec_name;
  
     my ($rt, $rc, $ttl, $rdlen) = unpack "nn N n", substr $pkt, $ofs; $ofs += 10;
     local $_ = substr $pkt, $ofs, $rdlen; $ofs += $rdlen;
  
     [
        $name,
        $type_str{$rt}  || $rt,
        $class_str{$rc} || $rc,
        $ttl,
        ($dec_rr{$rt} || sub { $_ })->(),
     ]
  }
  
  =item $dns = AnyEvent::DNS::dns_unpack $pkt
  
  Unpacks a DNS packet into a perl data structure.
  
  Examples:
  
     # an unsuccessful reply
     {
       'qd' => [
                 [ 'ruth.plan9.de.mach.uni-karlsruhe.de', '*', 'in' ]
               ],
       'rc' => 'nxdomain',
       'ar' => [],
       'ns' => [
                 [
                   'uni-karlsruhe.de',
                   'soa',
                   'in',
                   600,
                   'netserv.rz.uni-karlsruhe.de',
                   'hostmaster.rz.uni-karlsruhe.de',
                   2008052201, 10800, 1800, 2592000, 86400
                 ]
               ],
       'tc' => '',
       'ra' => 1,
       'qr' => 1,
       'id' => 45915,
       'aa' => '',
       'an' => [],
       'rd' => 1,
       'op' => 'query',
       '__' => '<original dns packet>',
     }
     
     # a successful reply
     
     {
       'qd' => [ [ 'www.google.de', 'a', 'in' ] ],
       'rc' => 0,
       'ar' => [
                 [ 'a.l.google.com', 'a', 'in', 3600, '209.85.139.9' ],
                 [ 'b.l.google.com', 'a', 'in', 3600, '64.233.179.9' ],
                 [ 'c.l.google.com', 'a', 'in', 3600, '64.233.161.9' ],
               ],
       'ns' => [
                 [ 'l.google.com', 'ns', 'in', 3600, 'a.l.google.com' ],
                 [ 'l.google.com', 'ns', 'in', 3600, 'b.l.google.com' ],
               ],
       'tc' => '',
       'ra' => 1,
       'qr' => 1,
       'id' => 64265,
       'aa' => '',
       'an' => [
                 [ 'www.google.de', 'cname', 'in', 3600, 'www.google.com' ],
                 [ 'www.google.com', 'cname', 'in', 3600, 'www.l.google.com' ],
                 [ 'www.l.google.com', 'a', 'in', 3600, '66.249.93.104' ],
                 [ 'www.l.google.com', 'a', 'in', 3600, '66.249.93.147' ],
               ],
       'rd' => 1,
       'op' => 0,
       '__' => '<original dns packet>',
     }
  
  =cut
  
  sub dns_unpack($) {
     local $pkt = shift;
     my ($id, $flags, $qd, $an, $ns, $ar)
        = unpack "nn nnnn A*", $pkt;
  
     local $ofs = 6 * 2;
  
     {
        __ => $pkt,
        id => $id,
        qr => ! ! ($flags & 0x8000),
        aa => ! ! ($flags & 0x0400),
        tc => ! ! ($flags & 0x0200),
        rd => ! ! ($flags & 0x0100),
        ra => ! ! ($flags & 0x0080),
        ad => ! ! ($flags & 0x0020),
        cd => ! ! ($flags & 0x0010),
        op => $opcode_str{($flags & 0x001e) >> 11},
        rc => $rcode_str{($flags & 0x000f)},
  
        qd => [map _dec_qd, 1 .. $qd],
        an => [map _dec_rr, 1 .. $an],
        ns => [map _dec_rr, 1 .. $ns],
        ar => [map _dec_rr, 1 .. $ar],
     }
  }
  
  #############################################################################
  
  =back
  
  =head3 Extending DNS Encoder and Decoder
  
  This section describes an I<experimental> method to extend the DNS encoder
  and decoder with new opcode, rcode, class and type strings, as well as
  resource record decoders.
  
  Since this is experimental, it can change, as anything can change, but
  this interface is expe ctedc to be relatively stable and was stable during
  the whole existance of C<AnyEvent::DNS> so far.
  
  Note that, since changing the decoder or encoder might break existing
  code, you should either be sure to control for this, or only temporarily
  change these values, e.g. like so:
  
     my $decoded = do {
        local $AnyEvent::DNS::opcode_str{7} = "yxrrset";
        AnyEvent::DNS::dns_unpack $mypkt
     };
  
  =over 4
  
  =item %AnyEvent::DNS::opcode_id, %AnyEvent::DNS::opcode_str
  
  Two hashes that map lowercase opcode strings to numerical id's (For the
  encoder), or vice versa (for the decoder). Example: add a new opcode
  string C<notzone>.
  
     $AnyEvent::DNS::opcode_id{notzone} = 10;
     $AnyEvent::DNS::opcode_str{10} = 'notzone';
  
  =item %AnyEvent::DNS::rcode_id, %AnyEvent::DNS::rcode_str
  
  Same as above, for for rcode values.
  
  =item %AnyEvent::DNS::class_id, %AnyEvent::DNS::class_str
  
  Same as above, but for resource record class names/values.
  
  =item %AnyEvent::DNS::type_id, %AnyEvent::DNS::type_str
  
  Same as above, but for resource record type names/values.
  
  =item %AnyEvent::DNS::dec_rr
  
  This hash maps resource record type values to code references. When
  decoding, they are called with C<$_> set to the undecoded data portion and
  C<$ofs> being the current byte offset. of the record. You should have a
  look at the existing implementations to understand how it works in detail,
  but here are two examples:
  
  Decode an A record. A records are simply four bytes with one byte per
  address component, so the decoder simply unpacks them and joins them with
  dots in between:
  
     $AnyEvent::DNS::dec_rr{1} = sub { join ".", unpack "C4", $_ };
  
  Decode a CNAME record, which contains a potentially compressed domain
  name.
  
     package AnyEvent::DNS; # for %dec_rr, $ofsd and &_dec_name
     $dec_rr{5} = sub { local $ofs = $ofs - length; _dec_name };
  
  =back
  
  =head2 THE AnyEvent::DNS RESOLVER CLASS
  
  This is the class which does the actual protocol work.
  
  =over 4
  
  =cut
  
  use Carp ();
  use Scalar::Util ();
  use Socket ();
  
  our $NOW;
  
  =item AnyEvent::DNS::resolver
  
  This function creates and returns a resolver that is ready to use and
  should mimic the default resolver for your system as good as possible. It
  is used by AnyEvent itself as well.
  
  It only ever creates one resolver and returns this one on subsequent calls
  - see C<$AnyEvent::DNS::RESOLVER>, below, for details.
  
  Unless you have special needs, prefer this function over creating your own
  resolver object.
  
  The resolver is created with the following parameters:
  
     untaint          enabled
     max_outstanding  $ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS} (default 10)
  
  C<os_config> will be used for OS-specific configuration, unless
  C<$ENV{PERL_ANYEVENT_RESOLV_CONF}> is specified, in which case that file
  gets parsed.
  
  =item $AnyEvent::DNS::RESOLVER
  
  This variable stores the default resolver returned by
  C<AnyEvent::DNS::resolver>, or C<undef> when the default resolver hasn't
  been instantiated yet.
  
  One can provide a custom resolver (e.g. one with caching functionality)
  by storing it in this variable, causing all subsequent resolves done via
  C<AnyEvent::DNS::resolver> to be done via the custom one.
  
  =cut
  
  our $RESOLVER;
  
  sub resolver() {
     $RESOLVER || do {
        $RESOLVER = new AnyEvent::DNS
           untaint         => 1,
           max_outstanding => $ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}*1 || 10,
        ;
  
        $ENV{PERL_ANYEVENT_RESOLV_CONF}
           ? $RESOLVER->_load_resolv_conf_file ($ENV{PERL_ANYEVENT_RESOLV_CONF})
           : $RESOLVER->os_config;
  
        $RESOLVER
     }
  }
  
  =item $resolver = new AnyEvent::DNS key => value...
  
  Creates and returns a new resolver.
  
  The following options are supported:
  
  =over 4
  
  =item server => [...]
  
  A list of server addresses (default: C<v127.0.0.1> or C<::1>) in network
  format (i.e. as returned by C<AnyEvent::Socket::parse_address> - both IPv4
  and IPv6 are supported).
  
  =item timeout => [...]
  
  A list of timeouts to use (also determines the number of retries). To make
  three retries with individual time-outs of 2, 5 and 5 seconds, use C<[2,
  5, 5]>, which is also the default.
  
  =item search => [...]
  
  The default search list of suffixes to append to a domain name (default: none).
  
  =item ndots => $integer
  
  The number of dots (default: C<1>) that a name must have so that the resolver
  tries to resolve the name without any suffixes first.
  
  =item max_outstanding => $integer
  
  Most name servers do not handle many parallel requests very well. This
  option limits the number of outstanding requests to C<$integer>
  (default: C<10>), that means if you request more than this many requests,
  then the additional requests will be queued until some other requests have
  been resolved.
  
  =item reuse => $seconds
  
  The number of seconds (default: C<300>) that a query id cannot be re-used
  after a timeout. If there was no time-out then query ids can be reused
  immediately.
  
  =item untaint => $boolean
  
  When true, then the resolver will automatically untaint results, and might
  also ignore certain environment variables.
  
  =back
  
  =cut
  
  sub new {
     my ($class, %arg) = @_;
  
     my $self = bless {
        server  => [],
        timeout => [2, 5, 5],
        search  => [],
        ndots   => 1,
        max_outstanding => 10,
        reuse   => 300,
        %arg,
        inhibit => 0,
        reuse_q => [],
     }, $class;
  
     # search should default to gethostname's domain
     # but perl lacks a good posix module
  
     # try to create an ipv4 and an ipv6 socket
     # only fail when we cannot create either
     my $got_socket;
  
     Scalar::Util::weaken (my $wself = $self);
  
     if (socket my $fh4, AF_INET , Socket::SOCK_DGRAM(), 0) {
        ++$got_socket;
  
        AnyEvent::fh_unblock $fh4;
        $self->{fh4} = $fh4;
        $self->{rw4} = AE::io $fh4, 0, sub {
           if (my $peer = recv $fh4, my $pkt, MAX_PKT, 0) {
              $wself->_recv ($pkt, $peer);
           }
        };
     }
  
     if (AF_INET6 && socket my $fh6, AF_INET6, Socket::SOCK_DGRAM(), 0) {
        ++$got_socket;
  
        $self->{fh6} = $fh6;
        AnyEvent::fh_unblock $fh6;
        $self->{rw6} = AE::io $fh6, 0, sub {
           if (my $peer = recv $fh6, my $pkt, MAX_PKT, 0) {
              $wself->_recv ($pkt, $peer);
           }
        };
     }
  
     $got_socket
        or Carp::croak "unable to create either an IPv4 or an IPv6 socket";
  
     $self->_compile;
  
     $self
  }
  
  # called to start asynchronous configuration
  sub _config_begin {
     ++$_[0]{inhibit};
  }
  
  # called when done with async config
  sub _config_done {
     --$_[0]{inhibit};
     $_[0]->_compile;
     $_[0]->_scheduler;
  }
  
  =item $resolver->parse_resolv_conf ($string)
  
  Parses the given string as if it were a F<resolv.conf> file. The following
  directives are supported (but not necessarily implemented).
  
  C<#>- and C<;>-style comments, C<nameserver>, C<domain>, C<search>, C<sortlist>,
  C<options> (C<timeout>, C<attempts>, C<ndots>).
  
  Everything else is silently ignored.
  
  =cut
  
  sub parse_resolv_conf {
     my ($self, $resolvconf) = @_;
  
     $self->{server} = [];
     $self->{search} = [];
  
     my $attempts;
  
     for (split /\n/, $resolvconf) {
        s/\s*[;#].*$//; # not quite legal, but many people insist
  
        if (/^\s*nameserver\s+(\S+)\s*$/i) {
           my $ip = $1;
           if (my $ipn = AnyEvent::Socket::parse_address ($ip)) {
              push @{ $self->{server} }, $ipn;
           } else {
              AE::log 5 => "nameserver $ip invalid and ignored, while parsing resolver config.";
           }
        } elsif (/^\s*domain\s+(\S*)\s*$/i) {
           $self->{search} = [$1];
        } elsif (/^\s*search\s+(.*?)\s*$/i) {
           $self->{search} = [split /\s+/, $1];
        } elsif (/^\s*sortlist\s+(.*?)\s*$/i) {
           # ignored, NYI
        } elsif (/^\s*options\s+(.*?)\s*$/i) {
           for (split /\s+/, $1) {
              if (/^timeout:(\d+)$/) {
                 $self->{timeout} = [$1];
              } elsif (/^attempts:(\d+)$/) {
                 $attempts = $1;
              } elsif (/^ndots:(\d+)$/) {
                 $self->{ndots} = $1;
              } else {
                 # debug, rotate, no-check-names, inet6
              }
           }
        } else {
           # silently skip stuff we don't understand
        }
     }
  
     $self->{timeout} = [($self->{timeout}[0]) x $attempts]
        if $attempts;
  
     $self->_compile;
  }
  
  sub _load_resolv_conf_file {
     my ($self, $resolv_conf) = @_;
  
     $self->_config_begin;
  
     require AnyEvent::IO;
     AnyEvent::IO::aio_load ($resolv_conf, sub {
        if (my ($contents) = @_) {
           $self->parse_resolv_conf ($contents);
        } else {
           AE::log 4 => "$resolv_conf: $!";
        }
  
        $self->_config_done;
     });
  }
  
  =item $resolver->os_config
  
  Tries so load and parse F</etc/resolv.conf> on portable operating
  systems. Tries various egregious hacks on windows to force the DNS servers
  and searchlist out of the system.
  
  This method must be called at most once before trying to resolve anything.
  
  =cut
  
  sub os_config {
     my ($self) = @_;
  
     $self->_config_begin;
  
     $self->{server} = [];
     $self->{search} = [];
  
     if ((AnyEvent::WIN32 || $^O =~ /cygwin/i)) {
        # TODO: this blocks the program, but should not, but I
        # am too lazy to implement and test it. need to boot windows. ugh.
  
        #no strict 'refs';
  
        # there are many options to find the current nameservers etc. on windows
        # all of them don't work consistently:
        # - the registry thing needs separate code on win32 native vs. cygwin
        # - the registry layout differs between windows versions
        # - calling windows api functions doesn't work on cygwin
        # - ipconfig uses locale-specific messages
  
        # we use Net::DNS::Resolver first, and if it fails, will fall back to
        # ipconfig parsing.
        unless (eval {
           # Net::DNS::Resolver uses a LOT of ram (~10mb), but what can we do :/
           # (this seems mostly to be due to Win32::API).
           require Net::DNS::Resolver;
           my $r = Net::DNS::Resolver->new;
  
           $r->nameservers
              or die;
  
           for my $s ($r->nameservers) {
              if (my $ipn = AnyEvent::Socket::parse_address ($s)) {
                 push @{ $self->{server} }, $ipn;
              }
           }
           $self->{search} = [$r->searchlist];
  
           1
        }) {
           # we use ipconfig parsing because, despite all its brokenness,
           # it seems quite stable in practise.
           # unfortunately it wants a console window.
           # for good measure, we append a fallback nameserver to our list.
  
           if (open my $fh, "ipconfig /all |") {
              # parsing strategy: we go through the output and look for
              # :-lines with DNS in them. everything in those is regarded as
              # either a nameserver (if it parses as an ip address), or a suffix
              # (all else).
  
              my $dns;
              local $_;
              while (<$fh>) {
                 if (s/^\s.*\bdns\b.*://i) {
                    $dns = 1;
                 } elsif (/^\S/ || /^\s[^:]{16,}: /) {
                    $dns = 0;
                 }
                 if ($dns && /^\s*(\S+)\s*$/) {
                    my $s = $1;
                    $s =~ s/%\d+(?!\S)//; # get rid of ipv6 scope id
                    if (my $ipn = AnyEvent::Socket::parse_address ($s)) {
                       push @{ $self->{server} }, $ipn;
                    } else {
                       push @{ $self->{search} }, $s;
                    }
                 }
              }
           }
        }
  
        # always add the fallback servers on windows
        push @{ $self->{server} }, @DNS_FALLBACK;
  
        $self->_config_done;
     } else {
        # try /etc/resolv.conf everywhere else
  
        require AnyEvent::IO;
        AnyEvent::IO::aio_stat ("/etc/resolv.conf", sub {
           $self->_load_resolv_conf_file ("/etc/resolv.conf")
              if @_;
           $self->_config_done;
        });
     }
  }
  
  =item $resolver->timeout ($timeout, ...)
  
  Sets the timeout values. See the C<timeout> constructor argument (and
  note that this method expects the timeout values themselves, not an
  array-reference).
  
  =cut
  
  sub timeout {
     my ($self, @timeout) = @_;
  
     $self->{timeout} = \@timeout;
     $self->_compile;
  }
  
  =item $resolver->max_outstanding ($nrequests)
  
  Sets the maximum number of outstanding requests to C<$nrequests>. See the
  C<max_outstanding> constructor argument.
  
  =cut
  
  sub max_outstanding {
     my ($self, $max) = @_;
  
     $self->{max_outstanding} = $max;
     $self->_compile;
  }
  
  sub _compile {
     my $self = shift;
  
     my %search; $self->{search} = [grep 0 < length, grep !$search{$_}++, @{ $self->{search} }];
     my %server; $self->{server} = [grep 0 < length, grep !$server{$_}++, @{ $self->{server} }];
  
     unless (@{ $self->{server} }) {
        # use 127.0.0.1/::1 by default, add public nameservers as fallback
        my $default = $AnyEvent::PROTOCOL{ipv6} > $AnyEvent::PROTOCOL{ipv4}
                      ? "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1" : "\x7f\x00\x00\x01";
        $self->{server} = [$default, @DNS_FALLBACK];
     }
  
     my @retry;
  
     for my $timeout (@{ $self->{timeout} }) {
        for my $server (@{ $self->{server} }) {
           push @retry, [$server, $timeout];
        }
     }
  
     $self->{retry} = \@retry;
  }
  
  sub _feed {
     my ($self, $res) = @_;
  
     ($res) = $res =~ /^(.*)$/s
        if AnyEvent::TAINT && $self->{untaint};
  
     $res = dns_unpack $res
        or return;
  
     my $id = $self->{id}{$res->{id}};
  
     return unless ref $id;
  
     $NOW = time;
     $id->[1]->($res);
  }
  
  sub _recv {
     my ($self, $pkt, $peer) = @_;
  
     # we ignore errors (often one gets port unreachable, but there is
     # no good way to take advantage of that.
  
     my ($port, $host) = AnyEvent::Socket::unpack_sockaddr ($peer);
  
     return unless $port == DOMAIN_PORT && grep $_ eq $host, @{ $self->{server} };
  
     $self->_feed ($pkt);
  }
  
  sub _free_id {
     my ($self, $id, $timeout) = @_;
  
     if ($timeout) {
        # we need to block the id for a while
        $self->{id}{$id} = 1;
        push @{ $self->{reuse_q} }, [$NOW + $self->{reuse}, $id];
     } else {
        # we can quickly recycle the id
        delete $self->{id}{$id};
     }
  
     --$self->{outstanding};
     $self->_scheduler;
  }
  
  # execute a single request, involves sending it with timeouts to multiple servers
  sub _exec {
     my ($self, $req) = @_;
  
     my $retry; # of retries
     my $do_retry;
  
     $do_retry = sub {
        my $retry_cfg = $self->{retry}[$retry++]
           or do {
              # failure
              $self->_free_id ($req->[2], $retry > 1);
              undef $do_retry; return $req->[1]->();
           };
  
        my ($server, $timeout) = @$retry_cfg;
        
        $self->{id}{$req->[2]} = [(AE::timer $timeout, 0, sub {
           $NOW = time;
  
           # timeout, try next
           &$do_retry if $do_retry;
        }), sub {
           my ($res) = @_;
  
           if ($res->{tc}) {
              # success, but truncated, so use tcp
              AnyEvent::Socket::tcp_connect (AnyEvent::Socket::format_address ($server), DOMAIN_PORT, sub {
                 return unless $do_retry; # some other request could have invalidated us already
  
                 my ($fh) = @_
                    or return &$do_retry;
  
                 require AnyEvent::Handle;
  
                 my $handle; $handle = new AnyEvent::Handle
                    fh       => $fh,
                    timeout  => $timeout,
                    on_error => sub {
                       undef $handle;
                       return unless $do_retry; # some other request could have invalidated us already
                       # failure, try next
                       &$do_retry;
                    };
  
                 $handle->push_write (pack "n/a*", $req->[0]);
                 $handle->push_read (chunk => 2, sub {
                    $handle->unshift_read (chunk => (unpack "n", $_[1]), sub {
                       undef $handle;
                       $self->_feed ($_[1]);
                    });
                 });
  
              }, sub { $timeout });
  
           } else {
              # success
              $self->_free_id ($req->[2], $retry > 1);
              undef $do_retry; return $req->[1]->($res);
           }
        }];
        
        my $sa = AnyEvent::Socket::pack_sockaddr (DOMAIN_PORT, $server);
  
        my $fh = AF_INET == AnyEvent::Socket::sockaddr_family ($sa)
                 ? $self->{fh4} : $self->{fh6}
           or return &$do_retry;
  
        send $fh, $req->[0], 0, $sa;
     };
  
     &$do_retry;
  }
  
  sub _scheduler {
     my ($self) = @_;
  
     return if $self->{inhibit};
  
     #no strict 'refs';
  
     $NOW = time;
  
     # first clear id reuse queue
     delete $self->{id}{ (shift @{ $self->{reuse_q} })->[1] }
        while @{ $self->{reuse_q} } && $self->{reuse_q}[0][0] <= $NOW;
  
     while ($self->{outstanding} < $self->{max_outstanding}) {
  
        if (@{ $self->{reuse_q} } >= 30000) {
           # we ran out of ID's, wait a bit
           $self->{reuse_to} ||= AE::timer $self->{reuse_q}[0][0] - $NOW, 0, sub {
              delete $self->{reuse_to};
              $self->_scheduler;
           };
           last;
        }
  
        if (my $req = shift @{ $self->{queue} }) {
           # found a request in the queue, execute it
           while () {
              $req->[2] = int rand 65536;
              last unless exists $self->{id}{$req->[2]};
           }
  
           ++$self->{outstanding};
           $self->{id}{$req->[2]} = 1;
           substr $req->[0], 0, 2, pack "n", $req->[2];
  
           $self->_exec ($req);
  
        } elsif (my $cb = shift @{ $self->{wait} }) {
           # found a wait_for_slot callback
           $cb->($self);
  
        } else {
           # nothing to do, just exit
           last;
        }
     }
  }
  
  =item $resolver->request ($req, $cb->($res))
  
  This is the main low-level workhorse for sending DNS requests.
  
  This function sends a single request (a hash-ref formated as specified
  for C<dns_pack>) to the configured nameservers in turn until it gets a
  response. It handles timeouts, retries and automatically falls back to
  virtual circuit mode (TCP) when it receives a truncated reply. It does not
  handle anything else, such as the domain searchlist or relative names -
  use C<< ->resolve >> for that.
  
  Calls the callback with the decoded response packet if a reply was
  received, or no arguments in case none of the servers answered.
  
  =cut
  
  sub request($$) {
     my ($self, $req, $cb) = @_;
  
     # _enc_name barfs on names that are too long, which is often outside
     # program control, so check for too long names here.
     for (@{ $req->{qd} }) {
        return AE::postpone sub { $cb->(undef) }
           if 255 < length $_->[0];
     }
  
     push @{ $self->{queue} }, [dns_pack $req, $cb];
     $self->_scheduler;
  }
  
  =item $resolver->resolve ($qname, $qtype, %options, $cb->(@rr))
  
  Queries the DNS for the given domain name C<$qname> of type C<$qtype>.
  
  A C<$qtype> is either a numerical query type (e.g. C<1> for A records) or
  a lowercase name (you have to look at the source to see which aliases are
  supported, but all types from RFC 1035, C<aaaa>, C<srv>, C<spf> and a few
  more are known to this module). A C<$qtype> of "*" is supported and means
  "any" record type.
  
  The callback will be invoked with a list of matching result records or
  none on any error or if the name could not be found.
  
  CNAME chains (although illegal) are followed up to a length of 10.
  
  The callback will be invoked with arraryefs of the form C<[$name,
  $type, $class, $ttl, @data>], where C<$name> is the domain name,
  C<$type> a type string or number, C<$class> a class name, C<$ttl> is the
  remaining time-to-live and C<@data> is resource-record-dependent data, in
  seconds. For C<a> records, this will be the textual IPv4 addresses, for
  C<ns> or C<cname> records this will be a domain name, for C<txt> records
  these are all the strings and so on.
  
  All types mentioned in RFC 1035, C<aaaa>, C<srv>, C<naptr> and C<spf> are
  decoded. All resource records not known to this module will have the raw
  C<rdata> field as fifth array element.
  
  Note that this resolver is just a stub resolver: it requires a name server
  supporting recursive queries, will not do any recursive queries itself and
  is not secure when used against an untrusted name server.
  
  The following options are supported:
  
  =over 4
  
  =item search => [$suffix...]
  
  Use the given search list (which might be empty), by appending each one
  in turn to the C<$qname>. If this option is missing then the configured
  C<ndots> and C<search> values define its value (depending on C<ndots>, the
  empty suffix will be prepended or appended to that C<search> value). If
  the C<$qname> ends in a dot, then the searchlist will be ignored.
  
  =item accept => [$type...]
  
  Lists the acceptable result types: only result types in this set will be
  accepted and returned. The default includes the C<$qtype> and nothing
  else. If this list includes C<cname>, then CNAME-chains will not be
  followed (because you asked for the CNAME record).
  
  =item class => "class"
  
  Specify the query class ("in" for internet, "ch" for chaosnet and "hs" for
  hesiod are the only ones making sense). The default is "in", of course.
  
  =back
  
  Examples:
  
     # full example, you can paste this into perl:
     use Data::Dumper;
     use AnyEvent::DNS;
     AnyEvent::DNS::resolver->resolve (
        "google.com", "*", my $cv = AnyEvent->condvar);
     warn Dumper [$cv->recv];
  
     # shortened result:
     # [
     #   [ 'google.com', 'soa', 'in', 3600, 'ns1.google.com', 'dns-admin.google.com',
     #     2008052701, 7200, 1800, 1209600, 300 ],
     #   [
     #     'google.com', 'txt', 'in', 3600,
     #     'v=spf1 include:_netblocks.google.com ~all'
     #   ],
     #   [ 'google.com', 'a', 'in', 3600, '64.233.187.99' ],
     #   [ 'google.com', 'mx', 'in', 3600, 10, 'smtp2.google.com' ],
     #   [ 'google.com', 'ns', 'in', 3600, 'ns2.google.com' ],
     # ]
  
     # resolve a records:
     $res->resolve ("ruth.plan9.de", "a", sub { warn Dumper [@_] });
  
     # result:
     # [
     #   [ 'ruth.schmorp.de', 'a', 'in', 86400, '129.13.162.95' ]
     # ]
  
     # resolve any records, but return only a and aaaa records:
     $res->resolve ("test1.laendle", "*",
        accept => ["a", "aaaa"],
        sub {
           warn Dumper [@_];
        }
     );
  
     # result:
     # [
     #   [ 'test1.laendle', 'a', 'in', 86400, '10.0.0.255' ],
     #   [ 'test1.laendle', 'aaaa', 'in', 60, '3ffe:1900:4545:0002:0240:0000:0000:f7e1' ]
     # ]
  
  =cut
  
  sub resolve($%) {
     my $cb = pop;
     my ($self, $qname, $qtype, %opt) = @_;
  
     $self->wait_for_slot (sub {
        my $self = shift;
  
        my @search = $qname =~ s/\.$//
           ? ""
           : $opt{search}
             ? @{ $opt{search} }
             : ($qname =~ y/.//) >= $self->{ndots}
               ? ("", @{ $self->{search} })
               : (@{ $self->{search} }, "");
  
        my $class = $opt{class} || "in";
  
        my %atype = $opt{accept}
           ? map +($_ => 1), @{ $opt{accept} }
           : ($qtype => 1);
  
        # advance in searchlist
        my ($do_search, $do_req);
        
        $do_search = sub {
           @search
              or (undef $do_search), (undef $do_req), return $cb->();
  
           (my $name = lc "$qname." . shift @search) =~ s/\.$//;
           my $depth = 10;
  
           # advance in cname-chain
           $do_req = sub {
              $self->request ({
                 rd => 1,
                 qd => [[$name, $qtype, $class]],
              }, sub {
                 my ($res) = @_
                    or return $do_search->();
  
                 my $cname;
  
                 while () {
                    # results found?
                    my @rr = grep $name eq lc $_->[0] && ($atype{"*"} || $atype{$_->[1]}), @{ $res->{an} };
  
                    (undef $do_search), (undef $do_req), return $cb->(@rr)
                       if @rr;
  
                    # see if there is a cname we can follow
                    my @rr = grep $name eq lc $_->[0] && $_->[1] eq "cname", @{ $res->{an} };
  
                    if (@rr) {
                       $depth--
                          or return $do_search->(); # cname chain too long
  
                       $cname = 1;
                       $name = lc $rr[0][4];
  
                    } elsif ($cname) {
                       # follow the cname
                       return $do_req->();
  
                    } else {
                       # no, not found anything
                       return $do_search->();
                    }
                  }
              });
           };
  
           $do_req->();
        };
  
        $do_search->();
     });
  }
  
  =item $resolver->wait_for_slot ($cb->($resolver))
  
  Wait until a free request slot is available and call the callback with the
  resolver object.
  
  A request slot is used each time a request is actually sent to the
  nameservers: There are never more than C<max_outstanding> of them.
  
  Although you can submit more requests (they will simply be queued until
  a request slot becomes available), sometimes, usually for rate-limiting
  purposes, it is useful to instead wait for a slot before generating the
  request (or simply to know when the request load is low enough so one can
  submit requests again).
  
  This is what this method does: The callback will be called when submitting
  a DNS request will not result in that request being queued. The callback
  may or may not generate any requests in response.
  
  Note that the callback will only be invoked when the request queue is
  empty, so this does not play well if somebody else keeps the request queue
  full at all times.
  
  =cut
  
  sub wait_for_slot {
     my ($self, $cb) = @_;
  
     push @{ $self->{wait} }, $cb;
     $self->_scheduler;
  }
  
  use AnyEvent::Socket (); # circular dependency, so do not import anything and do it at the end
  
  =back
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://anyevent.schmorp.de
  
  =cut
  
  1
ANYEVENT_DNS

$fatpacked{"AnyEvent/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_DEBUG';
  =head1 NAME
  
  AnyEvent::Debug - debugging utilities for AnyEvent
  
  =head1 SYNOPSIS
  
     use AnyEvent::Debug;
  
     # create an interactive shell into the program
     my $shell = AnyEvent::Debug::shell "unix/", "/home/schmorp/myshell";
     # then on the shell: "socat readline /home/schmorp/myshell"
  
  =head1 DESCRIPTION
  
  This module provides functionality hopefully useful for debugging.
  
  At the moment, "only" an interactive shell is implemented. This shell
  allows you to interactively "telnet into" your program and execute Perl
  code, e.g. to look at global variables.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =cut
  
  package AnyEvent::Debug;
  
  use B ();
  use Carp ();
  use Errno ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  use AnyEvent::Socket ();
  use AnyEvent::Log ();
  
  our $TRACE = 1; # trace status
  
  our ($TRACE_LOGGER, $TRACE_ENABLED);
  
  # cache often-used strings, purely to save memory, at the expense of speed
  our %STRCACHE;
  
  =item $shell = AnyEvent::Debug::shell $host, $service
  
  This function binds on the given host and service port and returns a
  shell object, which determines the lifetime of the shell. Any number
  of connections are accepted on the port, and they will give you a very
  primitive shell that simply executes every line you enter.
  
  All commands will be executed "blockingly" with the socket C<select>ed for
  output. For a less "blocking" interface see L<Coro::Debug>.
  
  The commands will be executed in the C<AnyEvent::Debug::shell> package,
  which currently has "help" and a few other commands, and can be freely
  modified by all shells. Code is evaluated under C<use strict 'subs'>.
  
  Every shell has a logging context (C<$LOGGER>) that is attached to
  C<$AnyEvent::Log::COLLECT>), which is especially useful to gether debug
  and trace messages.
  
  As a general programming guide, consider the beneficial aspects of
  using more global (C<our>) variables than local ones (C<my>) in package
  scope: Earlier all my modules tended to hide internal variables inside
  C<my> variables, so users couldn't accidentally access them. Having
  interactive access to your programs changed that: having internal
  variables still in the global scope means you can debug them easier.
  
  As no authentication is done, in most cases it is best not to use a TCP
  port, but a unix domain socket, whcih can be put wherever you can access
  it, but not others:
  
     our $SHELL = AnyEvent::Debug::shell "unix/", "/home/schmorp/shell";
  
  Then you can use a tool to connect to the shell, such as the ever
  versatile C<socat>, which in addition can give you readline support:
  
     socat readline /home/schmorp/shell
     # or:
     cd /home/schmorp; socat readline unix:shell
  
  Socat can even give you a persistent history:
  
     socat readline,history=.anyevent-history unix:shell
  
  Binding on C<127.0.0.1> (or C<::1>) might be a less secure but sitll not
  totally insecure (on single-user machines) alternative to let you use
  other tools, such as telnet:
  
     our $SHELL = AnyEvent::Debug::shell "127.1", "1357";
  
  And then:
  
     telnet localhost 1357
  
  =cut
  
  sub shell($$) {
     local $TRACE = 0;
  
     AnyEvent::Socket::tcp_server $_[0], $_[1], sub {
        my ($fh, $host, $port) = @_;
  
        syswrite $fh, "Welcome, $host:$port, use 'help' for more info!\015\012> ";
        my $rbuf;
  
        my $logger = new AnyEvent::Log::Ctx
           log_cb => sub {
              syswrite $fh, shift;
              0
           };
  
        my $logger_guard = AnyEvent::Util::guard {
           $AnyEvent::Log::COLLECT->detach ($logger);
        };
        $AnyEvent::Log::COLLECT->attach ($logger);
  
        local $TRACE = 0;
        my $rw; $rw = AE::io $fh, 0, sub {
           my $len = sysread $fh, $rbuf, 1024, length $rbuf;
  
           $logger_guard if 0; # reference it
  
           if (defined $len ? $len == 0 : ($! != Errno::EAGAIN && $! != Errno::EWOULDBLOCK)) {
              undef $rw;
           } else {
              while ($rbuf =~ s/^(.*)\015?\012//) {
                 my $line = $1;
  
                 AnyEvent::fh_block $fh;
  
                 if ($line =~ /^\s*exit\b/) {
                    syswrite $fh, "sorry, no... if you want to execute exit, try CORE::exit.\015\012";
                 } elsif ($line =~ /^\s*coro\b\s*(.*)/) {
                    my $arg = $1;
                    if (eval { require Coro; require Coro::Debug }) {
                       if ($arg =~ /\S/) {
                          Coro::async (sub {
                             select $fh;
                             Coro::Debug::command ($arg);
                             local $| = 1; # older Coro versions do not flush
                             syswrite $fh, "> ";
                          });
                          return;
                       } else {
                          undef $rw;
                          syswrite $fh, "switching to Coro::Debug...\015\012";
                          Coro::async (sub { Coro::Debug::session ($fh) });
                          return;
                       }
                    } else {
                       syswrite $fh, "Coro not available.\015\012";
                    }
  
                 } else {
                    package AnyEvent::Debug::shell;
  
                    no strict 'vars';
                    local $LOGGER = $logger;
                    my $old_stdout = select $fh;
                    local $| = 1;
  
                    my @res = eval $line;
  
                    select $old_stdout;
                    syswrite $fh, "$@" if $@;
                    syswrite $fh, "\015\012";
  
                    if (@res > 1) {
                       syswrite $fh, "$_: $res[$_]\015\012" for 0 .. $#res;
                    } elsif (@res == 1) {
                       syswrite $fh, "$res[0]\015\012";
                    }
                 }
  
                 syswrite $fh, "> ";
                 AnyEvent::fh_unblock $fh;
              }
           }
        };
     }
  }
  
  {
     package AnyEvent::Debug::shell;
  
     our $LOGGER;
  
     sub help() {
        <<EOF
  help         this command
  wr [level]   sets wrap level to level (or toggles if missing)
  v [level]    sets verbosity (or toggles between 0 and 9 if missing)
  wl 'regex'   print wrapped watchers matching the regex (or all if missing)
  i id,...     prints the watcher with the given ids in more detail
  t            enable tracing for newly created watchers (enabled by default)
  ut           disable tracing for newly created watchers
  t  id,...    enable tracing for the given watcher (enabled by default)
  ut id,...    disable tracing for the given watcher
  w id,...     converts the watcher ids to watcher objects (for scripting)
  coro xxx     run xxx as Coro::Debug shell command, if available
  coro         switch to Coro::Debug shell, if available
  EOF
     }
  
     sub wl(;$) {
        my $re = @_ ? qr<$_[0]>i : qr<.>;
  
        my %res;
  
        while (my ($k, $v) = each %AnyEvent::Debug::Wrapped) {
           my $s = "$v";
           $res{$s} = $k . (exists $v->{error} ? "*" : " ")
              if $s =~ $re;
        }
  
        join "", map "$res{$_} $_\n", sort keys %res
     }
  
     sub w {
        map {
           $AnyEvent::Debug::Wrapped{$_} || do {
              print "$_: no such wrapped watcher.\n";
              ()
           }
        } @_
     }
  
     sub i {
        join "",
           map $_->id . " $_\n" . $_->verbose . "\n",
              &w
     }
  
     sub wr {
        AnyEvent::Debug::wrap (@_);
  
        "wrap level now $AnyEvent::Debug::WRAP_LEVEL"
     }
  
     sub t {
        if (@_) {
           @_ = &w;
           $_->trace (1)
              for @_;
           "tracing enabled for @_."
        } else {
           $AnyEvent::Debug::TRACE = 1;
           "tracing for newly created watchers is now enabled."
        }
     }
  
     sub u {
        if (@_) {
           @_ = &w;
           $_->trace (0)
              for @_;
           "tracing disabled for @_."
        } else {
           $AnyEvent::Debug::TRACE = 0;
           "tracing for newly created watchers is now disabled."
        }
     }
  
     sub v {
        $LOGGER->level (@_ ? $_[0] : $LOGGER->[1] ? 0 : 9);
  
        "verbose logging is now " . ($LOGGER->[1] ? "enabled" : "disabled") . "."
     }
  }
  
  =item AnyEvent::Debug::wrap [$level]
  
  Sets the instrumenting/wrapping level of all watchers that are being
  created after this call. If no C<$level> has been specified, then it
  toggles between C<0> and C<1>.
  
  The default wrap level is C<0>, or whatever
  C<$ENV{PERL_ANYEVENT_DEBUG_WRAP}> specifies.
  
  A level of C<0> disables wrapping, i.e. AnyEvent works normally, and in
  its most efficient mode.
  
  A level of C<1> or higher enables wrapping, which replaces all watchers
  by AnyEvent::Debug::Wrapped objects, stores the location where a
  watcher was created and wraps the callback to log all invocations at
  "trace" loglevel if tracing is enabled fore the watcher. The initial
  state of tracing when creating a watcher is taken from the global
  variable C<$AnyEvent:Debug::TRACE>. The default value of that variable
  is C<1>, but it can make sense to set it to C<0> and then do C<< local
  $AnyEvent::Debug::TRACE = 1 >> in a block where you create "interesting"
  watchers. Tracing can also be enabled and disabled later by calling the
  watcher's C<trace> method.
  
  The wrapper will also count how many times the callback was invoked and
  will record up to ten runtime errors with corresponding backtraces. It
  will also log runtime errors at "error" loglevel.
  
  To see the trace messages, you can invoke your program with
  C<PERL_ANYEVENT_VERBOSE=9>, or you can use AnyEvent::Log to divert
  the trace messages in any way you like (the EXAMPLES section in
  L<AnyEvent::Log> has some examples).
  
  A level of C<2> does everything that level C<1> does, but also stores a
  full backtrace of the location the watcher was created, which slows down
  watcher creation considerably.
  
  Every wrapped watcher will be linked into C<%AnyEvent::Debug::Wrapped>,
  with its address as key. The C<wl> command in the debug shell can be used
  to list watchers.
  
  Instrumenting can increase the size of each watcher multiple times, and,
  especially when backtraces are involved, also slows down watcher creation
  a lot.
  
  Also, enabling and disabling instrumentation will not recover the full
  performance that you had before wrapping (the AE::xxx functions will stay
  slower, for example).
  
  If you are developing your program, also consider using AnyEvent::Strict
  to check for common mistakes.
  
  =cut
  
  our $WRAP_LEVEL;
  our $TRACE_CUR;
  our $POST_DETECT;
  
  sub wrap(;$) {
     my $PREV_LEVEL = $WRAP_LEVEL;
     $WRAP_LEVEL = @_ ? 0+shift : $WRAP_LEVEL ? 0 : 1;
  
     if ($AnyEvent::MODEL) {
        if ($WRAP_LEVEL && !$PREV_LEVEL) {
           $TRACE_LOGGER = AnyEvent::Log::logger trace => \$TRACE_ENABLED;
           AnyEvent::_isa_hook 0 => "AnyEvent::Debug::Wrap", 1;
           AnyEvent::Debug::Wrap::_reset ();
        } elsif (!$WRAP_LEVEL && $PREV_LEVEL) {
           AnyEvent::_isa_hook 0 => undef;
        }
     } else {
        $POST_DETECT ||= AnyEvent::post_detect {
           undef $POST_DETECT;
           return unless $WRAP_LEVEL;
  
           (my $level, $WRAP_LEVEL) = ($WRAP_LEVEL, undef);
  
           require AnyEvent::Strict unless $AnyEvent::Strict::VERSION;
  
           AnyEvent::post_detect { # make sure we run after AnyEvent::Strict
              wrap ($level);
           };
        };
     }
  }
  
  =item AnyEvent::Debug::path2mod $path
  
  Tries to replace a path (e.g. the file name returned by caller)
  by a module name. Returns the path unchanged if it fails.
  
  Example:
  
     print AnyEvent::Debug::path2mod "/usr/lib/perl5/AnyEvent/Debug.pm";
     # might print "AnyEvent::Debug"
  
  =cut
  
  sub path2mod($) {
     keys %INC; # reset iterator
  
     while (my ($k, $v) = each %INC) {
        if ($_[0] eq $v) {
           $k =~ s%/%::%g if $k =~ s/\.pm$//;
           return $k;
        }
     }
  
     my $path = shift;
  
     $path =~ s%^\./%%;
  
     $path
  }
  
  =item AnyEvent::Debug::cb2str $cb
  
  Using various gambits, tries to convert a callback (e.g. a code reference)
  into a more useful string.
  
  Very useful if you debug a program and have some callback, but you want to
  know where in the program the callback is actually defined.
  
  =cut
  
  sub cb2str($) {
     my $cb = shift;
  
     "CODE" eq ref $cb
        or return "$cb";
  
     eval {
        my $cv = B::svref_2object ($cb);
  
        my $gv = $cv->GV
           or return "$cb";
  
        my $name = $gv->NAME;
  
        return (AnyEvent::Debug::path2mod $gv->FILE) . ":" . $gv->LINE
           if $name eq "__ANON__";
  
        $gv->STASH->NAME . "::" . $name;
     } || "$cb"
  }
  
  sub sv2str($) {
     if (ref $_[0]) {
        if (ref $_[0] eq "CODE") {
           return "$_[0]=" . cb2str $_[0];
        } else {
           return "$_[0]";
        }
     } else {
        for ("\'$_[0]\'") { # make copy
           substr $_, $Carp::MaxArgLen, length, "'..."
              if length > $Carp::MaxArgLen;
           return $_;
        }
     }
  }
  
  =item AnyEvent::Debug::backtrace [$skip]
  
  Creates a backtrace (actually an AnyEvent::Debug::Backtrace object
  that you can stringify), not unlike the Carp module would. Unlike the
  Carp module it resolves some references (such as callbacks) to more
  user-friendly strings, has a more succinct output format and most
  importantly: doesn't leak memory like hell.
  
  The reason it creates an object is to save time, as formatting can be
  done at a later time. Still, creating a backtrace is a relatively slow
  operation.
  
  =cut
  
  sub backtrace(;$) {
     my $w = shift;
  
     my (@bt, @c);
     my ($modlen, $sub);
  
     for (;;) {
        #         0          1      2            3         4           5          6            7       8         9         10
        # ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask, $hinthash)
        package DB;
        @c = caller $w++
           or last;
        package AnyEvent::Debug; # no block for speed reasons
  
        if ($c[7]) {
           $sub = "require $c[6]";
        } elsif (defined $c[6]) {
           $sub = "eval \"\"";
        } else {
           $sub = ($c[4] ? "" : "&") . $c[3];
  
           $sub .= "("
                   . (join ",",
                         map sv2str $DB::args[$_],
                            0 .. (@DB::args < $Carp::MaxArgNums ? @DB::args : $Carp::MaxArgNums) - 1)
                   . ")"
              if $c[4];
        }
  
        push @bt, [\($STRCACHE{$c[1]} ||= $c[1]), $c[2], $sub];
     }
  
     @DB::args = ();
  
     bless \@bt, "AnyEvent::Debug::Backtrace"
  }
  
  =back
  
  =cut
  
  package AnyEvent::Debug::Wrap;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Scalar::Util ();
  use Carp ();
  
  sub _reset {
     for my $name (qw(io timer signal child idle)) {
        my $super = "SUPER::$name";
  
        *$name = sub {
           my ($self, %arg) = @_;
  
           my $w;
  
           my $t = $TRACE;
  
           my ($pkg, $file, $line, $sub);
           
           $w = 0;
           do {
              ($pkg, $file, $line) = caller $w++;
           } while $pkg =~ /^(?:AE|AnyEvent::(?:Socket|Handle|Util|Debug|Strict|Base|CondVar|CondVar::Base|Impl::.*)|Coro::AnyEvent::CondVar)$/;
  
           $sub = (caller $w)[3];
  
           my $cb = $arg{cb};
           $arg{cb} = sub {
              ++$w->{called};
  
              local $TRACE_CUR = $w;
  
              $TRACE_LOGGER->("enter $w") if $TRACE_ENABLED && $t;
              eval {
                 local $SIG{__DIE__} = sub {
                    die $_[0] . AnyEvent::Debug::backtrace
                       if defined $^S;
                 };
                 &$cb;
              };
              if ($@) {
                 my $err = "$@";
                 push @{ $w->{error} }, [AE::now, $err]
                    if @{ $w->{error} } < 10;
                 AE::log die => "($w) $err"
                    or warn "($w) $err";
              }
              $TRACE_LOGGER->("leave $w") if $TRACE_ENABLED && $t;
           };
  
           $self = bless {
              type   => $name,
              w      => $self->$super (%arg),
              rfile  => \($STRCACHE{$file} ||= $file),
              line   => $line,
              sub    => $sub,
              cur    => "$TRACE_CUR",
              now    => AE::now,
              arg    => \%arg,
              cb     => $cb,
              called => 0,
              rt     => \$t,
           }, "AnyEvent::Debug::Wrapped";
  
           delete $arg{cb};
  
           $self->{bt} = AnyEvent::Debug::backtrace 1
              if $WRAP_LEVEL >= 2;
  
           Scalar::Util::weaken ($w = $self);
           Scalar::Util::weaken ($AnyEvent::Debug::Wrapped{Scalar::Util::refaddr $self} = $self);
  
           $TRACE_LOGGER->("creat $w") if $TRACE_ENABLED && $t;
  
           $self
        };
     }
  }
  
  package AnyEvent::Debug::Wrapped;
  
  =head1 THE AnyEvent::Debug::Wrapped CLASS
  
  All watchers created while the wrap level is non-zero will be wrapped
  inside an AnyEvent::Debug::Wrapped object. The address of the
  wrapped watcher will become its ID - every watcher will be stored in
  C<$AnyEvent::Debug::Wrapped{$id}>.
  
  These wrapper objects can be stringified and have some methods defined on
  them.
  
  For debugging, of course, it can be helpful to look into these objects,
  which is why this is documented here, but this might change at any time in
  future versions.
  
  Each object is a relatively standard hash with the following members:
  
     type   => name of the method used ot create the watcher (e.g. C<io>, C<timer>).
     w      => the actual watcher
     rfile  => reference to the filename of the file the watcher was created in
     line   => line number where it was created
     sub    => function name (or a special string) which created the watcher
     cur    => if created inside another watcher callback, this is the string rep of the other watcher
     now    => the timestamp (AE::now) when the watcher was created
     arg    => the arguments used to create the watcher (sans C<cb>)
     cb     => the original callback used to create the watcher
     called => the number of times the callback was called
  
  Each object supports the following mehtods (warning: these are only
  available on wrapped watchers, so are best for interactive use via the
  debug shell).
  
  =over 4
  
  =cut
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use overload
     '""'     => sub {
        $_[0]{str} ||= do {
           my ($pkg, $line) = @{ $_[0]{caller} };
  
           my $mod = AnyEvent::Debug::path2mod ${ $_[0]{rfile} };
           my $sub = $_[0]{sub};
  
           if (defined $sub) {
              $sub =~ s/^\Q$mod\E:://;
              $sub = "($sub)";
           }
  
           "$mod:$_[0]{line}$sub>$_[0]{type}>"
           . (AnyEvent::Debug::cb2str $_[0]{cb})
        };
     },
     fallback => 1,
  ;
  
  =item $w->id
  
  Returns the numerical id of the watcher, as used in the debug shell.
  
  =cut
  
  sub id {
     Scalar::Util::refaddr shift
  }
  
  =item $w->verbose
  
  Returns a multiline textual description of the watcher, including the
  first ten exceptions caught while executing the callback.
  
  =cut
  
  sub verbose {
     my ($self) = @_;
  
     my $res = "type:    $self->{type} watcher\n"
             . "args:    " . (join " ", %{ $self->{arg} }) . "\n" # TODO: decode fh?
             . "created: " . (AnyEvent::Log::format_time $self->{now}) . " ($self->{now})\n"
             . "file:    ${ $self->{rfile} }\n"
             . "line:    $self->{line}\n"
             . "subname: $self->{sub}\n"
             . "context: $self->{cur}\n"
             . "tracing: " . (${ $self->{rt} } ? "enabled" : "disabled") . "\n"
             . "cb:      $self->{cb} (" . (AnyEvent::Debug::cb2str $self->{cb}) . ")\n"
             . "invoked: $self->{called} times\n";
  
     if (exists $self->{bt}) {
        $res .= "created\n$self->{bt}";
     }
  
     if (exists $self->{error}) {
        $res .= "errors:   " . @{$self->{error}} . "\n";
  
        $res .= "error: " . (AnyEvent::Log::format_time $_->[0]) . " ($_->[0]) $_->[1]\n"
           for @{$self->{error}};
     }
  
     $res
  }
  
  =item $w->trace ($on)
  
  Enables (C<$on> is true) or disables (C<$on> is false) tracing on this
  watcher.
  
  To get tracing messages, both the global logging settings must have trace
  messages enabled for the context C<AnyEvent::Debug> and tracing must be
  enabled for the wrapped watcher.
  
  To enable trace messages globally, the simplest way is to start the
  program with C<PERL_ANYEVENT_VERBOSE=9> in the environment.
  
  Tracing for each individual watcher is enabled by default (unless
  C<$AnyEvent::Debug::TRACE> has been set to false).
  
  =cut
  
  sub trace {
     ${ $_[0]{rt} } = $_[1];
  }
  
  sub DESTROY {
     $TRACE_LOGGER->("dstry $_[0]") if $TRACE_ENABLED && ${ $_[0]{rt} };
  
     delete $AnyEvent::Debug::Wrapped{Scalar::Util::refaddr $_[0]};
  }
  
  =back
  
  =cut
  
  package AnyEvent::Debug::Backtrace;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  sub as_string {
     my ($self) = @_;
  
     my @bt;
     my $modlen;
  
     for (@$self) {
        my ($rpath, $line, $sub) = @$_;
  
        $rpath = (AnyEvent::Debug::path2mod $$rpath) . " line $line";
        $modlen = length $rpath if $modlen < length $rpath;
  
        $sub =~ s/\r/\\r/g;
        $sub =~ s/\n/\\n/g;
        $sub =~ s/([\x00-\x1f\x7e-\xff])/sprintf "\\x%02x", ord $1/ge;
        $sub =~ s/([^\x20-\x7e])/sprintf "\\x{%x}", ord $1/ge;
  
        push @bt, [$rpath, $sub];
     }
  
     join "",
        map { sprintf "%*s %s\n", -$modlen, $_->[0], $_->[1] }
           @bt
  }
  
  use overload
     '""'     => \&as_string,
     fallback => 1,
  ;
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_DEBUG

$fatpacked{"AnyEvent/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_HTTP';
  =head1 NAME
  
  AnyEvent::HTTP - simple but non-blocking HTTP/HTTPS client
  
  =head1 SYNOPSIS
  
     use AnyEvent::HTTP;
  
     http_get "http://www.nethype.de/", sub { print $_[1] };
  
     # ... do something else here
  
  =head1 DESCRIPTION
  
  This module is an L<AnyEvent> user, you need to make sure that you use and
  run a supported event loop.
  
  This module implements a simple, stateless and non-blocking HTTP
  client. It supports GET, POST and other request methods, cookies and more,
  all on a very low level. It can follow redirects, supports proxies, and
  automatically limits the number of connections to the values specified in
  the RFC.
  
  It should generally be a "good client" that is enough for most HTTP
  tasks. Simple tasks should be simple, but complex tasks should still be
  possible as the user retains control over request and response headers.
  
  The caller is responsible for authentication management, cookies (if
  the simplistic implementation in this module doesn't suffice), referer
  and other high-level protocol details for which this module offers only
  limited support.
  
  =head2 METHODS
  
  =over 4
  
  =cut
  
  package AnyEvent::HTTP;
  
  use common::sense;
  
  use Errno ();
  
  use AnyEvent 5.0 ();
  use AnyEvent::Util ();
  use AnyEvent::Handle ();
  
  use base Exporter::;
  
  our $VERSION = 2.25;
  
  our @EXPORT = qw(http_get http_post http_head http_request);
  
  our $USERAGENT          = "Mozilla/5.0 (compatible; U; AnyEvent-HTTP/$VERSION; +http://software.schmorp.de/pkg/AnyEvent)";
  our $MAX_RECURSE        =  10;
  our $PERSISTENT_TIMEOUT =   3;
  our $TIMEOUT            = 300;
  our $MAX_PER_HOST       =   4; # changing this is evil
  
  our $PROXY;
  our $ACTIVE = 0;
  
  my %KA_CACHE; # indexed by uhost currently, points to [$handle...] array
  my %CO_SLOT;  # number of open connections, and wait queue, per host
  
  =item http_get $url, key => value..., $cb->($data, $headers)
  
  Executes an HTTP-GET request. See the http_request function for details on
  additional parameters and the return value.
  
  =item http_head $url, key => value..., $cb->($data, $headers)
  
  Executes an HTTP-HEAD request. See the http_request function for details
  on additional parameters and the return value.
  
  =item http_post $url, $body, key => value..., $cb->($data, $headers)
  
  Executes an HTTP-POST request with a request body of C<$body>. See the
  http_request function for details on additional parameters and the return
  value.
  
  =item http_request $method => $url, key => value..., $cb->($data, $headers)
  
  Executes a HTTP request of type C<$method> (e.g. C<GET>, C<POST>). The URL
  must be an absolute http or https URL.
  
  When called in void context, nothing is returned. In other contexts,
  C<http_request> returns a "cancellation guard" - you have to keep the
  object at least alive until the callback get called. If the object gets
  destroyed before the callback is called, the request will be cancelled.
  
  The callback will be called with the response body data as first argument
  (or C<undef> if an error occurred), and a hash-ref with response headers
  (and trailers) as second argument.
  
  All the headers in that hash are lowercased. In addition to the response
  headers, the "pseudo-headers" (uppercase to avoid clashing with possible
  response headers) C<HTTPVersion>, C<Status> and C<Reason> contain the
  three parts of the HTTP Status-Line of the same name. If an error occurs
  during the body phase of a request, then the original C<Status> and
  C<Reason> values from the header are available as C<OrigStatus> and
  C<OrigReason>.
  
  The pseudo-header C<URL> contains the actual URL (which can differ from
  the requested URL when following redirects - for example, you might get
  an error that your URL scheme is not supported even though your URL is a
  valid http URL because it redirected to an ftp URL, in which case you can
  look at the URL pseudo header).
  
  The pseudo-header C<Redirect> only exists when the request was a result
  of an internal redirect. In that case it is an array reference with
  the C<($data, $headers)> from the redirect response. Note that this
  response could in turn be the result of a redirect itself, and C<<
  $headers->{Redirect}[1]{Redirect} >> will then contain the original
  response, and so on.
  
  If the server sends a header multiple times, then their contents will be
  joined together with a comma (C<,>), as per the HTTP spec.
  
  If an internal error occurs, such as not being able to resolve a hostname,
  then C<$data> will be C<undef>, C<< $headers->{Status} >> will be
  C<590>-C<599> and the C<Reason> pseudo-header will contain an error
  message. Currently the following status codes are used:
  
  =over 4
  
  =item 595 - errors during connection establishment, proxy handshake.
  
  =item 596 - errors during TLS negotiation, request sending and header processing.
  
  =item 597 - errors during body receiving or processing.
  
  =item 598 - user aborted request via C<on_header> or C<on_body>.
  
  =item 599 - other, usually nonretryable, errors (garbled URL etc.).
  
  =back
  
  A typical callback might look like this:
  
     sub {
        my ($body, $hdr) = @_;
  
        if ($hdr->{Status} =~ /^2/) {
           ... everything should be ok
        } else {
           print "error, $hdr->{Status} $hdr->{Reason}\n";
        }
     }
  
  Additional parameters are key-value pairs, and are fully optional. They
  include:
  
  =over 4
  
  =item recurse => $count (default: $MAX_RECURSE)
  
  Whether to recurse requests or not, e.g. on redirects, authentication and
  other retries and so on, and how often to do so.
  
  Only redirects to http and https URLs are supported. While most common
  redirection forms are handled entirely within this module, some require
  the use of the optional L<URI> module. If it is required but missing, then
  the request will fail with an error.
  
  =item headers => hashref
  
  The request headers to use. Currently, C<http_request> may provide its own
  C<Host:>, C<Content-Length:>, C<Connection:> and C<Cookie:> headers and
  will provide defaults at least for C<TE:>, C<Referer:> and C<User-Agent:>
  (this can be suppressed by using C<undef> for these headers in which case
  they won't be sent at all).
  
  You really should provide your own C<User-Agent:> header value that is
  appropriate for your program - I wouldn't be surprised if the default
  AnyEvent string gets blocked by webservers sooner or later.
  
  Also, make sure that your headers names and values do not contain any
  embedded newlines.
  
  =item timeout => $seconds
  
  The time-out to use for various stages - each connect attempt will reset
  the timeout, as will read or write activity, i.e. this is not an overall
  timeout.
  
  Default timeout is 5 minutes.
  
  =item proxy => [$host, $port[, $scheme]] or undef
  
  Use the given http proxy for all requests, or no proxy if C<undef> is
  used.
  
  C<$scheme> must be either missing or must be C<http> for HTTP.
  
  If not specified, then the default proxy is used (see
  C<AnyEvent::HTTP::set_proxy>).
  
  Currently, if your proxy requires authorization, you have to specify an
  appropriate "Proxy-Authorization" header in every request.
  
  Note that this module will prefer an existing persistent connection,
  even if that connection was made using another proxy. If you need to
  ensure that a new connection is made in this case, you can either force
  C<persistent> to false or e.g. use the proxy address in your C<sessionid>.
  
  =item body => $string
  
  The request body, usually empty. Will be sent as-is (future versions of
  this module might offer more options).
  
  =item cookie_jar => $hash_ref
  
  Passing this parameter enables (simplified) cookie-processing, loosely
  based on the original netscape specification.
  
  The C<$hash_ref> must be an (initially empty) hash reference which
  will get updated automatically. It is possible to save the cookie jar
  to persistent storage with something like JSON or Storable - see the
  C<AnyEvent::HTTP::cookie_jar_expire> function if you wish to remove
  expired or session-only cookies, and also for documentation on the format
  of the cookie jar.
  
  Note that this cookie implementation is not meant to be complete. If
  you want complete cookie management you have to do that on your
  own. C<cookie_jar> is meant as a quick fix to get most cookie-using sites
  working. Cookies are a privacy disaster, do not use them unless required
  to.
  
  When cookie processing is enabled, the C<Cookie:> and C<Set-Cookie:>
  headers will be set and handled by this module, otherwise they will be
  left untouched.
  
  =item tls_ctx => $scheme | $tls_ctx
  
  Specifies the AnyEvent::TLS context to be used for https connections. This
  parameter follows the same rules as the C<tls_ctx> parameter to
  L<AnyEvent::Handle>, but additionally, the two strings C<low> or
  C<high> can be specified, which give you a predefined low-security (no
  verification, highest compatibility) and high-security (CA and common-name
  verification) TLS context.
  
  The default for this option is C<low>, which could be interpreted as "give
  me the page, no matter what".
  
  See also the C<sessionid> parameter.
  
  =item sessionid => $string
  
  The module might reuse connections to the same host internally (regardless
  of other settings, such as C<tcp_connect> or C<proxy>). Sometimes (e.g.
  when using TLS or a specfic proxy), you do not want to reuse connections
  from other sessions. This can be achieved by setting this parameter to
  some unique ID (such as the address of an object storing your state data
  or the TLS context, or the proxy IP) - only connections using the same
  unique ID will be reused.
  
  =item on_prepare => $callback->($fh)
  
  In rare cases you need to "tune" the socket before it is used to
  connect (for example, to bind it on a given IP address). This parameter
  overrides the prepare callback passed to C<AnyEvent::Socket::tcp_connect>
  and behaves exactly the same way (e.g. it has to provide a
  timeout). See the description for the C<$prepare_cb> argument of
  C<AnyEvent::Socket::tcp_connect> for details.
  
  =item tcp_connect => $callback->($host, $service, $connect_cb, $prepare_cb)
  
  In even rarer cases you want total control over how AnyEvent::HTTP
  establishes connections. Normally it uses L<AnyEvent::Socket::tcp_connect>
  to do this, but you can provide your own C<tcp_connect> function -
  obviously, it has to follow the same calling conventions, except that it
  may always return a connection guard object.
  
  The connections made by this hook will be treated as equivalent to
  connections made the built-in way, specifically, they will be put into
  and taken from the persistent connection cache. If your C<$tcp_connect>
  function is incompatible with this kind of re-use, consider switching off
  C<persistent> connections and/or providing a C<sessionid> identifier.
  
  There are probably lots of weird uses for this function, starting from
  tracing the hosts C<http_request> actually tries to connect, to (inexact
  but fast) host => IP address caching or even socks protocol support.
  
  =item on_header => $callback->($headers)
  
  When specified, this callback will be called with the header hash as soon
  as headers have been successfully received from the remote server (not on
  locally-generated errors).
  
  It has to return either true (in which case AnyEvent::HTTP will continue),
  or false, in which case AnyEvent::HTTP will cancel the download (and call
  the finish callback with an error code of C<598>).
  
  This callback is useful, among other things, to quickly reject unwanted
  content, which, if it is supposed to be rare, can be faster than first
  doing a C<HEAD> request.
  
  The downside is that cancelling the request makes it impossible to re-use
  the connection. Also, the C<on_header> callback will not receive any
  trailer (headers sent after the response body).
  
  Example: cancel the request unless the content-type is "text/html".
  
     on_header => sub {
        $_[0]{"content-type"} =~ /^text\/html\s*(?:;|$)/
     },
  
  =item on_body => $callback->($partial_body, $headers)
  
  When specified, all body data will be passed to this callback instead of
  to the completion callback. The completion callback will get the empty
  string instead of the body data.
  
  It has to return either true (in which case AnyEvent::HTTP will continue),
  or false, in which case AnyEvent::HTTP will cancel the download (and call
  the completion callback with an error code of C<598>).
  
  The downside to cancelling the request is that it makes it impossible to
  re-use the connection.
  
  This callback is useful when the data is too large to be held in memory
  (so the callback writes it to a file) or when only some information should
  be extracted, or when the body should be processed incrementally.
  
  It is usually preferred over doing your own body handling via
  C<want_body_handle>, but in case of streaming APIs, where HTTP is
  only used to create a connection, C<want_body_handle> is the better
  alternative, as it allows you to install your own event handler, reducing
  resource usage.
  
  =item want_body_handle => $enable
  
  When enabled (default is disabled), the behaviour of AnyEvent::HTTP
  changes considerably: after parsing the headers, and instead of
  downloading the body (if any), the completion callback will be
  called. Instead of the C<$body> argument containing the body data, the
  callback will receive the L<AnyEvent::Handle> object associated with the
  connection. In error cases, C<undef> will be passed. When there is no body
  (e.g. status C<304>), the empty string will be passed.
  
  The handle object might or might not be in TLS mode, might be connected
  to a proxy, be a persistent connection, use chunked transfer encoding
  etc., and configured in unspecified ways. The user is responsible for this
  handle (it will not be used by this module anymore).
  
  This is useful with some push-type services, where, after the initial
  headers, an interactive protocol is used (typical example would be the
  push-style twitter API which starts a JSON/XML stream).
  
  If you think you need this, first have a look at C<on_body>, to see if
  that doesn't solve your problem in a better way.
  
  =item persistent => $boolean
  
  Try to create/reuse a persistent connection. When this flag is set
  (default: true for idempotent requests, false for all others), then
  C<http_request> tries to re-use an existing (previously-created)
  persistent connection to same host (i.e. identical URL scheme, hostname,
  port and sessionid) and, failing that, tries to create a new one.
  
  Requests failing in certain ways will be automatically retried once, which
  is dangerous for non-idempotent requests, which is why it defaults to off
  for them. The reason for this is because the bozos who designed HTTP/1.1
  made it impossible to distinguish between a fatal error and a normal
  connection timeout, so you never know whether there was a problem with
  your request or not.
  
  When reusing an existent connection, many parameters (such as TLS context)
  will be ignored. See the C<sessionid> parameter for a workaround.
  
  =item keepalive => $boolean
  
  Only used when C<persistent> is also true. This parameter decides whether
  C<http_request> tries to handshake a HTTP/1.0-style keep-alive connection
  (as opposed to only a HTTP/1.1 persistent connection).
  
  The default is true, except when using a proxy, in which case it defaults
  to false, as HTTP/1.0 proxies cannot support this in a meaningful way.
  
  =item handle_params => { key => value ... }
  
  The key-value pairs in this hash will be passed to any L<AnyEvent::Handle>
  constructor that is called - not all requests will create a handle, and
  sometimes more than one is created, so this parameter is only good for
  setting hints.
  
  Example: set the maximum read size to 4096, to potentially conserve memory
  at the cost of speed.
  
     handle_params => {
        max_read_size => 4096,
     },
  
  =back
  
  Example: do a simple HTTP GET request for http://www.nethype.de/ and print
  the response body.
  
     http_request GET => "http://www.nethype.de/", sub {
        my ($body, $hdr) = @_;
        print "$body\n";
     };
  
  Example: do a HTTP HEAD request on https://www.google.com/, use a
  timeout of 30 seconds.
  
     http_request
        HEAD    => "https://www.google.com",
        headers => { "user-agent" => "MySearchClient 1.0" },
        timeout => 30,
        sub {
           my ($body, $hdr) = @_;
           use Data::Dumper;
           print Dumper $hdr;
        }
     ;
  
  Example: do another simple HTTP GET request, but immediately try to
  cancel it.
  
     my $request = http_request GET => "http://www.nethype.de/", sub {
        my ($body, $hdr) = @_;
        print "$body\n";
     };
  
     undef $request;
  
  =cut
  
  #############################################################################
  # wait queue/slots
  
  sub _slot_schedule;
  sub _slot_schedule($) {
     my $host = shift;
  
     while ($CO_SLOT{$host}[0] < $MAX_PER_HOST) {
        if (my $cb = shift @{ $CO_SLOT{$host}[1] }) {
           # somebody wants that slot
           ++$CO_SLOT{$host}[0];
           ++$ACTIVE;
  
           $cb->(AnyEvent::Util::guard {
              --$ACTIVE;
              --$CO_SLOT{$host}[0];
              _slot_schedule $host;
           });
        } else {
           # nobody wants the slot, maybe we can forget about it
           delete $CO_SLOT{$host} unless $CO_SLOT{$host}[0];
           last;
        }
     }
  }
  
  # wait for a free slot on host, call callback
  sub _get_slot($$) {
     push @{ $CO_SLOT{$_[0]}[1] }, $_[1];
  
     _slot_schedule $_[0];
  }
  
  #############################################################################
  # cookie handling
  
  # expire cookies
  sub cookie_jar_expire($;$) {
     my ($jar, $session_end) = @_;
  
     %$jar = () if $jar->{version} != 2;
  
     my $anow = AE::now;
  
     while (my ($chost, $paths) = each %$jar) {
        next unless ref $paths;
  
        while (my ($cpath, $cookies) = each %$paths) {
           while (my ($cookie, $kv) = each %$cookies) {
              if (exists $kv->{_expires}) {
                 delete $cookies->{$cookie}
                    if $anow > $kv->{_expires};
              } elsif ($session_end) {
                 delete $cookies->{$cookie};
              }
           }
  
           delete $paths->{$cpath}
              unless %$cookies;
        }
  
        delete $jar->{$chost}
           unless %$paths;
     }
  }
   
  # extract cookies from jar
  sub cookie_jar_extract($$$$) {
     my ($jar, $scheme, $host, $path) = @_;
  
     %$jar = () if $jar->{version} != 2;
  
     $host = AnyEvent::Util::idn_to_ascii $host
        if $host =~ /[^\x00-\x7f]/;
  
     my @cookies;
  
     while (my ($chost, $paths) = each %$jar) {
        next unless ref $paths;
  
        # exact match or suffix including . match
        $chost eq $host or ".$chost" eq substr $host, -1 - length $chost
           or next;
  
        while (my ($cpath, $cookies) = each %$paths) {
           next unless $cpath eq substr $path, 0, length $cpath;
  
           while (my ($cookie, $kv) = each %$cookies) {
              next if $scheme ne "https" && exists $kv->{secure};
  
              if (exists $kv->{_expires} and AE::now > $kv->{_expires}) {
                 delete $cookies->{$cookie};
                 next;
              }
  
              my $value = $kv->{value};
  
              if ($value =~ /[=;,[:space:]]/) {
                 $value =~ s/([\\"])/\\$1/g;
                 $value = "\"$value\"";
              }
  
              push @cookies, "$cookie=$value";
           }
        }
     }
  
     \@cookies
  }
   
  # parse set_cookie header into jar
  sub cookie_jar_set_cookie($$$$) {
     my ($jar, $set_cookie, $host, $date) = @_;
  
     %$jar = () if $jar->{version} != 2;
  
     my $anow = int AE::now;
     my $snow; # server-now
  
     for ($set_cookie) {
        # parse NAME=VALUE
        my @kv;
  
        # expires is not http-compliant in the original cookie-spec,
        # we support the official date format and some extensions
        while (
           m{
              \G\s*
              (?:
                 expires \s*=\s* ([A-Z][a-z][a-z]+,\ [^,;]+)
                 | ([^=;,[:space:]]+) (?: \s*=\s* (?: "((?:[^\\"]+|\\.)*)" | ([^;,[:space:]]*) ) )?
              )
           }gcxsi
        ) {
           my $name = $2;
           my $value = $4;
  
           if (defined $1) {
              # expires
              $name  = "expires";
              $value = $1;
           } elsif (defined $3) {
              # quoted
              $value = $3;
              $value =~ s/\\(.)/$1/gs;
           }
  
           push @kv, @kv ? lc $name : $name, $value;
  
           last unless /\G\s*;/gc;
        }
  
        last unless @kv;
  
        my $name = shift @kv;
        my %kv = (value => shift @kv, @kv);
  
        if (exists $kv{"max-age"}) {
           $kv{_expires} = $anow + delete $kv{"max-age"};
        } elsif (exists $kv{expires}) {
           $snow ||= parse_date ($date) || $anow;
           $kv{_expires} = $anow + (parse_date (delete $kv{expires}) - $snow);
        } else {
           delete $kv{_expires};
        }
  
        my $cdom;
        my $cpath = (delete $kv{path}) || "/";
  
        if (exists $kv{domain}) {
           $cdom = $kv{domain};
  
           $cdom =~ s/^\.?/./; # make sure it starts with a "."
  
           next if $cdom =~ /\.$/;
  
           # this is not rfc-like and not netscape-like. go figure.
           my $ndots = $cdom =~ y/.//;
           next if $ndots < ($cdom =~ /\.[^.][^.]\.[^.][^.]$/ ? 3 : 2);
  
           $cdom = substr $cdom, 1; # remove initial .
        } else {
           $cdom = $host;
        }
  
        # store it
        $jar->{version} = 2;
        $jar->{lc $cdom}{$cpath}{$name} = \%kv;
  
        redo if /\G\s*,/gc;
     }
  }
  
  #############################################################################
  # keepalive/persistent connection cache
  
  # fetch a connection from the keepalive cache
  sub ka_fetch($) {
     my $ka_key = shift;
  
     my $hdl = pop @{ $KA_CACHE{$ka_key} }; # currently we reuse the MOST RECENTLY USED connection
     delete $KA_CACHE{$ka_key}
        unless @{ $KA_CACHE{$ka_key} };
  
     $hdl
  }
  
  sub ka_store($$) {
     my ($ka_key, $hdl) = @_;
  
     my $kaa = $KA_CACHE{$ka_key} ||= [];
  
     my $destroy = sub {
        my @ka = grep $_ != $hdl, @{ $KA_CACHE{$ka_key} };
  
        $hdl->destroy;
  
        @ka
           ? $KA_CACHE{$ka_key} = \@ka
           : delete $KA_CACHE{$ka_key};
     };
  
     # on error etc., destroy
     $hdl->on_error ($destroy);
     $hdl->on_eof   ($destroy);
     $hdl->on_read  ($destroy);
     $hdl->timeout  ($PERSISTENT_TIMEOUT);
  
     push @$kaa, $hdl;
     shift @$kaa while @$kaa > $MAX_PER_HOST;
  }
  
  #############################################################################
  # utilities
  
  # continue to parse $_ for headers and place them into the arg
  sub _parse_hdr() {
     my %hdr;
  
     # things seen, not parsed:
     # p3pP="NON CUR OTPi OUR NOR UNI"
  
     $hdr{lc $1} .= ",$2"
        while /\G
              ([^:\000-\037]*):
              [\011\040]*
              ((?: [^\012]+ | \012[\011\040] )*)
              \012
           /gxc;
  
     /\G$/
       or return;
  
     # remove the "," prefix we added to all headers above
     substr $_, 0, 1, ""
        for values %hdr;
  
     \%hdr
  }
  
  #############################################################################
  # http_get
  
  our $qr_nlnl = qr{(?<![^\012])\015?\012};
  
  our $TLS_CTX_LOW  = { cache => 1, sslv2 => 1 };
  our $TLS_CTX_HIGH = { cache => 1, verify => 1, verify_peername => "https" };
  
  # maybe it should just become a normal object :/
  
  sub _destroy_state(\%) {
     my ($state) = @_;
  
     $state->{handle}->destroy if $state->{handle};
     %$state = ();
  }
  
  sub _error(\%$$) {
     my ($state, $cb, $hdr) = @_;
  
     &_destroy_state ($state);
  
     $cb->(undef, $hdr);
     ()
  }
  
  our %IDEMPOTENT = (
     DELETE		=> 1,
     GET			=> 1,
     HEAD			=> 1,
     OPTIONS		=> 1,
     PUT			=> 1,
     TRACE		=> 1,
  
     ACL			=> 1,
     "BASELINE-CONTROL"	=> 1,
     BIND			=> 1,
     CHECKIN		=> 1,
     CHECKOUT		=> 1,
     COPY			=> 1,
     LABEL		=> 1,
     LINK			=> 1,
     MERGE		=> 1,
     MKACTIVITY		=> 1,
     MKCALENDAR		=> 1,
     MKCOL		=> 1,
     MKREDIRECTREF	=> 1,
     MKWORKSPACE		=> 1,
     MOVE			=> 1,
     ORDERPATCH		=> 1,
     PROPFIND		=> 1,
     PROPPATCH		=> 1,
     REBIND		=> 1,
     REPORT		=> 1,
     SEARCH		=> 1,
     UNBIND		=> 1,
     UNCHECKOUT		=> 1,
     UNLINK		=> 1,
     UNLOCK		=> 1,
     UPDATE		=> 1,
     UPDATEREDIRECTREF	=> 1,
     "VERSION-CONTROL"	=> 1,
  );
  
  sub http_request($$@) {
     my $cb = pop;
     my ($method, $url, %arg) = @_;
  
     my %hdr;
  
     $arg{tls_ctx} = $TLS_CTX_LOW  if $arg{tls_ctx} eq "low" || !exists $arg{tls_ctx};
     $arg{tls_ctx} = $TLS_CTX_HIGH if $arg{tls_ctx} eq "high";
  
     $method = uc $method;
  
     if (my $hdr = $arg{headers}) {
        while (my ($k, $v) = each %$hdr) {
           $hdr{lc $k} = $v;
        }
     }
  
     # pseudo headers for all subsequent responses
     my @pseudo = (URL => $url);
     push @pseudo, Redirect => delete $arg{Redirect} if exists $arg{Redirect};
  
     my $recurse = exists $arg{recurse} ? delete $arg{recurse} : $MAX_RECURSE;
  
     return $cb->(undef, { @pseudo, Status => 599, Reason => "Too many redirections" })
        if $recurse < 0;
  
     my $proxy   = exists $arg{proxy} ? $arg{proxy} : $PROXY;
     my $timeout = $arg{timeout} || $TIMEOUT;
  
     my ($uscheme, $uauthority, $upath, $query, undef) = # ignore fragment
        $url =~ m|^([^:]+):(?://([^/?#]*))?([^?#]*)(?:(\?[^#]*))?(?:#(.*))?$|;
  
     $uscheme = lc $uscheme;
  
     my $uport = $uscheme eq "http"  ?  80
               : $uscheme eq "https" ? 443
               : return $cb->(undef, { @pseudo, Status => 599, Reason => "Only http and https URL schemes supported" });
  
     $uauthority =~ /^(?: .*\@ )? ([^\@]+?) (?: : (\d+) )?$/x
        or return $cb->(undef, { @pseudo, Status => 599, Reason => "Unparsable URL" });
  
     my $uhost = lc $1;
     $uport = $2 if defined $2;
  
     $hdr{host} = defined $2 ? "$uhost:$2" : "$uhost"
        unless exists $hdr{host};
  
     $uhost =~ s/^\[(.*)\]$/$1/;
     $upath .= $query if length $query;
  
     $upath =~ s%^/?%/%;
  
     # cookie processing
     if (my $jar = $arg{cookie_jar}) {
        my $cookies = cookie_jar_extract $jar, $uscheme, $uhost, $upath;
  
        $hdr{cookie} = join "; ", @$cookies
           if @$cookies;
     }
  
     my ($rhost, $rport, $rscheme, $rpath); # request host, port, path
  
     if ($proxy) {
        ($rpath, $rhost, $rport, $rscheme) = ($url, @$proxy);
  
        $rscheme = "http" unless defined $rscheme;
  
        # don't support https requests over https-proxy transport,
        # can't be done with tls as spec'ed, unless you double-encrypt.
        $rscheme = "http" if $uscheme eq "https" && $rscheme eq "https";
  
        $rhost   = lc $rhost;
        $rscheme = lc $rscheme;
     } else {
        ($rhost, $rport, $rscheme, $rpath) = ($uhost, $uport, $uscheme, $upath);
     }
  
     # leave out fragment and query string, just a heuristic
     $hdr{referer}      = "$uscheme://$uauthority$upath" unless exists $hdr{referer};
     $hdr{"user-agent"} = $USERAGENT                     unless exists $hdr{"user-agent"};
  
     $hdr{"content-length"} = length $arg{body}
        if length $arg{body} || $method ne "GET";
  
     my $idempotent = $IDEMPOTENT{$method};
  
     # default value for keepalive is true iff the request is for an idempotent method
     my $persistent = exists $arg{persistent} ? !!$arg{persistent} : $idempotent;
     my $keepalive  = exists $arg{keepalive}  ? !!$arg{keepalive}  : !$proxy;
     my $was_persistent; # true if this is actually a recycled connection
  
     # the key to use in the keepalive cache
     my $ka_key = "$uscheme\x00$uhost\x00$uport\x00$arg{sessionid}";
  
     $hdr{connection} = ($persistent ? $keepalive ? "keep-alive, " : "" : "close, ") . "Te"; #1.1
     $hdr{te}         = "trailers" unless exists $hdr{te}; #1.1
  
     my %state = (connect_guard => 1);
  
     my $ae_error = 595; # connecting
  
     # handle actual, non-tunneled, request
     my $handle_actual_request = sub {
        $ae_error = 596; # request phase
  
        my $hdl = $state{handle};
  
        $hdl->starttls ("connect") if $uscheme eq "https" && !exists $hdl->{tls};
  
        # send request
        $hdl->push_write (
           "$method $rpath HTTP/1.1\015\012"
           . (join "", map "\u$_: $hdr{$_}\015\012", grep defined $hdr{$_}, keys %hdr)
           . "\015\012"
           . $arg{body}
        );
  
        # return if error occurred during push_write()
        return unless %state;
  
        # reduce memory usage, save a kitten, also re-use it for the response headers.
        %hdr = ();
  
        # status line and headers
        $state{read_response} = sub {
           return unless %state;
  
           for ("$_[1]") {
              y/\015//d; # weed out any \015, as they show up in the weirdest of places.
  
              /^HTTP\/0*([0-9\.]+) \s+ ([0-9]{3}) (?: \s+ ([^\012]*) )? \012/gxci
                 or return _error %state, $cb, { @pseudo, Status => 599, Reason => "Invalid server response" };
  
              # 100 Continue handling
              # should not happen as we don't send expect: 100-continue,
              # but we handle it just in case.
              # since we send the request body regardless, if we get an error
              # we are out of-sync, which we currently do NOT handle correctly.
              return $state{handle}->push_read (line => $qr_nlnl, $state{read_response})
                 if $2 eq 100;
  
              push @pseudo,
                 HTTPVersion => $1,
                 Status      => $2,
                 Reason      => $3,
              ;
  
              my $hdr = _parse_hdr
                 or return _error %state, $cb, { @pseudo, Status => 599, Reason => "Garbled response headers" };
  
              %hdr = (%$hdr, @pseudo);
           }
  
           # redirect handling
           # relative uri handling forced by microsoft and other shitheads.
           # we give our best and fall back to URI if available.
           if (exists $hdr{location}) {
              my $loc = $hdr{location};
  
              if ($loc =~ m%^//%) { # //
                 $loc = "$uscheme:$loc";
  
              } elsif ($loc eq "") {
                 $loc = $url;
  
              } elsif ($loc !~ /^(?: $ | [^:\/?\#]+ : )/x) { # anything "simple"
                 $loc =~ s/^\.\/+//;
  
                 if ($loc !~ m%^[.?#]%) {
                    my $prefix = "$uscheme://$uauthority";
  
                    unless ($loc =~ s/^\///) {
                       $prefix .= $upath;
                       $prefix =~ s/\/[^\/]*$//;
                    }
  
                    $loc = "$prefix/$loc";
  
                 } elsif (eval { require URI }) { # uri
                    $loc = URI->new_abs ($loc, $url)->as_string;
  
                 } else {
                    return _error %state, $cb, { @pseudo, Status => 599, Reason => "Cannot parse Location (URI module missing)" };
                    #$hdr{Status} = 599;
                    #$hdr{Reason} = "Unparsable Redirect (URI module missing)";
                    #$recurse = 0;
                 }
              }
  
              $hdr{location} = $loc;
           }
  
           my $redirect;
  
           if ($recurse) {
              my $status = $hdr{Status};
  
              # industry standard is to redirect POST as GET for
              # 301, 302 and 303, in contrast to HTTP/1.0 and 1.1.
              # also, the UA should ask the user for 301 and 307 and POST,
              # industry standard seems to be to simply follow.
              # we go with the industry standard. 308 is defined
              # by rfc7538
              if ($status == 301 or $status == 302 or $status == 303) {
                 $redirect = 1;
                 # HTTP/1.1 is unclear on how to mutate the method
                 unless ($method eq "HEAD") {
                    $method = "GET";
                    delete $arg{body};
                 }
              } elsif ($status == 307 or $status == 308) {
                 $redirect = 1;
              }
           }
  
           my $finish = sub { # ($data, $err_status, $err_reason[, $persistent])
              if ($state{handle}) {
                 # handle keepalive
                 if (
                    $persistent
                    && $_[3]
                    && ($hdr{HTTPVersion} < 1.1
                        ? $hdr{connection} =~ /\bkeep-?alive\b/i
                        : $hdr{connection} !~ /\bclose\b/i)
                 ) {
                    ka_store $ka_key, delete $state{handle};
                 } else {
                    # no keepalive, destroy the handle
                    $state{handle}->destroy;
                 }
              }
  
              %state = ();
  
              if (defined $_[1]) {
                 $hdr{OrigStatus} = $hdr{Status}; $hdr{Status} = $_[1];
                 $hdr{OrigReason} = $hdr{Reason}; $hdr{Reason} = $_[2];
              }
  
              # set-cookie processing
              if ($arg{cookie_jar}) {
                 cookie_jar_set_cookie $arg{cookie_jar}, $hdr{"set-cookie"}, $uhost, $hdr{date};
              }
  
              if ($redirect && exists $hdr{location}) {
                 # we ignore any errors, as it is very common to receive
                 # Content-Length != 0 but no actual body
                 # we also access %hdr, as $_[1] might be an erro
                 $state{recurse} =
                    http_request (
                       $method  => $hdr{location},
                       %arg,
                       recurse  => $recurse - 1,
                       Redirect => [$_[0], \%hdr],
                       sub {
                          %state = ();
                          &$cb
                       },
                    );
              } else {
                 $cb->($_[0], \%hdr);
              }
           };
  
           $ae_error = 597; # body phase
  
           my $chunked = $hdr{"transfer-encoding"} =~ /\bchunked\b/i; # not quite correct...
  
           my $len = $chunked ? undef : $hdr{"content-length"};
  
           # body handling, many different code paths
           # - no body expected
           # - want_body_handle
           # - te chunked
           # - 2x length known (with or without on_body)
           # - 2x length not known (with or without on_body)
           if (!$redirect && $arg{on_header} && !$arg{on_header}(\%hdr)) {
              $finish->(undef, 598 => "Request cancelled by on_header");
           } elsif (
              $hdr{Status} =~ /^(?:1..|204|205|304)$/
              or $method eq "HEAD"
              or (defined $len && $len == 0) # == 0, not !, because "0   " is true
           ) {
              # no body
              $finish->("", undef, undef, 1);
  
           } elsif (!$redirect && $arg{want_body_handle}) {
              $_[0]->on_eof   (undef);
              $_[0]->on_error (undef);
              $_[0]->on_read  (undef);
  
              $finish->(delete $state{handle});
  
           } elsif ($chunked) {
              my $cl = 0;
              my $body = "";
              my $on_body = (!$redirect && $arg{on_body}) || sub { $body .= shift; 1 };
  
              $state{read_chunk} = sub {
                 $_[1] =~ /^([0-9a-fA-F]+)/
                    or return $finish->(undef, $ae_error => "Garbled chunked transfer encoding");
  
                 my $len = hex $1;
  
                 if ($len) {
                    $cl += $len;
  
                    $_[0]->push_read (chunk => $len, sub {
                       $on_body->($_[1], \%hdr)
                          or return $finish->(undef, 598 => "Request cancelled by on_body");
  
                       $_[0]->push_read (line => sub {
                          length $_[1]
                             and return $finish->(undef, $ae_error => "Garbled chunked transfer encoding");
                          $_[0]->push_read (line => $state{read_chunk});
                       });
                    });
                 } else {
                    $hdr{"content-length"} ||= $cl;
  
                    $_[0]->push_read (line => $qr_nlnl, sub {
                       if (length $_[1]) {
                          for ("$_[1]") {
                             y/\015//d; # weed out any \015, as they show up in the weirdest of places.
  
                             my $hdr = _parse_hdr
                                or return $finish->(undef, $ae_error => "Garbled response trailers");
  
                             %hdr = (%hdr, %$hdr);
                          }
                       }
  
                       $finish->($body, undef, undef, 1);
                    });
                 }
              };
  
              $_[0]->push_read (line => $state{read_chunk});
  
           } elsif (!$redirect && $arg{on_body}) {
              if (defined $len) {
                 $_[0]->on_read (sub {
                    $len -= length $_[0]{rbuf};
  
                    $arg{on_body}(delete $_[0]{rbuf}, \%hdr)
                       or return $finish->(undef, 598 => "Request cancelled by on_body");
  
                    $len > 0
                       or $finish->("", undef, undef, 1);
                 });
              } else {
                 $_[0]->on_eof (sub {
                    $finish->("");
                 });
                 $_[0]->on_read (sub {
                    $arg{on_body}(delete $_[0]{rbuf}, \%hdr)
                       or $finish->(undef, 598 => "Request cancelled by on_body");
                 });
              }
           } else {
              $_[0]->on_eof (undef);
  
              if (defined $len) {
                 $_[0]->on_read (sub {
                    $finish->((substr delete $_[0]{rbuf}, 0, $len, ""), undef, undef, 1)
                       if $len <= length $_[0]{rbuf};
                 });
              } else {
                 $_[0]->on_error (sub {
                    ($! == Errno::EPIPE || !$!)
                       ? $finish->(delete $_[0]{rbuf})
                       : $finish->(undef, $ae_error => $_[2]);
                 });
                 $_[0]->on_read (sub { });
              }
           }
        };
  
        # if keepalive is enabled, then the server closing the connection
        # before a response can happen legally - we retry on idempotent methods.
        if ($was_persistent && $idempotent) {
           my $old_eof = $hdl->{on_eof};
           $hdl->{on_eof} = sub {
              _destroy_state %state;
  
              %state = ();
              $state{recurse} =
                 http_request (
                    $method    => $url,
                    %arg,
                    recurse    => $recurse - 1,
                    persistent => 0,
                    sub {
                       %state = ();
                       &$cb
                    }
                 );
           };
           $hdl->on_read (sub {
              return unless %state;
  
              # as soon as we receive something, a connection close
              # once more becomes a hard error
              $hdl->{on_eof} = $old_eof;
              $hdl->push_read (line => $qr_nlnl, $state{read_response});
           });
        } else {
           $hdl->push_read (line => $qr_nlnl, $state{read_response});
        }
     };
  
     my $prepare_handle = sub {
        my ($hdl) = $state{handle};
  
        $hdl->on_error (sub {
           _error %state, $cb, { @pseudo, Status => $ae_error, Reason => $_[2] };
        });
        $hdl->on_eof (sub {
           _error %state, $cb, { @pseudo, Status => $ae_error, Reason => "Unexpected end-of-file" };
        });
        $hdl->timeout_reset;
        $hdl->timeout ($timeout);
     };
  
     # connected to proxy (or origin server)
     my $connect_cb = sub {
        my $fh = shift
           or return _error %state, $cb, { @pseudo, Status => $ae_error, Reason => "$!" };
  
        return unless delete $state{connect_guard};
  
        # get handle
        $state{handle} = new AnyEvent::Handle
           %{ $arg{handle_params} },
           fh       => $fh,
           peername => $uhost,
           tls_ctx  => $arg{tls_ctx},
        ;
  
        $prepare_handle->();
  
        #$state{handle}->starttls ("connect") if $rscheme eq "https";
  
        # now handle proxy-CONNECT method
        if ($proxy && $uscheme eq "https") {
           # oh dear, we have to wrap it into a connect request
  
           my $auth = exists $hdr{"proxy-authorization"}
              ? "proxy-authorization: " . (delete $hdr{"proxy-authorization"}) . "\015\012"
              : "";
  
           # maybe re-use $uauthority with patched port?
           $state{handle}->push_write ("CONNECT $uhost:$uport HTTP/1.0\015\012$auth\015\012");
           $state{handle}->push_read (line => $qr_nlnl, sub {
              $_[1] =~ /^HTTP\/([0-9\.]+) \s+ ([0-9]{3}) (?: \s+ ([^\015\012]*) )?/ix
                 or return _error %state, $cb, { @pseudo, Status => 599, Reason => "Invalid proxy connect response ($_[1])" };
  
              if ($2 == 200) {
                 $rpath = $upath;
                 $handle_actual_request->();
              } else {
                 _error %state, $cb, { @pseudo, Status => $2, Reason => $3 };
              }
           });
        } else {
           delete $hdr{"proxy-authorization"} unless $proxy;
  
           $handle_actual_request->();
        }
     };
  
     _get_slot $uhost, sub {
        $state{slot_guard} = shift;
  
        return unless $state{connect_guard};
  
        # try to use an existing keepalive connection, but only if we, ourselves, plan
        # on a keepalive request (in theory, this should be a separate config option).
        if ($persistent && $KA_CACHE{$ka_key}) {
           $was_persistent = 1;
  
           $state{handle} = ka_fetch $ka_key;
  #         $state{handle}->destroyed
  #            and die "AnyEvent::HTTP: unexpectedly got a destructed handle (1), please report.";#d#
           $prepare_handle->();
  #         $state{handle}->destroyed
  #            and die "AnyEvent::HTTP: unexpectedly got a destructed handle (2), please report.";#d#
           $rpath = $upath;
           $handle_actual_request->();
  
        } else {
           my $tcp_connect = $arg{tcp_connect}
                             || do { require AnyEvent::Socket; \&AnyEvent::Socket::tcp_connect };
  
           $state{connect_guard} = $tcp_connect->($rhost, $rport, $connect_cb, $arg{on_prepare} || sub { $timeout });
        }
     };
  
     defined wantarray && AnyEvent::Util::guard { _destroy_state %state }
  }
  
  sub http_get($@) {
     unshift @_, "GET";
     &http_request
  }
  
  sub http_head($@) {
     unshift @_, "HEAD";
     &http_request
  }
  
  sub http_post($$@) {
     my $url = shift;
     unshift @_, "POST", $url, "body";
     &http_request
  }
  
  =back
  
  =head2 DNS CACHING
  
  AnyEvent::HTTP uses the AnyEvent::Socket::tcp_connect function for
  the actual connection, which in turn uses AnyEvent::DNS to resolve
  hostnames. The latter is a simple stub resolver and does no caching
  on its own. If you want DNS caching, you currently have to provide
  your own default resolver (by storing a suitable resolver object in
  C<$AnyEvent::DNS::RESOLVER>) or your own C<tcp_connect> callback.
  
  =head2 GLOBAL FUNCTIONS AND VARIABLES
  
  =over 4
  
  =item AnyEvent::HTTP::set_proxy "proxy-url"
  
  Sets the default proxy server to use. The proxy-url must begin with a
  string of the form C<http://host:port>, croaks otherwise.
  
  To clear an already-set proxy, use C<undef>.
  
  When AnyEvent::HTTP is loaded for the first time it will query the
  default proxy from the operating system, currently by looking at
  C<$ENV{http_proxy>}.
  
  =item AnyEvent::HTTP::cookie_jar_expire $jar[, $session_end]
  
  Remove all cookies from the cookie jar that have been expired. If
  C<$session_end> is given and true, then additionally remove all session
  cookies.
  
  You should call this function (with a true C<$session_end>) before you
  save cookies to disk, and you should call this function after loading them
  again. If you have a long-running program you can additionally call this
  function from time to time.
  
  A cookie jar is initially an empty hash-reference that is managed by this
  module. Its format is subject to change, but currently it is as follows:
  
  The key C<version> has to contain C<2>, otherwise the hash gets
  cleared. All other keys are hostnames or IP addresses pointing to
  hash-references. The key for these inner hash references is the
  server path for which this cookie is meant, and the values are again
  hash-references. Each key of those hash-references is a cookie name, and
  the value, you guessed it, is another hash-reference, this time with the
  key-value pairs from the cookie, except for C<expires> and C<max-age>,
  which have been replaced by a C<_expires> key that contains the cookie
  expiry timestamp. Session cookies are indicated by not having an
  C<_expires> key.
  
  Here is an example of a cookie jar with a single cookie, so you have a
  chance of understanding the above paragraph:
  
     {
        version    => 2,
        "10.0.0.1" => {
           "/" => {
              "mythweb_id" => {
                _expires => 1293917923,
                value    => "ooRung9dThee3ooyXooM1Ohm",
              },
           },
        },
     }
  
  =item $date = AnyEvent::HTTP::format_date $timestamp
  
  Takes a POSIX timestamp (seconds since the epoch) and formats it as a HTTP
  Date (RFC 2616).
  
  =item $timestamp = AnyEvent::HTTP::parse_date $date
  
  Takes a HTTP Date (RFC 2616) or a Cookie date (netscape cookie spec) or a
  bunch of minor variations of those, and returns the corresponding POSIX
  timestamp, or C<undef> if the date cannot be parsed.
  
  =item $AnyEvent::HTTP::MAX_RECURSE
  
  The default value for the C<recurse> request parameter (default: C<10>).
  
  =item $AnyEvent::HTTP::TIMEOUT
  
  The default timeout for connection operations (default: C<300>).
  
  =item $AnyEvent::HTTP::USERAGENT
  
  The default value for the C<User-Agent> header (the default is
  C<Mozilla/5.0 (compatible; U; AnyEvent-HTTP/$VERSION; +http://software.schmorp.de/pkg/AnyEvent)>).
  
  =item $AnyEvent::HTTP::MAX_PER_HOST
  
  The maximum number of concurrent connections to the same host (identified
  by the hostname). If the limit is exceeded, then additional requests
  are queued until previous connections are closed. Both persistent and
  non-persistent connections are counted in this limit.
  
  The default value for this is C<4>, and it is highly advisable to not
  increase it much.
  
  For comparison: the RFC's recommend 4 non-persistent or 2 persistent
  connections, older browsers used 2, newer ones (such as firefox 3)
  typically use 6, and Opera uses 8 because like, they have the fastest
  browser and give a shit for everybody else on the planet.
  
  =item $AnyEvent::HTTP::PERSISTENT_TIMEOUT
  
  The time after which idle persistent connections get closed by
  AnyEvent::HTTP (default: C<3>).
  
  =item $AnyEvent::HTTP::ACTIVE
  
  The number of active connections. This is not the number of currently
  running requests, but the number of currently open and non-idle TCP
  connections. This number can be useful for load-leveling.
  
  =back
  
  =cut
  
  our @month   = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  our @weekday = qw(Sun Mon Tue Wed Thu Fri Sat);
  
  sub format_date($) {
     my ($time) = @_;
  
     # RFC 822/1123 format
     my ($S, $M, $H, $mday, $mon, $year, $wday, $yday, undef) = gmtime $time;
  
     sprintf "%s, %02d %s %04d %02d:%02d:%02d GMT",
        $weekday[$wday], $mday, $month[$mon], $year + 1900,
        $H, $M, $S;
  }
  
  sub parse_date($) {
     my ($date) = @_;
  
     my ($d, $m, $y, $H, $M, $S);
  
     if ($date =~ /^[A-Z][a-z][a-z]+, ([0-9][0-9]?)[\- ]([A-Z][a-z][a-z])[\- ]([0-9][0-9][0-9][0-9]) ([0-9][0-9]?):([0-9][0-9]?):([0-9][0-9]?) GMT$/) {
        # RFC 822/1123, required by RFC 2616 (with " ")
        # cookie dates (with "-")
  
        ($d, $m, $y, $H, $M, $S) = ($1, $2, $3, $4, $5, $6);
  
     } elsif ($date =~ /^[A-Z][a-z][a-z]+, ([0-9][0-9]?)-([A-Z][a-z][a-z])-([0-9][0-9]) ([0-9][0-9]?):([0-9][0-9]?):([0-9][0-9]?) GMT$/) {
        # RFC 850
        ($d, $m, $y, $H, $M, $S) = ($1, $2, $3 < 69 ? $3 + 2000 : $3 + 1900, $4, $5, $6);
  
     } elsif ($date =~ /^[A-Z][a-z][a-z]+ ([A-Z][a-z][a-z]) ([0-9 ]?[0-9]) ([0-9][0-9]?):([0-9][0-9]?):([0-9][0-9]?) ([0-9][0-9][0-9][0-9])$/) {
        # ISO C's asctime
        ($d, $m, $y, $H, $M, $S) = ($2, $1, $6, $3, $4, $5);
     }
     # other formats fail in the loop below
  
     for (0..11) {
        if ($m eq $month[$_]) {
           require Time::Local;
           return eval { Time::Local::timegm ($S, $M, $H, $d, $_, $y) };
        }
     }
  
     undef
  }
  
  sub set_proxy($) {
     if (length $_[0]) {
        $_[0] =~ m%^(http):// ([^:/]+) (?: : (\d*) )?%ix
           or Carp::croak "$_[0]: invalid proxy URL";
        $PROXY = [$2, $3 || 3128, $1]
     } else {
        undef $PROXY;
     }
  }
  
  # initialise proxy from environment
  eval {
     set_proxy $ENV{http_proxy};
  };
  
  =head2 SHOWCASE
  
  This section contains some more elaborate "real-world" examples or code
  snippets.
  
  =head2 HTTP/1.1 FILE DOWNLOAD
  
  Downloading files with HTTP can be quite tricky, especially when something
  goes wrong and you want to resume.
  
  Here is a function that initiates and resumes a download. It uses the
  last modified time to check for file content changes, and works with many
  HTTP/1.0 servers as well, and usually falls back to a complete re-download
  on older servers.
  
  It calls the completion callback with either C<undef>, which means a
  nonretryable error occurred, C<0> when the download was partial and should
  be retried, and C<1> if it was successful.
  
     use AnyEvent::HTTP;
  
     sub download($$$) {
        my ($url, $file, $cb) = @_;
  
        open my $fh, "+<", $file
           or die "$file: $!";
  
        my %hdr;
        my $ofs = 0;
  
        if (stat $fh and -s _) {
           $ofs = -s _;
           warn "-s is ", $ofs;
           $hdr{"if-unmodified-since"} = AnyEvent::HTTP::format_date +(stat _)[9];
           $hdr{"range"} = "bytes=$ofs-";
        }
  
        http_get $url,
           headers   => \%hdr,
           on_header => sub {
              my ($hdr) = @_;
  
              if ($hdr->{Status} == 200 && $ofs) {
                 # resume failed
                 truncate $fh, $ofs = 0;
              }
  
              sysseek $fh, $ofs, 0;
  
              1
           },
           on_body   => sub {
              my ($data, $hdr) = @_;
  
              if ($hdr->{Status} =~ /^2/) {
                 length $data == syswrite $fh, $data
                    or return; # abort on write errors
              }
  
              1
           },
           sub {
              my (undef, $hdr) = @_;
  
              my $status = $hdr->{Status};
  
              if (my $time = AnyEvent::HTTP::parse_date $hdr->{"last-modified"}) {
                 utime $time, $time, $fh;
              }
  
              if ($status == 200 || $status == 206 || $status == 416) {
                 # download ok || resume ok || file already fully downloaded
                 $cb->(1, $hdr);
  
              } elsif ($status == 412) {
                 # file has changed while resuming, delete and retry
                 unlink $file;
                 $cb->(0, $hdr);
  
              } elsif ($status == 500 or $status == 503 or $status =~ /^59/) {
                 # retry later
                 $cb->(0, $hdr);
  
              } else {
                 $cb->(undef, $hdr);
              }
           }
        ;
     }
  
     download "http://server/somelargefile", "/tmp/somelargefile", sub {
        if ($_[0]) {
           print "OK!\n";
        } elsif (defined $_[0]) {
           print "please retry later\n";
        } else {
           print "ERROR\n";
        }
     };
  
  =head3 SOCKS PROXIES
  
  Socks proxies are not directly supported by AnyEvent::HTTP. You can
  compile your perl to support socks, or use an external program such as
  F<socksify> (dante) or F<tsocks> to make your program use a socks proxy
  transparently.
  
  Alternatively, for AnyEvent::HTTP only, you can use your own
  C<tcp_connect> function that does the proxy handshake - here is an example
  that works with socks4a proxies:
  
     use Errno;
     use AnyEvent::Util;
     use AnyEvent::Socket;
     use AnyEvent::Handle;
  
     # host, port and username of/for your socks4a proxy
     my $socks_host = "10.0.0.23";
     my $socks_port = 9050;
     my $socks_user = "";
  
     sub socks4a_connect {
        my ($host, $port, $connect_cb, $prepare_cb) = @_;
  
        my $hdl = new AnyEvent::Handle
           connect    => [$socks_host, $socks_port],
           on_prepare => sub { $prepare_cb->($_[0]{fh}) },
           on_error   => sub { $connect_cb->() },
        ;
  
        $hdl->push_write (pack "CCnNZ*Z*", 4, 1, $port, 1, $socks_user, $host);
  
        $hdl->push_read (chunk => 8, sub {
           my ($hdl, $chunk) = @_;
           my ($status, $port, $ipn) = unpack "xCna4", $chunk;
  
           if ($status == 0x5a) {
              $connect_cb->($hdl->{fh}, (format_address $ipn) . ":$port");
           } else {
              $! = Errno::ENXIO; $connect_cb->();
           }
        });
  
        $hdl
     }
  
  Use C<socks4a_connect> instead of C<tcp_connect> when doing C<http_request>s,
  possibly after switching off other proxy types:
  
     AnyEvent::HTTP::set_proxy undef; # usually you do not want other proxies
  
     http_get 'http://www.google.com', tcp_connect => \&socks4a_connect, sub {
        my ($data, $headers) = @_;
        ...
     };
  
  =head1 SEE ALSO
  
  L<AnyEvent>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://home.schmorp.de/
  
  With many thanks to  , who provided countless
  testcases and bugreports.
  
  =cut
  
  1
  
ANYEVENT_HTTP

$fatpacked{"AnyEvent/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_HANDLE';
  =head1 NAME
  
  AnyEvent::Handle - non-blocking I/O on streaming handles via AnyEvent
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use AnyEvent::Handle;
  
     my $cv = AnyEvent->condvar;
  
     my $hdl; $hdl = new AnyEvent::Handle
        fh => \*STDIN,
        on_error => sub {
           my ($hdl, $fatal, $msg) = @_;
           AE::log error => $msg;
           $hdl->destroy;
           $cv->send;
        };
  
     # send some request line
     $hdl->push_write ("getinfo\015\012");
  
     # read the response line
     $hdl->push_read (line => sub {
        my ($hdl, $line) = @_;
        say "got line <$line>";
        $cv->send;
     });
  
     $cv->recv;
  
  =head1 DESCRIPTION
  
  This is a helper module to make it easier to do event-based I/O
  on stream-based filehandles (sockets, pipes, and other stream
  things). Specifically, it doesn't work as expected on files, packet-based
  sockets or similar things.
  
  The L<AnyEvent::Intro> tutorial contains some well-documented
  AnyEvent::Handle examples.
  
  In the following, where the documentation refers to "bytes", it means
  characters. As sysread and syswrite are used for all I/O, their
  treatment of characters applies to this module as well.
  
  At the very minimum, you should specify C<fh> or C<connect>, and the
  C<on_error> callback.
  
  All callbacks will be invoked with the handle object as their first
  argument.
  
  =cut
  
  package AnyEvent::Handle;
  
  use Scalar::Util ();
  use List::Util ();
  use Carp ();
  use Errno qw(EAGAIN EWOULDBLOCK EINTR);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(WSAEWOULDBLOCK);
  
  our $VERSION = $AnyEvent::VERSION;
  
  sub _load_func($) {
     my $func = $_[0];
  
     unless (defined &$func) {
        my $pkg = $func;
        do {
           $pkg =~ s/::[^:]+$//
              or return;
           eval "require $pkg";
        } until defined &$func;
     }
  
     \&$func
  }
  
  sub MAX_READ_SIZE() { 131072 }
  
  =head1 METHODS
  
  =over 4
  
  =item $handle = B<new> AnyEvent::Handle fh => $filehandle, key => value...
  
  The constructor supports these arguments (all as C<< key => value >> pairs).
  
  =over 4
  
  =item fh => $filehandle     [C<fh> or C<connect> MANDATORY]
  
  The filehandle this L<AnyEvent::Handle> object will operate on.
  NOTE: The filehandle will be set to non-blocking mode (using
  C<AnyEvent::fh_unblock>) by the constructor and needs to stay in
  that mode.
  
  =item connect => [$host, $service]      [C<fh> or C<connect> MANDATORY]
  
  Try to connect to the specified host and service (port), using
  C<AnyEvent::Socket::tcp_connect>. The C<$host> additionally becomes the
  default C<peername>.
  
  You have to specify either this parameter, or C<fh>, above.
  
  It is possible to push requests on the read and write queues, and modify
  properties of the stream, even while AnyEvent::Handle is connecting.
  
  When this parameter is specified, then the C<on_prepare>,
  C<on_connect_error> and C<on_connect> callbacks will be called under the
  appropriate circumstances:
  
  =over 4
  
  =item on_prepare => $cb->($handle)
  
  This (rarely used) callback is called before a new connection is
  attempted, but after the file handle has been created (you can access that
  file handle via C<< $handle->{fh} >>). It could be used to prepare the
  file handle with parameters required for the actual connect (as opposed to
  settings that can be changed when the connection is already established).
  
  The return value of this callback should be the connect timeout value in
  seconds (or C<0>, or C<undef>, or the empty list, to indicate that the
  default timeout is to be used).
  
  =item on_connect => $cb->($handle, $host, $port, $retry->())
  
  This callback is called when a connection has been successfully established.
  
  The peer's numeric host and port (the socket peername) are passed as
  parameters, together with a retry callback. At the time it is called the
  read and write queues, EOF status, TLS status and similar properties of
  the handle will have been reset.
  
  If, for some reason, the handle is not acceptable, calling C<$retry> will
  continue with the next connection target (in case of multi-homed hosts or
  SRV records there can be multiple connection endpoints). The C<$retry>
  callback can be invoked after the connect callback returns, i.e. one can
  start a handshake and then decide to retry with the next host if the
  handshake fails.
  
  In most cases, you should ignore the C<$retry> parameter.
  
  =item on_connect_error => $cb->($handle, $message)
  
  This callback is called when the connection could not be
  established. C<$!> will contain the relevant error code, and C<$message> a
  message describing it (usually the same as C<"$!">).
  
  If this callback isn't specified, then C<on_error> will be called with a
  fatal error instead.
  
  =back
  
  =item on_error => $cb->($handle, $fatal, $message)
  
  This is the error callback, which is called when, well, some error
  occured, such as not being able to resolve the hostname, failure to
  connect, or a read error.
  
  Some errors are fatal (which is indicated by C<$fatal> being true). On
  fatal errors the handle object will be destroyed (by a call to C<< ->
  destroy >>) after invoking the error callback (which means you are free to
  examine the handle object). Examples of fatal errors are an EOF condition
  with active (but unsatisfiable) read watchers (C<EPIPE>) or I/O errors. In
  cases where the other side can close the connection at will, it is
  often easiest to not report C<EPIPE> errors in this callback.
  
  AnyEvent::Handle tries to find an appropriate error code for you to check
  against, but in some cases (TLS errors), this does not work well.
  
  If you report the error to the user, it is recommended to always output
  the C<$message> argument in human-readable error messages (you don't need
  to report C<"$!"> if you report C<$message>).
  
  If you want to react programmatically to the error, then looking at C<$!>
  and comparing it against some of the documented C<Errno> values is usually
  better than looking at the C<$message>.
  
  Non-fatal errors can be retried by returning, but it is recommended
  to simply ignore this parameter and instead abondon the handle object
  when this callback is invoked. Examples of non-fatal errors are timeouts
  C<ETIMEDOUT>) or badly-formatted data (C<EBADMSG>).
  
  On entry to the callback, the value of C<$!> contains the operating
  system error code (or C<ENOSPC>, C<EPIPE>, C<ETIMEDOUT>, C<EBADMSG> or
  C<EPROTO>).
  
  While not mandatory, it is I<highly> recommended to set this callback, as
  you will not be notified of errors otherwise. The default just calls
  C<croak>.
  
  =item on_read => $cb->($handle)
  
  This sets the default read callback, which is called when data arrives
  and no read request is in the queue (unlike read queue callbacks, this
  callback will only be called when at least one octet of data is in the
  read buffer).
  
  To access (and remove data from) the read buffer, use the C<< ->rbuf >>
  method or access the C<< $handle->{rbuf} >> member directly. Note that you
  must not enlarge or modify the read buffer, you can only remove data at
  the beginning from it.
  
  You can also call C<< ->push_read (...) >> or any other function that
  modifies the read queue. Or do both. Or ...
  
  When an EOF condition is detected, AnyEvent::Handle will first try to
  feed all the remaining data to the queued callbacks and C<on_read> before
  calling the C<on_eof> callback. If no progress can be made, then a fatal
  error will be raised (with C<$!> set to C<EPIPE>).
  
  Note that, unlike requests in the read queue, an C<on_read> callback
  doesn't mean you I<require> some data: if there is an EOF and there
  are outstanding read requests then an error will be flagged. With an
  C<on_read> callback, the C<on_eof> callback will be invoked.
  
  =item on_eof => $cb->($handle)
  
  Set the callback to be called when an end-of-file condition is detected,
  i.e. in the case of a socket, when the other side has closed the
  connection cleanly, and there are no outstanding read requests in the
  queue (if there are read requests, then an EOF counts as an unexpected
  connection close and will be flagged as an error).
  
  For sockets, this just means that the other side has stopped sending data,
  you can still try to write data, and, in fact, one can return from the EOF
  callback and continue writing data, as only the read part has been shut
  down.
  
  If an EOF condition has been detected but no C<on_eof> callback has been
  set, then a fatal error will be raised with C<$!> set to <0>.
  
  =item on_drain => $cb->($handle)
  
  This sets the callback that is called once when the write buffer becomes
  empty (and immediately when the handle object is created).
  
  To append to the write buffer, use the C<< ->push_write >> method.
  
  This callback is useful when you don't want to put all of your write data
  into the queue at once, for example, when you want to write the contents
  of some file to the socket you might not want to read the whole file into
  memory and push it into the queue, but instead only read more data from
  the file when the write queue becomes empty.
  
  =item timeout => $fractional_seconds
  
  =item rtimeout => $fractional_seconds
  
  =item wtimeout => $fractional_seconds
  
  If non-zero, then these enables an "inactivity" timeout: whenever this
  many seconds pass without a successful read or write on the underlying
  file handle (or a call to C<timeout_reset>), the C<on_timeout> callback
  will be invoked (and if that one is missing, a non-fatal C<ETIMEDOUT>
  error will be raised).
  
  There are three variants of the timeouts that work independently of each
  other, for both read and write (triggered when nothing was read I<OR>
  written), just read (triggered when nothing was read), and just write:
  C<timeout>, C<rtimeout> and C<wtimeout>, with corresponding callbacks
  C<on_timeout>, C<on_rtimeout> and C<on_wtimeout>, and reset functions
  C<timeout_reset>, C<rtimeout_reset>, and C<wtimeout_reset>.
  
  Note that timeout processing is active even when you do not have any
  outstanding read or write requests: If you plan to keep the connection
  idle then you should disable the timeout temporarily or ignore the
  timeout in the corresponding C<on_timeout> callback, in which case
  AnyEvent::Handle will simply restart the timeout.
  
  Zero (the default) disables the corresponding timeout.
  
  =item on_timeout => $cb->($handle)
  
  =item on_rtimeout => $cb->($handle)
  
  =item on_wtimeout => $cb->($handle)
  
  Called whenever the inactivity timeout passes. If you return from this
  callback, then the timeout will be reset as if some activity had happened,
  so this condition is not fatal in any way.
  
  =item rbuf_max => <bytes>
  
  If defined, then a fatal error will be raised (with C<$!> set to C<ENOSPC>)
  when the read buffer ever (strictly) exceeds this size. This is useful to
  avoid some forms of denial-of-service attacks.
  
  For example, a server accepting connections from untrusted sources should
  be configured to accept only so-and-so much data that it cannot act on
  (for example, when expecting a line, an attacker could send an unlimited
  amount of data without a callback ever being called as long as the line
  isn't finished).
  
  =item wbuf_max => <bytes>
  
  If defined, then a fatal error will be raised (with C<$!> set to C<ENOSPC>)
  when the write buffer ever (strictly) exceeds this size. This is useful to
  avoid some forms of denial-of-service attacks.
  
  Although the units of this parameter is bytes, this is the I<raw> number
  of bytes not yet accepted by the kernel. This can make a difference when
  you e.g. use TLS, as TLS typically makes your write data larger (but it
  can also make it smaller due to compression).
  
  As an example of when this limit is useful, take a chat server that sends
  chat messages to a client. If the client does not read those in a timely
  manner then the send buffer in the server would grow unbounded.
  
  =item autocork => <boolean>
  
  When disabled (the default), C<push_write> will try to immediately
  write the data to the handle if possible. This avoids having to register
  a write watcher and wait for the next event loop iteration, but can
  be inefficient if you write multiple small chunks (on the wire, this
  disadvantage is usually avoided by your kernel's nagle algorithm, see
  C<no_delay>, but this option can save costly syscalls).
  
  When enabled, writes will always be queued till the next event loop
  iteration. This is efficient when you do many small writes per iteration,
  but less efficient when you do a single write only per iteration (or when
  the write buffer often is full). It also increases write latency.
  
  =item no_delay => <boolean>
  
  When doing small writes on sockets, your operating system kernel might
  wait a bit for more data before actually sending it out. This is called
  the Nagle algorithm, and usually it is beneficial.
  
  In some situations you want as low a delay as possible, which can be
  accomplishd by setting this option to a true value.
  
  The default is your operating system's default behaviour (most likely
  enabled). This option explicitly enables or disables it, if possible.
  
  =item keepalive => <boolean>
  
  Enables (default disable) the SO_KEEPALIVE option on the stream socket:
  normally, TCP connections have no time-out once established, so TCP
  connections, once established, can stay alive forever even when the other
  side has long gone. TCP keepalives are a cheap way to take down long-lived
  TCP connections when the other side becomes unreachable. While the default
  is OS-dependent, TCP keepalives usually kick in after around two hours,
  and, if the other side doesn't reply, take down the TCP connection some 10
  to 15 minutes later.
  
  It is harmless to specify this option for file handles that do not support
  keepalives, and enabling it on connections that are potentially long-lived
  is usually a good idea.
  
  =item oobinline => <boolean>
  
  BSD majorly fucked up the implementation of TCP urgent data. The result
  is that almost no OS implements TCP according to the specs, and every OS
  implements it slightly differently.
  
  If you want to handle TCP urgent data, then setting this flag (the default
  is enabled) gives you the most portable way of getting urgent data, by
  putting it into the stream.
  
  Since BSD emulation of OOB data on top of TCP's urgent data can have
  security implications, AnyEvent::Handle sets this flag automatically
  unless explicitly specified. Note that setting this flag after
  establishing a connection I<may> be a bit too late (data loss could
  already have occured on BSD systems), but at least it will protect you
  from most attacks.
  
  =item read_size => <bytes>
  
  The initial read block size, the number of bytes this module will try
  to read during each loop iteration. Each handle object will consume
  at least this amount of memory for the read buffer as well, so when
  handling many connections watch out for memory requirements). See also
  C<max_read_size>. Default: C<2048>.
  
  =item max_read_size => <bytes>
  
  The maximum read buffer size used by the dynamic adjustment
  algorithm: Each time AnyEvent::Handle can read C<read_size> bytes in
  one go it will double C<read_size> up to the maximum given by this
  option. Default: C<131072> or C<read_size>, whichever is higher.
  
  =item low_water_mark => <bytes>
  
  Sets the number of bytes (default: C<0>) that make up an "empty" write
  buffer: If the buffer reaches this size or gets even samller it is
  considered empty.
  
  Sometimes it can be beneficial (for performance reasons) to add data to
  the write buffer before it is fully drained, but this is a rare case, as
  the operating system kernel usually buffers data as well, so the default
  is good in almost all cases.
  
  =item linger => <seconds>
  
  If this is non-zero (default: C<3600>), the destructor of the
  AnyEvent::Handle object will check whether there is still outstanding
  write data and will install a watcher that will write this data to the
  socket. No errors will be reported (this mostly matches how the operating
  system treats outstanding data at socket close time).
  
  This will not work for partial TLS data that could not be encoded
  yet. This data will be lost. Calling the C<stoptls> method in time might
  help.
  
  =item peername => $string
  
  A string used to identify the remote site - usually the DNS hostname
  (I<not> IDN!) used to create the connection, rarely the IP address.
  
  Apart from being useful in error messages, this string is also used in TLS
  peername verification (see C<verify_peername> in L<AnyEvent::TLS>). This
  verification will be skipped when C<peername> is not specified or is
  C<undef>.
  
  =item tls => "accept" | "connect" | Net::SSLeay::SSL object
  
  When this parameter is given, it enables TLS (SSL) mode, that means
  AnyEvent will start a TLS handshake as soon as the connection has been
  established and will transparently encrypt/decrypt data afterwards.
  
  All TLS protocol errors will be signalled as C<EPROTO>, with an
  appropriate error message.
  
  TLS mode requires Net::SSLeay to be installed (it will be loaded
  automatically when you try to create a TLS handle): this module doesn't
  have a dependency on that module, so if your module requires it, you have
  to add the dependency yourself. If Net::SSLeay cannot be loaded or is too
  old, you get an C<EPROTO> error.
  
  Unlike TCP, TLS has a server and client side: for the TLS server side, use
  C<accept>, and for the TLS client side of a connection, use C<connect>
  mode.
  
  You can also provide your own TLS connection object, but you have
  to make sure that you call either C<Net::SSLeay::set_connect_state>
  or C<Net::SSLeay::set_accept_state> on it before you pass it to
  AnyEvent::Handle. Also, this module will take ownership of this connection
  object.
  
  At some future point, AnyEvent::Handle might switch to another TLS
  implementation, then the option to use your own session object will go
  away.
  
  B<IMPORTANT:> since Net::SSLeay "objects" are really only integers,
  passing in the wrong integer will lead to certain crash. This most often
  happens when one uses a stylish C<< tls => 1 >> and is surprised about the
  segmentation fault.
  
  Use the C<< ->starttls >> method if you need to start TLS negotiation later.
  
  =item tls_ctx => $anyevent_tls
  
  Use the given C<AnyEvent::TLS> object to create the new TLS connection
  (unless a connection object was specified directly). If this
  parameter is missing (or C<undef>), then AnyEvent::Handle will use
  C<AnyEvent::Handle::TLS_CTX>.
  
  Instead of an object, you can also specify a hash reference with C<< key
  => value >> pairs. Those will be passed to L<AnyEvent::TLS> to create a
  new TLS context object.
  
  =item on_starttls => $cb->($handle, $success[, $error_message])
  
  This callback will be invoked when the TLS/SSL handshake has finished. If
  C<$success> is true, then the TLS handshake succeeded, otherwise it failed
  (C<on_stoptls> will not be called in this case).
  
  The session in C<< $handle->{tls} >> can still be examined in this
  callback, even when the handshake was not successful.
  
  TLS handshake failures will not cause C<on_error> to be invoked when this
  callback is in effect, instead, the error message will be passed to C<on_starttls>.
  
  Without this callback, handshake failures lead to C<on_error> being
  called as usual.
  
  Note that you cannot just call C<starttls> again in this callback. If you
  need to do that, start an zero-second timer instead whose callback can
  then call C<< ->starttls >> again.
  
  =item on_stoptls => $cb->($handle)
  
  When a SSLv3/TLS shutdown/close notify/EOF is detected and this callback is
  set, then it will be invoked after freeing the TLS session. If it is not,
  then a TLS shutdown condition will be treated like a normal EOF condition
  on the handle.
  
  The session in C<< $handle->{tls} >> can still be examined in this
  callback.
  
  This callback will only be called on TLS shutdowns, not when the
  underlying handle signals EOF.
  
  =item json => L<JSON>, L<JSON::PP> or L<JSON::XS> object
  
  This is the json coder object used by the C<json> read and write types.
  
  If you don't supply it, then AnyEvent::Handle will create and use a
  suitable one (on demand), which will write and expect UTF-8 encoded
  JSON texts (either using L<JSON::XS> or L<JSON>). The written texts are
  guaranteed not to contain any newline character.
  
  For security reasons, this encoder will likely I<not> handle numbers and
  strings, only arrays and objects/hashes. The reason is that originally
  JSON was self-delimited, but Dougles Crockford thought it was a splendid
  idea to redefine JSON incompatibly, so this is no longer true.
  
  For protocols that used back-to-back JSON texts, this might lead to
  run-ins, where two or more JSON texts will be interpreted as one JSON
  text.
  
  For this reason, if the default encoder uses L<JSON::XS>, it will default
  to not allowing anything but arrays and objects/hashes, at least for the
  forseeable future (it will change at some point). This might or might not
  be true for the L<JSON> module, so this might cause a security issue.
  
  If you depend on either behaviour, you should create your own json object
  and pass it in explicitly.
  
  =item cbor => L<CBOR::XS> object
  
  This is the cbor coder object used by the C<cbor> read and write types.
  
  If you don't supply it, then AnyEvent::Handle will create and use a
  suitable one (on demand), which will write CBOR without using extensions,
  if possible.
  
  Note that you are responsible to depend on the L<CBOR::XS> module if you
  want to use this functionality, as AnyEvent does not have a dependency on
  it itself.
  
  =back
  
  =cut
  
  sub new {
     my $class = shift;
     my $self = bless { @_ }, $class;
  
     if ($self->{fh}) {
        $self->_start;
        return unless $self->{fh}; # could be gone by now
  
     } elsif ($self->{connect}) {
        require AnyEvent::Socket;
  
        $self->{peername} = $self->{connect}[0]
           unless exists $self->{peername};
  
        $self->{_skip_drain_rbuf} = 1;
  
        {
           Scalar::Util::weaken (my $self = $self);
  
           $self->{_connect} =
              AnyEvent::Socket::tcp_connect (
                 $self->{connect}[0],
                 $self->{connect}[1],
                 sub {
                    my ($fh, $host, $port, $retry) = @_;
  
                    delete $self->{_connect}; # no longer needed
  
                    if ($fh) {
                       $self->{fh} = $fh;
  
                       delete $self->{_skip_drain_rbuf};
                       $self->_start;
  
                       $self->{on_connect}
                          and $self->{on_connect}($self, $host, $port, sub {
                                 delete @$self{qw(fh _tw _rtw _wtw _ww _rw _eof _queue rbuf _wbuf tls _tls_rbuf _tls_wbuf)};
                                 $self->{_skip_drain_rbuf} = 1;
                                 &$retry;
                              });
  
                    } else {
                       if ($self->{on_connect_error}) {
                          $self->{on_connect_error}($self, "$!");
                          $self->destroy if $self;
                       } else {
                          $self->_error ($!, 1);
                       }
                    }
                 },
                 sub {
                    local $self->{fh} = $_[0];
  
                    $self->{on_prepare}
                       ? $self->{on_prepare}->($self)
                       : ()
                 }
              );
        }
  
     } else {
        Carp::croak "AnyEvent::Handle: either an existing fh or the connect parameter must be specified";
     }
  
     $self
  }
  
  sub _start {
     my ($self) = @_;
  
     # too many clueless people try to use udp and similar sockets
     # with AnyEvent::Handle, do them a favour.
     my $type = getsockopt $self->{fh}, Socket::SOL_SOCKET (), Socket::SO_TYPE ();
     Carp::croak "AnyEvent::Handle: only stream sockets supported, anything else will NOT work!"
        if Socket::SOCK_STREAM () != (unpack "I", $type) && defined $type;
  
     AnyEvent::fh_unblock $self->{fh};
  
     $self->{_activity}  =
     $self->{_ractivity} =
     $self->{_wactivity} = AE::now;
  
     $self->{read_size} ||= 2048;
     $self->{max_read_size} = $self->{read_size}
        if $self->{read_size} > ($self->{max_read_size} || MAX_READ_SIZE);
  
     $self->timeout   (delete $self->{timeout}  ) if $self->{timeout};
     $self->rtimeout  (delete $self->{rtimeout} ) if $self->{rtimeout};
     $self->wtimeout  (delete $self->{wtimeout} ) if $self->{wtimeout};
  
     $self->no_delay  (delete $self->{no_delay} ) if exists $self->{no_delay}  && $self->{no_delay};
     $self->keepalive (delete $self->{keepalive}) if exists $self->{keepalive} && $self->{keepalive};
  
     $self->oobinline (exists $self->{oobinline} ? delete $self->{oobinline} : 1);
  
     $self->starttls  (delete $self->{tls}, delete $self->{tls_ctx})
        if $self->{tls};
  
     $self->on_drain  (delete $self->{on_drain} ) if $self->{on_drain};
  
     $self->start_read
        if $self->{on_read} || @{ $self->{_queue} };
  
     $self->_drain_wbuf;
  }
  
  sub _error {
     my ($self, $errno, $fatal, $message) = @_;
  
     $! = $errno;
     $message ||= "$!";
  
     if ($self->{on_error}) {
        $self->{on_error}($self, $fatal, $message);
        $self->destroy if $fatal;
     } elsif ($self->{fh} || $self->{connect}) {
        $self->destroy;
        Carp::croak "AnyEvent::Handle uncaught error: $message";
     }
  }
  
  =item $fh = $handle->fh
  
  This method returns the file handle used to create the L<AnyEvent::Handle> object.
  
  =cut
  
  sub fh { $_[0]{fh} }
  
  =item $handle->on_error ($cb)
  
  Replace the current C<on_error> callback (see the C<on_error> constructor argument).
  
  =cut
  
  sub on_error {
     $_[0]{on_error} = $_[1];
  }
  
  =item $handle->on_eof ($cb)
  
  Replace the current C<on_eof> callback (see the C<on_eof> constructor argument).
  
  =cut
  
  sub on_eof {
     $_[0]{on_eof} = $_[1];
  }
  
  =item $handle->on_timeout ($cb)
  
  =item $handle->on_rtimeout ($cb)
  
  =item $handle->on_wtimeout ($cb)
  
  Replace the current C<on_timeout>, C<on_rtimeout> or C<on_wtimeout>
  callback, or disables the callback (but not the timeout) if C<$cb> =
  C<undef>. See the C<timeout> constructor argument and method.
  
  =cut
  
  # see below
  
  =item $handle->autocork ($boolean)
  
  Enables or disables the current autocork behaviour (see C<autocork>
  constructor argument). Changes will only take effect on the next write.
  
  =cut
  
  sub autocork {
     $_[0]{autocork} = $_[1];
  }
  
  =item $handle->no_delay ($boolean)
  
  Enables or disables the C<no_delay> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub no_delay {
     $_[0]{no_delay} = $_[1];
  
     setsockopt $_[0]{fh}, Socket::IPPROTO_TCP (), Socket::TCP_NODELAY (), int $_[1]
        if $_[0]{fh};
  }
  
  =item $handle->keepalive ($boolean)
  
  Enables or disables the C<keepalive> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub keepalive {
     $_[0]{keepalive} = $_[1];
  
     eval {
        local $SIG{__DIE__};
        setsockopt $_[0]{fh}, Socket::SOL_SOCKET (), Socket::SO_KEEPALIVE (), int $_[1]
           if $_[0]{fh};
     };
  }
  
  =item $handle->oobinline ($boolean)
  
  Enables or disables the C<oobinline> setting (see constructor argument of
  the same name for details).
  
  =cut
  
  sub oobinline {
     $_[0]{oobinline} = $_[1];
  
     eval {
        local $SIG{__DIE__};
        setsockopt $_[0]{fh}, Socket::SOL_SOCKET (), Socket::SO_OOBINLINE (), int $_[1]
           if $_[0]{fh};
     };
  }
  
  =item $handle->on_starttls ($cb)
  
  Replace the current C<on_starttls> callback (see the C<on_starttls> constructor argument).
  
  =cut
  
  sub on_starttls {
     $_[0]{on_starttls} = $_[1];
  }
  
  =item $handle->on_stoptls ($cb)
  
  Replace the current C<on_stoptls> callback (see the C<on_stoptls> constructor argument).
  
  =cut
  
  sub on_stoptls {
     $_[0]{on_stoptls} = $_[1];
  }
  
  =item $handle->rbuf_max ($max_octets)
  
  Configures the C<rbuf_max> setting (C<undef> disables it).
  
  =item $handle->wbuf_max ($max_octets)
  
  Configures the C<wbuf_max> setting (C<undef> disables it).
  
  =cut
  
  sub rbuf_max {
     $_[0]{rbuf_max} = $_[1];
  }
  
  sub wbuf_max {
     $_[0]{wbuf_max} = $_[1];
  }
  
  #############################################################################
  
  =item $handle->timeout ($seconds)
  
  =item $handle->rtimeout ($seconds)
  
  =item $handle->wtimeout ($seconds)
  
  Configures (or disables) the inactivity timeout.
  
  The timeout will be checked instantly, so this method might destroy the
  handle before it returns.
  
  =item $handle->timeout_reset
  
  =item $handle->rtimeout_reset
  
  =item $handle->wtimeout_reset
  
  Reset the activity timeout, as if data was received or sent.
  
  These methods are cheap to call.
  
  =cut
  
  for my $dir ("", "r", "w") {
     my $timeout    = "${dir}timeout";
     my $tw         = "_${dir}tw";
     my $on_timeout = "on_${dir}timeout";
     my $activity   = "_${dir}activity";
     my $cb;
  
     *$on_timeout = sub {
        $_[0]{$on_timeout} = $_[1];
     };
  
     *$timeout = sub {
        my ($self, $new_value) = @_;
  
        $new_value >= 0
           or Carp::croak "AnyEvent::Handle->$timeout called with negative timeout ($new_value), caught";
  
        $self->{$timeout} = $new_value;
        delete $self->{$tw}; &$cb;
     };
  
     *{"${dir}timeout_reset"} = sub {
        $_[0]{$activity} = AE::now;
     };
  
     # main workhorse:
     # reset the timeout watcher, as neccessary
     # also check for time-outs
     $cb = sub {
        my ($self) = @_;
  
        if ($self->{$timeout} && $self->{fh}) {
           my $NOW = AE::now;
  
           # when would the timeout trigger?
           my $after = $self->{$activity} + $self->{$timeout} - $NOW;
  
           # now or in the past already?
           if ($after <= 0) {
              $self->{$activity} = $NOW;
  
              if ($self->{$on_timeout}) {
                 $self->{$on_timeout}($self);
              } else {
                 $self->_error (Errno::ETIMEDOUT);
              }
  
              # callback could have changed timeout value, optimise
              return unless $self->{$timeout};
  
              # calculate new after
              $after = $self->{$timeout};
           }
  
           Scalar::Util::weaken $self;
           return unless $self; # ->error could have destroyed $self
  
           $self->{$tw} ||= AE::timer $after, 0, sub {
              delete $self->{$tw};
              $cb->($self);
           };
        } else {
           delete $self->{$tw};
        }
     }
  }
  
  #############################################################################
  
  =back
  
  =head2 WRITE QUEUE
  
  AnyEvent::Handle manages two queues per handle, one for writing and one
  for reading.
  
  The write queue is very simple: you can add data to its end, and
  AnyEvent::Handle will automatically try to get rid of it for you.
  
  When data could be written and the write buffer is shorter then the low
  water mark, the C<on_drain> callback will be invoked once.
  
  =over 4
  
  =item $handle->on_drain ($cb)
  
  Sets the C<on_drain> callback or clears it (see the description of
  C<on_drain> in the constructor).
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub on_drain {
     my ($self, $cb) = @_;
  
     $self->{on_drain} = $cb;
  
     $cb->($self)
        if $cb && $self->{low_water_mark} >= (length $self->{wbuf}) + (length $self->{_tls_wbuf});
  }
  
  =item $handle->push_write ($data)
  
  Queues the given scalar to be written. You can push as much data as
  you want (only limited by the available memory and C<wbuf_max>), as
  C<AnyEvent::Handle> buffers it independently of the kernel.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub _drain_wbuf {
     my ($self) = @_;
  
     if (!$self->{_ww} && length $self->{wbuf}) {
  
        Scalar::Util::weaken $self;
  
        my $cb = sub {
           my $len = syswrite $self->{fh}, $self->{wbuf};
  
           if (defined $len) {
              substr $self->{wbuf}, 0, $len, "";
  
              $self->{_activity} = $self->{_wactivity} = AE::now;
  
              $self->{on_drain}($self)
                 if $self->{low_water_mark} >= (length $self->{wbuf}) + (length $self->{_tls_wbuf})
                    && $self->{on_drain};
  
              delete $self->{_ww} unless length $self->{wbuf};
           } elsif ($! != EAGAIN && $! != EINTR && $! != EWOULDBLOCK && $! != WSAEWOULDBLOCK) {
              $self->_error ($!, 1);
           }
        };
  
        # try to write data immediately
        $cb->() unless $self->{autocork};
  
        # if still data left in wbuf, we need to poll
        $self->{_ww} = AE::io $self->{fh}, 1, $cb
           if length $self->{wbuf};
  
        if (
           defined $self->{wbuf_max}
           && $self->{wbuf_max} < length $self->{wbuf}
        ) {
           $self->_error (Errno::ENOSPC, 1), return;
        }
     };
  }
  
  our %WH;
  
  # deprecated
  sub register_write_type($$) {
     $WH{$_[0]} = $_[1];
  }
  
  sub push_write {
     my $self = shift;
  
     if (@_ > 1) {
        my $type = shift;
  
        @_ = ($WH{$type} ||= _load_func "$type\::anyevent_write_type"
              or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_write")
             ->($self, @_);
     }
  
     # we downgrade here to avoid hard-to-track-down bugs,
     # and diagnose the problem earlier and better.
  
     if ($self->{tls}) {
        utf8::downgrade $self->{_tls_wbuf} .= $_[0];
        &_dotls ($self)    if $self->{fh};
     } else {
        utf8::downgrade $self->{wbuf}      .= $_[0];
        $self->_drain_wbuf if $self->{fh};
     }
  }
  
  =item $handle->push_write (type => @args)
  
  Instead of formatting your data yourself, you can also let this module
  do the job by specifying a type and type-specific arguments. You
  can also specify the (fully qualified) name of a package, in which
  case AnyEvent tries to load the package and then expects to find the
  C<anyevent_write_type> function inside (see "custom write types", below).
  
  Predefined types are (if you have ideas for additional types, feel free to
  drop by and tell us):
  
  =over 4
  
  =item netstring => $string
  
  Formats the given value as netstring
  (http://cr.yp.to/proto/netstrings.txt, this is not a recommendation to use them).
  
  =cut
  
  register_write_type netstring => sub {
     my ($self, $string) = @_;
  
     (length $string) . ":$string,"
  };
  
  =item packstring => $format, $data
  
  An octet string prefixed with an encoded length. The encoding C<$format>
  uses the same format as a Perl C<pack> format, but must specify a single
  integer only (only one of C<cCsSlLqQiInNvVjJw> is allowed, plus an
  optional C<!>, C<< < >> or C<< > >> modifier).
  
  =cut
  
  register_write_type packstring => sub {
     my ($self, $format, $string) = @_;
  
     pack "$format/a*", $string
  };
  
  =item json => $array_or_hashref
  
  Encodes the given hash or array reference into a JSON object. Unless you
  provide your own JSON object, this means it will be encoded to JSON text
  in UTF-8.
  
  The default encoder might or might not handle every type of JSON value -
  it might be limited to arrays and objects for security reasons. See the
  C<json> constructor attribute for more details.
  
  JSON objects (and arrays) are self-delimiting, so if you only use arrays
  and hashes, you can write JSON at one end of a handle and read them at the
  other end without using any additional framing.
  
  The JSON text generated by the default encoder is guaranteed not to
  contain any newlines: While this module doesn't need delimiters after or
  between JSON texts to be able to read them, many other languages depend on
  them.
  
  A simple RPC protocol that interoperates easily with other languages is
  to send JSON arrays (or objects, although arrays are usually the better
  choice as they mimic how function argument passing works) and a newline
  after each JSON text:
  
     $handle->push_write (json => ["method", "arg1", "arg2"]); # whatever
     $handle->push_write ("\012");
   
  An AnyEvent::Handle receiver would simply use the C<json> read type and
  rely on the fact that the newline will be skipped as leading whitespace:
  
     $handle->push_read (json => sub { my $array = $_[1]; ... });
  
  Other languages could read single lines terminated by a newline and pass
  this line into their JSON decoder of choice.
  
  =item cbor => $perl_scalar
  
  Encodes the given scalar into a CBOR value. Unless you provide your own
  L<CBOR::XS> object, this means it will be encoded to a CBOR string not
  using any extensions, if possible.
  
  CBOR values are self-delimiting, so you can write CBOR at one end of
  a handle and read them at the other end without using any additional
  framing.
  
  A simple nd very very fast RPC protocol that interoperates with
  other languages is to send CBOR and receive CBOR values (arrays are
  recommended):
  
     $handle->push_write (cbor => ["method", "arg1", "arg2"]); # whatever
   
  An AnyEvent::Handle receiver would simply use the C<cbor> read type:
  
     $handle->push_read (cbor => sub { my $array = $_[1]; ... });
  
  =cut
  
  sub json_coder() {
     eval { require JSON::XS; JSON::XS->new->utf8 }
        || do { require JSON::PP; JSON::PP->new->utf8 }
  }
  
  register_write_type json => sub {
     my ($self, $ref) = @_;
  
     ($self->{json} ||= json_coder)
        ->encode ($ref)
  };
  
  sub cbor_coder() {
     require CBOR::XS;
     CBOR::XS->new
  }
  
  register_write_type cbor => sub {
     my ($self, $scalar) = @_;
  
     ($self->{cbor} ||= cbor_coder)
        ->encode ($scalar)
  };
  
  =item storable => $reference
  
  Freezes the given reference using L<Storable> and writes it to the
  handle. Uses the C<nfreeze> format.
  
  =cut
  
  register_write_type storable => sub {
     my ($self, $ref) = @_;
  
     require Storable unless $Storable::VERSION;
  
     pack "w/a*", Storable::nfreeze ($ref)
  };
  
  =back
  
  =item $handle->push_shutdown
  
  Sometimes you know you want to close the socket after writing your data
  before it was actually written. One way to do that is to replace your
  C<on_drain> handler by a callback that shuts down the socket (and set
  C<low_water_mark> to C<0>). This method is a shorthand for just that, and
  replaces the C<on_drain> callback with:
  
     sub { shutdown $_[0]{fh}, 1 }
  
  This simply shuts down the write side and signals an EOF condition to the
  the peer.
  
  You can rely on the normal read queue and C<on_eof> handling
  afterwards. This is the cleanest way to close a connection.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub push_shutdown {
     my ($self) = @_;
  
     delete $self->{low_water_mark};
     $self->on_drain (sub { shutdown $_[0]{fh}, 1 });
  }
  
  =item custom write types - Package::anyevent_write_type $handle, @args
  
  Instead of one of the predefined types, you can also specify the name of
  a package. AnyEvent will try to load the package and then expects to find
  a function named C<anyevent_write_type> inside. If it isn't found, it
  progressively tries to load the parent package until it either finds the
  function (good) or runs out of packages (bad).
  
  Whenever the given C<type> is used, C<push_write> will the function with
  the handle object and the remaining arguments.
  
  The function is supposed to return a single octet string that will be
  appended to the write buffer, so you can mentally treat this function as a
  "arguments to on-the-wire-format" converter.
  
  Example: implement a custom write type C<join> that joins the remaining
  arguments using the first one.
  
     $handle->push_write (My::Type => " ", 1,2,3);
  
     # uses the following package, which can be defined in the "My::Type" or in
     # the "My" modules to be auto-loaded, or just about anywhere when the
     # My::Type::anyevent_write_type is defined before invoking it.
  
     package My::Type;
  
     sub anyevent_write_type {
        my ($handle, $delim, @args) = @_;
  
        join $delim, @args
     }
  
  =cut
  
  #############################################################################
  
  =back
  
  =head2 READ QUEUE
  
  AnyEvent::Handle manages two queues per handle, one for writing and one
  for reading.
  
  The read queue is more complex than the write queue. It can be used in two
  ways, the "simple" way, using only C<on_read> and the "complex" way, using
  a queue.
  
  In the simple case, you just install an C<on_read> callback and whenever
  new data arrives, it will be called. You can then remove some data (if
  enough is there) from the read buffer (C<< $handle->rbuf >>). Or you can
  leave the data there if you want to accumulate more (e.g. when only a
  partial message has been received so far), or change the read queue with
  e.g. C<push_read>.
  
  In the more complex case, you want to queue multiple callbacks. In this
  case, AnyEvent::Handle will call the first queued callback each time new
  data arrives (also the first time it is queued) and remove it when it has
  done its job (see C<push_read>, below).
  
  This way you can, for example, push three line-reads, followed by reading
  a chunk of data, and AnyEvent::Handle will execute them in order.
  
  Example 1: EPP protocol parser. EPP sends 4 byte length info, followed by
  the specified number of bytes which give an XML datagram.
  
     # in the default state, expect some header bytes
     $handle->on_read (sub {
        # some data is here, now queue the length-header-read (4 octets)
        shift->unshift_read (chunk => 4, sub {
           # header arrived, decode
           my $len = unpack "N", $_[1];
  
           # now read the payload
           shift->unshift_read (chunk => $len, sub {
              my $xml = $_[1];
              # handle xml
           });
        });
     });
  
  Example 2: Implement a client for a protocol that replies either with "OK"
  and another line or "ERROR" for the first request that is sent, and 64
  bytes for the second request. Due to the availability of a queue, we can
  just pipeline sending both requests and manipulate the queue as necessary
  in the callbacks.
  
  When the first callback is called and sees an "OK" response, it will
  C<unshift> another line-read. This line-read will be queued I<before> the
  64-byte chunk callback.
  
     # request one, returns either "OK + extra line" or "ERROR"
     $handle->push_write ("request 1\015\012");
  
     # we expect "ERROR" or "OK" as response, so push a line read
     $handle->push_read (line => sub {
        # if we got an "OK", we have to _prepend_ another line,
        # so it will be read before the second request reads its 64 bytes
        # which are already in the queue when this callback is called
        # we don't do this in case we got an error
        if ($_[1] eq "OK") {
           $_[0]->unshift_read (line => sub {
              my $response = $_[1];
              ...
           });
        }
     });
  
     # request two, simply returns 64 octets
     $handle->push_write ("request 2\015\012");
  
     # simply read 64 bytes, always
     $handle->push_read (chunk => 64, sub {
        my $response = $_[1];
        ...
     });
  
  =over 4
  
  =cut
  
  sub _drain_rbuf {
     my ($self) = @_;
  
     # avoid recursion
     return if $self->{_skip_drain_rbuf};
     local $self->{_skip_drain_rbuf} = 1;
  
     while () {
        # we need to use a separate tls read buffer, as we must not receive data while
        # we are draining the buffer, and this can only happen with TLS.
        $self->{rbuf} .= delete $self->{_tls_rbuf}
           if exists $self->{_tls_rbuf};
  
        my $len = length $self->{rbuf};
  
        if (my $cb = shift @{ $self->{_queue} }) {
           unless ($cb->($self)) {
              # no progress can be made
              # (not enough data and no data forthcoming)
              $self->_error (Errno::EPIPE, 1), return
                 if $self->{_eof};
  
              unshift @{ $self->{_queue} }, $cb;
              last;
           }
        } elsif ($self->{on_read}) {
           last unless $len;
  
           $self->{on_read}($self);
  
           if (
              $len == length $self->{rbuf} # if no data has been consumed
              && !@{ $self->{_queue} }     # and the queue is still empty
              && $self->{on_read}          # but we still have on_read
           ) {
              # no further data will arrive
              # so no progress can be made
              $self->_error (Errno::EPIPE, 1), return
                 if $self->{_eof};
  
              last; # more data might arrive
           }
        } else {
           # read side becomes idle
           delete $self->{_rw} unless $self->{tls};
           last;
        }
     }
  
     if ($self->{_eof}) {
        $self->{on_eof}
           ? $self->{on_eof}($self)
           : $self->_error (0, 1, "Unexpected end-of-file");
  
        return;
     }
  
     if (
        defined $self->{rbuf_max}
        && $self->{rbuf_max} < length $self->{rbuf}
     ) {
        $self->_error (Errno::ENOSPC, 1), return;
     }
  
     # may need to restart read watcher
     unless ($self->{_rw}) {
        $self->start_read
           if $self->{on_read} || @{ $self->{_queue} };
     }
  }
  
  =item $handle->on_read ($cb)
  
  This replaces the currently set C<on_read> callback, or clears it (when
  the new callback is C<undef>). See the description of C<on_read> in the
  constructor.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub on_read {
     my ($self, $cb) = @_;
  
     $self->{on_read} = $cb;
     $self->_drain_rbuf if $cb;
  }
  
  =item $handle->rbuf
  
  Returns the read buffer (as a modifiable lvalue). You can also access the
  read buffer directly as the C<< ->{rbuf} >> member, if you want (this is
  much faster, and no less clean).
  
  The only operation allowed on the read buffer (apart from looking at it)
  is removing data from its beginning. Otherwise modifying or appending to
  it is not allowed and will lead to hard-to-track-down bugs.
  
  NOTE: The read buffer should only be used or modified in the C<on_read>
  callback or when C<push_read> or C<unshift_read> are used with a single
  callback (i.e. untyped). Typed C<push_read> and C<unshift_read> methods
  will manage the read buffer on their own.
  
  =cut
  
  sub rbuf : lvalue {
     $_[0]{rbuf}
  }
  
  =item $handle->push_read ($cb)
  
  =item $handle->unshift_read ($cb)
  
  Append the given callback to the end of the queue (C<push_read>) or
  prepend it (C<unshift_read>).
  
  The callback is called each time some additional read data arrives.
  
  It must check whether enough data is in the read buffer already.
  
  If not enough data is available, it must return the empty list or a false
  value, in which case it will be called repeatedly until enough data is
  available (or an error condition is detected).
  
  If enough data was available, then the callback must remove all data it is
  interested in (which can be none at all) and return a true value. After returning
  true, it will be removed from the queue.
  
  These methods may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  our %RH;
  
  sub register_read_type($$) {
     $RH{$_[0]} = $_[1];
  }
  
  sub push_read {
     my $self = shift;
     my $cb = pop;
  
     if (@_) {
        my $type = shift;
  
        $cb = ($RH{$type} ||= _load_func "$type\::anyevent_read_type"
               or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_read")
              ->($self, $cb, @_);
     }
  
     push @{ $self->{_queue} }, $cb;
     $self->_drain_rbuf;
  }
  
  sub unshift_read {
     my $self = shift;
     my $cb = pop;
  
     if (@_) {
        my $type = shift;
  
        $cb = ($RH{$type} ||= _load_func "$type\::anyevent_read_type"
               or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::unshift_read")
              ->($self, $cb, @_);
     }
  
     unshift @{ $self->{_queue} }, $cb;
     $self->_drain_rbuf;
  }
  
  =item $handle->push_read (type => @args, $cb)
  
  =item $handle->unshift_read (type => @args, $cb)
  
  Instead of providing a callback that parses the data itself you can chose
  between a number of predefined parsing formats, for chunks of data, lines
  etc. You can also specify the (fully qualified) name of a package, in
  which case AnyEvent tries to load the package and then expects to find the
  C<anyevent_read_type> function inside (see "custom read types", below).
  
  Predefined types are (if you have ideas for additional types, feel free to
  drop by and tell us):
  
  =over 4
  
  =item chunk => $octets, $cb->($handle, $data)
  
  Invoke the callback only once C<$octets> bytes have been read. Pass the
  data read to the callback. The callback will never be called with less
  data.
  
  Example: read 2 bytes.
  
     $handle->push_read (chunk => 2, sub {
        say "yay " . unpack "H*", $_[1];
     });
  
  =cut
  
  register_read_type chunk => sub {
     my ($self, $cb, $len) = @_;
  
     sub {
        $len <= length $_[0]{rbuf} or return;
        $cb->($_[0], substr $_[0]{rbuf}, 0, $len, "");
        1
     }
  };
  
  =item line => [$eol, ]$cb->($handle, $line, $eol)
  
  The callback will be called only once a full line (including the end of
  line marker, C<$eol>) has been read. This line (excluding the end of line
  marker) will be passed to the callback as second argument (C<$line>), and
  the end of line marker as the third argument (C<$eol>).
  
  The end of line marker, C<$eol>, can be either a string, in which case it
  will be interpreted as a fixed record end marker, or it can be a regex
  object (e.g. created by C<qr>), in which case it is interpreted as a
  regular expression.
  
  The end of line marker argument C<$eol> is optional, if it is missing (NOT
  undef), then C<qr|\015?\012|> is used (which is good for most internet
  protocols).
  
  Partial lines at the end of the stream will never be returned, as they are
  not marked by the end of line marker.
  
  =cut
  
  register_read_type line => sub {
     my ($self, $cb, $eol) = @_;
  
     if (@_ < 3) {
        # this is faster then the generic code below
        sub {
           (my $pos = index $_[0]{rbuf}, "\012") >= 0
              or return;
  
           (my $str = substr $_[0]{rbuf}, 0, $pos + 1, "") =~ s/(\015?\012)\Z// or die;
           $cb->($_[0], $str, "$1");
           1
        }
     } else {
        $eol = quotemeta $eol unless ref $eol;
        $eol = qr|^(.*?)($eol)|s;
  
        sub {
           $_[0]{rbuf} =~ s/$eol// or return;
  
           $cb->($_[0], "$1", "$2");
           1
        }
     }
  };
  
  =item regex => $accept[, $reject[, $skip], $cb->($handle, $data)
  
  Makes a regex match against the regex object C<$accept> and returns
  everything up to and including the match. All the usual regex variables
  ($1, %+ etc.) from the regex match are available in the callback.
  
  Example: read a single line terminated by '\n'.
  
     $handle->push_read (regex => qr<\n>, sub { ... });
  
  If C<$reject> is given and not undef, then it determines when the data is
  to be rejected: it is matched against the data when the C<$accept> regex
  does not match and generates an C<EBADMSG> error when it matches. This is
  useful to quickly reject wrong data (to avoid waiting for a timeout or a
  receive buffer overflow).
  
  Example: expect a single decimal number followed by whitespace, reject
  anything else (not the use of an anchor).
  
     $handle->push_read (regex => qr<^[0-9]+\s>, qr<[^0-9]>, sub { ... });
  
  If C<$skip> is given and not C<undef>, then it will be matched against
  the receive buffer when neither C<$accept> nor C<$reject> match,
  and everything preceding and including the match will be accepted
  unconditionally. This is useful to skip large amounts of data that you
  know cannot be matched, so that the C<$accept> or C<$reject> regex do not
  have to start matching from the beginning. This is purely an optimisation
  and is usually worth it only when you expect more than a few kilobytes.
  
  Example: expect a http header, which ends at C<\015\012\015\012>. Since we
  expect the header to be very large (it isn't in practice, but...), we use
  a skip regex to skip initial portions. The skip regex is tricky in that
  it only accepts something not ending in either \015 or \012, as these are
  required for the accept regex.
  
     $handle->push_read (regex =>
        qr<\015\012\015\012>,
        undef, # no reject
        qr<^.*[^\015\012]>,
        sub { ... });
  
  =cut
  
  register_read_type regex => sub {
     my ($self, $cb, $accept, $reject, $skip) = @_;
  
     my $data;
     my $rbuf = \$self->{rbuf};
  
     sub {
        # accept
        if ($$rbuf =~ $accept) {
           $data .= substr $$rbuf, 0, $+[0], "";
           $cb->($_[0], $data);
           return 1;
        }
        
        # reject
        if ($reject && $$rbuf =~ $reject) {
           $_[0]->_error (Errno::EBADMSG);
        }
  
        # skip
        if ($skip && $$rbuf =~ $skip) {
           $data .= substr $$rbuf, 0, $+[0], "";
        }
  
        ()
     }
  };
  
  =item netstring => $cb->($handle, $string)
  
  A netstring (http://cr.yp.to/proto/netstrings.txt, this is not an endorsement).
  
  Throws an error with C<$!> set to EBADMSG on format violations.
  
  =cut
  
  register_read_type netstring => sub {
     my ($self, $cb) = @_;
  
     sub {
        unless ($_[0]{rbuf} =~ s/^(0|[1-9][0-9]*)://) {
           if ($_[0]{rbuf} =~ /[^0-9]/) {
              $_[0]->_error (Errno::EBADMSG);
           }
           return;
        }
  
        my $len = $1;
  
        $_[0]->unshift_read (chunk => $len, sub {
           my $string = $_[1];
           $_[0]->unshift_read (chunk => 1, sub {
              if ($_[1] eq ",") {
                 $cb->($_[0], $string);
              } else {
                 $_[0]->_error (Errno::EBADMSG);
              }
           });
        });
  
        1
     }
  };
  
  =item packstring => $format, $cb->($handle, $string)
  
  An octet string prefixed with an encoded length. The encoding C<$format>
  uses the same format as a Perl C<pack> format, but must specify a single
  integer only (only one of C<cCsSlLqQiInNvVjJw> is allowed, plus an
  optional C<!>, C<< < >> or C<< > >> modifier).
  
  For example, DNS over TCP uses a prefix of C<n> (2 octet network order),
  EPP uses a prefix of C<N> (4 octtes).
  
  Example: read a block of data prefixed by its length in BER-encoded
  format (very efficient).
  
     $handle->push_read (packstring => "w", sub {
        my ($handle, $data) = @_;
     });
  
  =cut
  
  register_read_type packstring => sub {
     my ($self, $cb, $format) = @_;
  
     sub {
        # when we can use 5.10 we can use ".", but for 5.8 we use the re-pack method
        defined (my $len = eval { unpack $format, $_[0]{rbuf} })
           or return;
  
        $format = length pack $format, $len;
  
        # bypass unshift if we already have the remaining chunk
        if ($format + $len <= length $_[0]{rbuf}) {
           my $data = substr $_[0]{rbuf}, $format, $len;
           substr $_[0]{rbuf}, 0, $format + $len, "";
           $cb->($_[0], $data);
        } else {
           # remove prefix
           substr $_[0]{rbuf}, 0, $format, "";
  
           # read remaining chunk
           $_[0]->unshift_read (chunk => $len, $cb);
        }
  
        1
     }
  };
  
  =item json => $cb->($handle, $hash_or_arrayref)
  
  Reads a JSON object or array, decodes it and passes it to the
  callback. When a parse error occurs, an C<EBADMSG> error will be raised.
  
  If a C<json> object was passed to the constructor, then that will be
  used for the final decode, otherwise it will create a L<JSON::XS> or
  L<JSON::PP> coder object expecting UTF-8.
  
  This read type uses the incremental parser available with JSON version
  2.09 (and JSON::XS version 2.2) and above.
  
  Since JSON texts are fully self-delimiting, the C<json> read and write
  types are an ideal simple RPC protocol: just exchange JSON datagrams. See
  the C<json> write type description, above, for an actual example.
  
  =cut
  
  register_read_type json => sub {
     my ($self, $cb) = @_;
  
     my $json = $self->{json} ||= json_coder;
  
     my $data;
  
     sub {
        my $ref = eval { $json->incr_parse ($_[0]{rbuf}) };
  
        if ($ref) {
           $_[0]{rbuf} = $json->incr_text;
           $json->incr_text = "";
           $cb->($_[0], $ref);
  
           1
        } elsif ($@) {
           # error case
           $json->incr_skip;
  
           $_[0]{rbuf} = $json->incr_text;
           $json->incr_text = "";
  
           $_[0]->_error (Errno::EBADMSG);
  
           ()
        } else {
           $_[0]{rbuf} = "";
  
           ()
        }
     }
  };
  
  =item cbor => $cb->($handle, $scalar)
  
  Reads a CBOR value, decodes it and passes it to the callback. When a parse
  error occurs, an C<EBADMSG> error will be raised.
  
  If a L<CBOR::XS> object was passed to the constructor, then that will be
  used for the final decode, otherwise it will create a CBOR coder without
  enabling any options.
  
  You have to provide a dependency to L<CBOR::XS> on your own: this module
  will load the L<CBOR::XS> module, but AnyEvent does not depend on it
  itself.
  
  Since CBOR values are fully self-delimiting, the C<cbor> read and write
  types are an ideal simple RPC protocol: just exchange CBOR datagrams. See
  the C<cbor> write type description, above, for an actual example.
  
  =cut
  
  register_read_type cbor => sub {
     my ($self, $cb) = @_;
  
     my $cbor = $self->{cbor} ||= cbor_coder;
  
     my $data;
  
     sub {
        my (@value) = eval { $cbor->incr_parse ($_[0]{rbuf}) };
  
        if (@value) {
           $cb->($_[0], @value);
  
           1
        } elsif ($@) {
           # error case
           $cbor->incr_reset;
  
           $_[0]->_error (Errno::EBADMSG);
  
           ()
        } else {
           ()
        }
     }
  };
  
  =item storable => $cb->($handle, $ref)
  
  Deserialises a L<Storable> frozen representation as written by the
  C<storable> write type (BER-encoded length prefix followed by nfreeze'd
  data).
  
  Raises C<EBADMSG> error if the data could not be decoded.
  
  =cut
  
  register_read_type storable => sub {
     my ($self, $cb) = @_;
  
     require Storable unless $Storable::VERSION;
  
     sub {
        # when we can use 5.10 we can use ".", but for 5.8 we use the re-pack method
        defined (my $len = eval { unpack "w", $_[0]{rbuf} })
           or return;
  
        my $format = length pack "w", $len;
  
        # bypass unshift if we already have the remaining chunk
        if ($format + $len <= length $_[0]{rbuf}) {
           my $data = substr $_[0]{rbuf}, $format, $len;
           substr $_[0]{rbuf}, 0, $format + $len, "";
  
           eval { $cb->($_[0], Storable::thaw ($data)); 1 }
              or return $_[0]->_error (Errno::EBADMSG);
        } else {
           # remove prefix
           substr $_[0]{rbuf}, 0, $format, "";
  
           # read remaining chunk
           $_[0]->unshift_read (chunk => $len, sub {
              eval { $cb->($_[0], Storable::thaw ($_[1])); 1 }
                 or $_[0]->_error (Errno::EBADMSG);
           });
        }
  
        1
     }
  };
  
  =item tls_detect => $cb->($handle, $detect, $major, $minor)
  
  Checks the input stream for a valid SSL or TLS handshake TLSPaintext
  record without consuming anything. Only SSL version 3 or higher
  is handled, up to the fictituous protocol 4.x (but both SSL3+ and
  SSL2-compatible framing is supported).
  
  If it detects that the input data is likely TLS, it calls the callback
  with a true value for C<$detect> and the (on-wire) TLS version as second
  and third argument (C<$major> is C<3>, and C<$minor> is 0..4 for SSL
  3.0, TLS 1.0, 1.1, 1.2 and 1.3, respectively).  If it detects the input
  to be definitely not TLS, it calls the callback with a false value for
  C<$detect>.
  
  The callback could use this information to decide whether or not to start
  TLS negotiation.
  
  In all cases the data read so far is passed to the following read
  handlers.
  
  Usually you want to use the C<tls_autostart> read type instead.
  
  If you want to design a protocol that works in the presence of TLS
  dtection, make sure that any non-TLS data doesn't start with the octet 22
  (ASCII SYN, 16 hex) or 128-255 (i.e. highest bit set). The checks this
  read type does are a bit more strict, but might losen in the future to
  accomodate protocol changes.
  
  This read type does not rely on L<AnyEvent::TLS> (and thus, not on
  L<Net::SSLeay>).
  
  =item tls_autostart => [$tls_ctx, ]$tls
  
  Tries to detect a valid SSL or TLS handshake. If one is detected, it tries
  to start tls by calling C<starttls> with the given arguments.
  
  In practise, C<$tls> must be C<accept>, or a Net::SSLeay context that has
  been configured to accept, as servers do not normally send a handshake on
  their own and ths cannot be detected in this way.
  
  See C<tls_detect> above for more details.
  
  Example: give the client a chance to start TLS before accepting a text
  line.
  
     $hdl->push_read (tls_autostart => "accept");
     $hdl->push_read (line => sub {
        print "received ", ($_[0]{tls} ? "encrypted" : "cleartext"), " <$_[1]>\n";
     });
  
  =cut
  
  register_read_type tls_detect => sub {
     my ($self, $cb) = @_;
  
     sub {
        # this regex matches a full or partial tls record
        if (
           # ssl3+: type(22=handshake) major(=3) minor(any) length_hi
           $self->{rbuf} =~ /^(?:\z| \x16 (\z| [\x03\x04] (?:\z| . (?:\z| [\x00-\x40] ))))/xs
           # ssl2 comapatible: len_hi len_lo type(1) major minor dummy(forlength)
           or $self->{rbuf} =~ /^(?:\z| [\x80-\xff] (?:\z| . (?:\z| \x01 (\z| [\x03\x04] (?:\z| . (?:\z| . ))))))/xs
        ) {
           return if 3 != length $1; # partial match, can't decide yet
  
           # full match, valid TLS record
           my ($major, $minor) = unpack "CC", $1;
           $cb->($self, "accept", $major, $minor);
        } else {
           # mismatch == guaranteed not TLS
           $cb->($self, undef);
        }
  
        1
     }
  };
  
  register_read_type tls_autostart => sub {
     my ($self, @tls) = @_;
  
     $RH{tls_detect}($self, sub {
        return unless $_[1];
        $_[0]->starttls (@tls);
     })
  };
  
  =back
  
  =item custom read types - Package::anyevent_read_type $handle, $cb, @args
  
  Instead of one of the predefined types, you can also specify the name
  of a package. AnyEvent will try to load the package and then expects to
  find a function named C<anyevent_read_type> inside. If it isn't found, it
  progressively tries to load the parent package until it either finds the
  function (good) or runs out of packages (bad).
  
  Whenever this type is used, C<push_read> will invoke the function with the
  handle object, the original callback and the remaining arguments.
  
  The function is supposed to return a callback (usually a closure) that
  works as a plain read callback (see C<< ->push_read ($cb) >>), so you can
  mentally treat the function as a "configurable read type to read callback"
  converter.
  
  It should invoke the original callback when it is done reading (remember
  to pass C<$handle> as first argument as all other callbacks do that,
  although there is no strict requirement on this).
  
  For examples, see the source of this module (F<perldoc -m
  AnyEvent::Handle>, search for C<register_read_type>)).
  
  =item $handle->stop_read
  
  =item $handle->start_read
  
  In rare cases you actually do not want to read anything from the
  socket. In this case you can call C<stop_read>. Neither C<on_read> nor
  any queued callbacks will be executed then. To start reading again, call
  C<start_read>.
  
  Note that AnyEvent::Handle will automatically C<start_read> for you when
  you change the C<on_read> callback or push/unshift a read callback, and it
  will automatically C<stop_read> for you when neither C<on_read> is set nor
  there are any read requests in the queue.
  
  In older versions of this module (<= 5.3), these methods had no effect,
  as TLS does not support half-duplex connections. In current versions they
  work as expected, as this behaviour is required to avoid certain resource
  attacks, where the program would be forced to read (and buffer) arbitrary
  amounts of data before being able to send some data. The drawback is that
  some readings of the the SSL/TLS specifications basically require this
  attack to be working, as SSL/TLS implementations might stall sending data
  during a rehandshake.
  
  As a guideline, during the initial handshake, you should not stop reading,
  and as a client, it might cause problems, depending on your application.
  
  =cut
  
  sub stop_read {
     my ($self) = @_;
  
     delete $self->{_rw};
  }
  
  sub start_read {
     my ($self) = @_;
  
     unless ($self->{_rw} || $self->{_eof} || !$self->{fh}) {
        Scalar::Util::weaken $self;
  
        $self->{_rw} = AE::io $self->{fh}, 0, sub {
           my $rbuf = \($self->{tls} ? my $buf : $self->{rbuf});
           my $len = sysread $self->{fh}, $$rbuf, $self->{read_size}, length $$rbuf;
  
           if ($len > 0) {
              $self->{_activity} = $self->{_ractivity} = AE::now;
  
              if ($self->{tls}) {
                 Net::SSLeay::BIO_write ($self->{_rbio}, $$rbuf);
  
                 &_dotls ($self);
              } else {
                 $self->_drain_rbuf;
              }
  
              if ($len == $self->{read_size}) {
                 $self->{read_size} *= 2;
                 $self->{read_size} = $self->{max_read_size} || MAX_READ_SIZE
                    if $self->{read_size} > ($self->{max_read_size} || MAX_READ_SIZE);
              }
  
           } elsif (defined $len) {
              delete $self->{_rw};
              $self->{_eof} = 1;
              $self->_drain_rbuf;
  
           } elsif ($! != EAGAIN && $! != EINTR && $! != EWOULDBLOCK && $! != WSAEWOULDBLOCK) {
              return $self->_error ($!, 1);
           }
        };
     }
  }
  
  our $ERROR_SYSCALL;
  our $ERROR_WANT_READ;
  
  sub _tls_error {
     my ($self, $err) = @_;
  
     return $self->_error ($!, 1)
        if $err == Net::SSLeay::ERROR_SYSCALL ();
  
     my $err = Net::SSLeay::ERR_error_string (Net::SSLeay::ERR_get_error ());
  
     # reduce error string to look less scary
     $err =~ s/^error:[0-9a-fA-F]{8}:[^:]+:([^:]+):/\L$1: /;
  
     if ($self->{_on_starttls}) {
        (delete $self->{_on_starttls})->($self, undef, $err);
        &_freetls;
     } else {
        &_freetls;
        $self->_error (Errno::EPROTO, 1, $err);
     }
  }
  
  # poll the write BIO and send the data if applicable
  # also decode read data if possible
  # this is basiclaly our TLS state machine
  # more efficient implementations are possible with openssl,
  # but not with the buggy and incomplete Net::SSLeay.
  sub _dotls {
     my ($self) = @_;
  
     my $tmp;
  
     while (length $self->{_tls_wbuf}) {
        if (($tmp = Net::SSLeay::write ($self->{tls}, $self->{_tls_wbuf})) <= 0) {
           $tmp = Net::SSLeay::get_error ($self->{tls}, $tmp);
  
           return $self->_tls_error ($tmp)
              if $tmp != $ERROR_WANT_READ
                 && ($tmp != $ERROR_SYSCALL || $!);
  
           last;
        }
  
        substr $self->{_tls_wbuf}, 0, $tmp, "";
     }
  
     while (defined ($tmp = Net::SSLeay::read ($self->{tls}))) {
        unless (length $tmp) {
           $self->{_on_starttls}
              and (delete $self->{_on_starttls})->($self, undef, "EOF during handshake"); # ???
           &_freetls;
  
           if ($self->{on_stoptls}) {
              $self->{on_stoptls}($self);
              return;
           } else {
              # let's treat SSL-eof as we treat normal EOF
              delete $self->{_rw};
              $self->{_eof} = 1;
           }
        }
  
        $self->{_tls_rbuf} .= $tmp;
        $self->_drain_rbuf;
        $self->{tls} or return; # tls session might have gone away in callback
     }
  
     $tmp = Net::SSLeay::get_error ($self->{tls}, -1); # -1 is not neccessarily correct, but Net::SSLeay doesn't tell us
     return $self->_tls_error ($tmp)
        if $tmp != $ERROR_WANT_READ
           && ($tmp != $ERROR_SYSCALL || $!);
  
     while (length ($tmp = Net::SSLeay::BIO_read ($self->{_wbio}))) {
        $self->{wbuf} .= $tmp;
        $self->_drain_wbuf;
        $self->{tls} or return; # tls session might have gone away in callback
     }
  
     $self->{_on_starttls}
        and Net::SSLeay::state ($self->{tls}) == Net::SSLeay::ST_OK ()
        and (delete $self->{_on_starttls})->($self, 1, "TLS/SSL connection established");
  }
  
  =item $handle->starttls ($tls[, $tls_ctx])
  
  Instead of starting TLS negotiation immediately when the AnyEvent::Handle
  object is created, you can also do that at a later time by calling
  C<starttls>. See the C<tls> constructor argument for general info.
  
  Starting TLS is currently an asynchronous operation - when you push some
  write data and then call C<< ->starttls >> then TLS negotiation will start
  immediately, after which the queued write data is then sent. This might
  change in future versions, so best make sure you have no outstanding write
  data when calling this method.
  
  The first argument is the same as the C<tls> constructor argument (either
  C<"connect">, C<"accept"> or an existing Net::SSLeay object).
  
  The second argument is the optional C<AnyEvent::TLS> object that is used
  when AnyEvent::Handle has to create its own TLS connection object, or
  a hash reference with C<< key => value >> pairs that will be used to
  construct a new context.
  
  The TLS connection object will end up in C<< $handle->{tls} >>, the TLS
  context in C<< $handle->{tls_ctx} >> after this call and can be used or
  changed to your liking. Note that the handshake might have already started
  when this function returns.
  
  Due to bugs in OpenSSL, it might or might not be possible to do multiple
  handshakes on the same stream. It is best to not attempt to use the
  stream after stopping TLS.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  our %TLS_CACHE; #TODO not yet documented, should we?
  
  sub starttls {
     my ($self, $tls, $ctx) = @_;
  
     Carp::croak "It is an error to call starttls on an AnyEvent::Handle object while TLS is already active, caught"
        if $self->{tls};
  
     unless (defined $AnyEvent::TLS::VERSION) {
        eval {
           require Net::SSLeay;
           require AnyEvent::TLS;
           1
        } or return $self->_error (Errno::EPROTO, 1, "TLS support not available on this system");
     }
  
     $self->{tls}     = $tls;
     $self->{tls_ctx} = $ctx if @_ > 2;
  
     return unless $self->{fh};
  
     $ERROR_SYSCALL   = Net::SSLeay::ERROR_SYSCALL     ();
     $ERROR_WANT_READ = Net::SSLeay::ERROR_WANT_READ   ();
  
     $tls = delete $self->{tls};
     $ctx = $self->{tls_ctx};
  
     local $Carp::CarpLevel = 1; # skip ourselves when creating a new context or session
  
     if ("HASH" eq ref $ctx) {
        if ($ctx->{cache}) {
           my $key = $ctx+0;
           $ctx = $TLS_CACHE{$key} ||= new AnyEvent::TLS %$ctx;
        } else {
           $ctx = new AnyEvent::TLS %$ctx;
        }
     }
     
     $self->{tls_ctx} = $ctx || TLS_CTX ();
     $self->{tls}     = $tls = $self->{tls_ctx}->_get_session ($tls, $self, $self->{peername});
  
     # basically, this is deep magic (because SSL_read should have the same issues)
     # but the openssl maintainers basically said: "trust us, it just works".
     # (unfortunately, we have to hardcode constants because the abysmally misdesigned
     # and mismaintained ssleay-module didn't offer them for a decade or so).
     # http://www.mail-archive.com/openssl-dev@openssl.org/msg22420.html
     #
     # in short: this is a mess.
     #
     # note that we do not try to keep the length constant between writes as we are required to do.
     # we assume that most (but not all) of this insanity only applies to non-blocking cases,
     # and we drive openssl fully in blocking mode here. Or maybe we don't - openssl seems to
     # have identity issues in that area.
  #   Net::SSLeay::set_mode ($ssl,
  #      (eval { local $SIG{__DIE__}; Net::SSLeay::MODE_ENABLE_PARTIAL_WRITE () } || 1)
  #      | (eval { local $SIG{__DIE__}; Net::SSLeay::MODE_ACCEPT_MOVING_WRITE_BUFFER () } || 2));
     Net::SSLeay::set_mode ($tls, 1|2);
  
     $self->{_rbio} = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
     $self->{_wbio} = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
  
     Net::SSLeay::BIO_write ($self->{_rbio}, $self->{rbuf});
     $self->{rbuf} = "";
  
     Net::SSLeay::set_bio ($tls, $self->{_rbio}, $self->{_wbio});
  
     $self->{_on_starttls} = sub { $_[0]{on_starttls}(@_) }
        if $self->{on_starttls};
  
     &_dotls; # need to trigger the initial handshake
     $self->start_read; # make sure we actually do read
  }
  
  =item $handle->stoptls
  
  Shuts down the SSL connection - this makes a proper EOF handshake by
  sending a close notify to the other side, but since OpenSSL doesn't
  support non-blocking shut downs, it is not guaranteed that you can re-use
  the stream afterwards.
  
  This method may invoke callbacks (and therefore the handle might be
  destroyed after it returns).
  
  =cut
  
  sub stoptls {
     my ($self) = @_;
  
     if ($self->{tls} && $self->{fh}) {
        Net::SSLeay::shutdown ($self->{tls});
  
        &_dotls;
  
  #      # we don't give a shit. no, we do, but we can't. no...#d#
  #      # we, we... have to use openssl :/#d#
  #      &_freetls;#d#
     }
  }
  
  sub _freetls {
     my ($self) = @_;
  
     return unless $self->{tls};
  
     $self->{tls_ctx}->_put_session (delete $self->{tls})
        if $self->{tls} > 0;
     
     delete @$self{qw(_rbio _wbio _tls_wbuf _on_starttls)};
  }
  
  =item $handle->resettls
  
  This rarely-used method simply resets and TLS state on the handle, usually
  causing data loss.
  
  One case where it may be useful is when you want to skip over the data in
  the stream but you are not interested in interpreting it, so data loss is
  no concern.
  
  =cut
  
  *resettls = \&_freetls;
  
  sub DESTROY {
     my ($self) = @_;
  
     &_freetls;
  
     my $linger = exists $self->{linger} ? $self->{linger} : 3600;
  
     if ($linger && length $self->{wbuf} && $self->{fh}) {
        my $fh   = delete $self->{fh};
        my $wbuf = delete $self->{wbuf};
  
        my @linger;
  
        push @linger, AE::io $fh, 1, sub {
           my $len = syswrite $fh, $wbuf, length $wbuf;
  
           if ($len > 0) {
              substr $wbuf, 0, $len, "";
           } elsif (defined $len || ($! != EAGAIN && $! != EINTR && $! != EWOULDBLOCK && $! != WSAEWOULDBLOCK)) {
              @linger = (); # end
           }
        };
        push @linger, AE::timer $linger, 0, sub {
           @linger = ();
        };
     }
  }
  
  =item $handle->destroy
  
  Shuts down the handle object as much as possible - this call ensures that
  no further callbacks will be invoked and as many resources as possible
  will be freed. Any method you will call on the handle object after
  destroying it in this way will be silently ignored (and it will return the
  empty list).
  
  Normally, you can just "forget" any references to an AnyEvent::Handle
  object and it will simply shut down. This works in fatal error and EOF
  callbacks, as well as code outside. It does I<NOT> work in a read or write
  callback, so when you want to destroy the AnyEvent::Handle object from
  within such an callback. You I<MUST> call C<< ->destroy >> explicitly in
  that case.
  
  Destroying the handle object in this way has the advantage that callbacks
  will be removed as well, so if those are the only reference holders (as
  is common), then one doesn't need to do anything special to break any
  reference cycles.
  
  The handle might still linger in the background and write out remaining
  data, as specified by the C<linger> option, however.
  
  =cut
  
  sub destroy {
     my ($self) = @_;
  
     $self->DESTROY;
     %$self = ();
     bless $self, "AnyEvent::Handle::destroyed";
  }
  
  sub AnyEvent::Handle::destroyed::AUTOLOAD {
     #nop
  }
  
  =item $handle->destroyed
  
  Returns false as long as the handle hasn't been destroyed by a call to C<<
  ->destroy >>, true otherwise.
  
  Can be useful to decide whether the handle is still valid after some
  callback possibly destroyed the handle. For example, C<< ->push_write >>,
  C<< ->starttls >> and other methods can call user callbacks, which in turn
  can destroy the handle, so work can be avoided by checking sometimes:
  
     $hdl->starttls ("accept");
     return if $hdl->destroyed;
     $hdl->push_write (...
  
  Note that the call to C<push_write> will silently be ignored if the handle
  has been destroyed, so often you can just ignore the possibility of the
  handle being destroyed.
  
  =cut
  
  sub destroyed { 0 }
  sub AnyEvent::Handle::destroyed::destroyed { 1 }
  
  =item AnyEvent::Handle::TLS_CTX
  
  This function creates and returns the AnyEvent::TLS object used by default
  for TLS mode.
  
  The context is created by calling L<AnyEvent::TLS> without any arguments.
  
  =cut
  
  our $TLS_CTX;
  
  sub TLS_CTX() {
     $TLS_CTX ||= do {
        require AnyEvent::TLS;
  
        new AnyEvent::TLS
     }
  }
  
  =back
  
  
  =head1 NONFREQUENTLY ASKED QUESTIONS
  
  =over 4
  
  =item I C<undef> the AnyEvent::Handle reference inside my callback and
  still get further invocations!
  
  That's because AnyEvent::Handle keeps a reference to itself when handling
  read or write callbacks.
  
  It is only safe to "forget" the reference inside EOF or error callbacks,
  from within all other callbacks, you need to explicitly call the C<<
  ->destroy >> method.
  
  =item Why is my C<on_eof> callback never called?
  
  Probably because your C<on_error> callback is being called instead: When
  you have outstanding requests in your read queue, then an EOF is
  considered an error as you clearly expected some data.
  
  To avoid this, make sure you have an empty read queue whenever your handle
  is supposed to be "idle" (i.e. connection closes are O.K.). You can set
  an C<on_read> handler that simply pushes the first read requests in the
  queue.
  
  See also the next question, which explains this in a bit more detail.
  
  =item How can I serve requests in a loop?
  
  Most protocols consist of some setup phase (authentication for example)
  followed by a request handling phase, where the server waits for requests
  and handles them, in a loop.
  
  There are two important variants: The first (traditional, better) variant
  handles requests until the server gets some QUIT command, causing it to
  close the connection first (highly desirable for a busy TCP server). A
  client dropping the connection is an error, which means this variant can
  detect an unexpected detection close.
  
  To handle this case, always make sure you have a non-empty read queue, by
  pushing the "read request start" handler on it:
  
     # we assume a request starts with a single line
     my @start_request; @start_request = (line => sub {
        my ($hdl, $line) = @_;
  
        ... handle request
  
        # push next request read, possibly from a nested callback
        $hdl->push_read (@start_request);
     });
  
     # auth done, now go into request handling loop
     # now push the first @start_request
     $hdl->push_read (@start_request);
  
  By always having an outstanding C<push_read>, the handle always expects
  some data and raises the C<EPIPE> error when the connction is dropped
  unexpectedly.
  
  The second variant is a protocol where the client can drop the connection
  at any time. For TCP, this means that the server machine may run out of
  sockets easier, and in general, it means you cannot distinguish a protocl
  failure/client crash from a normal connection close. Nevertheless, these
  kinds of protocols are common (and sometimes even the best solution to the
  problem).
  
  Having an outstanding read request at all times is possible if you ignore
  C<EPIPE> errors, but this doesn't help with when the client drops the
  connection during a request, which would still be an error.
  
  A better solution is to push the initial request read in an C<on_read>
  callback. This avoids an error, as when the server doesn't expect data
  (i.e. is idly waiting for the next request, an EOF will not raise an
  error, but simply result in an C<on_eof> callback. It is also a bit slower
  and simpler:
  
     # auth done, now go into request handling loop
     $hdl->on_read (sub {
        my ($hdl) = @_;
  
        # called each time we receive data but the read queue is empty
        # simply start read the request
  
        $hdl->push_read (line => sub {
           my ($hdl, $line) = @_;
  
           ... handle request
  
           # do nothing special when the request has been handled, just
           # let the request queue go empty.
        });
     });
  
  =item I get different callback invocations in TLS mode/Why can't I pause
  reading?
  
  Unlike, say, TCP, TLS connections do not consist of two independent
  communication channels, one for each direction. Or put differently, the
  read and write directions are not independent of each other: you cannot
  write data unless you are also prepared to read, and vice versa.
  
  This means that, in TLS mode, you might get C<on_error> or C<on_eof>
  callback invocations when you are not expecting any read data - the reason
  is that AnyEvent::Handle always reads in TLS mode.
  
  During the connection, you have to make sure that you always have a
  non-empty read-queue, or an C<on_read> watcher. At the end of the
  connection (or when you no longer want to use it) you can call the
  C<destroy> method.
  
  =item How do I read data until the other side closes the connection?
  
  If you just want to read your data into a perl scalar, the easiest way
  to achieve this is by setting an C<on_read> callback that does nothing,
  clearing the C<on_eof> callback and in the C<on_error> callback, the data
  will be in C<$_[0]{rbuf}>:
  
     $handle->on_read (sub { });
     $handle->on_eof (undef);
     $handle->on_error (sub {
        my $data = delete $_[0]{rbuf};
     });
  
  Note that this example removes the C<rbuf> member from the handle object,
  which is not normally allowed by the API. It is expressly permitted in
  this case only, as the handle object needs to be destroyed afterwards.
  
  The reason to use C<on_error> is that TCP connections, due to latencies
  and packets loss, might get closed quite violently with an error, when in
  fact all data has been received.
  
  It is usually better to use acknowledgements when transferring data,
  to make sure the other side hasn't just died and you got the data
  intact. This is also one reason why so many internet protocols have an
  explicit QUIT command.
  
  =item I don't want to destroy the handle too early - how do I wait until
  all data has been written?
  
  After writing your last bits of data, set the C<on_drain> callback
  and destroy the handle in there - with the default setting of
  C<low_water_mark> this will be called precisely when all data has been
  written to the socket:
  
     $handle->push_write (...);
     $handle->on_drain (sub {
        AE::log debug => "All data submitted to the kernel.";
        undef $handle;
     });
  
  If you just want to queue some data and then signal EOF to the other side,
  consider using C<< ->push_shutdown >> instead.
  
  =item I want to contact a TLS/SSL server, I don't care about security.
  
  If your TLS server is a pure TLS server (e.g. HTTPS) that only speaks TLS,
  connect to it and then create the AnyEvent::Handle with the C<tls>
  parameter:
  
     tcp_connect $host, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh  => $fh,
           tls => "connect",
           on_error => sub { ... };
  
        $handle->push_write (...);
     };
  
  =item I want to contact a TLS/SSL server, I do care about security.
  
  Then you should additionally enable certificate verification, including
  peername verification, if the protocol you use supports it (see
  L<AnyEvent::TLS>, C<verify_peername>).
  
  E.g. for HTTPS:
  
     tcp_connect $host, $port, sub {
        my ($fh) = @_;
  
         my $handle = new AnyEvent::Handle
            fh       => $fh,
            peername => $host,
            tls      => "connect",
            tls_ctx  => { verify => 1, verify_peername => "https" },
            ...
  
  Note that you must specify the hostname you connected to (or whatever
  "peername" the protocol needs) as the C<peername> argument, otherwise no
  peername verification will be done.
  
  The above will use the system-dependent default set of trusted CA
  certificates. If you want to check against a specific CA, add the
  C<ca_file> (or C<ca_cert>) arguments to C<tls_ctx>:
  
         tls_ctx  => {
            verify          => 1,
            verify_peername => "https",
            ca_file         => "my-ca-cert.pem",
         },
  
  =item I want to create a TLS/SSL server, how do I do that?
  
  Well, you first need to get a server certificate and key. You have
  three options: a) ask a CA (buy one, use cacert.org etc.) b) create a
  self-signed certificate (cheap. check the search engine of your choice,
  there are many tutorials on the net) or c) make your own CA (tinyca2 is a
  nice program for that purpose).
  
  Then create a file with your private key (in PEM format, see
  L<AnyEvent::TLS>), followed by the certificate (also in PEM format). The
  file should then look like this:
  
     -----BEGIN RSA PRIVATE KEY-----
     ...header data
     ... lots of base64'y-stuff
     -----END RSA PRIVATE KEY-----
  
     -----BEGIN CERTIFICATE-----
     ... lots of base64'y-stuff
     -----END CERTIFICATE-----
  
  The important bits are the "PRIVATE KEY" and "CERTIFICATE" parts.  Then
  specify this file as C<cert_file>:
  
     tcp_server undef, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh       => $fh,
           tls      => "accept",
           tls_ctx  => { cert_file => "my-server-keycert.pem" },
           ...
  
  When you have intermediate CA certificates that your clients might not
  know about, just append them to the C<cert_file>.
  
  =back
  
  =head1 SUBCLASSING AnyEvent::Handle
  
  In many cases, you might want to subclass AnyEvent::Handle.
  
  To make this easier, a given version of AnyEvent::Handle uses these
  conventions:
  
  =over 4
  
  =item * all constructor arguments become object members.
  
  At least initially, when you pass a C<tls>-argument to the constructor it
  will end up in C<< $handle->{tls} >>. Those members might be changed or
  mutated later on (for example C<tls> will hold the TLS connection object).
  
  =item * other object member names are prefixed with an C<_>.
  
  All object members not explicitly documented (internal use) are prefixed
  with an underscore character, so the remaining non-C<_>-namespace is free
  for use for subclasses.
  
  =item * all members not documented here and not prefixed with an underscore
  are free to use in subclasses.
  
  Of course, new versions of AnyEvent::Handle may introduce more "public"
  member variables, but that's just life. At least it is documented.
  
  =back
  
  =head1 AUTHOR
  
  Robin Redeker C<< <elmex at ta-sa.org> >>, Marc Lehmann <schmorp@schmorp.de>.
  
  =cut
  
  1
  
ANYEVENT_HANDLE

$fatpacked{"AnyEvent/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO';
  =head1 NAME
  
  AnyEvent::IO - the DBI of asynchronous I/O implementations
  
  =head1 SYNOPSIS
  
     use AnyEvent::IO;
  
     # load /etc/passwd, call callback with the file data when done.
     aio_load "/etc/passwd", sub {
        my ($data) = @_
           or return AE::log error => "/etc/passwd: $!";
  
        warn "/etc/passwd contains ", ($data =~ y/://) , " colons.\n";
     };
  
     # the rest of the SYNOPSIS does the same, but with individual I/O calls
  
     # also import O_XXX flags
     use AnyEvent::IO qw(:DEFAULT :flags);
  
     my $filedata = AE::cv;
  
     # first open the file
     aio_open "/etc/passwd", O_RDONLY, 0, sub {
        my ($fh) = @_
           or return AE::log error => "/etc/passwd: $!";
  
        # now stat the file to get the size
        aio_stat $fh, sub {
           @_
              or return AE::log error => "/etc/passwd: $!";
  
           my $size = -s _;
  
           # now read all the file data
           aio_read $fh, $size, sub {
              my ($data) = @_
                 or return AE::log error => "/etc/passwd: $!";
  
              $size == length $data
                 or return AE::log error => "/etc/passwd: short read, file changed?";
  
              # mostly the same as aio_load, above - $data contains
              # the file contents now.
              $filedata->($data);
           };
        };
     };
  
     my $passwd = $filedata->recv;
     warn length $passwd, " octets.\n";
  
  =head1 DESCRIPTION
  
  This module provides functions that do I/O in an asynchronous fashion. It
  is to I/O the same as L<AnyEvent> is to event libraries - it only
  I<interfaces> to other implementations or to a portable pure-perl
  implementation (which does not, however, do asynchronous I/O).
  
  The only other implementation that is supported (or even known to the
  author) is L<IO::AIO>, which is used automatically when it can be loaded
  (via L<AnyEvent::AIO>, which also needs to be installed). If it is not
  available, then L<AnyEvent::IO> falls back to its synchronous pure-perl
  implementation.
  
  Unlike L<AnyEvent>, which model to use is currently decided at module load
  time, not at first use. Future releases might change this.
  
  =head2 RATIONALE
  
  While disk I/O often seems "instant" compared to, say, socket I/O, there
  are many situations where your program can block for extended time periods
  when doing disk I/O. For example, you access a disk on an NFS server and
  it is gone - can take ages to respond again, if ever. Or your system is
  extremely busy because it creates or restores a backup - reading data from
  disk can then take seconds. Or you use Linux, which for so many years has
  a close-to-broken VM/IO subsystem that can often induce minutes or more of
  delay for disk I/O, even under what I would consider light I/O loads.
  
  Whatever the situation, some programs just can't afford to block for long
  times (say, half a second or more), because they need to respond as fast
  as possible.
  
  For those cases, you need asynchronous I/O.
  
  The problem is, AnyEvent itself sometimes reads disk files (for example,
  when looking at F</etc/hosts>), and under the above situations, this can
  bring your program to a complete halt even if your program otherwise
  takes care to only use asynchronous I/O for everything (e.g. by using
  L<IO::AIO>).
  
  On the other hand, requiring L<IO::AIO> for AnyEvent is clearly
  impossible, as AnyEvent promises to stay pure-perl, and the overhead of
  IO::AIO for small programs would be immense, especially when asynchronous
  I/O isn't even needed.
  
  Clearly, this calls for an abstraction layer, and that is what you are
  looking at right now :-)
  
  =head2 ASYNCHRONOUS VS. NON-BLOCKING
  
  Many people are continuously confused on what the difference is between
  asynchronous I/O and non-blocking I/O. In fact, those two terms are
  not well defined, which often makes it hard to even talk about the
  difference. Here is a short guideline that should leave you less
  confused. It only talks about read operations, but the reasoning works
  with other I/O operations as well.
  
  Non-blocking I/O means that data is delivered by some external means,
  automatically - that is, something I<pushes> data towards your file
  handle, without you having to do anything. Non-blocking means that if
  your operating system currently has no data (or EOF, or some error)
  available for you, it will not wait ("block") as it would normally do,
  but immediately return with an error (e.g. C<EWOULDBLOCK> - "I would have
  blocked, but you forbid it").
  
  Your program can then wait for data to arrive by other means, for example,
  an I/O watcher which tells you when to re-attempt the read, after which it
  can try to read again, and so on.
  
  Often, you would expect this to work for disk files as well - if the data
  isn't already in memory, one might want to wait for it and then re-attempt
  the read for example. While this is sound reasoning, the POSIX API does
  not support this, because disk drives and file systems do not send data
  "on their own", and more so, the OS already knows that data is there, it
  doesn't need to "wait" until it arrives from some external entity, it only
  needs to transfer the data from disk to your memory buffer.
  
  So basically, while the concept is sound, the existing OS APIs do not
  support this. Therefore, it makes no sense to switch a disk file handle
  into non-blocking mode - it will behave exactly the same as in blocking
  mode, namely it will block until the data has been read from the disk.
  
  The alternative to non-blocking I/O that actually works with disk files
  is usually called I<asynchronous I/O>. Asynchronous, because the actual
  I/O is done while your program does something else: there is no need to
  call the read function to see if data is there, you only order the read
  once, and it will notify you when the read has finished and the data is
  your buffer - all the work is done in the background.
  
  This works with disk files, and even with sockets and other sources. It
  is, however, not very efficient when used with sources that could be
  driven in a non-blocking way, because it usually has higher overhead
  in the OS than non-blocking I/O, because it ties memory buffers for a
  potentially unlimited time and often only a limited number of operations
  can be done in parallel.
  
  That's why asynchronous I/O makes most sense when confronted with disk
  files, and non-blocking I/O only makes sense with sockets, pipes and
  similar streaming sources.
  
  =head1 IMPORT TAGS
  
  By default, this module exports all C<aio_>xxx functions. In addition,
  the following import tags can be used:
  
     :aio       all aio_* functions, same as :DEFAULT
     :flags     the fcntl open flags (O_CREAT, O_RDONLY, ...)
  
  =head1 API NOTES
  
  The functions in this module are not meant to be the most versatile or
  the highest-performers (they are not very slow either, of course). They
  are primarily meant to give users of your code the option to do the I/O
  asynchronously (by installing L<IO::AIO> and L<AnyEvent::AIO>),
  without adding a dependency on those modules.
  
  =head2 NAMING
  
  All the functions in this module implement an I/O operation, usually with
  the same or similar name as the Perl built-in that they mimic, but with
  an C<aio_> prefix. If you like you can think of the C<aio_>xxx functions as
  "AnyEvent I/O" or "Asynchronous I/O" variants of Perl built-ins.
  
  =head2 CALLING CONVENTIONS AND ERROR REPORTING
  
  Each function expects a callback as their last argument. The callback is
  usually called with the result data or result code. An error is usually
  signalled by passing no arguments to the callback, which is then free to
  look at C<$!> for the error code.
  
  This makes all of the following forms of error checking valid:
  
     aio_open ...., sub {
        my $fh = shift   # scalar assignment - will assign undef on error
           or return AE::log error => "...";
  
        my ($fh) = @_    # list assignment - will be 0 elements on error
           or return AE::log error => "...";
  
        @_               # check the number of elements directly
           or return AE::log error => "...";
  
  =head2 CAVEAT: RELATIVE PATHS
  
  When a path is specified, this path I<must be an absolute> path, unless
  you make certain that nothing in your process calls C<chdir> or an
  equivalent function while the request executes.
  
  =head2 CAVEAT: OTHER SHARED STATE
  
  Changing the C<umask> while any requests execute that create files (or
  otherwise rely on the current umask) results in undefined behaviour -
  likewise changing anything else that would change the outcome, such as
  your effective user or group ID.
  
  =head2 CALLBACKS MIGHT BE CALLED BEFORE FUNCTION RETURNS TO CALLER
  
  Unlike other functions in the AnyEvent module family, these functions
  I<may> call your callback instantly, before returning. This should not be
  a real problem, as these functions never return anything useful.
  
  =head2 BEHAVIOUR AT PROGRAM EXIT
  
  Both L<AnyEvent::IO::Perl> and L<AnyEvent::IO::IOAIO> implementations
  make sure that operations that have started will be finished on a clean
  programs exit. That makes programs work that start some I/O operations and
  then exit. For example this complete program:
  
     use AnyEvent::IO;
  
     aio_stat "path1", sub {
        aio_stat "path2", sub {
           warn "both stats done\n";
        };
     };
  
  Starts a C<stat> operation and then exits by "falling off the end" of
  the program. Nevertheless, I<both> C<stat> operations will be executed,
  as AnyEvent::IO waits for all outstanding requests to finish and you can
  start new requests from request callbacks.
  
  In fact, since L<AnyEvent::IO::Perl> is currently synchronous, the
  program will do both stats before falling off the end, but with
  L<AnyEvent::IO::IOAIO>, the program first falls of the end, then the stats
  are executed.
  
  While not guaranteed, this behaviour will be present in future versions,
  if reasonably possible (which is extreemly likely :).
  
  =cut
  
  package AnyEvent::IO;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use base "Exporter";
  
  our @AIO_REQ = qw(
     aio_load aio_open aio_close aio_seek aio_read aio_write aio_truncate
     aio_utime aio_chown aio_chmod aio_stat aio_lstat
     aio_link aio_symlink aio_readlink aio_rename aio_unlink
     aio_mkdir aio_rmdir aio_readdir
  );
  *EXPORT = \@AIO_REQ;
  our @FLAGS = qw(O_RDONLY O_WRONLY O_RDWR O_CREAT O_EXCL O_TRUNC O_APPEND);
  *EXPORT_OK = \@FLAGS;
  our %EXPORT_TAGS = (flags => \@FLAGS, aio => \@AIO_REQ);
  
  our $MODEL;
  
  if ($MODEL) {
     AE::log 7 => "Found preloaded IO model '$MODEL', using it.";
  } else {
     if ($ENV{PERL_ANYEVENT_IO_MODEL} =~ /^([a-zA-Z0-9:]+)$/) {
        if (eval { require "AnyEvent/IO/$ENV{PERL_ANYEVENT_IO_MODEL}.pm" }) {
           AE::log 7 => "Loaded IO model '$MODEL' (forced by \$ENV{PERL_ANYEVENT_IO_MODEL}), using it.";
        } else {
           undef $MODEL;
           AE::log 4 => "Unable to load IO model '$ENV{PERL_ANYEVENT_IO_MODEL}' (from \$ENV{PERL_ANYEVENT_IO_MODEL}):\n$@";
        }
     }
  
     unless ($MODEL) {
        if (eval { require IO::AIO; require AnyEvent::AIO; require AnyEvent::IO::IOAIO }) {
           AE::log 7 => "Autoloaded IO model 'IOAIO', using it.";
        } else {
           require AnyEvent::IO::Perl;
           AE::log 7 => "Autoloaded IO model 'Perl', using it.";
        }
     }
  }
  
  =head1 GLOBAL VARIABLES AND FUNCTIONS
  
  =over 4
  
  =item $AnyEvent::IO::MODEL
  
  Contains the package name of the backend I/O model in use - at the moment,
  this is usually C<AnyEvent::IO::Perl> or C<AnyEvent::IO::IOAIO>.
  
  =item aio_load $path, $cb->($data)
  
  Tries to open C<$path> and read its contents into memory (obviously,
  should only be used on files that are "small enough"), then passes them to
  the callback as a string.
  
  Example: load F</etc/hosts>.
  
     aio_load "/etc/hosts", sub {
        my ($hosts) = @_
           or return AE::log error => "/etc/hosts: $!";
  
        AE::log info => "/etc/hosts contains ", ($hosts =~ y/\n/), " lines\n";
     };
  
  =item aio_open $path, $flags, $mode, $cb->($fh)
  
  Tries to open the file specified by C<$path> with the O_XXX-flags
  C<$flags> (from the Fcntl module, or see below) and the mode C<$mode> (a
  good value is 0666 for C<O_CREAT>, and C<0> otherwise).
  
  The (normal, standard, perl) file handle associated with the opened file
  is then passed to the callback.
  
  This works very much like Perl's C<sysopen> function.
  
  Changing the C<umask> while this request executes results in undefined
  behaviour - likewise changing anything else that would change the outcome,
  such as your effective user or group ID.
  
  To avoid having to load L<Fcntl>, this module provides constants
  for C<O_RDONLY>, C<O_WRONLY>, C<O_RDWR>, C<O_CREAT>, C<O_EXCL>,
  C<O_TRUNC> and C<O_APPEND> - you can either access them directly
  (C<AnyEvent::IO::O_RDONLY>) or import them by specifying the C<:flags>
  import tag (see SYNOPSIS).
  
  Example: securely open a file in F</var/tmp>, fail if it exists or is a symlink.
  
     use AnyEvent::IO qw(:flags);
  
     aio_open "/var/tmp/mytmp$$", O_CREAT | O_EXCL | O_RDWR, 0600, sub {
        my ($fh) = @_
           or return AE::log error => "$! - denial of service attack?";
  
        # now we have $fh
     };
  
  =item aio_close $fh, $cb->($success)
  
  Closes the file handle (yes, close can block your process indefinitely)
  and passes a true value to the callback on success.
  
  Due to idiosyncrasies in perl, instead of calling C<close>, the file
  handle might get closed by C<dup2>'ing another file descriptor over
  it, that is, the C<$fh> might still be open, but can be closed safely
  afterwards and must not be used for anything.
  
  Example: close a file handle, and dirty as we are, do not even bother
  to check for errors.
  
     aio_close $fh, sub { };
  
  =item aio_read $fh, $length, $cb->($data)
  
  Tries to read C<$length> octets from the current position from C<$fh> and
  passes these bytes to C<$cb>. Otherwise the semantics are very much like
  those of Perl's C<sysread>.
  
  If less than C<$length> octets have been read, C<$data> will contain
  only those bytes actually read. At EOF, C<$data> will be a zero-length
  string. If an error occurs, then nothing is passed to the callback.
  
  Obviously, multiple C<aio_read>'s or C<aio_write>'s at the same time on file
  handles sharing the underlying open file description results in undefined
  behaviour, due to sharing of the current file offset (and less obviously
  so, because OS X is not thread safe and corrupts data when you try).
  
  Example: read 128 octets from a file.
  
     aio_read $fh, 128, sub {
        my ($data) = @_
           or return AE::log error "read from fh: $!";
    
        if (length $data) {
           print "read ", length $data, " octets.\n";
        } else {
           print "EOF\n";
        }
     };
  
  =item aio_seek $fh, $offset, $whence, $callback->($offs)
  
  Seeks the filehandle to the new C<$offset>, similarly to Perl's
  C<sysseek>. The C<$whence> are the traditional values (C<0> to count from
  start, C<1> to count from the current position and C<2> to count from the
  end).
  
  The resulting absolute offset will be passed to the callback on success.
  
  Example: measure the size of the file in the old-fashioned way using seek.
  
     aio_seek $fh, 0, 2, sub {
        my ($size) = @_
           or return AE::log error => "seek to end failed: $!";
  
        # maybe we need to seek to the beginning again?
        aio_seek $fh, 0, 0, sub {
           # now we are hopefully at the beginning
        };
     };
  
  =item aio_write $fh, $data, $cb->($length)
  
  Tries to write the octets in C<$data> to the current position of C<$fh>
  and passes the actual number of bytes written to the C<$cb>. Otherwise the
  semantics are very much like those of Perl's C<syswrite>.
  
  If less than C<length $data> octets have been written, C<$length> will
  reflect that. If an error occurs, then nothing is passed to the callback.
  
  Obviously, multiple C<aio_read>'s or C<aio_write>'s at the same time on file
  handles sharing the underlying open file description results in undefined
  behaviour, due to sharing of the current file offset (and less obviously
  so, because OS X is not thread safe and corrupts data when you try).
  
  =item aio_truncate $fh_or_path, $new_length, $cb->($success)
  
  Calls C<truncate> on the path or perl file handle and passes a true value
  to the callback on success.
  
  Example: truncate F</etc/passwd> to zero length - this only works on
  systems that support C<truncate>, should not be tried out for obvious
  reasons and debian will probably open yte another security bug about this
  example.
  
     aio_truncate "/etc/passwd", sub {
        @_
           or return AE::log error => "/etc/passwd: $! - are you root enough?";
     };
  
  =item aio_utime $fh_or_path, $atime, $mtime, $cb->($success)
  
  Calls C<utime> on the path or perl file handle and passes a true value to
  the callback on success.
  
  The special case of both C<$atime> and C<$mtime> being C<undef> sets the
  times to the current time, on systems that support this.
  
  Example: try to touch F<file>.
  
     aio_utime "file", undef, undef, sub { };
  
  =item aio_chown $fh_or_path, $uid, $gid, $cb->($success)
  
  Calls C<chown> on the path or perl file handle and passes a true value to
  the callback on success.
  
  If C<$uid> or C<$gid> can be specified as C<undef>, in which case the
  uid or gid of the file is not changed. This differs from Perl's C<chown>
  built-in, which wants C<-1> for this.
  
  Example: update the group of F<file> to 0 (root), but leave the owner alone.
  
     aio_chown "file", undef, 0, sub {
        @_
           or return AE::log error => "chown 'file': $!";
     };
  
  =item aio_chmod $fh_or_path, $perms, $cb->($success)
  
  Calls C<chmod> on the path or perl file handle and passes a true value to
  the callback on success.
  
  Example: change F<file> to be user/group/world-readable, but leave the other flags
  alone.
  
     aio_stat "file", sub {
        @_
           or return AE::log error => "file: $!";
  
        aio_chmod "file", (stat _)[2] & 07777 | 00444, sub { };
     };
  
  =item aio_stat $fh_or_path, $cb->($success)
  
  =item aio_lstat $path, $cb->($success)
  
  Calls C<stat> or C<lstat> on the path or perl file handle and passes a
  true value to the callback on success.
  
  The stat data will be available by C<stat>'ing the C<_> file handle
  (e.g. C<-x _>, C<stat _> and so on).
  
  Example: see if we can find the number of subdirectories of F</etc>.
  
     aio_stat "/etc", sub {
        @_
           or return AE::log error => "/etc: $!";
  
        (stat _)[3] >= 2
           or return AE::log warn => "/etc has low link count - non-POSIX filesystem?";
  
        print "/etc has ", (stat _)[3] - 2, " subdirectories.\n";
     };
  
  =item aio_link $oldpath, $newpath, $cb->($success)
  
  Calls C<link> on the paths and passes a true value to the callback on
  success.
  
  Example: link "F<file> to F<file.bak>, then rename F<file.new> over F<file>,
  to atomically replace it.
  
     aio_link "file", "file.bak", sub {
        @_
           or return AE::log error => "file: $!";
  
        aio_rename "file.new", "file", sub {
           @_
              or return AE::log error => "file.new: $!";
  
           print "file atomically replaced by file.new, backup file.bak\n";
        };
     };
  
  =item aio_symlink $oldpath, $newpath, $cb->($success)
  
  Calls C<symlink> on the paths and passes a true value to the callback on
  success.
  
  Example: create a symlink "F<slink> containing "random data".
  
     aio_symlink "random data", "slink", sub {
        @_
           or return AE::log error => "slink: $!";
     };
  
  =item aio_readlink $path, $cb->($target)
  
  Calls C<readlink> on the paths and passes the link target string to the
  callback.
  
  Example: read the symlink called Fyslink> and verify that it contains "random data".
  
    aio_readlink "slink", sub {
       my ($target) = @_
          or return AE::log error => "slink: $!";
  
       $target eq "random data"
          or AE::log critical => "omg, the world will end!";
    };
  
  =item aio_rename $oldpath, $newpath, $cb->($success)
  
  Calls C<rename> on the paths and passes a true value to the callback on
  success.
  
  See C<aio_link> for an example.
  
  =item aio_unlink $path, $cb->($success)
  
  Tries to unlink the object at C<$path> and passes a true value to the
  callback on success.
  
  Example: try to delete the file F<tmpfile.dat~>.
  
     aio_unlink "tmpfile.dat~", sub { };
  
  =item aio_mkdir $path, $perms, $cb->($success)
  
  Calls C<mkdir> on the path with the given permissions C<$perms> (when in
  doubt, C<0777> is a good value) and passes a true value to the callback on
  success.
  
  Example: try to create the directory F<subdir> and leave it to whoeveer
  comes after us to check whether it worked.
  
     aio_mkdir "subdir", 0777, sub { };
  
  =item aio_rmdir $path, $cb->($success)
  
  Tries to remove the directory at C<$path> and passes a true value to the
  callback on success.
  
  Example: try to remove the directory F<subdir> and don't give a damn if
  that fails.
  
     aio_rmdir "subdir", sub { };
  
  =item aio_readdir $path, $cb->(\@names)
  
  Reads all filenames from the directory specified by C<$path> and passes
  them to the callback, as an array reference with the names (without a path
  prefix). The F<.> and F<..> names will be filtered out first.
  
  The ordering of the file names is undefined - backends that are capable
  of it (e.g. L<IO::AIO>) will return the ordering that most likely is
  fastest to C<stat> through, and furthermore put entries that likely are
  directories first in the array.
  
  If you need best performance in recursive directory traversal or when
  looking at really big directories, you are advised to use L<IO::AIO>
  directly, specifically the C<aio_readdirx> and C<aio_scandir> functions,
  which have more options to tune performance.
  
  Example: recursively scan a directory hierarchy, silently skip diretcories
  we couldn't read and print all others.
  
     sub scan($); # visibility-in-next statement is not so useful these days
     sub scan($) {
        my ($path) = @_;
  
        aio_readdir $path, sub {
           my ($names) = @_
              or return;
  
           print "$path\n";
  
           for my $name (@$names) {
              aio_lstat "$path/$name", sub {
                 scan "$path/$name"
                    if -d _;
              };
           }
        };
     }
  
     scan "/etc";
  
  =back
  
  =head1 ENVIRONMENT VARIABLES
  
  See the description of C<PERL_ANYEVENT_IO_MODEL> in the L<AnyEvent>
  manpage.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IO

$fatpacked{"AnyEvent/IO/IOAIO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO_IOAIO';
  =head1 NAME
  
  AnyEvent::IO::IOAIO - AnyEvent::IO backend based on IO::AIO
  
  =head1 SYNOPSIS
  
     use AnyEvent::IO;
  
  =head1 DESCRIPTION
  
  This is the L<IO::AIO>-based backend of L<AnyEvent::IO> (via
  L<AnyEvent::AIO>). All I/O operations it implements are done
  asynchronously.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =cut
  
  package AnyEvent::IO::IOAIO;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  our $VERSION = $AnyEvent::VERSION;
  
  package AnyEvent::IO;
  
  use IO::AIO 4.13 ();
  use AnyEvent::AIO ();
  
  our $MODEL = "AnyEvent::IO::IOAIO";
  
  sub aio_load($$) {
     my ($cb, $data) = $_[1];
     IO::AIO::aio_load $_[0], $data,                  sub { $cb->($_[0] >= 0 ? $data : ()) };
  }
  
  sub aio_open($$$$) {
     my $cb = $_[3];
     IO::AIO::aio_open $_[0], $_[1], $_[2],           sub { $cb->($_[0] or ()) };
  }
  
  sub aio_close($$) {
     my $cb = $_[1];
     IO::AIO::aio_close $_[0],                        sub { $cb->($_[0] >= 0 ? 1 : ()) };
  }
  
  sub aio_seek($$$$) {
     my ($cb) = $_[3];
     IO::AIO::aio_seek $_[0], $_[1], $_[2],           sub { $cb->($_[0] >= 0 ? $_[0] : ()) };
  }
  
  sub aio_read($$$) {
     my ($cb, $data) = $_[2];
     IO::AIO::aio_read $_[0], undef, $_[1], $data, 0, sub { $cb->($_[0] >= 0 ? $data : ()) };
  }
  
  sub aio_write($$$) {
     my $cb = $_[2];
     IO::AIO::aio_write $_[0], undef, (length $_[1]), $_[1], 0,
                                                      sub { $cb->($_[0] >= 0 ? $_[0] : ()) };
  }
  
  sub aio_truncate($$$) {
     my $cb = $_[2];
     IO::AIO::aio_truncate $_[0], $_[1],              sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_utime($$$$) {
     my $cb = $_[3];
     IO::AIO::aio_utime $_[0], $_[1], $_[2],          sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_chown($$$$) {
     my $cb = $_[3];
     IO::AIO::aio_chown $_[0], $_[1], $_[2],          sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_chmod($$$) {
     my $cb = $_[2];
     IO::AIO::aio_chmod $_[0], $_[1],                 sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_stat($$) {
     my $cb = $_[1];
     IO::AIO::aio_stat $_[0],                         sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_lstat($$) {
     my $cb = $_[1];
     IO::AIO::aio_lstat $_[0],                        sub { $cb->($_[0] ? () : 1) }
  }
  
  sub aio_link($$$) {
     my $cb = $_[2];
     IO::AIO::aio_link $_[0], $_[1],                  sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_symlink($$$) {
     my $cb = $_[2];
     IO::AIO::aio_symlink $_[0], $_[1],               sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_readlink($$) {
     my $cb = $_[1];
     IO::AIO::aio_readlink $_[0],                     sub { $cb->(defined $_[0] ? $_[0] : ()) };
  }
  
  sub aio_rename($$$) {
     my $cb = $_[2];
     IO::AIO::aio_rename $_[0], $_[1],                sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_unlink($$) {
     my $cb = $_[1];
     IO::AIO::aio_unlink $_[0],                       sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_mkdir($$$) {
     my $cb = $_[2];
     IO::AIO::aio_mkdir $_[0], $_[1],                 sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_rmdir($$) {
     my $cb = $_[1];
     IO::AIO::aio_rmdir $_[0],                        sub { $cb->($_[0] ? () : 1) };
  }
  
  sub aio_readdir($$) {
     my $cb = $_[1];
  
     IO::AIO::aio_readdirx $_[0], IO::AIO::READDIR_DIRS_FIRST | IO::AIO::READDIR_STAT_ORDER,
                                                      sub { $cb->($_[0] or ()); };
  }
  
  =back
  
  =head1 SEE ALSO
  
  L<AnyEvent::IO>, L<AnyEvent>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IO_IOAIO

$fatpacked{"AnyEvent/IO/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO_PERL';
  =head1 NAME
  
  AnyEvent::IO::Perl - pure perl backend for AnyEvent::IO
  
  =head1 SYNOPSIS
  
     use AnyEvent::IO;
  
  =head1 DESCRIPTION
  
  This is the pure-perl backend of L<AnyEvent::IO> - it is always available,
  but does not actually implement any I/O operation asynchronously -
  everything is synchronous.
  
  For simple programs that can wait for I/O, this is likely the most
  efficient implementation.
  
  =cut
  
  package AnyEvent::IO::Perl;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  our $VERSION = $AnyEvent::VERSION;
  
  package AnyEvent::IO;
  
  our $MODEL = "AnyEvent::IO::Perl";
  
  sub aio_load($$) {
     my ($path, $cb, $fh, $data) = @_;
  
     $cb->(
        (open $fh, "<:raw:perlio", $path
           and stat $fh
           and (-s _) == sysread $fh, $data, -s _)
        ? $data : ()
     );
  }
  
  sub aio_open($$$$) {
     sysopen my $fh, $_[0], $_[1], $_[2]
        or return $_[3]();
  
     $_[3]($fh)
  }
  
  sub aio_close($$) {
     $_[1](close $_[0]);
  }
  
  sub aio_seek($$$$) {
     my $data;
     $_[3](sysseek $_[0], $_[1], $_[2] or ());
  }
  
  sub aio_read($$$) {
     my $data;
     $_[2]( (defined sysread $_[0], $data, $_[1]) ? $data : () );
  }
  
  sub aio_write($$$) {
     my $res = syswrite $_[0], $_[1];
     $_[2](defined $res ? $res : ());
  }
  
  sub aio_truncate($$$) {
     #TODO: raises an exception on !truncate|ftruncate systems, maybe eval + set errno?
     $_[2](truncate $_[0], $_[1] or ());
  }
  
  sub aio_utime($$$$) {
     $_[3](utime $_[1], $_[2], $_[0] or ());
  }
  
  sub aio_chown($$$$) {
     $_[3](chown defined $_[1] ? $_[1] : -1, defined $_[2] ? $_[2] : -1, $_[0] or ());
  }
  
  sub aio_chmod($$$) {
     $_[2](chmod $_[1], $_[0] or ());
  }
  
  sub aio_stat($$) {
     $_[1](stat  $_[0]);
  }
  
  sub aio_lstat($$) {
     $_[1](lstat $_[0]);
  }
  
  sub aio_link($$$) {
     $_[2](link $_[0], $_[1] or ());
  }
  
  sub aio_symlink($$$) {
     #TODO: raises an exception on !symlink systems, maybe eval + set errno?
     $_[2](symlink $_[0], $_[1] or ());
  }
  
  sub aio_readlink($$) {
     #TODO: raises an exception on !symlink systems, maybe eval + set errno?
     my $res = readlink $_[0];
     $_[1](defined $res ? $res : ());
  }
  
  sub aio_rename($$$) {
     $_[2](rename $_[0], $_[1] or ());
  }
  
  sub aio_unlink($$) {
     $_[1](unlink $_[0] or ());
  }
  
  sub aio_mkdir($$$) {
     $_[2](mkdir $_[0], $_[1] or ());
  }
  
  sub aio_rmdir($$) {
     $_[1](rmdir $_[0] or ());
  }
  
  sub aio_readdir($$) {
     my ($fh, @res);
  
     opendir $fh, $_[0]
        or return $_[1]();
  
     @res = grep !/^\.\.?$/, readdir $fh;
  
     $_[1]((closedir $fh) ? \@res : ());
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent::IO>, L<AnyEvent>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IO_PERL

$fatpacked{"AnyEvent/Impl/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_COCOA';
  =head1 NAME
  
  AnyEvent::Impl::Cocoa - AnyEvent adaptor for Cocoa::EventLoop
  
  =head1 SYNOPSIS
  
      use AnyEvent;
      use Cocoa::EventLoop;
      
      # do something
  
  =head1 DESCRIPTION
  
  This module provides NSRunLoop support to AnyEvent.
  
  NSRunLoop is an event loop for Cocoa applications, wrapped by
  L<Cocoa::EventLoop>. By using this module, you can use Cocoa based API in
  your AnyEvent application, or AnyEvent within Cocoa applications.
  
  It does not support blocking waits.
  
  =head1 BUGS
  
  Right now, L<Cocoa::EventLoop> (and this module) are in an early
  development phase and has some shortcomings and likely bugs.
  
  For example, there seems to be no way to just handle a single event
  with Cocoa (is there nothing they can implement properly?), so this
  module currently wakes up at least ten times a second when waiting for
  events. Also, events caused by timers might get delayed by up to 0.1
  seconds.
  
  =cut
  
  package AnyEvent::Impl::Cocoa;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Cocoa::EventLoop;
  
  sub io {
     my ($class, %arg) = @_;
  
     Cocoa::EventLoop->io (%arg)
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     Cocoa::EventLoop->timer (%arg)
  }
  
  # does not support blocking waits
  
  #sub loop {
  #   Cocoa::EventLoop->run;
  #}
  
  =head1 AUTHORS
  
  Daisuke Murase <typester@cpan.org>, Marc Lehmann <schmorp@schmorp.de>.
  
  =head1 COPYRIGHTS
  
     Copyright (c) 2009 by KAYAC Inc.
     Copyright (c) 2010,2011 by Marc Lehmann <schmorp@schmorp.de>
  
  =cut
  
  1
  
ANYEVENT_IMPL_COCOA

$fatpacked{"AnyEvent/Impl/EV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EV';
  =head1 NAME
  
  AnyEvent::Impl::EV - AnyEvent adaptor for EV
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use EV;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make EV work with AnyEvent except by loading EV before
  creating the first AnyEvent watcher.
  
  EV is the fastest event library for perl, and best supported by
  AnyEvent. Most functions from the L<AE> API are implemented as direct
  aliases to EV functions, so using EV via AE is as fast as using EV
  directly.
  
  =cut
  
  package AnyEvent::Impl::EV;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use EV 4.00;
  
  *AE::time       = \&EV::time;
  *AE::now        = \&EV::now;
  *AE::now_update = \&EV::now_update;
  *AE::timer      = \&EV::timer;
  *AE::signal     = \&EV::signal;
  *AE::idle       = \&EV::idle;
  
  # cannot override directly, as EV doesn't allow arguments
  sub time       { EV::time       }
  sub now        { EV::now        }
  sub now_update { EV::now_update }
  
  *AE::io = defined &EV::_ae_io # 3.8+, but keep just in case it is dropped
     ? \&EV::_ae_io
     : sub($$$) { EV::io $_[0], $_[1] ? EV::WRITE : EV::READ, $_[2] };
  
  sub timer {
     my ($class, %arg) = @_;
  
     EV::timer $arg{after}, $arg{interval}, $arg{cb}
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     EV::io
        $arg{fh},
        $arg{poll} eq "r" ? EV::READ : EV::WRITE,
        $arg{cb}
  }
  
  sub signal {
     my ($class, %arg) = @_;
  
     EV::signal $arg{signal}, $arg{cb}
  }
  
  sub child {
     my ($class, %arg) = @_;
  
     my $cb = $arg{cb};
  
     EV::child $arg{pid}, 0, sub {
        $cb->($_[0]->rpid, $_[0]->rstatus);
     }
  }
  
  sub idle {
     my ($class, %arg) = @_;
  
     EV::idle $arg{cb}
  }
  
  sub _poll {
     EV::run EV::RUN_ONCE;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     EV::run EV::RUN_ONCE until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   EV::run;
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<EV>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_EV

$fatpacked{"AnyEvent/Impl/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EVENT';
  =head1 NAME
  
  AnyEvent::Impl::Event - AnyEvent adaptor for Event
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Event;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Event work with AnyEvent except by loading Event before
  creating the first AnyEvent watcher.
  
  The event module is reasonably efficient and generally works correctly
  even with many watchers, except that its signal handling is inherently
  racy and requires the wake-up-frequently workaround.
  
  =cut
  
  package AnyEvent::Impl::Event;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Event qw(unloop); # we have to import something to make Event use Time::HiRes
  
  sub io {
     my (undef, %arg) = @_;
     $arg{fd} = delete $arg{fh};
     $arg{poll} .= "e" if AnyEvent::WIN32; # work around windows connect bug
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \(Event->io (%arg)), __PACKAGE__
  }
  
  sub timer {
     my (undef, %arg) = @_;
     $arg{after} = 0 if $arg{after} < 0;
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \Event->timer (%arg, repeat => $arg{interval}), __PACKAGE__
  }
  
  sub idle {
     my (undef, %arg) = @_;
     my $cb = $arg{cb}; $arg{cb} = sub { &$cb }; # event doesn't like callable objects
     bless \Event->idle (repeat => 1, min => 0, %arg), __PACKAGE__
  }
  
  sub DESTROY {
     ${$_[0]}->cancel;
  }
  
  sub signal {
     my (undef, %arg) = @_;
  
     my $cb = $arg{cb};
     my $w = Event->signal (
        signal => AnyEvent::Base::sig2name $arg{signal},
        cb     => sub { &$cb }, # event doesn't like callable objects
     );
  
     AnyEvent::Base::_sig_add;
     bless \$w, "AnyEvent::Impl::Event::signal"
  }
  
  sub AnyEvent::Impl::Event::signal::DESTROY {
     AnyEvent::Base::_sig_del;
     ${$_[0]}->cancel;
  }
  
  sub _poll {
     Event::one_event;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Event::one_event until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   Event::loop;
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Event>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_EVENT

$fatpacked{"AnyEvent/Impl/EventLib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EVENTLIB';
  =head1 NAME
  
  AnyEvent::Impl::EventLib - AnyEvent adaptor for Event::Lib
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Event::Lib;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Event work with AnyEvent except by loading Event::Lib
  before creating the first AnyEvent watcher.
  
  Note: the AnyEvent author has not found recent releases of Event::Lib to
  be even remotely working (not even the examples from the manpage or the
  testsuite work), so this event backend should be avoided (or somebody
  should step up and maintain it, hint, hint).
  
  The L<Event::Lib> module suffers from the same limitations and bugs as
  libevent, most notably it kills already-installed watchers on a file
  descriptor and it is unable to support fork. These are not fatal issues,
  and are worked-around by this module, but the L<Event::Lib> perl module
  itself has many additional bugs such as taking references to file handles
  and callbacks instead of making a copy or freeing still-allocated scalars,
  causing memory corruption and random crashes. Only Tk rivals it in its
  brokenness.
  
  This adaptor module employs the same workaround around the watcher
  problems as Tk and should therefore be avoided. (This was done for
  simplicity, one could in theory work around the problems with lower
  overhead by managing our own watchers).
  
  Event::Lib also leaks file handles and memory and tends to just exit on
  problems.
  
  It also doesn't work around the Windows bug of not signalling TCP
  connection failures.
  
  It also doesn't work with many special devices on Linux (F</dev/random>
  works, F</dev/urandom> fails, F</dev/tty> works, F</dev/null> fails and so
  on).
  
  Event::Lib does not support idle watchers. They could be emulated using
  low-priority timers but as the priority range (and availability) is not
  queryable nor guaranteed, and the default priority is likely the lowest
  one, this module cannot use them.
  
  Avoid Event::Lib if you can.
  
  =cut
  
  package AnyEvent::Impl::EventLib;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Event::Lib;
  
  # Event::Lib doesn't always take a reference to the callback, so closures
  # cause memory corruption and segfaults. it also has an issue actually
  # calling callbacks, so this exists as workaround.
  sub ccb {
     # Event:Lib accesses $_[0] after the callback, when it might be freed,
     # so we keep it referenced until after the callback. This still accesses
     # a freed scalar, but at least it'll not crash.
     my $keep_it = $_[0];
  
     $_[2]();
  }
  
  my $ccb = \&ccb;
  
  sub io {
     my (undef, %arg) = @_;
  
     # work around these bugs in Event::Lib:
     # - adding a callback might destroy other callbacks
     # - only one callback per fd/poll combination
     my ($fh, $mode) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, EV_READ, EV_WRITE;
  
     # event_new errornously takes a reference to fh and cb instead of making a copy
     # fortunately, going through %arg/_dupfh already makes a copy, so it happpens to work
     my $w = event_new $fh, $mode | EV_PERSIST, $ccb, $arg{cb};
     event_add $w;
     bless \\$w, __PACKAGE__
  }
  
  sub timer {
     my (undef, %arg) = @_;
  
     my $ival = $arg{interval};
     my $cb   = $arg{cb};
  
     my $w; $w = timer_new $ccb,
                    $ival
                       ? sub { event_add $w, $ival; &$cb }
                       : sub { undef $w           ; &$cb };
  
     event_add $w, $arg{after} || 1e-10; # work around 0-bug in Event::Lib
  
     bless \\$w, __PACKAGE__
  }
  
  sub DESTROY {
     local $@;
     ${${$_[0]}}->remove;
  }
  
  sub signal {
     my (undef, %arg) = @_;
  
     my $w = signal_new AnyEvent::Base::sig2num $arg{signal}, $ccb, $arg{cb};
     event_add $w;
     AnyEvent::Base::_sig_add;
     bless \\$w, "AnyEvent::Impl::EventLib::signal"
  }
  
  sub AnyEvent::Impl::EventLib::signal::DESTROY {
     AnyEvent::Base::_sig_del;
     local $@;
     ${${$_[0]}}->remove;
  }
  
  #sub loop {
  #   event_mainloop;
  #}
  
  sub _poll {
     event_one_loop;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     event_one_loop until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Event::Lib>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_EVENTLIB

$fatpacked{"AnyEvent/Impl/FLTK.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_FLTK';
  =head1 NAME
  
  AnyEvent::Impl::FLTK - AnyEvent adaptor for FLTK (Fast Light Toolkit version two)
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use FLTK;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make FLTK work with AnyEvent except by loading FLTK before
  creating the first AnyEvent watcher.
  
  This implementation is not to be confused with AnyEvent::Impl::FLTK by
  Sanko Robinson. That implementation is completely broken, and the author
  is apparently unreachable.
  
  In any case, FLTK suffers from typical GUI-ToolKit diseases, such as O(n)
  or worse for every operation (adding a timer, destroying a timer etc.),
  the typical Not-Well-Tested Perl Interface disases such as non-random
  memory corruption and the typical Event-Loop-as-an-Afterthrough issues,
  such as multiple watchers on the same fd silently overwriting the others.
  
  It doesn't have native idle, signal or child watchers, so all of these are
  emulated.
  
  =cut
  
  package AnyEvent::Impl::FLTK;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use FLTK 0.532 ();
  use Scalar::Util ();
  
  #*AE::timer      = \&EV::timer;
  #*AE::signal     = \&EV::signal;
  #*AE::idle       = \&EV::idle;
  
  # FLTK::get_time_secs returns a glob :/
  # on unix, fltk uses gettimeofday, so we are likely compatible
  # on windows, fltk uses GetTickCount, to which we are unlikely to be compatible with.
  #sub time { FLTK::get_time_secs }
  #*now = \&time;
  
  sub timer_interval_cb {
     my $id = shift; # add_timeout kills @_, so we have to make a copy :(
     $id->[0] = FLTK::add_timeout $id->[1], \&timer_interval_cb, $id;
     &{ $id->[2] }
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     my $cb = $arg{cb};
  
     if ($arg{interval}) {
        my $id = [undef, $arg{interval}, $cb];
  
        $id->[0] = FLTK::add_timeout $arg{after}, \&timer_interval_cb, $id;
  
        return bless $id, "AnyEvent::Impl::FLTK::timer"
     } else {
        # non-repeating timers can be done very efficiently
        # also, FLTK doesn't like callable objects
        return FLTK::add_timeout $arg{after}, sub { &$cb }
     }
  }
  
  sub AnyEvent::Impl::FLTK::timer::DESTROY {
     undef $_[0][0];
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     # only one watcher/fd :(
  
     my $cb = $arg{cb};
     my ($fh, $ev) = AnyEvent::_dupfh $arg{poll}, $arg{fh},
        FLTK::READ,
        FLTK::WRITE | (AnyEvent::WIN32 ? FLTK::EXCEPT : 0);
  
     # fltk hardcodes poll constants and aliases EXCEPT with POLLERR,
     # which is grossly wrong, but likely it doesn't use poll on windows.
     FLTK::add_fd $fh, $ev, sub { &$cb }
  }
  
  # use signal and child emulation - fltk has no facilities for that
  
  # fltk idle watchers are like EV::check watchers, and fltk check watchers
  # are like EV::prepare watchers. both are called when the loop is busy,
  # so we have to use idle watcher emulation.
  
  sub _poll {
     FLTK::wait;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     FLTK::wait until exists $_[0]{_ae_sent};
  }
  
  #sub loop {
  #   FLTK::run;
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<FLTK>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_FLTK

$fatpacked{"AnyEvent/Impl/Glib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_GLIB';
  =head1 NAME
  
  AnyEvent::Impl::Glib - AnyEvent adaptor for Glib
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Glib;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Glib work with AnyEvent except by loading Glib before
  creating the first AnyEvent watcher.
  
  Glib is probably the most inefficient event loop that has ever seen the
  light of the world: Glib not only scans all its watchers (really, ALL of
  them, whether I/O-related, timer-related or what not) during each loop
  iteration, it also does so multiple times and rebuilds the poll list for
  the kernel each time again, dynamically even. Newer versions of libglib
  fortunately do not call malloc/free on every single watcher invocation,
  though.
  
  Glib also enforces certain undocumented behaviours, for example, you
  cannot always remove active child watchers, and the conditions on when
  it is valid to do so are not documented. Of course, if you get it wrong,
  you get "GLib-CRITICAL" messages. This makes it extremely hard to write
  "correct" glib programs, as you have to study the source code to get it
  right, and hope future versions don't change any internals.
  
  AnyEvent implements the necessary workarounds, at a small performance
  cost.
  
  On the positive side, and most importantly, when it works, Glib generally
  works correctly, no quarrels there.
  
  If you create many watchers (as in: more than two), you might consider one
  of the L<Glib::EV>, L<EV::Glib> or L<Glib::Event> modules that map Glib to
  other, more efficient, event loops.
  
  This module uses the default Glib main context for all its watchers.
  
  =cut
  
  package AnyEvent::Impl::Glib;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Glib 1.210 (); # (stable 1.220 2009, also Glib 2.4+ required, 2004)
  
  our $mainloop = Glib::MainContext->default;
  
  my %io_cond = (
     r => ["in" , "hup"],
     w => ["out", "hup"],
  );
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = add_watch Glib::IO
        $fd,
        $io_cond{$arg{poll}},
        sub { &$cb; 1 };
  
     bless \\$source, $class
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb   = $arg{cb};
     my $ival = $arg{interval} * 1000;
  
     my $source; $source = add Glib::Timeout $arg{after} < 0 ? 0 : $arg{after} * 1000,
        $ival ? sub {
                  remove Glib::Source $source;
                  $source = add Glib::Timeout $ival, sub { &$cb; 1 };
                  &$cb;
                  1 # already removed, should be a nop
                }
              : sub {
                 # due to the braindamaged libglib API (it manages
                 # removed-but-active watchers internally, but forces
                 # users to # manage the same externally as well),
                 # we have to go through these contortions.
                 remove Glib::Source $source;
                 undef $source;
                 &$cb;
                 1 # already removed, should be a nop
              };
  
     bless \\$source, $class
  }
  
  sub idle {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $source = add Glib::Idle sub { &$cb; 1 };
  
     bless \\$source, $class
  }
  
  sub DESTROY {
     remove Glib::Source $${$_[0]}
        if defined $${$_[0]};
  }
  
  our %pid_w;
  our %pid_cb;
  
  sub child {
     my ($class, %arg) = @_;
  
     $arg{pid} > 0
        or Carp::croak "Glib does not support watching for all pids (pid == 0) as attempted";
  
     my $pid = $arg{pid};
     my $cb  = $arg{cb};
  
     $pid_cb{$pid}{$cb+0} = $cb;
  
     $pid_w{$pid} ||= Glib::Child->watch_add ($pid, sub {
        # the unbelievably braindamaged glib api ignores the return
        # value and always removes the watcher (this is of course
        # undocumented), so we need to go through these contortions to
        # work around this, here and in DESTROY.
        undef $pid_w{$pid};
  
        $_->($_[0], $_[1])
           for values %{ $pid_cb{$pid} };
  
        1 # gets ignored
     });
  
     bless [$pid, $cb+0], "AnyEvent::Impl::Glib::child"
  }
  
  sub AnyEvent::Impl::Glib::child::DESTROY {
     my ($pid, $icb) = @{ $_[0] };
  
     delete $pid_cb{$pid}{$icb};
     unless (%{ $pid_cb{$pid} }) {
        delete $pid_cb{$pid};
        my $source = delete $pid_w{$pid};
        remove Glib::Source if defined $source;
     }
  }
  
  #sub loop {
  #   # hackish, but we do not have a mainloop, just a maincontext
  #   $mainloop->iteration (1) while 1;
  #}
  
  sub _poll {
     $mainloop->iteration (1);
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     $mainloop->iteration (1) until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Glib>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_GLIB

$fatpacked{"AnyEvent/Impl/IOAsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_IOASYNC';
  =head1 NAME
  
  AnyEvent::Impl::IOAsync - AnyEvent adaptor for IO::Async
  
  =head1 SYNOPSIS
  
    use AnyEvent;
    use IO::Async::Loop;
  
    # optionally set another event loop
    use AnyEvent::Impl::IOAsync;
    my $loop = new IO::Async::Loop;
    AnyEvent::Impl::IOAsync::set_loop $loop;
  
  =head1 DESCRIPTION
  
  This module provides support for IO::Async as AnyEvent backend. It supports
  I/O, timers, signals and child process watchers. Idle watchers are emulated.
  I/O watchers need to dup their fh because IO::Async only supports IO handles,
  not plain file descriptors.
  
  =head1 FUNCTIONS AND VARIABLES
  
  The only user-servicible part in this module is the C<set_loop> function
  and C<$LOOP> variable:
  
  =over 4
  
  =item AnyEvent::Impl::IOAsync::set_loop $new_loop
  
  Unfortunately, IO::Async has no concept of a default loop. Modules using
  IO::Async must be told by their caller which loop to use, which makes it
  impossible to transparently use IO::Async from a module.
  
  This module is no exception. It creates a new IO::Async::Loop object when
  it is loaded. This might not be the right loop object, though, and thus
  you can replace it by a call to this function with the loop object of your
  choice.
  
  Note that switching loops while watchers are already initialised can have
  unexpected effects, and is not supported unless you can live witht he
  consequences.
  
  =item $AnyEvent::Impl::IOAsync::LOOP
  
  This variable always contains the IO::Async::Loop object used by this
  AnyEvent backend. See above for more info.
  
  Storing the "default" loop makes this module a possible arbiter for other
  modules that want to use IO::Async transparently. It's advised to directly
  refer to this variable each time you want to use it, without making a
  local copy.
  
  =back
  
  =head1 PROBLEMS WITH IO::Async
  
  This section had a long list of problems and shortcomings that made it
  almost impossible to support L<IO::Async>. With version 0.33 of IO::Async,
  however, most of these have been fixed, so L<IO::Async> can now be used as
  easily as many other loops.
  
  There are a few remaining problems that require emulation or workarounds:
  
  =over 4
  
  =item No support for multiple watchers per event
  
  In most (all? documentation?) cases you cannot have multiple watchers
  for the same event (what's the point of having all these fancy notifier
  classes when you cannot have multiple notifiers for the same event? That's
  like only allowing one timer per second or so...).
  
  For I/O watchers, AnyEvent has to dup() every file handle, as IO::Async
  fails to support the same or different file handles pointing to the same
  fd (the good thing is that it is documented, but why not fix it instead?).
  
  =back
  
  Apart from these fatal flaws, there are a number of unpleasent properties
  that just need some mentioning:
  
  =over 4
  
  =item Confusing and misleading names
  
  Another rather negative point about this module family is its name,
  which is deeply confusing: Despite the "async" in the name, L<IO::Async>
  only does I<synchronous> I/O, there is nothing "asynchronous" about it
  whatsoever (when I first heard about it, I thought, "wow, a second async
  I/O module, what does it do compared to L<IO::AIO>", and was somehow set
  back when I learned that the only "async" aspect of it is the name).
  
  =item Inconsistent, incomplete and convoluted API
  
  Implementing AnyEvent's rather simple timers on top of IO::Async's timers
  was a nightmare (try implementing a timer with configurable interval and
  delay value...).
  
  The method naming is chaotic: C<watch_child> creates a child watcher,
  but C<watch_io> is an internal method; C<detach_signal> removes a signal
  watcher, but C<detach_child> forks a subprocess and so on).
  
  =item Unpleasant surprises on GNU/Linux
  
  When you develop your program on FreeBSD and run it on GNU/Linux, you
  might have unpleasant surprises, as IO::Async::Loop will by default use
  L<IO::Async::Loop::Epoll>, which is incompatible with C<fork>, so your
  network server will run into spurious and very hard to debug problems
  under heavy load, as IO::Async forks a lot of processes, e.g. for DNS
  resolution. It would be better if IO::Async would only load "safe"
  backends by default (or fix the epoll backend to work in the presence of
  fork, which admittedly is hard - EV does it for you, and also does not use
  unsafe backends by default).
  
  =back
  
  On the positive side, performance with IO::Async is quite good even in my
  very demanding eyes.
  
  =cut
  
  package AnyEvent::Impl::IOAsync;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use Time::HiRes ();
  use Scalar::Util ();
  
  use IO::Async::Loop 0.33;
  
  our $LOOP = new IO::Async::Loop;
  
  sub set_loop($) {
     $LOOP = $_[0];
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
  
     my $id;
  
     if (my $ival = $arg{interval}) {
        my $ival_cb; $ival_cb = sub {
           $id = $LOOP->enqueue_timer (delay => $ival, code => $ival_cb);
           &$cb;
        };
        $id = $LOOP->enqueue_timer (delay => $arg{after}, code => $ival_cb);
  
        # we have to weaken afterwards, but when enqueue dies, we have a memleak.
        # still, we do anything for speed...
        Scalar::Util::weaken $ival_cb;
  
     } else {
        # IO::Async has problems with overloaded objects
        $id = $LOOP->enqueue_timer (delay => $arg{after}, code => sub {
           undef $id; # IO::Async <= 0.43 bug workaround
           &$cb;
        });
     }
  
     bless \\$id, "AnyEvent::Impl::IOAsync::timer"
  }
  
  sub AnyEvent::Impl::IOAsync::timer::DESTROY {
     # Need to be well-behaved during global destruction
     $LOOP->cancel_timer (${${$_[0]}})
        if defined ${${$_[0]}}; # IO::Async <= 0.43 bug workaround
  }
  
  sub io {
     my ($class, %arg) = @_;
  
     # Ensure we have a real IO handle, and not just a UNIX fd integer
     my ($fh) = AnyEvent::_dupfh $arg{poll}, $arg{fh};
  
     my $event = $arg{poll} eq "r" ? "on_read_ready" : "on_write_ready";
  
     $LOOP->watch_io (
        handle => $fh,
        $event => $arg{cb},
     );
  
     bless [$fh, $event], "AnyEvent::Impl::IOAsync::io"
  }
  
  sub AnyEvent::Impl::IOAsync::io::DESTROY {
     $LOOP->unwatch_io (
        handle => $_[0][0],
        $_[0][1] => 1,
     );
  }
  
  sub signal {
     my ($class, %arg) = @_;
  
     my $signal = $arg{signal};
  
     my $id = $LOOP->attach_signal ($arg{signal}, $arg{cb});
     bless [$signal, $id], "AnyEvent::Impl::IOAsync::signal"
  }
  
  sub AnyEvent::Impl::IOAsync::signal::DESTROY {
     $LOOP->detach_signal (@{ $_[0] });
  }
  
  our %pid_cb;
  
  sub child {
     my ($class, %arg) = @_;
  
     my $pid = $arg{pid};
  
     $LOOP->watch_child ($pid, $arg{cb});
     bless [$pid], "AnyEvent::Impl::IOAsync::child"
  }
  
  sub child {
     my ($class, %arg) = @_;
  
     my $pid = $arg{pid};
     my $cb  = $arg{cb};
  
     unless (%{ $pid_cb{$pid} }) {
        $LOOP->watch_child ($pid, sub {
           $_->($_[0], $_[1])
              for values %{ $pid_cb{$pid} };
        });
     }
  
     $pid_cb{$pid}{$cb+0} = $cb;
  
     bless [$pid, $cb+0], "AnyEvent::Impl::IOAsync::child"
  }
  
  sub AnyEvent::Impl::IOAsync::child::DESTROY {
     my ($pid, $icb) = @{ $_[0] };
  
     delete $pid_cb{$pid}{$icb};
  
     unless (%{ $pid_cb{$pid} }) {
        delete $pid_cb{$pid};
        $LOOP->unwatch_child ($pid);
     }
  }
  
  #sub loop {
  #   $LOOP->loop_forever;
  #}
  
  sub _poll {
     $LOOP->loop_once;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     $LOOP->loop_once until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<IO::Async>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
   Paul Evans <leonerd@leonerd.org.uk>
   Rewrote the backend for IO::Async version 0.33.
  
  =cut
  
  1
  
ANYEVENT_IMPL_IOASYNC

$fatpacked{"AnyEvent/Impl/Irssi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_IRSSI';
  =head1 NAME
  
  AnyEvent::Impl::Irssi - AnyEvent adaptor for Irssi
  
  =head1 SYNOPSIS
  
     use AnyEvent;
    
     # this module gets loaded automatically when running under irssi
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Irssi scripts work with AnyEvent.
  
  Limitations of this backend and implementation details:
  
  =over 4
  
  =item * This backend does not support blocking waits.
  
  That means you must set a callback on any condvars, or otherwise make sure
  to never call C<recv> on a condvar that hasn't been signalled yet.
  
  =item * Child exits will be handled by AnyEvent.
  
  AnyEvent will take over child handling, as Irssi only polls for children
  once/second and cannot handle unspecific child watchers.
  
  This I<should> have no negative effect, as AnyEvent will emit a pidwait
  signal just like irssi itself would.
  
  =item * Artificial timer delays.
  
  Irssi artificially enforces timers to have at least a 10ms delay (by
  croaking, even).
  
  This means that some applications will be limited to a rate of 100Hz (for
  example, L<Coro::AnyEvent> thread scheduling).
  
  =item * Irssi leaks memory like hell.
  
  Yeah.
  
  =back
  
  Apart from that, documentation is notoriously wrong (e.g. file handles
  are not supported by C<input_add>, contrary to documentation), hooking
  into irssi has to be done in... weird... ways, but otherwise, Irssi is
  surprisingly full-featured (for basically being a hack).
  
  =cut
  
  package AnyEvent::Impl::Irssi;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Carp ();
  use Irssi ();
  
  our @ISA;
  
  # irssi works only from certain namespaces, so we
  # create one and use it.
  sub init {
     my $pkg = caller;
  
     push @ISA, $pkg;
  
     local $/;
     eval "package $pkg; " . <DATA>;
     print "AnyEvent::Impl::Irssi fatal compilation error: $@" if $@;
  
     close DATA;
  }
  
  Irssi::command "/script exec -permanent AnyEvent::Impl::Irssi::init 'AnyEvent adaptor'";
  
  1;
  
  __DATA__
  
  BEGIN { AnyEvent::common_sense }
  use base "AnyEvent::Base";
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = Irssi::input_add
        $fd,
        $arg{poll} eq "r" ? Irssi::INPUT_READ : Irssi::INPUT_WRITE,
        $cb,
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::io"
  }
  
  sub AnyEvent::Impl::Irssi::io::DESTROY {
     Irssi::input_remove $${$_[0]};
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb    = $arg{cb};
     my $ival  = $arg{interval} * 1000;
     my $after = $arg{after} * 1000;
  
     my $source; $source = Irssi::timeout_add_once $after > 10 ? $after : 10,
        ($ival ? sub {
                   $source = Irssi::timeout_add $ival > 10 ? $ival : 10, $cb, undef;
                   &$cb;
                   0
                 }
               : $cb),
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::timer"
  }
  
  sub AnyEvent::Impl::Irssi::timer::DESTROY {
     Irssi::timeout_remove $${$_[0]};
  }
  
  my $_pidwait = sub {
     my ($rpid, $rstatus) = @_;
  
     AnyEvent::Base->_emit_childstatus ($rpid, $rstatus);
  };
  
  Irssi::signal_add pidwait => $_pidwait;
  
  sub _emit_childstatus {
     my ($self, $rpid, $rstatus) = @_;
     $self->SUPER::_emit_childstatus ($rpid, $rstatus);
  
     Irssi::signal_remove pidwait => $_pidwait;
     Irssi::signal_emit   pidwait => $rpid+0, $rstatus+0;
     Irssi::signal_add    pidwait => $_pidwait;
  }
  
  #sub loop {
  #   Carp::croak "Irssi does not support blocking waits";
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Irssi>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_IRSSI

$fatpacked{"AnyEvent/Impl/POE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_POE';
  =head1 NAME
  
  AnyEvent::Impl::POE - AnyEvent adaptor for POE
  
  =encoding utf-8
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use POE;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make POE work with AnyEvent except by loading POE before
  creating the first AnyEvent watcher. There are some cases where POE will
  issue spurious (and non-suppressible) warnings. These can be avoided by
  loading AnyEvent::Impl::POE before loading any other modules using POE and
  AnyEvent, i.e. in your main program.
  
  AnyEvent::Impl::POE will output some spurious message how to work around
  POE's spurious messages when it detects these cases.
  
  Unfortunately, POE isn't generic enough to implement a fully working
  AnyEvent backend: POE is too badly designed, too badly documented and too
  badly implemented.
  
  Here are the details, and what it means to you if you want to be
  interoperable with POE:
  
  =over 4
  
  =item Weird messages
  
  If you only use C<run_one_timeslice> (as AnyEvent has to for its
  condition variables), POE will print an ugly, unsuppressible, message at
  program exit:
  
     Sessions were started, but POE::Kernel's run() method was never...
  
  The message is correct, the question is why POE prints it in the first
  place in a correct program (this is not a singular case though).
  
  AnyEvent consequently patches the POE kernel so it thinks it already
  ran. Other workarounds, even the one cited in the POE documentation
  itself, have serious side effects, such as throwing away events.
  
  The author of POE verified that this is indeed true, and has no plans to
  change this.
  
  POE has other weird messages, and sometimes weird behaviour, for example,
  it doesn't support overloaded code references as callbacks for no apparent
  reason.
  
  =item One POE session per Event
  
  AnyEvent has to create one POE::Session per event watcher, which is
  immensely slow and makes watchers very large. The reason for this is
  lacking lifetime management (mostly undocumented, too). Without one
  session/watcher it is not possible to easily keep the kernel from running
  endlessly.
  
  This is not just a problem with the way AnyEvent has to interact with
  POE, but is a principal issue with POEs lifetime management (namely
  that stopping the kernel stops sessions, but AnyEvent has no control
  over who and when the kernel starts or stops w.r.t. AnyEvent watcher
  creation/destruction).
  
  From benchmark data it is not clear that session creation is that costly,
  though - the real inefficiencies with POE seem to come from other sources,
  such as event handling.
  
  =item One watcher per fd/event combo
  
  POE, of course, suffers from the same bug as Tk and some other badly
  designed event models in that it doesn't support multiple watchers per
  fd/poll combo. The workaround is the same as with Tk: AnyEvent::Impl::POE
  creates a separate file descriptor to hand to POE, which isn't fast and
  certainly not nice to your resources.
  
  Of course, without the workaround, POE also prints ugly messages again
  that say the program *might* be buggy.
  
  While this is not good to performance, at least regarding speed, with a
  modern Linux kernel, the overhead is actually quite small.
  
  =item Timing deficiencies
  
  POE manages to not have a function that returns the current time. This is
  extremely problematic, as POE can use different time functions, which can
  differ by more than a second - and user code is left guessing which one is
  used.
  
  In addition, most timer functions in POE want an absolute timestamp, which
  is hard to create if all you have is a relative time and no function to
  return the "current time".
  
  And of course POE doesn't handle time jumps at all (not even when using
  an event loop that happens to do that, such as L<EV>, as it does its own
  unoptimised timer management).
  
  AnyEvent works around the unavailability of the current time using
  relative timers exclusively, in the hope that POE gets it right at least
  internally.
  
  =item Lack of defined event ordering
  
  POE cannot guarantee the order of callback invocation for timers, and
  usually gets it wrong. That is, if you have two timers, one timing out
  after another (all else being equal), the callbacks might be called in
  reverse order.
  
  How one manages to even implement stuff that way escapes me.
  
  =item Child watchers
  
  POE offers child watchers - which is a laudable thing, as few event loops
  do. Unfortunately, they cannot even implement AnyEvent's simple child
  watchers: they are not generic enough (the POE implementation isn't even
  generic enough to let properly designed back-end use their native child
  watcher instead - it insist on doing it itself the broken way).
  
  Unfortunately, POE's child handling is inherently racy: if the child exits
  before the handler is created (because e.g. it crashes or simply is quick
  about it), then current versions of POE (1.352) will I<never> invoke the
  child watcher, and there is nothing that can be done about it. Older
  versions of POE only delayed in this case. The reason is that POE first
  checks if the child has already exited, and I<then> installs the signal
  handler - aa classical race.
  
  Your only hope is for the fork'ed process to not exit too quickly, in
  which case everything happens to work.
  
  Of course, whenever POE reaps an unrelated child it will also output a
  message for it that you cannot suppress (which shouldn't be too surprising
  at this point). Very professional.
  
  As a workaround, AnyEvent::Impl::POE will take advantage of undocumented
  behaviour in POE::Kernel to catch the status of all child processes, but
  it cannot guarantee delivery.
  
  How one manages to have such a glaring bug in an event loop after ten
  years of development escapes me.
  
  (There are more annoying bugs, for example, POE runs C<waitpid>
  unconditionally at finaliser time, so your program will hang until all
  child processes have exited.)
  
  =item Documentation quality
  
  At the time of this writing, POE was in its tenth year. Still, its
  documentation is extremely lacking, making it impossible to implement
  stuff as trivial as AnyEvent watchers without having to resort to
  undocumented behaviour or features.
  
  For example, the POE::Kernel manpage has nine occurrences of the word TODO
  with an explanation of whats missing. In general, the POE man pages are
  littered with comments like "section not yet written".
  
  Some other gems:
  
     This allows many object methods to also be package methods.
  
  This is nice, but since it doesn't document I<which> methods these are,
  this is utterly useless information.
  
     Terminal signals will kill sessions if they are not handled by a
     "sig_handled"() call. The OS signals that usually kill or dump a
     process are considered terminal in POE, but they never trigger a
     coredump. These are: HUP, INT, QUIT and TERM.
  
  Although AnyEvent calls C<sig_handled>, removing it has no apparent
  effects on POE handling SIGINT.
  
     refcount_increment SESSION_ID, COUNTER_NAME
  
  Nowhere is explained which COUNTER_NAMEs are valid and which aren't - not
  all scalars (or even strings) are valid counter names. Take your guess,
  failure is of course completely silent. I found this out the hard way, as
  the first name I came up with was silently ignored.
  
     get_next_event_time() returns the time the next event is due, in a form
     compatible with the UNIX time() function.
  
  And surely, one would hope that POE supports sub-second accuracy as
  documented elsewhere, unlike the explanation above implies. Yet:
  
     POE::Kernel timers support subsecond accuracy, but dont expect too
     much here. Perl is not the right language for realtime programming.
  
  ... of course, Perl is not the right language to expect sub-second
  accuracy - the manpage author must hate Perl to spread so much FUD in
  so little space. The Deliantra game server logs with 100s-accuracy
  because Perl is fast enough to require this, and is still able to deliver
  map updates with little jitter at exactly the right time. It does not,
  however, use POE.
  
     Furthermore, since the Kernel keeps track of everything sessions do, it
     knows when a session has run out of tasks to perform.
  
  This is impossible - how does the kernel know that a session is no longer
  watching for some (external) event (e.g. by some other session)? It
  cannot, and therefore this is wrong - but you would be hard pressed to
  find out how to work around this and tell the kernel manually about such
  events.
  
  It gets worse, though - the notion of "task" or "resource", although used
  throughout the documentation, is not defined in a usable way. For example,
  waiting for a timeout is considered to be a task, waiting for a signal is
  not (a session that only waits for a signal is considered finished and
  gets removed). The user is left guessing when waiting for an event counts
  as task and when not (in fact, the issue with signals is mentioned in
  passing in a section about child watchers and directly contradicts earlier
  parts in that document).
  
  One could go on endlessly - ten years, no usable documentation.
  
  It is likely that differences between documentation, or the one or two
  things I had to guess, cause unanticipated problems with this adaptor.
  
  =item Fragile and inconsistent API
  
  The POE API is extremely inconsistent - sometimes you have to pass a
  session argument, sometimes it gets ignored, sometimes a session-specific
  method must not use a session argument.
  
  Error handling is sub-standard as well: even for programming mistakes,
  POE does not C<croak> but, in most cases, just sets C<$!> or simply does
  nothing at all, leading to fragile programs.
  
  Sometimes registering a handler uses the "eventname, parameter" ordering
  (timeouts), sometimes it is "parameter, eventname" (signals). There is
  little consistency overall.
  
  =item Lack of knowledge
  
     The IO::Poll event loop provides an alternative that theoretically
     scales better than select().
  
  The IO::Poll "event loop" (who in his right mind would call that an event
  loop) of course scales about identically (sometimes it is a bit faster,
  sometimes a bit slower) to select in theory, and also in practise, of
  course, as both are O(n) in the number of file descriptors, which is
  rather bad.
  
  This is just one place where it gets obvious how little the author of the
  POE manpage understands.
  
  =item No idle events
  
  The POE-recommended workaround to this is apparently to use
  C<fork>. Consequently, idle watchers will have to be emulated by AnyEvent.
  
  =item Questionable maintainer behaviour
  
  The author of POE is known to fabricate statements and post these to
  public mailinglists - apparently, spreading FUD about competing (in his
  eyes) projects or their maintainers is acceptable to him.
  
  This has (I believe) zero effects on the quality or usefulness of his
  code, but it does completely undermine his trustworthyness - so don't
  blindly believe anything he says, he might have just made it up to suit
  his needs (benchmark results, the names of my ten wifes, the length of my
  penis, etc. etc.). When in doubt, double-check - not just him, anybody
  actually.
  
  Example: L<http://www.nntp.perl.org/group/perl.perl5.porters/2012/01/msg182141.html>.
  I challenged him in that thread to provide evidence for his statement by giving at
  least two examples, but of course since he just made it up, he couldn't provide any evidence.
  
  =back
  
  On the good side, AnyEvent allows you to write your modules in a 100%
  POE-compatible way (bug-for-bug compatible even), without forcing your
  module to use POE - it is still open to better event models, of which
  there are plenty.
  
  Oh, and one other positive thing:
  
     RUNNING_IN_HELL
  
  POE knows about the nature of the beast!
  
  =cut
  
  package AnyEvent::Impl::POE;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use POE;
  
  # suppress an idiotic warning inside POE
  ${ POE::Kernel->new->[POE::Kernel::KR_RUN] } |= POE::Kernel::KR_RUN_CALLED;
  
  sub io {
     my ($class, %arg) = @_;
  
     # POE itself might do the right thing, but some POE backends don't,
     # so do the safe thing, it's not as if this will slow us down
     # any further *g*
     my ($fh, $pee) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, "select_read", "select_write";
  
     my $cb = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
  
     my $session = POE::Session->create (
        inline_states => {
           _start => sub { $_[KERNEL]->$pee ($fh => "ready") },
           ready  => sub { $cb->() },
           stop   => sub { $_[KERNEL]->$pee ($fh) },
        },
     );
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     my $after = delete $arg{after};
     my $ival  = delete $arg{interval};
     my $cb    = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
  
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              $_[KERNEL]->delay_set (timeout => $after);
           },
           timeout => $ival ? sub { $_[KERNEL]->delay_set (timeout => $ival); $cb->() } : $cb,
           stop => sub {
              $_[KERNEL]->alarm_remove_all;
           },
        },
     );
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub signal {
     my ($class, %arg) = @_;
     my $signal = AnyEvent::Base::sig2name delete $arg{signal};
     my $cb     = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              # I suck - POE
           },
           start => sub {
              $_[KERNEL]->sig ($signal => "catch");
              $_[KERNEL]->refcount_increment ($_[SESSION]->ID => "poe");
           },
           catch => sub {
              $cb->();
              $_[KERNEL]->sig_handled;
           },
           stop => sub {
              $_[KERNEL]->refcount_decrement ($_[SESSION]->ID => "poe");
              $_[KERNEL]->sig ($signal);
           },
        },
     );
     POE::Kernel->call ($session, "start");
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub child {
     my ($class, %arg) = @_;
     my $pid = delete $arg{pid};
     my $cb  = delete $arg{cb}; my $cb = sub { &$cb }; # POE doesn't like callable objects
     my $session = POE::Session->create (
        inline_states => {
           _start => sub {
              # I suck - POE
           },
           start => sub {
              $_[KERNEL]->sig (CHLD => "child");
              $_[KERNEL]->refcount_increment ($_[SESSION]->ID => "poe");
           },
           child => sub {
              my ($rpid, $status) = @_[ARG1, ARG2];
  
              $cb->($rpid, $status) if $rpid == $pid || $pid == 0;
           },
           stop => sub {
              $_[KERNEL]->refcount_decrement ($_[SESSION]->ID => "poe");
              $_[KERNEL]->sig ("CHLD");
           },
        },
     );
     # newer POE versions lose signals unless we call ->sig early.
     POE::Kernel->call ($session, "start");
     bless \\$session, "AnyEvent::Impl::POE"
  }
  
  sub DESTROY {
     POE::Kernel->call (${${$_[0]}}, "stop");
  }
  
  #sub loop {
  #   POE::Kernel->run;
  #}
  
  sub _poll {
     POE::Kernel->loop_do_timeslice;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     POE::Kernel->loop_do_timeslice until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<POE>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_POE

$fatpacked{"AnyEvent/Impl/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_PERL';
  =head1 NAME
  
  AnyEvent::Impl::Perl - AnyEvent adaptor for AnyEvent's pure perl AnyEvent::Loop
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use AnyEvent::Loop;
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent in case no other
  event loop could be found or loaded.
  
  If you want to use this module instead of autoloading another event loop
  you can simply load L<AnyEvent::Loop> before creating the first watcher.
  
  Naturally, it supports all features of AnyEvent.
  
  See L<AnyEvent::Loop> for more details on performance characteristics.
  
  =cut
  
  package AnyEvent::Impl::Perl;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Loop;
  
  our $VERSION = $AnyEvent::VERSION;
  
  # time() is provided via AnyEvent::Base
  
  *AE::now        = \&AnyEvent::Loop::now;
  *AE::now_update = \&AnyEvent::Loop::now_update;
  *AE::io         = \&AnyEvent::Loop::io;
  *AE::timer      = \&AnyEvent::Loop::timer;
  *AE::idle       = \&AnyEvent::Loop::idle;
  *_poll          = \&AnyEvent::Loop::one_event;
  *loop           = \&AnyEvent::Loop::run; # compatibility with AnyEvent < 6.0
  *now_update     = \&AnyEvent::Loop::now_update;
  
  sub now { $AnyEvent::Loop::NOW }
  
  sub AnyEvent::CondVar::Base::_wait {
     AnyEvent::Loop::one_event until exists $_[0]{_ae_sent};
  }
  
  sub io {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::io $arg{fh}, $arg{poll} eq "w", $arg{cb}
  }
  
  sub timer {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::timer $arg{after}, $arg{interval}, $arg{cb}
  }
  
  sub idle {
     my (undef, %arg) = @_;
  
     AnyEvent::Loop::idle $arg{cb}
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_PERL

$fatpacked{"AnyEvent/Impl/Qt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_QT';
  =head1 NAME
  
  AnyEvent::Impl::Qt - AnyEvent adaptor for Qt
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Qt;
    
     my $app = Qt::Application \@ARGV; # REQUIRED!
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have
  to do anything to make Qt work with AnyEvent except by loading Qt
  before creating the first AnyEvent watcher I<and instantiating the
  Qt::Application object>. Failure to do so will result in segfaults,
  which is why this model doesn't work as a default model and will not be
  autoprobed (but it will be autodetected when the main program uses Qt).
  
  Qt suffers from the same limitations as Event::Lib and Tk, the workaround
  is also the same (duplicating file descriptors).
  
  Qt doesn't support idle events, so they are being emulated.
  
  Avoid Qt if you can.
  
  =cut
  
  package AnyEvent::Impl::Qt::Io;
  
  use Qt;
  use Qt::isa qw(Qt::SocketNotifier); # Socket? what where they smoking
  use Qt::slots cb => [];
  
  sub NEW {
     my ($class, $fh, $mode, $cb) = @_;
     shift->SUPER::NEW (fileno $fh, $mode);
     this->{fh} = $fh;
     this->{cb} = $cb;
     this->connect (this, SIGNAL "activated(int)", SLOT "cb()");
  }
  
  sub cb {
     this->setEnabled (0); # required according to the docs. heavy smoking required.
     this->{cb}->();
     this->setEnabled (1);
  }
  
  package AnyEvent::Impl::Qt::Timer;
  
  use Qt;
  use Qt::isa qw(Qt::Timer);
  use Qt::slots cb => [];
  
  # having to go through these contortions just to get a timer event is
  # considered an advantage over other gui toolkits how?
  
  sub NEW {
     my ($class, $after, $interval, $cb) = @_;
     shift->SUPER::NEW ();
     this->{interval} = $interval;
     this->{cb}       = $cb;
     this->connect (this, SIGNAL "timeout()", SLOT "cb()");
     this->start ($after, 1);
  }
  
  sub cb {
     this->start (this->{interval}, 1) if defined this->{interval};
     this->{cb}->();
  }
  
  package AnyEvent::Impl::Qt;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Qt;
  
  use AnyEvent::Impl::Qt::Timer;
  use AnyEvent::Impl::Qt::Io;
  
  our $app = Qt::Application \@ARGV; # REQUIRED!
  
  sub io {
     my ($class, %arg) = @_;
  
     # work around these bugs in Qt:
     # - adding a callback might destroy other callbacks
     # - only one callback per fd/poll combination
     my ($fh, $qt) = AnyEvent::_dupfh $arg{poll}, $arg{fh},
                        Qt::SocketNotifier::Read (), Qt::SocketNotifier::Write ();
  
     AnyEvent::Impl::Qt::Io $fh, $qt, $arg{cb}
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     # old Qt treats 0 timeout as "idle"
     AnyEvent::Impl::Qt::Timer
        $arg{after} * 1000 || 1,
        $arg{interval} ? $arg{interval} * 1000 || 1 : undef,
        $arg{cb}
  }
  
  # newer Qt have no idle mode for timers anymore...
  #sub idle {
  #   my ($class, %arg) = @_;
  #   
  #   AnyEvent::Impl::Qt::Timer 0, 0, $arg{cb}
  #}
  
  #sub loop {
  #   Qt::app->exec;
  #}
  
  sub _poll {
     Qt::app->processOneEvent;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Qt::app->processOneEvent until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Qt>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_QT

$fatpacked{"AnyEvent/Impl/Tk.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_TK';
  =head1 NAME
  
  AnyEvent::Impl::Tk - AnyEvent adaptor for Tk
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use Tk;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make Tk work with AnyEvent except by loading Tk before
  creating the first AnyEvent watcher.
  
  Tk is buggy. Tk is extremely buggy. Tk is so unbelievably buggy that
  for each bug reported and fixed, you get one new bug followed by
  reintroduction of the old bug in a later revision. It is also basically
  unmaintained: the maintainers are not even interested in improving
  the situation - reporting bugs is considered rude, and fixing bugs is
  considered changing holy code, so it's apparently better to leave it
  broken.
  
  I regularly run out of words to describe how bad it really is.
  
  To work around some of the many, many bugs in Tk that don't get fixed,
  this adaptor dup()'s all filehandles that get passed into its I/O
  watchers, so if you register a read and a write watcher for one fh,
  AnyEvent will create two additional file descriptors (and handles).
  
  This creates a high overhead and is slow, but seems to work around most
  known bugs in L<Tk::fileevent> on 32 bit architectures (Tk seems to be
  terminally broken on 64 bit, do not expect more than 10 or so watchers to
  work on 64 bit machines).
  
  Do not expect these workarounds to avoid segfaults and crashes inside Tk.
  
  Note also that Tk event ids wrap around after 2**32 or so events, which on
  my machine can happen within less than 12 hours, after which Tk will stomp
  on random other events and kill them. So don't run Tk programs for more
  than an hour or so.
  
  To be able to access the Tk event loop, this module creates a main
  window and withdraws it immediately. This might cause flickering on some
  platforms, but Tk perversely requires a window to be able to wait for file
  handle readyness notifications. This window is always created (in this
  version of AnyEvent) and can be accessed as C<$AnyEvent::Impl::Tk::mw>.
  
  =cut
  
  package AnyEvent::Impl::Tk;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use Tk ();
  
  our $mw = new MainWindow -title => "AnyEvent Dummy Window";
  $mw->withdraw;
  
  END { undef $mw }
  
  sub io {
     my (undef, %arg) = @_;
  
     # work around these bugs in Tk:
     # - removing a callback will destroy other callbacks
     # - removing a callback might crash
     # - adding a callback might destroy other callbacks
     # - only one callback per fh
     # - only one callback per fh/poll combination
     my ($fh, $tk) = AnyEvent::_dupfh $arg{poll}, $arg{fh}, "readable", "writable";
  
     $mw->fileevent ($fh, $tk => $arg{cb});
  
     bless [$fh, $tk], "AnyEvent::Impl::Tk::io"
  }
  
  sub AnyEvent::Impl::Tk::io::DESTROY {
     my ($fh, $tk) = @{$_[0]};
  
     # work around another bug: watchers don't get removed when
     # the fh is closed, contrary to documentation. also, trying
     # to unregister a read callback will make it impossible
     # to remove the write callback.
     # if your program segfaults here then you need to destroy
     # your watchers before program exit. sorry, no way around
     # that.
     $mw->fileevent ($fh, $tk => "");
  }
  
  sub timer {
     my (undef, %arg) = @_;
     
     my $after = $arg{after} < 0 ? 0 : $arg{after} * 1000;
     my $cb = $arg{cb};
     my $id;
  
     if ($arg{interval}) {
        my $ival = $arg{interval} * 1000;
        my $rcb = sub {
           $id = Tk::after $mw, $ival, [$_[0], $_[0]];
           &$cb;
        };
        $id = Tk::after $mw, $after, [$rcb, $rcb];
     } else {
        # tk blesses $cb, thus the extra indirection
        $id = Tk::after $mw, $after, sub { &$cb };
     }
  
     bless \\$id, "AnyEvent::Impl::Tk::after"
  }
  
  sub idle {
     my (undef, %arg) = @_;
  
     my $cb = $arg{cb};
     my $id;
     my $rcb = sub {
        # in their endless stupidity, they decided to give repeating idle watchers
        # strictly higher priority than timers :/
        $id = Tk::after $mw, 0 => [sub {
           $id = Tk::after $mw, idle => [$_[0], $_[0]];
        }, $_[0]];
        &$cb;
     };
  
     $id = Tk::after $mw, idle => [$rcb, $rcb];
     bless \\$id, "AnyEvent::Impl::Tk::after"
  }
  
  sub AnyEvent::Impl::Tk::after::DESTROY {
     Tk::after $mw, cancel => $${$_[0]};
  }
  
  #sub loop {
  #   Tk::MainLoop;
  #}
  
  sub _poll {
     Tk::DoOneEvent (0);
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     Tk::DoOneEvent (0) until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Tk>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_TK

$fatpacked{"AnyEvent/Impl/UV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_UV';
  =head1 NAME
  
  AnyEvent::Impl::UV - AnyEvent adaptor for UV
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     use UV;
    
     # this module gets loaded automatically as required
  
  =head1 DESCRIPTION
  
  This module provides transparent support for AnyEvent. You don't have to
  do anything to make UV work with AnyEvent except by loading UV before
  creating the first AnyEvent watcher.
  
  =cut
  
  package AnyEvent::Impl::UV;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use UV 0.24;
  use Scalar::Util qw(weaken);
  
  sub warnlog {
     my $err = UV::last_error;
  
     AnyEvent::log warn => "returned $_[0]: "
                           . UV::err_name ($err) . "($err): "
                           . UV::strerror ($err);
  
     @_
  }
  
  # https://github.com/joyent/libuv/issues/680
  # https://github.com/joyent/libuv/blob/dc1ea27c736f0d21c7160c790bcd1b113d20abd9/include/uv.h#L1277
  my %io_watchers;
  
  sub io_watcher_cb {
     my $slaves = shift;
     my (undef, $events) = @_;
     return unless defined $slaves;
  
     foreach my $entry (keys %$slaves) {
        my $slave = $slaves->{$entry};
        $slave->{cb}(@_) if $slave->{mode} & $events;
     }
  }
  
  sub AnyEvent::Impl::UV::io_slave::new {
     bless { parent => $_[1] }, $_[0]
  }
  
  sub AnyEvent::Impl::UV::io_slave::DESTROY {
     my $self   = $_[0];
     my $master = $self->{parent};
  
     delete $master->{slaves}{$self};
     if (keys %{$master->{slaves}} == 0) {
        if (defined $master->{w}) {
           my $rc = UV::poll_stop $master->{w};
           warnlog $rc if $rc;
        }
        delete $io_watchers{$master->{fd}};
        return;
     }
  
     my $mode = 0;
     foreach my $entry (keys %{$master->{slaves}}) {
        $mode |= $master->{slaves}{$entry}{mode};
     }
  
     if ($master->{mode} != $mode) {
        $master->{mode} = $mode;
        my $rc = UV::poll_start $master->{w}, $master->{mode}, sub {
           io_watcher_cb $master->{slaves}, @_;
        };
        warnlog $rc if $rc;
     }
  }
  
  sub io {
     my ($class, %arg) = @_;
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $master = $io_watchers{$fd} ||= { fd => $fd };
  
     unless (defined $master->{w}) {
        $master->{w} = UV::poll_init $fd;
        return warnlog $master->{w} unless defined $master->{w};
        $master->{slaves} = {};
     }
  
     my $slave = AnyEvent::Impl::UV::io_slave->new ($master);
     weaken ($master->{slaves}->{$slave} = $slave);
  
     $slave->{mode}  = $arg{poll} eq "r" ? UV::READABLE : UV::WRITABLE;
     $master->{mode} = 0 unless defined $master->{mode};
     $slave->{cb}    = $arg{cb};
  
     unless ($master->{mode} & $slave->{mode}) {
        $master->{mode} |= $slave->{mode};
        my $rc = UV::poll_start $master->{w}, $master->{mode}, sub {
           io_watcher_cb $master->{slaves}, @_;
        };
        warnlog $rc if $rc;
     }
  
     $slave
  }
  
  sub AnyEvent::Impl::UV::handle::new {
     my ($class, $w, $start, $stop, @args) = @_;
     return warnlog $w unless defined $w;
  
     my $rc = $start->($w, @args);
     warnlog $rc if $rc;
  
     bless { w => $w, stop => $stop }, $class
  }
  
  sub AnyEvent::Impl::UV::handle::DESTROY {
     my $h  = $_[0];
     return unless $h->{w};
     my $rc = $h->{stop}($h->{w});
     warnlog $rc if $rc;
     UV::close $h->{w};
  }
  
  sub idle {
     my ($class, %arg) = @_;
  
     AnyEvent::Impl::UV::handle->new (
        UV::timer_init,
        \&UV::idle_start,
        \&UV::idle_stop,
        $arg{cb}
     );
  }
  
  sub timer {
     my ($class, %arg) = @_;
  
     AnyEvent::Impl::UV::handle->new (
        UV::timer_init,
        \&UV::timer_start,
        \&UV::timer_stop,
        $arg{after} * 1000, $arg{interval} * 1000, $arg{cb}
     );
  }
  
  sub now { UV::now }
  
  sub _poll {
     UV::run UV::RUN_ONCE;
  }
  
  sub AnyEvent::CondVar::Base::_wait {
     UV::run UV::RUN_NOWAIT until exists $_[0]{_ae_sent};
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<UV>.
  
  =head1 AUTHOR
  
   Mike Lowell <mikedotlowell@gmail.com>
  
  =cut
  
  1
  
ANYEVENT_IMPL_UV

$fatpacked{"AnyEvent/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_LOG';
  =head1 NAME
  
  AnyEvent::Log - simple logging "framework"
  
  =head1 SYNOPSIS
  
  Simple uses:
  
     use AnyEvent;
  
     AE::log fatal => "No config found, cannot continue!"; # never returns
     AE::log alert => "The battery died!";
     AE::log crit  => "The battery is too hot!";
     AE::log error => "Division by zero attempted.";
     AE::log warn  => "Couldn't delete the file.";
     AE::log note  => "Attempted to create config, but config already exists.";
     AE::log info  => "File soandso successfully deleted.";
     AE::log debug => "the function returned 3";
     AE::log trace => "going to call function abc";
  
  Log level overview:
  
     LVL NAME      SYSLOG   PERL  NOTE
      1  fatal     emerg    exit  system unusable, aborts program!
      2  alert                    failure in primary system
      3  critical  crit           failure in backup system
      4  error     err      die   non-urgent program errors, a bug
      5  warn      warning        possible problem, not necessarily error
      6  note      notice         unusual conditions
      7  info                     normal messages, no action required
      8  debug                    debugging messages for development
      9  trace                    copious tracing output
  
  "Complex" uses (for speed sensitive code, e.g. trace/debug messages):
  
     use AnyEvent::Log;
  
     my $tracer = AnyEvent::Log::logger trace => \my $trace;
  
     $tracer->("i am here") if $trace;
     $tracer->(sub { "lots of data: " . Dumper $self }) if $trace;
  
  Configuration (also look at the EXAMPLES section):
  
     # set default logging level to suppress anything below "notice"
     # i.e. enable logging at "notice" or above - the default is to
     # to not log anything at all.
     $AnyEvent::Log::FILTER->level ("notice");
  
     # set logging for the current package to errors and higher only
     AnyEvent::Log::ctx->level ("error");
  
     # enable logging for the current package, regardless of global logging level
     AnyEvent::Log::ctx->attach ($AnyEvent::Log::LOG);
  
     # enable debug logging for module some::mod and enable logging by default
     (AnyEvent::Log::ctx "some::mod")->level ("debug");
     (AnyEvent::Log::ctx "some::mod")->attach ($AnyEvent::Log::LOG);
  
     # send all critical and higher priority messages to syslog,
     # regardless of (most) other settings
     $AnyEvent::Log::COLLECT->attach (new AnyEvent::Log::Ctx
        level         => "critical",
        log_to_syslog => "user",
     );
  
  =head1 DESCRIPTION
  
  This module implements a relatively simple "logging framework". It doesn't
  attempt to be "the" logging solution or even "a" logging solution for
  AnyEvent - AnyEvent simply creates logging messages internally, and this
  module more or less exposes the mechanism, with some extra spiff to allow
  using it from other modules as well.
  
  Remember that the default verbosity level is C<4> (C<error>), so only
  errors and more important messages will be logged, unless you set
  C<PERL_ANYEVENT_VERBOSE> to a higher number before starting your program
  (C<AE_VERBOSE=5> is recommended during development), or change the logging
  level at runtime with something like:
  
     use AnyEvent::Log;
     $AnyEvent::Log::FILTER->level ("info");
  
  The design goal behind this module was to keep it simple (and small),
  but make it powerful enough to be potentially useful for any module,
  and extensive enough for the most common tasks, such as logging to
  multiple targets, or being able to log into a database.
  
  The module is also usable before AnyEvent itself is initialised, in which
  case some of the functionality might be reduced.
  
  The amount of documentation might indicate otherwise, but the runtime part
  of the module is still just below 300 lines of code.
  
  =head1 LOGGING LEVELS
  
  Logging levels in this module range from C<1> (highest priority) to C<9>
  (lowest priority). Note that the lowest numerical value is the highest
  priority, so when this document says "higher priority" it means "lower
  numerical value".
  
  Instead of specifying levels by name you can also specify them by aliases:
  
     LVL NAME      SYSLOG   PERL  NOTE
      1  fatal     emerg    exit  system unusable, aborts program!
      2  alert                    failure in primary system
      3  critical  crit           failure in backup system
      4  error     err      die   non-urgent program errors, a bug
      5  warn      warning        possible problem, not necessarily error
      6  note      notice         unusual conditions
      7  info                     normal messages, no action required
      8  debug                    debugging messages for development
      9  trace                    copious tracing output
  
  As you can see, some logging levels have multiple aliases - the first one
  is the "official" name, the second one the "syslog" name (if it differs)
  and the third one the "perl" name, suggesting (only!) that you log C<die>
  messages at C<error> priority. The NOTE column tries to provide some
  rationale on how to chose a logging level.
  
  As a rough guideline, levels 1..3 are primarily meant for users of the
  program (admins, staff), and are the only ones logged to STDERR by
  default. Levels 4..6 are meant for users and developers alike, while
  levels 7..9 are usually meant for developers.
  
  You can normally only log a message once at highest priority level (C<1>,
  C<fatal>), because logging a fatal message will also quit the program - so
  use it sparingly :)
  
  For example, a program that finds an unknown switch on the commandline
  might well use a fatal logging level to tell users about it - the "system"
  in this case would be the program, or module.
  
  Some methods also offer some extra levels, such as C<0>, C<off>, C<none>
  or C<all> - these are only valid for the methods that documented them.
  
  =head1 LOGGING FUNCTIONS
  
  The following functions allow you to log messages. They always use the
  caller's package as a "logging context". Also, the main logging function,
  C<log>, is aliased to C<AnyEvent::log> and C<AE::log> when the C<AnyEvent>
  module is loaded.
  
  =over 4
  
  =cut
  
  package AnyEvent::Log;
  
  use Carp ();
  use POSIX ();
  
  # layout of a context
  #       0       1         2        3        4,    5
  # [$title, $level, %$slaves, &$logcb, &$fmtcb, $cap]
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  #use AnyEvent::Util (); need to load this in a delayed fashion, as it uses AE::log
  
  our $VERSION = $AnyEvent::VERSION;
  
  our ($COLLECT, $FILTER, $LOG);
  
  our ($now_int, $now_str1, $now_str2);
  
  # Format Time, not public - yet?
  sub format_time($) {
     my $i = int $_[0];
     my $f = sprintf "%06d", 1e6 * ($_[0] - $i);
  
     ($now_int, $now_str1, $now_str2) = ($i, split /\x01/, POSIX::strftime "%Y-%m-%d %H:%M:%S.\x01 %z", localtime $i)
        if $now_int != $i;
  
     "$now_str1$f$now_str2"
  }
  
  our %CTX; # all package contexts
  
  # creates a default package context object for the given package
  sub _pkg_ctx($) {
     my $ctx = bless [$_[0], (1 << 10) - 1 - 1, {}], "AnyEvent::Log::Ctx";
  
     # link "parent" package
     my $parent = $_[0] =~ /^(.+)::/
        ? $CTX{$1} ||= &_pkg_ctx ("$1")
        : $COLLECT;
  
     $ctx->[2]{$parent+0} = $parent;
  
     $ctx
  }
  
  =item AnyEvent::Log::log $level, $msg[, @args]
  
  Requests logging of the given C<$msg> with the given log level, and
  returns true if the message was logged I<somewhere>.
  
  For loglevel C<fatal>, the program will abort.
  
  If only a C<$msg> is given, it is logged as-is. With extra C<@args>, the
  C<$msg> is interpreted as an sprintf format string.
  
  The C<$msg> should not end with C<\n>, but may if that is convenient for
  you. Also, multiline messages are handled properly.
  
  Last not least, C<$msg> might be a code reference, in which case it is
  supposed to return the message. It will be called only then the message
  actually gets logged, which is useful if it is costly to create the
  message in the first place.
  
  This function takes care of saving and restoring C<$!> and C<$@>, so you
  don't have to.
  
  Whether the given message will be logged depends on the maximum log level
  and the caller's package. The return value can be used to ensure that
  messages or not "lost" - for example, when L<AnyEvent::Debug> detects a
  runtime error it tries to log it at C<die> level, but if that message is
  lost it simply uses warn.
  
  Note that you can (and should) call this function as C<AnyEvent::log> or
  C<AE::log>, without C<use>-ing this module if possible (i.e. you don't
  need any additional functionality), as those functions will load the
  logging module on demand only. They are also much shorter to write.
  
  Also, if you optionally generate a lot of debug messages (such as when
  tracing some code), you should look into using a logger callback and a
  boolean enabler (see C<logger>, below).
  
  Example: log something at error level.
  
     AE::log error => "something";
  
  Example: use printf-formatting.
  
     AE::log info => "%5d %-10.10s %s", $index, $category, $msg;
  
  Example: only generate a costly dump when the message is actually being logged.
  
     AE::log debug => sub { require Data::Dump; Data::Dump::dump \%cache };
  
  =cut
  
  # also allow syslog equivalent names
  our %STR2LEVEL = (
     fatal    => 1, emerg    => 1, exit => 1,
     alert    => 2,
     critical => 3, crit     => 3,
     error    => 4, err      => 4, die  => 4,
     warn     => 5, warning  => 5,
     note     => 6, notice   => 6,
     info     => 7,
     debug    => 8,
     trace    => 9,
  );
  
  our $TIME_EXACT;
  
  sub exact_time($) {
     $TIME_EXACT = shift;
     *_ts = $AnyEvent::MODEL
        ? $TIME_EXACT ? \&AE::now : \&AE::time
        : sub () { $TIME_EXACT ? do { require Time::HiRes; Time::HiRes::time () } : time };
  }
  
  BEGIN {
     exact_time 0;
  }
  
  AnyEvent::post_detect {
     exact_time $TIME_EXACT;
  };
  
  our @LEVEL2STR = qw(0 fatal alert crit error warn note info debug trace);
  
  # time, ctx, level, msg
  sub default_format($$$$) {
     my $ts = format_time $_[0];
     my $ct = " ";
  
     my @res;
  
     for (split /\n/, sprintf "%-5s %s: %s", $LEVEL2STR[$_[2]], $_[1][0], $_[3]) {
        push @res, "$ts$ct$_\n";
        $ct = " + ";
     }
  
     join "", @res
  }
  
  sub fatal_exit() {
     exit 1;
  }
  
  sub _log {
     my ($ctx, $level, $format, @args) = @_;
  
     $level = $level > 0 && $level <= 9
              ? $level+0
              : $STR2LEVEL{$level} || Carp::croak "$level: not a valid logging level, caught";
  
     my $mask = 1 << $level;
  
     my ($success, %seen, @ctx, $now, @fmt);
  
     do
        {
           # if !ref, then it's a level number
           if (!ref $ctx) {
              $level = $ctx;
           } elsif ($ctx->[1] & $mask and !$seen{$ctx+0}++) {
              # logging/recursing into this context
  
              # level cap
              if ($ctx->[5] > $level) {
                 push @ctx, $level; # restore level when going up in tree
                 $level = $ctx->[5];
              }
  
              # log if log cb
              if ($ctx->[3]) {
                 # logging target found
  
                 local ($!, $@);
  
                 # now get raw message, unless we have it already
                 unless ($now) {
                    $format = $format->() if ref $format;
                    $format = sprintf $format, @args if @args;
                    $format =~ s/\n$//;
                    $now = _ts;
                 };
  
                 # format msg
                 my $str = $ctx->[4]
                    ? $ctx->[4]($now, $_[0], $level, $format)
                    : ($fmt[$level] ||= default_format $now, $_[0], $level, $format);
  
                 $success = 1;
  
                 $ctx->[3]($str)
                    or push @ctx, values %{ $ctx->[2] }; # not consumed - propagate
              } else {
                 push @ctx, values %{ $ctx->[2] }; # not masked - propagate
              }
           }
        }
     while $ctx = pop @ctx;
  
     fatal_exit if $level <= 1;
  
     $success
  }
  
  sub log($$;@) {
     _log
        $CTX{ (caller)[0] } ||= _pkg_ctx +(caller)[0],
        @_;
  }
  
  =item $logger = AnyEvent::Log::logger $level[, \$enabled]
  
  Creates a code reference that, when called, acts as if the
  C<AnyEvent::Log::log> function was called at this point with the given
  level. C<$logger> is passed a C<$msg> and optional C<@args>, just as with
  the C<AnyEvent::Log::log> function:
  
     my $debug_log = AnyEvent::Log::logger "debug";
  
     $debug_log->("debug here");
     $debug_log->("%06d emails processed", 12345);
     $debug_log->(sub { $obj->as_string });
  
  The idea behind this function is to decide whether to log before actually
  logging - when the C<logger> function is called once, but the returned
  logger callback often, then this can be a tremendous speed win.
  
  Despite this speed advantage, changes in logging configuration will
  still be reflected by the logger callback, even if configuration changes
  I<after> it was created.
  
  To further speed up logging, you can bind a scalar variable to the logger,
  which contains true if the logger should be called or not - if it is
  false, calling the logger can be safely skipped. This variable will be
  updated as long as C<$logger> is alive.
  
  Full example:
  
     # near the init section
     use AnyEvent::Log;
  
     my $debug_log = AnyEvent:Log::logger debug => \my $debug;
  
     # and later in your program
     $debug_log->("yo, stuff here") if $debug;
  
     $debug and $debug_log->("123");
  
  =cut
  
  our %LOGGER;
  
  # re-assess logging status for all loggers
  sub _reassess {
     local $SIG{__DIE__};
     my $die = sub { die };
  
     for (@_ ? $LOGGER{$_[0]} : values %LOGGER) {
        my ($ctx, $level, $renabled) = @$_;
  
        # to detect whether a message would be logged, we actually
        # try to log one and die. this isn't fast, but we can be
        # sure that the logging decision is correct :)
  
        $$renabled = !eval {
           _log $ctx, $level, $die;
  
           1
        };
     }
  }
  
  sub _logger {
     my ($ctx, $level, $renabled) = @_;
  
     $$renabled = 1;
  
     my $logger = [$ctx, $level, $renabled];
  
     $LOGGER{$logger+0} = $logger;
  
     _reassess $logger+0;
  
     require AnyEvent::Util unless $AnyEvent::Util::VERSION;
     my $guard = AnyEvent::Util::guard (sub {
        # "clean up"
        delete $LOGGER{$logger+0};
     });
  
     sub {
        $guard if 0; # keep guard alive, but don't cause runtime overhead
  
        _log $ctx, $level, @_
           if $$renabled;
     }
  }
  
  sub logger($;$) {
     _logger
        $CTX{ (caller)[0] } ||= _pkg_ctx +(caller)[0],
        @_
  }
  
  =item AnyEvent::Log::exact_time $on
  
  By default, C<AnyEvent::Log> will use C<AE::now>, i.e. the cached
  eventloop time, for the log timestamps. After calling this function with a
  true value it will instead resort to C<AE::time>, i.e. fetch the current
  time on each log message. This only makes a difference for event loops
  that actually cache the time (such as L<EV> or L<AnyEvent::Loop>).
  
  This setting can be changed at any time by calling this function.
  
  Since C<AnyEvent::Log> has to work even before the L<AnyEvent> has been
  initialised, this switch will also decide whether to use C<CORE::time> or
  C<Time::HiRes::time> when logging a message before L<AnyEvent> becomes
  available.
  
  =item AnyEvent::Log::format_time $timestamp
  
  Formats a timestamp as returned by C<< AnyEvent->now >> or C<<
  AnyEvent->time >> or many other functions in the same way as
  C<AnyEvent::Log> does.
  
  In your main program (as opposed to in your module) you can override
  the default timestamp display format by loading this module and then
  redefining this function.
  
  Most commonly, this function can be used in formatting callbacks.
  
  =item AnyEvent::Log::default_format $time, $ctx, $level, $msg
  
  Format a log message using the given timestamp, logging context, log level
  and log message.
  
  This is the formatting function used to format messages when no custom
  function is provided.
  
  In your main program (as opposed to in your module) you can override the
  default message format by loading this module and then redefining this
  function.
  
  =item AnyEvent::Log::fatal_exit()
  
  This is the function that is called after logging a C<fatal> log
  message. It must not return.
  
  The default implementation simply calls C<exit 1>.
  
  In your main program (as opposed to in your module) you can override
  the fatal exit function by loading this module and then redefining this
  function. Make sure you don't return.
  
  =back
  
  =head1 LOGGING CONTEXTS
  
  This module associates every log message with a so-called I<logging
  context>, based on the package of the caller. Every perl package has its
  own logging context.
  
  A logging context has three major responsibilities: filtering, logging and
  propagating the message.
  
  For the first purpose, filtering, each context has a set of logging
  levels, called the log level mask. Messages not in the set will be ignored
  by this context (masked).
  
  For logging, the context stores a formatting callback (which takes the
  timestamp, context, level and string message and formats it in the way
  it should be logged) and a logging callback (which is responsible for
  actually logging the formatted message and telling C<AnyEvent::Log>
  whether it has consumed the message, or whether it should be propagated).
  
  For propagation, a context can have any number of attached I<slave
  contexts>. Any message that is neither masked by the logging mask nor
  masked by the logging callback returning true will be passed to all slave
  contexts.
  
  Each call to a logging function will log the message at most once per
  context, so it does not matter (much) if there are cycles or if the
  message can arrive at the same context via multiple paths.
  
  =head2 DEFAULTS
  
  By default, all logging contexts have an full set of log levels ("all"), a
  disabled logging callback and the default formatting callback.
  
  Package contexts have the package name as logging title by default.
  
  They have exactly one slave - the context of the "parent" package. The
  parent package is simply defined to be the package name without the last
  component, i.e. C<AnyEvent::Debug::Wrapped> becomes C<AnyEvent::Debug>,
  and C<AnyEvent> becomes ... C<$AnyEvent::Log::COLLECT> which is the
  exception of the rule - just like the "parent" of any single-component
  package name in Perl is C<main>, the default slave of any top-level
  package context is C<$AnyEvent::Log::COLLECT>.
  
  Since perl packages form only an approximate hierarchy, this slave
  context can of course be removed.
  
  All other (anonymous) contexts have no slaves and an empty title by
  default.
  
  When the module is loaded it creates the C<$AnyEvent::Log::LOG> logging
  context that simply logs everything via C<warn>, without propagating
  anything anywhere by default.  The purpose of this context is to provide
  a convenient place to override the global logging target or to attach
  additional log targets. It's not meant for filtering.
  
  It then creates the C<$AnyEvent::Log::FILTER> context whose
  purpose is to suppress all messages with priority higher
  than C<$ENV{PERL_ANYEVENT_VERBOSE}>. It then attached the
  C<$AnyEvent::Log::LOG> context to it. The purpose of the filter context
  is to simply provide filtering according to some global log level.
  
  Finally it creates the top-level package context C<$AnyEvent::Log::COLLECT>
  and attaches the C<$AnyEvent::Log::FILTER> context to it, but otherwise
  leaves it at default config. Its purpose is simply to collect all log
  messages system-wide.
  
  The hierarchy is then:
  
     any package, eventually -> $COLLECT -> $FILTER -> $LOG
  
  The effect of all this is that log messages, by default, wander up to the
  C<$AnyEvent::Log::COLLECT> context where all messages normally end up,
  from there to C<$AnyEvent::Log::FILTER> where log messages with lower
  priority then C<$ENV{PERL_ANYEVENT_VERBOSE}> will be filtered out and then
  to the C<$AnyEvent::Log::LOG> context to be passed to C<warn>.
  
  This makes it easy to set a global logging level (by modifying $FILTER),
  but still allow other contexts to send, for example, their debug and trace
  messages to the $LOG target despite the global logging level, or to attach
  additional log targets that log messages, regardless of the global logging
  level.
  
  It also makes it easy to modify the default warn-logger ($LOG) to
  something that logs to a file, or to attach additional logging targets
  (such as loggign to a file) by attaching it to $FILTER.
  
  =head2 CREATING/FINDING/DESTROYING CONTEXTS
  
  =over 4
  
  =item $ctx = AnyEvent::Log::ctx [$pkg]
  
  This function creates or returns a logging context (which is an object).
  
  If a package name is given, then the context for that package is
  returned. If it is called without any arguments, then the context for the
  callers package is returned (i.e. the same context as a C<AE::log> call
  would use).
  
  If C<undef> is given, then it creates a new anonymous context that is not
  tied to any package and is destroyed when no longer referenced.
  
  =cut
  
  sub ctx(;$) {
     my $pkg = @_ ? shift : (caller)[0];
  
     ref $pkg
        ? $pkg
        : defined $pkg
           ? $CTX{$pkg} ||= AnyEvent::Log::_pkg_ctx $pkg
           : bless [undef, (1 << 10) - 1 - 1], "AnyEvent::Log::Ctx"
  }
  
  =item AnyEvent::Log::reset
  
  Resets all package contexts and recreates the default hierarchy if
  necessary, i.e. resets the logging subsystem to defaults, as much as
  possible. This process keeps references to contexts held by other parts of
  the program intact.
  
  This can be used to implement config-file (re-)loading: before loading a
  configuration, reset all contexts.
  
  =cut
  
  our $ORIG_VERBOSE = $AnyEvent::VERBOSE;
  $AnyEvent::VERBOSE = 9;
  
  sub reset {
     # hard to kill complex data structures
     # we "recreate" all package loggers and reset the hierarchy
     while (my ($k, $v) = each %CTX) {
        @$v = ($k, (1 << 10) - 1 - 1, { });
  
        $v->attach ($k =~ /^(.+)::/ ? $CTX{$1} : $AnyEvent::Log::COLLECT);
     }
  
     @$_ = ($_->[0], (1 << 10) - 1 - 1)
        for $LOG, $FILTER, $COLLECT;
  
     #$LOG->slaves;
     $LOG->title ('$AnyEvent::Log::LOG');
     $LOG->log_to_warn;
  
     $FILTER->slaves ($LOG);
     $FILTER->title ('$AnyEvent::Log::FILTER');
     $FILTER->level ($ORIG_VERBOSE);
  
     $COLLECT->slaves ($FILTER);
     $COLLECT->title ('$AnyEvent::Log::COLLECT');
  
     _reassess;
  }
  
  # override AE::log/logger
  *AnyEvent::log    = *AE::log    = \&log;
  *AnyEvent::logger = *AE::logger = \&logger;
  
  # convert AnyEvent loggers to AnyEvent::Log loggers
  $_->[0] = ctx $_->[0] # convert "pkg" to "ctx"
     for values %LOGGER;
  
  # create the default logger contexts
  $LOG     = ctx undef;
  $FILTER  = ctx undef;
  $COLLECT = ctx undef;
  
  AnyEvent::Log::reset;
  
  # hello, CPAN, please catch me
  package AnyEvent::Log::LOG;
  package AE::Log::LOG;
  package AnyEvent::Log::FILTER;
  package AE::Log::FILTER;
  package AnyEvent::Log::COLLECT;
  package AE::Log::COLLECT;
  
  package AnyEvent::Log::Ctx;
  
  =item $ctx = new AnyEvent::Log::Ctx methodname => param...
  
  This is a convenience constructor that makes it simpler to construct
  anonymous logging contexts.
  
  Each key-value pair results in an invocation of the method of the same
  name as the key with the value as parameter, unless the value is an
  arrayref, in which case it calls the method with the contents of the
  array. The methods are called in the same order as specified.
  
  Example: create a new logging context and set both the default logging
  level, some slave contexts and a logging callback.
  
     $ctx = new AnyEvent::Log::Ctx
        title   => "dubious messages",
        level   => "error",
        log_cb  => sub { print STDOUT shift; 0 },
        slaves  => [$ctx1, $ctx, $ctx2],
     ;
  
  =back
  
  =cut
  
  sub new {
     my $class = shift;
  
     my $ctx = AnyEvent::Log::ctx undef;
  
     while (@_) {
        my ($k, $v) = splice @_, 0, 2;
        $ctx->$k (ref $v eq "ARRAY" ? @$v : $v);
     }
  
     bless $ctx, $class # do we really support subclassing, hmm?
  }
  
  
  =head2 CONFIGURING A LOG CONTEXT
  
  The following methods can be used to configure the logging context.
  
  =over 4
  
  =item $ctx->title ([$new_title])
  
  Returns the title of the logging context - this is the package name, for
  package contexts, and a user defined string for all others.
  
  If C<$new_title> is given, then it replaces the package name or title.
  
  =cut
  
  sub title {
     $_[0][0] = $_[1] if @_ > 1;
     $_[0][0]
  }
  
  =back
  
  =head3 LOGGING LEVELS
  
  The following methods deal with the logging level set associated with the
  log context.
  
  The most common method to use is probably C<< $ctx->level ($level) >>,
  which configures the specified and any higher priority levels.
  
  All functions which accept a list of levels also accept the special string
  C<all> which expands to all logging levels.
  
  =over 4
  
  =item $ctx->levels ($level[, $level...)
  
  Enables logging for the given levels and disables it for all others.
  
  =item $ctx->level ($level)
  
  Enables logging for the given level and all lower level (higher priority)
  ones. In addition to normal logging levels, specifying a level of C<0> or
  C<off> disables all logging for this level.
  
  Example: log warnings, errors and higher priority messages.
  
     $ctx->level ("warn");
     $ctx->level (5); # same thing, just numeric
  
  =item $ctx->enable ($level[, $level...])
  
  Enables logging for the given levels, leaving all others unchanged.
  
  =item $ctx->disable ($level[, $level...])
  
  Disables logging for the given levels, leaving all others unchanged.
  
  =item $ctx->cap ($level)
  
  Caps the maximum priority to the given level, for all messages logged
  to, or passing through, this context. That is, while this doesn't affect
  whether a message is logged or passed on, the maximum priority of messages
  will be limited to the specified level - messages with a higher priority
  will be set to the specified priority.
  
  Another way to view this is that C<< ->level >> filters out messages with
  a too low priority, while C<< ->cap >> modifies messages with a too high
  priority.
  
  This is useful when different log targets have different interpretations
  of priority. For example, for a specific command line program, a wrong
  command line switch might well result in a C<fatal> log message, while the
  same message, logged to syslog, is likely I<not> fatal to the system or
  syslog facility as a whole, but more likely a mere C<error>.
  
  This can be modeled by having a stderr logger that logs messages "as-is"
  and a syslog logger that logs messages with a level cap of, say, C<error>,
  or, for truly system-critical components, actually C<critical>.
  
  =cut
  
  sub _lvl_lst {
     map {
        $_ > 0 && $_ <= 9 ? $_+0
        : $_ eq "all"     ? (1 .. 9)
        : $STR2LEVEL{$_} || Carp::croak "$_: not a valid logging level, caught"
     } @_
  }
  
  sub _lvl {
     $_[0] =~ /^(?:0|off|none)$/ ? 0 : (_lvl_lst $_[0])[-1]
  }
  
  our $NOP_CB = sub { 0 };
  
  sub levels {
     my $ctx = shift;
     $ctx->[1] = 0;
     $ctx->[1] |= 1 << $_
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub level {
     my $ctx = shift;
     $ctx->[1] = ((1 << &_lvl) - 1) << 1;
     AnyEvent::Log::_reassess;
  }
  
  sub enable {
     my $ctx = shift;
     $ctx->[1] |= 1 << $_
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub disable {
     my $ctx = shift;
     $ctx->[1] &= ~(1 << $_)
        for &_lvl_lst;
     AnyEvent::Log::_reassess;
  }
  
  sub cap {
     my $ctx = shift;
     $ctx->[5] = &_lvl;
  }
  
  =back
  
  =head3 SLAVE CONTEXTS
  
  The following methods attach and detach another logging context to a
  logging context.
  
  Log messages are propagated to all slave contexts, unless the logging
  callback consumes the message.
  
  =over 4
  
  =item $ctx->attach ($ctx2[, $ctx3...])
  
  Attaches the given contexts as slaves to this context. It is not an error
  to add a context twice (the second add will be ignored).
  
  A context can be specified either as package name or as a context object.
  
  =item $ctx->detach ($ctx2[, $ctx3...])
  
  Removes the given slaves from this context - it's not an error to attempt
  to remove a context that hasn't been added.
  
  A context can be specified either as package name or as a context object.
  
  =item $ctx->slaves ($ctx2[, $ctx3...])
  
  Replaces all slaves attached to this context by the ones given.
  
  =cut
  
  sub attach {
     my $ctx = shift;
  
     $ctx->[2]{$_+0} = $_
        for map { AnyEvent::Log::ctx $_ } @_;
     AnyEvent::Log::_reassess;
  }
  
  sub detach {
     my $ctx = shift;
  
     delete $ctx->[2]{$_+0}
        for map { AnyEvent::Log::ctx $_ } @_;
     AnyEvent::Log::_reassess;
  }
  
  sub slaves {
     undef $_[0][2];
     &attach;
     AnyEvent::Log::_reassess;
  }
  
  =back
  
  =head3 LOG TARGETS
  
  The following methods configure how the logging context actually does
  the logging (which consists of formatting the message and printing it or
  whatever it wants to do with it).
  
  =over 4
  
  =item $ctx->log_cb ($cb->($str))
  
  Replaces the logging callback on the context (C<undef> disables the
  logging callback).
  
  The logging callback is responsible for handling formatted log messages
  (see C<fmt_cb> below) - normally simple text strings that end with a
  newline (and are possibly multiline themselves).
  
  It also has to return true iff it has consumed the log message, and false
  if it hasn't. Consuming a message means that it will not be sent to any
  slave context. When in doubt, return C<0> from your logging callback.
  
  Example: a very simple logging callback, simply dump the message to STDOUT
  and do not consume it.
  
     $ctx->log_cb (sub { print STDERR shift; 0 });
  
  You can filter messages by having a log callback that simply returns C<1>
  and does not do anything with the message, but this counts as "message
  being logged" and might not be very efficient.
  
  Example: propagate all messages except for log levels "debug" and
  "trace". The messages will still be generated, though, which can slow down
  your program.
  
     $ctx->levels ("debug", "trace");
     $ctx->log_cb (sub { 1 }); # do not log, but eat debug and trace messages
  
  =item $ctx->fmt_cb ($fmt_cb->($timestamp, $orig_ctx, $level, $message))
  
  Replaces the formatting callback on the context (C<undef> restores the
  default formatter).
  
  The callback is passed the (possibly fractional) timestamp, the original
  logging context (object, not title), the (numeric) logging level and
  the raw message string and needs to return a formatted log message. In
  most cases this will be a string, but it could just as well be an array
  reference that just stores the values.
  
  If, for some reason, you want to use C<caller> to find out more about the
  logger then you should walk up the call stack until you are no longer
  inside the C<AnyEvent::Log> package.
  
  To implement your own logging callback, you might find the
  C<AnyEvent::Log::format_time> and C<AnyEvent::Log::default_format>
  functions useful.
  
  Example: format the message just as AnyEvent::Log would, by letting
  AnyEvent::Log do the work. This is a good basis to design a formatting
  callback that only changes minor aspects of the formatting.
  
     $ctx->fmt_cb (sub {
        my ($time, $ctx, $lvl, $msg) = @_;
  
        AnyEvent::Log::default_format $time, $ctx, $lvl, $msg
     });
  
  Example: format just the raw message, with numeric log level in angle
  brackets.
  
     $ctx->fmt_cb (sub {
        my ($time, $ctx, $lvl, $msg) = @_;
  
        "<$lvl>$msg\n"
     });
  
  Example: return an array reference with just the log values, and use
  C<PApp::SQL::sql_exec> to store the message in a database.
  
     $ctx->fmt_cb (sub { \@_ });
     $ctx->log_cb (sub {
        my ($msg) = @_;
  
        sql_exec "insert into log (when, subsys, prio, msg) values (?, ?, ?, ?)",
                 $msg->[0] + 0,
                 "$msg->[1]",
                 $msg->[2] + 0,
                 "$msg->[3]";
  
        0
     });
  
  =item $ctx->log_to_warn
  
  Sets the C<log_cb> to simply use C<CORE::warn> to report any messages
  (usually this logs to STDERR).
  
  =item $ctx->log_to_file ($path)
  
  Sets the C<log_cb> to log to a file (by appending), unbuffered. The
  function might return before the log file has been opened or created.
  
  =item $ctx->log_to_path ($path)
  
  Same as C<< ->log_to_file >>, but opens the file for each message. This
  is much slower, but allows you to change/move/rename/delete the file at
  basically any time.
  
  Needless(?) to say, if you do not want to be bitten by some evil person
  calling C<chdir>, the path should be absolute. Doesn't help with
  C<chroot>, but hey...
  
  =item $ctx->log_to_syslog ([$facility])
  
  Logs all messages via L<Sys::Syslog>, mapping C<trace> to C<debug> and
  all the others in the obvious way. If specified, then the C<$facility> is
  used as the facility (C<user>, C<auth>, C<local0> and so on). The default
  facility is C<user>.
  
  Note that this function also sets a C<fmt_cb> - the logging part requires
  an array reference with [$level, $str] as input.
  
  =cut
  
  sub log_cb {
     my ($ctx, $cb) = @_;
  
     $ctx->[3] = $cb;
  }
  
  sub fmt_cb {
     my ($ctx, $cb) = @_;
  
     $ctx->[4] = $cb;
  }
  
  sub log_to_warn {
     my ($ctx, $path) = @_;
  
     $ctx->log_cb (sub {
        warn shift;
        0
     });
  }
  
  # this function is a good example of why threads are a must,
  # simply for priority inversion.
  sub _log_to_disk {
     # eval'uating this at runtime saves 220kb rss - perl has become
     # an insane memory waster.
     eval q{ # poor man's autoloading {}
        sub _log_to_disk {
           my ($ctx, $path, $keepopen) = @_;
  
           my $fh;
           my @queue;
           my $delay;
           my $disable;
  
           use AnyEvent::IO ();
  
           my $kick = sub {
              undef $delay;
              return unless @queue;
              $delay = 1;
  
              # we pass $kick to $kick, so $kick itself doesn't keep a reference to $kick.
              my $kick = shift;
  
              # write one or more messages
              my $write = sub {
                 # we write as many messages as have been queued
                 my $data = join "", @queue;
                 @queue = ();
  
                 AnyEvent::IO::aio_write $fh, $data, sub {
                    $disable = 1;
                    @_
                       ? ($_[0] == length $data or AE::log 4 => "unable to write to logfile '$path': short write")
                       :                           AE::log 4 => "unable to write to logfile '$path': $!";
                    undef $disable;
  
                    if ($keepopen) {
                       $kick->($kick);
                    } else {
                       AnyEvent::IO::aio_close ($fh, sub {
                          undef $fh;
                          $kick->($kick);
                       });
                    }
                 };
              };
  
              if ($fh) {
                 $write->();
              } else {
                 AnyEvent::IO::aio_open
                    $path,
                    AnyEvent::IO::O_CREAT | AnyEvent::IO::O_WRONLY | AnyEvent::IO::O_APPEND,
                    0666,
                    sub {
                       $fh = shift
                          or do {
                             $disable = 1;
                             AE::log 4 => "unable to open logfile '$path': $!";
                             undef $disable;
                             return;
                          };
  
                       $write->();
                    }
                 ;
              }
           };
  
           $ctx->log_cb (sub {
              return if $disable;
              push @queue, shift;
              $kick->($kick) unless $delay;
              0
           });
  
           $kick->($kick) if $keepopen; # initial open
        };
     };
     die if $@;
     &_log_to_disk
  }
  
  sub log_to_file {
     my ($ctx, $path) = @_;
  
     _log_to_disk $ctx, $path, 1;
  }
  
  sub log_to_path {
     my ($ctx, $path) = @_;
  
     _log_to_disk $ctx, $path, 0;
  }
  
  sub log_to_syslog {
     my ($ctx, $facility) = @_;
  
     require Sys::Syslog;
  
     $ctx->fmt_cb (sub {
        my $str = $_[3];
        $str =~ s/\n(?=.)/\n+ /g;
  
        [$_[2], "($_[1][0]) $str"]
     });
  
     $facility ||= "user";
  
     $ctx->log_cb (sub {
        my $lvl = $_[0][0] < 9 ? $_[0][0] : 8;
  
        Sys::Syslog::syslog ("$facility|" . ($lvl - 1), $_)
           for split /\n/, $_[0][1];
  
        0
     });
  }
  
  =back
  
  =head3 MESSAGE LOGGING
  
  These methods allow you to log messages directly to a context, without
  going via your package context.
  
  =over 4
  
  =item $ctx->log ($level, $msg[, @params])
  
  Same as C<AnyEvent::Log::log>, but uses the given context as log context.
  
  Example: log a message in the context of another package.
  
     (AnyEvent::Log::ctx "Other::Package")->log (warn => "heely bo");
  
  =item $logger = $ctx->logger ($level[, \$enabled])
  
  Same as C<AnyEvent::Log::logger>, but uses the given context as log
  context.
  
  =cut
  
  *log    = \&AnyEvent::Log::_log;
  *logger = \&AnyEvent::Log::_logger;
  
  =back
  
  =cut
  
  package AnyEvent::Log;
  
  =head1 CONFIGURATION VIA $ENV{PERL_ANYEVENT_LOG}
  
  Logging can also be configured by setting the environment variable
  C<PERL_ANYEVENT_LOG> (or C<AE_LOG>).
  
  The value consists of one or more logging context specifications separated
  by C<:> or whitespace. Each logging specification in turn starts with a
  context name, followed by C<=>, followed by zero or more comma-separated
  configuration directives, here are some examples:
  
     # set default logging level
     filter=warn
  
     # log to file instead of to stderr
     log=file=/tmp/mylog
  
     # log to file in addition to stderr
     log=+%file:%file=file=/tmp/mylog
  
     # enable debug log messages, log warnings and above to syslog
     filter=debug:log=+%warnings:%warnings=warn,syslog=LOG_LOCAL0
  
     # log trace messages (only) from AnyEvent::Debug to file
     AnyEvent::Debug=+%trace:%trace=only,trace,file=/tmp/tracelog
  
  A context name in the log specification can be any of the following:
  
  =over 4
  
  =item C<collect>, C<filter>, C<log>
  
  Correspond to the three predefined C<$AnyEvent::Log::COLLECT>,
  C<AnyEvent::Log::FILTER> and C<$AnyEvent::Log::LOG> contexts.
  
  =item C<%name>
  
  Context names starting with a C<%> are anonymous contexts created when the
  name is first mentioned. The difference to package contexts is that by
  default they have no attached slaves.
  
  This makes it possible to create new log contexts that can be refered to
  multiple times by name within the same log specification.
  
  =item a perl package name
  
  Any other string references the logging context associated with the given
  Perl C<package>. In the unlikely case where you want to specify a package
  context that matches on of the other context name forms, you can add a
  C<::> to the package name to force interpretation as a package.
  
  =back
  
  The configuration specifications can be any number of the following:
  
  =over 4
  
  =item C<stderr>
  
  Configures the context to use Perl's C<warn> function (which typically
  logs to C<STDERR>). Works like C<log_to_warn>.
  
  =item C<file=>I<path>
  
  Configures the context to log to a file with the given path. Works like
  C<log_to_file>.
  
  =item C<path=>I<path>
  
  Configures the context to log to a file with the given path. Works like
  C<log_to_path>.
  
  =item C<syslog> or C<syslog=>I<expr>
  
  Configures the context to log to syslog. If I<expr> is given, then it is
  evaluated in the L<Sys::Syslog> package, so you could use:
  
     log=syslog=LOG_LOCAL0
  
  =item C<nolog>
  
  Configures the context to not log anything by itself, which is the
  default. Same as C<< $ctx->log_cb (undef) >>.
  
  =item C<cap=>I<level>
  
  Caps logging messages entering this context at the given level, i.e.
  reduces the priority of messages with higher priority than this level. The
  default is C<0> (or C<off>), meaning the priority will not be touched.
  
  =item C<0> or C<off>
  
  Sets the logging level of the context to C<0>, i.e. all messages will be
  filtered out.
  
  =item C<all>
  
  Enables all logging levels, i.e. filtering will effectively be switched
  off (the default).
  
  =item C<only>
  
  Disables all logging levels, and changes the interpretation of following
  level specifications to enable the specified level only.
  
  Example: only enable debug messages for a context.
  
     context=only,debug
  
  =item C<except>
  
  Enables all logging levels, and changes the interpretation of following
  level specifications to disable that level. Rarely used.
  
  Example: enable all logging levels except fatal and trace (this is rather
  nonsensical).
  
     filter=exept,fatal,trace
  
  =item C<level>
  
  Enables all logging levels, and changes the interpretation of following
  level specifications to be "that level or any higher priority
  message". This is the default.
  
  Example: log anything at or above warn level.
  
     filter=warn
  
     # or, more verbose
     filter=only,level,warn
  
  =item C<1>..C<9> or a logging level name (C<error>, C<debug> etc.)
  
  A numeric loglevel or the name of a loglevel will be interpreted according
  to the most recent C<only>, C<except> or C<level> directive. By default,
  specifying a logging level enables that and any higher priority messages.
  
  =item C<+>I<context>
  
  Attaches the named context as slave to the context.
  
  =item C<+>
  
  A lone C<+> detaches all contexts, i.e. clears the slave list from the
  context. Anonymous (C<%name>) contexts have no attached slaves by default,
  but package contexts have the parent context as slave by default.
  
  Example: log messages from My::Module to a file, do not send them to the
  default log collector.
  
     My::Module=+,file=/tmp/mymodulelog
  
  =back
  
  Any character can be escaped by prefixing it with a C<\> (backslash), as
  usual, so to log to a file containing a comma, colon, backslash and some
  spaces in the filename, you would do this:
  
     PERL_ANYEVENT_LOG='log=file=/some\ \:file\ with\,\ \\-escapes'
  
  Since whitespace (which includes newlines) is allowed, it is fine to
  specify multiple lines in C<PERL_ANYEVENT_LOG>, e.g.:
  
     PERL_ANYEVENT_LOG="
        filter=warn
        AnyEvent::Debug=+%trace
        %trace=only,trace,+log
     " myprog
  
  Also, in the unlikely case when you want to concatenate specifications,
  use whitespace as separator, as C<::> will be interpreted as part of a
  module name, an empty spec with two separators:
  
     PERL_ANYEVENT_LOG="$PERL_ANYEVENT_LOG MyMod=debug"
  
  =cut
  
  for (my $spec = $ENV{PERL_ANYEVENT_LOG}) {
     my %anon;
  
     my $pkg = sub {
        $_[0] eq "log"              ? $LOG
        : $_[0] eq "filter"         ? $FILTER
        : $_[0] eq "collect"        ? $COLLECT
        : $_[0] =~ /^%(.+)$/        ? ($anon{$1} ||= do { my $ctx = ctx undef; $ctx->[0] = $_[0]; $ctx })
        : $_[0] =~ /^(.*?)(?:::)?$/ ? ctx "$1" # egad :/
        : die # never reached?
     };
  
     /\G[[:space:]]+/gc; # skip initial whitespace
  
     while (/\G((?:[^:=[:space:]]+|::|\\.)+)=/gc) {
        my $ctx = $pkg->($1);
        my $level = "level";
  
        while (/\G((?:[^,:[:space:]]+|::|\\.)+)/gc) {
           for ("$1") {
              if ($_ eq "stderr"               ) { $ctx->log_to_warn;
              } elsif (/^file=(.+)/            ) { $ctx->log_to_file ("$1");
              } elsif (/^path=(.+)/            ) { $ctx->log_to_path ("$1");
              } elsif (/^syslog(?:=(.*))?/     ) { require Sys::Syslog; $ctx->log_to_syslog ("$1");
              } elsif ($_ eq "nolog"           ) { $ctx->log_cb (undef);
              } elsif (/^cap=(.+)/             ) { $ctx->cap ("$1");
              } elsif (/^\+(.+)$/              ) { $ctx->attach ($pkg->("$1"));
              } elsif ($_ eq "+"               ) { $ctx->slaves;
              } elsif ($_ eq "off" or $_ eq "0") { $ctx->level (0);
              } elsif ($_ eq "all"             ) { $ctx->level ("all");
              } elsif ($_ eq "level"           ) { $ctx->level ("all"); $level = "level";
              } elsif ($_ eq "only"            ) { $ctx->level ("off"); $level = "enable";
              } elsif ($_ eq "except"          ) { $ctx->level ("all"); $level = "disable";
              } elsif (/^\d$/                  ) { $ctx->$level ($_);
              } elsif (exists $STR2LEVEL{$_}   ) { $ctx->$level ($_);
              } else                             { die "PERL_ANYEVENT_LOG ($spec): parse error at '$_'\n";
              }
           }
  
           /\G,/gc or last;
        }
  
        /\G[:[:space:]]+/gc or last;
     }
  
     /\G[[:space:]]+/gc; # skip trailing whitespace
  
     if (/\G(.+)/g) {
        die "PERL_ANYEVENT_LOG ($spec): parse error at '$1'\n";
     }
  }
  
  =head1 EXAMPLES
  
  This section shows some common configurations, both as code, and as
  C<PERL_ANYEVENT_LOG> string.
  
  =over 4
  
  =item Setting the global logging level.
  
  Either put C<PERL_ANYEVENT_VERBOSE=><number> into your environment before
  running your program, use C<PERL_ANYEVENT_LOG> or modify the log level of
  the root context at runtime:
  
     PERL_ANYEVENT_VERBOSE=5 ./myprog
  
     PERL_ANYEVENT_LOG=log=warn
  
     $AnyEvent::Log::FILTER->level ("warn");
  
  =item Append all messages to a file instead of sending them to STDERR.
  
  This is affected by the global logging level.
  
     $AnyEvent::Log::LOG->log_to_file ($path);
  
     PERL_ANYEVENT_LOG=log=file=/some/path
  
  =item Write all messages with priority C<error> and higher to a file.
  
  This writes them only when the global logging level allows it, because
  it is attached to the default context which is invoked I<after> global
  filtering.
  
     $AnyEvent::Log::FILTER->attach (
        new AnyEvent::Log::Ctx log_to_file => $path);
  
     PERL_ANYEVENT_LOG=filter=+%filelogger:%filelogger=file=/some/path
  
  This writes them regardless of the global logging level, because it is
  attached to the toplevel context, which receives all messages I<before>
  the global filtering.
  
     $AnyEvent::Log::COLLECT->attach (
        new AnyEvent::Log::Ctx log_to_file => $path);
  
     PERL_ANYEVENT_LOG=%filelogger=file=/some/path:collect=+%filelogger
  
  In both cases, messages are still written to STDERR.
  
  =item Additionally log all messages with C<warn> and higher priority to
  C<syslog>, but cap at C<error>.
  
  This logs all messages to the default log target, but also logs messages
  with priority C<warn> or higher (and not filtered otherwise) to syslog
  facility C<user>. Messages with priority higher than C<error> will be
  logged with level C<error>.
  
     $AnyEvent::Log::LOG->attach (
        new AnyEvent::Log::Ctx
           level  => "warn",
           cap    => "error",
           syslog => "user",
     );
  
     PERL_ANYEVENT_LOG=log=+%syslog:%syslog=warn,cap=error,syslog
  
  =item Write trace messages (only) from L<AnyEvent::Debug> to the default logging target(s).
  
  Attach the C<$AnyEvent::Log::LOG> context to the C<AnyEvent::Debug>
  context - this simply circumvents the global filtering for trace messages.
  
     my $debug = AnyEvent::Debug->AnyEvent::Log::ctx;
     $debug->attach ($AnyEvent::Log::LOG);
  
     PERL_ANYEVENT_LOG=AnyEvent::Debug=+log
  
  This of course works for any package, not just L<AnyEvent::Debug>, but
  assumes the log level for AnyEvent::Debug hasn't been changed from the
  default.
  
  =back
  
  =head1 ASYNCHRONOUS DISK I/O
  
  This module uses L<AnyEvent::IO> to actually write log messages (in
  C<log_to_file> and C<log_to_path>), so it doesn't block your program when
  the disk is busy and a non-blocking L<AnyEvent::IO> backend is available.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_LOG

$fatpacked{"AnyEvent/Loop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_LOOP';
  =head1 NAME
  
  AnyEvent::Loop - AnyEvent's Pure-Perl event loop
  
  =head1 SYNOPSIS
  
     use AnyEvent;
     # use AnyEvent::Loop;
    
     # this module gets loaded automatically when no other loop can be found
  
     # Explicit use:
     use AnyEvent::Loop;
     use AnyEvent;
  
     ...
  
     AnyEvent::Loop::run; # run the event loop
  
  =head1 DESCRIPTION
  
  This module provides an event loop for AnyEvent in case no other event
  loop could be found or loaded. You don't have to do anything to make it
  work with AnyEvent except by possibly loading it before creating the first
  AnyEvent watcher.
  
  This module is I<not> some loop abstracion used by AnyEvent, but just
  another event loop like EV or Glib, just written in pure perl and
  delivered with AnyEvent, so AnyEvent always works, even in the absence of
  any other backend.
  
  If you want to use this module instead of autoloading a potentially better
  event loop you can simply load it (and no other event loops) before
  creating the first watcher.
  
  As for performance, this module is on par with (and usually faster than)
  most select/poll-based C event modules such as Event or Glib (it does not
  even come close to EV, though), with respect to I/O watchers. Timers are
  handled less optimally, but for many common tasks, it is still on par with
  event loops written in C.
  
  This event loop has been optimised for the following use cases:
  
  =over 4
  
  =item monotonic clock is available
  
  This module will use the POSIX monotonic clock option (if it can be
  detected at runtime) or the POSIX C<times> function (if the resolution
  is at least 100Hz), in which case it will not suffer adversely from time
  jumps.
  
  If no monotonic clock is available, this module will not attempt to
  correct for time jumps in any way.
  
  The clock chosen will be reported if the environment variable
  C<$PERL_ANYEVENT_VERBOSE> is set to 8 or higher.
  
  =item any number of watchers on one fd
  
  Supporting a large number of watchers per fd is purely a dirty benchmark
  optimisation not relevant in practise. The more common case of having one
  watcher per fd/poll combo is special-cased, however, and therefore fast,
  too.
  
  =item relatively few active fds per C<select> call
  
  This module expects that only a tiny amount of fds is active at any one
  time. This is relatively typical of larger servers (but not the case where
  C<select> traditionally is fast), at the expense of the "dense activity
  case" where most of the fds are active (which suits C<select>).
  
  The optimal implementation of the "dense" case is not much faster, though,
  so the module should behave very well in most cases, subject to the bad
  scalability of C<select> in the presence of a large number of inactive
  file descriptors.
  
  =item lots of timer changes/iteration, or none at all
  
  This module sorts the timer list using perl's C<sort>, even though a total
  ordering is not required for timers internally.
  
  This sorting is expensive, but means sorting can be avoided unless the
  timer list has changed in a way that requires a new sort.
  
  This means that adding lots of timers is very efficient, as well as not
  changing the timers. Advancing timers (e.g. recreating a timeout watcher
  on activity) is also relatively efficient, for example, if you have a
  large number of timeout watchers that time out after 10 seconds, then the
  timer list will be sorted only once every 10 seconds.
  
  This should not have much of an impact unless you have hundreds or
  thousands of timers, though, or your timers have very small timeouts.
  
  =back
  
  =head1 FUNCTIONS
  
  The only user-visible functions provided by this module loop related -
  watchers are created via the normal AnyEvent mechanisms.
  
  =over 4
  
  =item AnyEvent::Loop::run
  
  Run the event loop, usually the last thing done in the main program when
  you want to use the pure-perl backend.
  
  =item AnyEvent::Loop::one_event
  
  Blocks until at least one new event has been received by the operating
  system, whether or not it was AnyEvent-related.
  
  =back
  
  =cut
  
  package AnyEvent::Loop;
  
  use Scalar::Util qw(weaken);
  use List::Util ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  
  our $VERSION = $AnyEvent::VERSION;
  
  our ($NOW, $MNOW);
  
  sub MAXWAIT() { 3600 } # never sleep for longer than this many seconds
  
  BEGIN {
     local $SIG{__DIE__}; # protect us against the many broken __DIE__ handlers out there
     my $time_hires = eval "use Time::HiRes (); 1";
     my $clk_tck    = eval "use POSIX (); POSIX::sysconf (POSIX::_SC_CLK_TCK ())";
     my $round; # actual granularity
  
     if ($time_hires && eval "&Time::HiRes::clock_gettime (Time::HiRes::CLOCK_MONOTONIC ())") {
        AE::log 8 => "Using CLOCK_MONOTONIC as timebase.";
        *_update_clock = sub {
           $NOW  = &Time::HiRes::time;
           $MNOW = Time::HiRes::clock_gettime (&Time::HiRes::CLOCK_MONOTONIC);
        };
  
     } elsif (100 <= $clk_tck && $clk_tck <= 1000000 && eval { (POSIX::times ())[0] != -1 }) { # -1 is also a valid return value :/
        AE::log 8 => "Using POSIX::times (monotonic) as timebase.";
        my $HZ1 = 1 / $clk_tck;
  
        my $last = (POSIX::times ())[0];
        my $next;
        *_update_clock = sub {
           $NOW  = time; # d'oh
  
           $next = (POSIX::times ())[0];
           # we assume 32 bit signed on wrap but 64 bit will never wrap
           $last -= 4294967296 if $last > $next; # 0x100000000, but perl has problems with big hex constants
           $MNOW += ($next - $last) * $HZ1;
           $last = $next;
        };
  
        $round = $HZ1;
  
     } elsif (eval "use Time::HiRes (); 1") {
        AE::log 8 => "Using Time::HiRes::time (non-monotonic) clock as timebase.";
        *_update_clock = sub {
           $NOW = $MNOW = &Time::HiRes::time;
        };
  
     } else {
        AE::log fatal => "Unable to find sub-second time source (is this really perl 5.8.0 or later?)";
     }
  
     $round = 0.001 if $round < 0.001; # 1ms is enough for us
     $round -= $round * 1e-2; # 0.1 => 0.099
     eval "sub ROUNDUP() { $round }";
  }
  
  _update_clock;
  
  # rely on AnyEvent:Base::time to provide time
  sub now       () { $NOW          }
  sub now_update() { _update_clock }
  
  # fds[0] is for read, fds[1] is for write watchers
  # fds[poll][V] is the bitmask for select
  # fds[poll][W][fd] contains a list of i/o watchers
  # an I/O watcher is a blessed arrayref containing [fh, poll(0/1), callback, queue-index]
  # the queue-index is simply the index in the [W] array, which is only used to improve
  # benchmark results in the synthetic "many watchers on one fd" benchmark.
  my @fds = ([], []);
  sub V() { 0 }
  sub W() { 1 }
  
  my $need_sort = 1e300; # when to re-sort timer list
  my @timer; # list of [ abs-timeout, Timer::[callback] ]
  my @idle;  # list of idle callbacks
  
  # the pure perl mainloop
  sub one_event {
     _update_clock;
  
     # first sort timers if required (slow)
     if ($MNOW >= $need_sort) {
        $need_sort = 1e300;
        @timer = sort { $a->[0] <=> $b->[0] } @timer;
     }
  
     # handle all pending timers
     if (@timer && $timer[0][0] <= $MNOW) {
        do {
           my $timer = shift @timer;
           $timer->[1] && $timer->[1]($timer);
        } while @timer && $timer[0][0] <= $MNOW;
  
     } else {
        # poll for I/O events, we do not do this when there
        # were any pending timers to ensure that one_event returns
        # quickly when some timers have been handled
        my ($wait, @vec, $fds)
           = (@timer && $timer[0][0] < $need_sort ? $timer[0][0] : $need_sort) - $MNOW;
  
        $wait = $wait < MAXWAIT ? $wait + ROUNDUP : MAXWAIT;
        $wait = 0 if @idle;
  
        $fds = CORE::select
          $vec[0] = $fds[0][V],
          $vec[1] = $fds[1][V],
          AnyEvent::WIN32 ? $vec[2] = $fds[1][V] : undef,
          $wait;
  
        _update_clock;
  
        if ($fds > 0) {
           # buggy microshit windows errornously sets exceptfds instead of writefds
           $vec[1] |= $vec[2] if AnyEvent::WIN32;
  
           # prefer write watchers, because they might reduce memory pressure.
           for (1, 0) {
              my $fds = $fds[$_];
  
              # we parse the bitmask by first expanding it into
              # a string of bits
              for (unpack "b*", $vec[$_]) {
                 # and then repeatedly matching a regex against it
                 while (/1/g) {
                    # and use the resulting string position as fd
                    $_ && $_->[2]()
                       for @{ $fds->[W][(pos) - 1] || [] };
                 }
              }
           }
        } elsif (AnyEvent::WIN32 && $fds && $! == AnyEvent::Util::WSAEINVAL) {
           # buggy microshit windoze asks us to route around it
           CORE::select undef, undef, undef, $wait if $wait;
        } elsif (!@timer || $timer[0][0] > $MNOW && !$fds) {
           $$$_ && $$$_->() for @idle = grep $$$_, @idle;
        }
     }
  }
  
  sub run {
     one_event while 1;
  }
  
  sub io($$$) {
     my ($fd, $write, $cb) = @_;
  
     defined ($fd = fileno $fd)
        or $fd = $_[0];
  
     my $self = bless [
        $fd,
        $write,
        $cb,
        # q-idx
     ], "AnyEvent::Loop::io";
  
     my $fds = $fds[$self->[1]];
  
     # add watcher to fds structure
     my $q = $fds->[W][$fd] ||= [];
  
     (vec $fds->[V], $fd, 1) = 1;
  
     $self->[3] = @$q;
     push @$q, $self;
     weaken $q->[-1];
  
     $self
  }
  
  sub AnyEvent::Loop::io::DESTROY {
     my ($self) = @_;
  
     my $fds = $fds[$self->[1]];
  
     # remove watcher from fds structure
     my $fd = $self->[0];
  
     if (@{ $fds->[W][$fd] } == 1) {
        delete $fds->[W][$fd];
        (vec $fds->[V], $fd, 1) = 0;
     } else {
        my $q = $fds->[W][$fd];
        my $last = pop @$q;
  
        if ($last != $self) {
           weaken ($q->[$self->[3]] = $last);
           $last->[3] = $self->[3];
        }
     }
  }
  
  sub timer($$$) {
     my ($after, $interval, $cb) = @_;
     
     my $self;
  
     if ($interval) {
        $self = [$MNOW + $after , sub {
           $_[0][0] = List::Util::max $_[0][0] + $interval, $MNOW;
           push @timer, $_[0];
           weaken $timer[-1];
           $need_sort = $_[0][0] if $_[0][0] < $need_sort;
           &$cb;
        }];
     } else {
        $self = [$MNOW + $after, $cb];
     }
  
     push @timer, $self;
     weaken $timer[-1];
     $need_sort = $self->[0] if $self->[0] < $need_sort;
  
     $self
  }
  
  sub idle($) {
     my $cb = shift;
  
     push @idle, \\$cb;
     weaken ${$idle[-1]};
  
     ${$idle[-1]}
  }
  
  =head1 SEE ALSO
  
  L<AnyEvent>.
  
  =head1 AUTHOR
  
     Marc Lehmann <schmorp@schmorp.de>
     http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_LOOP

$fatpacked{"AnyEvent/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_SOCKET';
  =head1 NAME
  
  AnyEvent::Socket - useful IPv4 and IPv6 stuff. also unix domain sockets. and stuff.
  
  =head1 SYNOPSIS
  
     use AnyEvent::Socket;
     
     tcp_connect "gameserver.deliantra.net", 13327, sub {
        my ($fh) = @_
           or die "gameserver.deliantra.net connect failed: $!";
     
        # enjoy your filehandle
     };
     
     # a simple tcp server
     tcp_server undef, 8888, sub {
        my ($fh, $host, $port) = @_;
     
        syswrite $fh, "The internet is full, $host:$port. Go away!\015\012";
     };
  
  =head1 DESCRIPTION
  
  This module implements various utility functions for handling internet
  protocol addresses and sockets, in an as transparent and simple way as
  possible.
  
  All functions documented without C<AnyEvent::Socket::> prefix are exported
  by default.
  
  =over 4
  
  =cut
  
  package AnyEvent::Socket;
  
  use Carp ();
  use Errno ();
  use Socket qw(AF_INET AF_UNIX SOCK_STREAM SOCK_DGRAM SOL_SOCKET SO_REUSEADDR);
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util qw(guard AF_INET6);
  use AnyEvent::DNS ();
  
  use base 'Exporter';
  
  our @EXPORT = qw(
     getprotobyname
     parse_hostport format_hostport
     parse_ipv4 parse_ipv6
     parse_ip parse_address
     format_ipv4 format_ipv6
     format_ip format_address
     address_family
     inet_aton
     tcp_server
     tcp_connect
  );
  
  our $VERSION = $AnyEvent::VERSION;
  
  =item $ipn = parse_ipv4 $dotted_quad
  
  Tries to parse the given dotted quad IPv4 address and return it in
  octet form (or undef when it isn't in a parsable format). Supports all
  forms specified by POSIX (e.g. C<10.0.0.1>, C<10.1>, C<10.0x020304>,
  C<0x12345678> or C<0377.0377.0377.0377>).
  
  =cut
  
  sub parse_ipv4($) {
     $_[0] =~ /^      (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* )
                (?:\. (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* ) ){0,3}$/x
        or return undef;
  
     @_ = map /^0/ ? oct : $_, split /\./, $_[0];
  
     # check leading parts against range
     return undef if grep $_ >= 256, @_[0 .. @_ - 2];
  
     # check trailing part against range
     return undef if $_[-1] >= 2 ** (8 * (4 - $#_));
  
     pack "N", (pop)
               + ($_[0] << 24)
               + ($_[1] << 16)
               + ($_[2] <<  8);
  }
  
  =item $ipn = parse_ipv6 $textual_ipv6_address
  
  Tries to parse the given IPv6 address and return it in
  octet form (or undef when it isn't in a parsable format).
  
  Should support all forms specified by RFC 2373 (and additionally all IPv4
  forms supported by parse_ipv4). Note that scope-id's are not supported
  (and will not parse).
  
  This function works similarly to C<inet_pton AF_INET6, ...>.
  
  Example:
  
     print unpack "H*", parse_ipv6 "2002:5345::10.0.0.1";
     # => 2002534500000000000000000a000001
  
     print unpack "H*", parse_ipv6 "192.89.98.1";
     # => 00000000000000000000ffffc0596201
  
  =cut
  
  sub parse_ipv6($) {
     # quick test to avoid longer processing
     my $n = $_[0] =~ y/://;
  
     if ($n < 2 || $n > 8) {
        if (!$n && (my $ipn = parse_ipv4 $_[0])) {
           return "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff$ipn";
        }
        return undef;
     }
  
     my ($h, $t) = split /::/, $_[0], 2;
  
     unless (defined $t) {
        ($h, $t) = (undef, $h);
     }
  
     my @h = split /:/, $h, -1;
     my @t = split /:/, $t, -1;
  
     # check for ipv4 tail
     if (@t && $t[-1]=~ /\./) {
        return undef if $n > 6;
  
        my $ipn = parse_ipv4 pop @t
           or return undef;
  
        push @t, map +(sprintf "%x", $_), unpack "nn", $ipn;
     }
  
     # no :: then we need to have exactly 8 components
     return undef unless @h + @t == 8 || $_[0] =~ /::/;
  
     # now check all parts for validity
     return undef if grep !/^[0-9a-fA-F]{1,4}$/, @h, @t;
  
     # now pad...
     push @h, 0 while @h + @t < 8;
  
     # and done
     pack "n*", map hex, @h, @t
  }
  
  =item $token = parse_unix $hostname
  
  This function exists mainly for symmetry to the other C<parse_protocol>
  functions - it takes a hostname and, if it is C<unix/>, it returns a
  special address token, otherwise C<undef>.
  
  The only use for this function is probably to detect whether a hostname
  matches whatever AnyEvent uses for unix domain sockets.
  
  =cut
  
  sub parse_unix($) {
     $_[0] eq "unix/"
        ? pack "S", AF_UNIX
        : undef
  
  }
  
  =item $ipn = parse_address $ip
  
  Combines C<parse_ipv4>, C<parse_ipv6> and C<parse_unix> in one
  function. The address here refers to the host address (not socket address)
  in network form (binary).
  
  If the C<$text> is C<unix/>, then this function returns a special token
  recognised by the other functions in this module to mean "UNIX domain
  socket".
  
  If the C<$text> to parse is a plain IPv4 or mapped IPv4 in IPv6 address
  (:ffff::<ipv4>), then it will be treated as an IPv4 address and four
  octets will be returned. If you don't want that, you have to call
  C<parse_ipv4> and/or C<parse_ipv6> manually (the latter always returning a
  16 octet IPv6 address for mapped IPv4 addresses).
  
  Example:
  
     print unpack "H*", parse_address "10.1.2.3";
     # => 0a010203
  
  =item $ipn = AnyEvent::Socket::aton $ip
  
  Same as C<parse_address>, but not exported (think C<Socket::inet_aton> but
  I<without> name resolution).
  
  =cut
  
  sub parse_address($) {
     for (&parse_ipv6) {
        if ($_) {
           s/^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff//;
           return $_
        } else {
           return &parse_unix
        }
     }
  }
  
  *aton = \&parse_address;
  
  =item ($name, $aliases, $proto) = getprotobyname $name
  
  Works like the builtin function of the same name, except it tries hard to
  work even on broken platforms (well, that's windows), where getprotobyname
  is traditionally very unreliable.
  
  Example: get the protocol number for TCP (usually 6)
  
     my $proto = getprotobyname "tcp";
  
  =cut
  
  # microsoft can't even get getprotobyname working (the etc/protocols file
  # gets lost fairly often on windows), so we have to hardcode some common
  # protocol numbers ourselves.
  our %PROTO_BYNAME;
  
  $PROTO_BYNAME{tcp}  = Socket::IPPROTO_TCP () if defined &Socket::IPPROTO_TCP;
  $PROTO_BYNAME{udp}  = Socket::IPPROTO_UDP () if defined &Socket::IPPROTO_UDP;
  $PROTO_BYNAME{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
  
  sub getprotobyname($) {
     my $name = lc shift;
  
     defined (my $proton = $PROTO_BYNAME{$name} || (getprotobyname $name)[2])
        or return;
  
     ($name, uc $name, $proton)
  }
  
  =item ($host, $service) = parse_hostport $string[, $default_service]
  
  Splitting a string of the form C<hostname:port> is a common
  problem. Unfortunately, just splitting on the colon makes it hard to
  specify IPv6 addresses and doesn't support the less common but well
  standardised C<[ip literal]> syntax.
  
  This function tries to do this job in a better way, it supports (at
  least) the following formats, where C<port> can be a numerical port
  number of a service name, or a C<name=port> string, and the C< port> and
  C<:port> parts are optional. Also, everywhere where an IP address is
  supported a hostname or unix domain socket address is also supported (see
  C<parse_unix>), and strings starting with C</> will also be interpreted as
  unix domain sockets.
  
     hostname:port    e.g. "www.linux.org", "www.x.de:443", "www.x.de:https=443",
     ipv4:port        e.g. "198.182.196.56", "127.1:22"
     ipv6             e.g. "::1", "affe::1"
     [ipv4or6]:port   e.g. "[::1]", "[10.0.1]:80"
     [ipv4or6] port   e.g. "[127.0.0.1]", "[www.x.org] 17"
     ipv4or6 port     e.g. "::1 443", "10.0.0.1 smtp"
     unix/:path       e.g. "unix/:/path/to/socket"
     /path            e.g. "/path/to/socket"
  
  It also supports defaulting the service name in a simple way by using
  C<$default_service> if no service was detected. If neither a service was
  detected nor a default was specified, then this function returns the
  empty list. The same happens when a parse error was detected, such as a
  hostname with a colon in it (the function is rather forgiving, though).
  
  Example:
  
    print join ",", parse_hostport "localhost:443";
    # => "localhost,443"
  
    print join ",", parse_hostport "localhost", "https";
    # => "localhost,https"
  
    print join ",", parse_hostport "[::1]";
    # => "," (empty list)
  
    print join ",", parse_hostport "/tmp/debug.sock";
    # => "unix/", "/tmp/debug.sock"
  
  =cut
  
  sub parse_hostport($;$) {
     my ($host, $port);
  
     for ("$_[0]") { # work on a copy, just in case, and also reset pos
  
        # shortcut for /path
        return ("unix/", $_)
           if m%^/%;
  
        # parse host, special cases: "ipv6" or "ipv6[#p ]port"
        unless (
           ($host) = /^\s* ([0-9a-fA-F:]*:[0-9a-fA-F:]*:[0-9a-fA-F\.:]*)/xgc
           and parse_ipv6 $host
        ) {
           /^\s*/xgc;
  
           if (/^ \[ ([^\[\]]+) \]/xgc) {
              $host = $1;
           } elsif (/^ ([^\[\]:\ ]+) /xgc) {
              $host = $1;
           } else {
              return;
           }
        }
  
        # parse port
        if (/\G (?:\s+|:|\#) ([^:[:space:]]+) \s*$/xgc) {
           $port = $1;
        } elsif (/\G\s*$/gc && length $_[1]) {
           $port = $_[1];
        } else {
           return;
        }
  
     }
  
     # hostnames must not contain :'s
     return if $host =~ /:/ && !parse_ipv6 $host;
  
     ($host, $port)
  }
  
  =item $string = format_hostport $host, $port
  
  Takes a host (in textual form) and a port and formats in unambigiously in
  a way that C<parse_hostport> can parse it again. C<$port> can be C<undef>.
  
  =cut
  
  sub format_hostport($;$) {
     my ($host, $port) = @_;
  
     $port = ":$port"  if length $port;
     $host = "[$host]" if $host =~ /:/;
  
     "$host$port"
  }
  
  =item $sa_family = address_family $ipn
  
  Returns the address family/protocol-family (AF_xxx/PF_xxx, in one value :)
  of the given host address in network format.
  
  =cut
  
  sub address_family($) {
     4 == length $_[0]
        ? AF_INET
        : 16 == length $_[0]
           ? AF_INET6
           : unpack "S", $_[0]
  }
  
  =item $text = format_ipv4 $ipn
  
  Expects a four octet string representing a binary IPv4 address and returns
  its textual format. Rarely used, see C<format_address> for a nicer
  interface.
  
  =item $text = format_ipv6 $ipn
  
  Expects a sixteen octet string representing a binary IPv6 address and
  returns its textual format. Rarely used, see C<format_address> for a
  nicer interface.
  
  =item $text = format_address $ipn
  
  Covnvert a host address in network format (e.g. 4 octets for IPv4 or 16
  octets for IPv6) and convert it into textual form.
  
  Returns C<unix/> for UNIX domain sockets.
  
  This function works similarly to C<inet_ntop AF_INET || AF_INET6, ...>,
  except it automatically detects the address type.
  
  Returns C<undef> if it cannot detect the type.
  
  If the C<$ipn> is a mapped IPv4 in IPv6 address (:ffff::<ipv4>), then just
  the contained IPv4 address will be returned. If you do not want that, you
  have to call C<format_ipv6> manually.
  
  Example:
  
     print format_address "\x01\x02\x03\x05";
     => 1.2.3.5
  
  =item $text = AnyEvent::Socket::ntoa $ipn
  
  Same as format_address, but not exported (think C<inet_ntoa>).
  
  =cut
  
  sub format_ipv4($) {
     join ".", unpack "C4", $_[0]
  }
  
  sub format_ipv6($) {
     if ($_[0] =~ /^\x00\x00\x00\x00\x00\x00\x00\x00/) {
        if (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 eq $_[0]) {
           return "::";
        } elsif (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1 eq $_[0]) {
           return "::1";
        } elsif (v0.0.0.0.0.0.0.0.0.0.0.0 eq substr $_[0], 0, 12) {
           # v4compatible
           return "::" . format_ipv4 substr $_[0], 12;
        } elsif (v0.0.0.0.0.0.0.0.0.0.255.255 eq substr $_[0], 0, 12) {
           # v4mapped
           return "::ffff:" . format_ipv4 substr $_[0], 12;
        } elsif (v0.0.0.0.0.0.0.0.255.255.0.0 eq substr $_[0], 0, 12) {
           # v4translated
           return "::ffff:0:" . format_ipv4 substr $_[0], 12;
        }
     }
  
     my $ip = sprintf "%x:%x:%x:%x:%x:%x:%x:%x", unpack "n8", $_[0];
  
     # this is admittedly rather sucky
        $ip =~ s/(?:^|:) 0:0:0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)   0:0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)     0:0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)       0:0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)         0:0:0 (?:$|:)/::/x
     or $ip =~ s/(?:^|:)           0:0 (?:$|:)/::/x;
  
     $ip
  }
  
  sub format_address($) {
     if (4 == length $_[0]) {
        return &format_ipv4;
     } elsif (16 == length $_[0]) {
        return $_[0] =~ /^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff(....)$/s
           ? format_ipv4 $1
           : &format_ipv6;
     } elsif (AF_UNIX == address_family $_[0]) {
        return "unix/"
     } else {
        return undef
     }
  }
  
  *ntoa = \&format_address;
  
  =item inet_aton $name_or_address, $cb->(@addresses)
  
  Works similarly to its Socket counterpart, except that it uses a
  callback. Use the length to distinguish between ipv4 and ipv6 (4 octets
  for IPv4, 16 for IPv6), or use C<format_address> to convert it to a more
  readable format.
  
  Note that C<resolve_sockaddr>, while initially a more complex interface,
  resolves host addresses, IDNs, service names and SRV records and gives you
  an ordered list of socket addresses to try and should be preferred over
  C<inet_aton>.
  
  Example.
  
     inet_aton "www.google.com", my $cv = AE::cv;
     say unpack "H*", $_
        for $cv->recv;
     # => d155e363
     # => d155e367 etc.
  
     inet_aton "ipv6.google.com", my $cv = AE::cv;
     say unpack "H*", $_
        for $cv->recv;
     # => 20014860a00300000000000000000068
  
  =cut
  
  sub inet_aton {
     my ($name, $cb) = @_;
  
     if (my $ipn = &parse_ipv4) {
        $cb->($ipn);
     } elsif (my $ipn = &parse_ipv6) {
        $cb->($ipn);
     } elsif ($name eq "localhost") { # rfc2606 et al.
        $cb->(v127.0.0.1, v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1);
     } else {
        require AnyEvent::DNS unless $AnyEvent::DNS::VERSION;
  
        my $ipv4 = $AnyEvent::PROTOCOL{ipv4};
        my $ipv6 = $AnyEvent::PROTOCOL{ipv6};
  
        my @res;
  
        my $cv = AE::cv {
           $cb->(map @$_, reverse @res);
        };
  
        $cv->begin;
  
        if ($ipv4) {
           $cv->begin;
           AnyEvent::DNS::a ($name, sub {
              $res[$ipv4] = [map { parse_ipv4 $_ } @_];
              $cv->end;
           });
        };
  
        if ($ipv6) {
           $cv->begin;
           AnyEvent::DNS::aaaa ($name, sub {
              $res[$ipv6] = [map { parse_ipv6 $_ } @_];
              $cv->end;
           });
        };
  
        $cv->end;
     }
  }
  
  BEGIN {
     *sockaddr_family = $Socket::VERSION >= 1.75
        ? \&Socket::sockaddr_family
        : # for 5.6.x, we need to do something much more horrible
          (Socket::pack_sockaddr_in 0x5555, "\x55\x55\x55\x55"
             | eval { Socket::pack_sockaddr_un "U" }) =~ /^\x00/
             ? sub { unpack "xC", $_[0] }
             : sub { unpack "S" , $_[0] };
  }
  
  # check for broken platforms with an extra field in sockaddr structure
  # kind of a rfc vs. bsd issue, as usual (ok, normally it's a
  # unix vs. bsd issue, a iso C vs. bsd issue or simply a
  # correctness vs. bsd issue.)
  my $pack_family = 0x55 == sockaddr_family ("\x55\x55")
                    ? "xC" : "S";
  
  =item $sa = AnyEvent::Socket::pack_sockaddr $service, $host
  
  Pack the given port/host combination into a binary sockaddr
  structure. Handles both IPv4 and IPv6 host addresses, as well as UNIX
  domain sockets (C<$host> == C<unix/> and C<$service> == absolute
  pathname).
  
  Example:
  
     my $bind = AnyEvent::Socket::pack_sockaddr 43, v195.234.53.120;
     bind $socket, $bind
        or die "bind: $!";
  
  =cut
  
  sub pack_sockaddr($$) {
     my $af = address_family $_[1];
  
     if ($af == AF_INET) {
        Socket::pack_sockaddr_in $_[0], $_[1]
     } elsif ($af == AF_INET6) {
        pack "$pack_family nL a16 L",
           AF_INET6,
           $_[0], # port
           0,     # flowinfo
           $_[1], # addr
           0      # scope id
     } elsif ($af == AF_UNIX) {
        Socket::pack_sockaddr_un $_[0]
     } else {
        Carp::croak "pack_sockaddr: invalid host";
     }
  }
  
  =item ($service, $host) = AnyEvent::Socket::unpack_sockaddr $sa
  
  Unpack the given binary sockaddr structure (as used by bind, getpeername
  etc.) into a C<$service, $host> combination.
  
  For IPv4 and IPv6, C<$service> is the port number and C<$host> the host
  address in network format (binary).
  
  For UNIX domain sockets, C<$service> is the absolute pathname and C<$host>
  is a special token that is understood by the other functions in this
  module (C<format_address> converts it to C<unix/>).
  
  =cut
  
  # perl contains a bug (imho) where it requires that the kernel always returns
  # sockaddr_un structures of maximum length (which is not, AFAICS, required
  # by any standard). try to 0-pad structures for the benefit of those platforms.
  # unfortunately, the IO::Async author chose to break Socket again in version
  # 2.011 - it now contains a bogus length check, so we disable the workaround.
  
  my $sa_un_zero = $Socket::VERSION >= 2.011
     ? ""
     : eval { Socket::pack_sockaddr_un "" };
  
  $sa_un_zero ^= $sa_un_zero;
  
  sub unpack_sockaddr($) {
     my $af = sockaddr_family $_[0];
  
     if ($af == AF_INET) {
        Socket::unpack_sockaddr_in $_[0]
     } elsif ($af == AF_INET6) {
        unpack "x2 n x4 a16", $_[0]
     } elsif ($af == AF_UNIX) {
        ((Socket::unpack_sockaddr_un $_[0] ^ $sa_un_zero), pack "S", AF_UNIX)
     } else {
        Carp::croak "unpack_sockaddr: unsupported protocol family $af";
     }
  }
  
  =item AnyEvent::Socket::resolve_sockaddr $node, $service, $proto, $family, $type, $cb->([$family, $type, $proto, $sockaddr], ...)
  
  Tries to resolve the given nodename and service name into protocol families
  and sockaddr structures usable to connect to this node and service in a
  protocol-independent way. It works remotely similar to the getaddrinfo
  posix function.
  
  For internet addresses, C<$node> is either an IPv4 or IPv6 address, an
  internet hostname (DNS domain name or IDN), and C<$service> is either
  a service name (port name from F</etc/services>) or a numerical port
  number. If both C<$node> and C<$service> are names, then SRV records
  will be consulted to find the real service, otherwise they will be
  used as-is. If you know that the service name is not in your services
  database, then you can specify the service in the format C<name=port>
  (e.g. C<http=80>).
  
  If a host cannot be found via DNS, then it will be looked up in
  F</etc/hosts> (or the file specified via C<< $ENV{PERL_ANYEVENT_HOSTS}
  >>). If they are found, the addresses there will be used. The effect is as
  if entries from F</etc/hosts> would yield C<A> and C<AAAA> records for the
  host name unless DNS already had records for them.
  
  For UNIX domain sockets, C<$node> must be the string C<unix/> and
  C<$service> must be the absolute pathname of the socket. In this case,
  C<$proto> will be ignored.
  
  C<$proto> must be a protocol name, currently C<tcp>, C<udp> or
  C<sctp>. The default is currently C<tcp>, but in the future, this function
  might try to use other protocols such as C<sctp>, depending on the socket
  type and any SRV records it might find.
  
  C<$family> must be either C<0> (meaning any protocol is OK), C<4> (use
  only IPv4) or C<6> (use only IPv6). The default is influenced by
  C<$ENV{PERL_ANYEVENT_PROTOCOLS}>.
  
  C<$type> must be C<SOCK_STREAM>, C<SOCK_DGRAM> or C<SOCK_SEQPACKET> (or
  C<undef> in which case it gets automatically chosen to be C<SOCK_STREAM>
  unless C<$proto> is C<udp>).
  
  The callback will receive zero or more array references that contain
  C<$family, $type, $proto> for use in C<socket> and a binary
  C<$sockaddr> for use in C<connect> (or C<bind>).
  
  The application should try these in the order given.
  
  Example:
  
     resolve_sockaddr "google.com", "http", 0, undef, undef, sub { ... };
  
  =cut
  
  our %HOSTS;          # $HOSTS{$nodename}[$ipv6] = [@aliases...]
  our @HOSTS_CHECKING; # callbacks to call when hosts have been loaded
  our $HOSTS_MTIME;
  
  sub _parse_hosts($) {
     %HOSTS = ();
  
     for (split /\n/, $_[0]) {
        s/#.*$//;
        s/^[ \t]+//;
        y/A-Z/a-z/;
  
        my ($addr, @aliases) = split /[ \t]+/;
        next unless @aliases;
  
        if (my $ip = parse_ipv4 $addr) {
           ($ip) = $ip =~ /^(.*)$/s if AnyEvent::TAINT;
           push @{ $HOSTS{$_}[0] }, $ip
              for @aliases;
        } elsif (my $ip = parse_ipv6 $addr) {
           ($ip) = $ip =~ /^(.*)$/s if AnyEvent::TAINT;
           push @{ $HOSTS{$_}[1] }, $ip
              for @aliases;
        }
     }
  }
  
  # helper function - unless dns delivered results, check and parse hosts, then call continuation code
  sub _load_hosts_unless(&$@) {
     my ($cont, $cv, @dns) = @_;
  
     if (@dns) {
        $cv->end;
     } else {
        my $etc_hosts = length $ENV{PERL_ANYEVENT_HOSTS} ? $ENV{PERL_ANYEVENT_HOSTS}
                        : AnyEvent::WIN32                ? "$ENV{SystemRoot}/system32/drivers/etc/hosts"
                        :                                  "/etc/hosts";
  
        push @HOSTS_CHECKING, sub {
           $cont->();
           $cv->end;
        };
  
        unless ($#HOSTS_CHECKING) {
           # we are not the first, so we actually have to do the work
           require AnyEvent::IO;
  
           AnyEvent::IO::aio_stat ($etc_hosts, sub {
              if ((stat _)[9] ne $HOSTS_MTIME) {
                 AE::log 8 => "(re)loading $etc_hosts.";
                 $HOSTS_MTIME = (stat _)[9];
                 # we might load a newer version of hosts,but that's a harmless race,
                 # as the next call will just load it again.
                 AnyEvent::IO::aio_load ($etc_hosts, sub {
                    _parse_hosts $_[0];
                    (shift @HOSTS_CHECKING)->() while @HOSTS_CHECKING;
                 });
              } else {
                 (shift @HOSTS_CHECKING)->() while @HOSTS_CHECKING;
              }
           });
        }
     }
  }
  
  sub resolve_sockaddr($$$$$$) {
     my ($node, $service, $proto, $family, $type, $cb) = @_;
  
     if ($node eq "unix/") {
        return $cb->() if $family || $service !~ /^\//; # no can do
  
        return $cb->([AF_UNIX, defined $type ? $type : SOCK_STREAM, 0, Socket::pack_sockaddr_un $service]);
     }
  
     unless (AF_INET6) {
        $family != 6
           or return $cb->();
  
        $family = 4;
     }
  
     $cb->() if $family == 4 && !$AnyEvent::PROTOCOL{ipv4};
     $cb->() if $family == 6 && !$AnyEvent::PROTOCOL{ipv6};
  
     $family ||= 4 unless $AnyEvent::PROTOCOL{ipv6};
     $family ||= 6 unless $AnyEvent::PROTOCOL{ipv4};
  
     $proto ||= "tcp";
     $type  ||= $proto eq "udp" ? SOCK_DGRAM : SOCK_STREAM;
  
     my $proton = AnyEvent::Socket::getprotobyname $proto
        or Carp::croak "$proto: protocol unknown";
  
     my $port;
  
     if ($service =~ /^(\S+)=(\d+)$/) {
        ($service, $port) = ($1, $2);
     } elsif ($service =~ /^\d+$/) {
        ($service, $port) = (undef, $service);
     } else {
        $port = (getservbyname $service, $proto)[2]
                or Carp::croak "$service/$proto: service unknown";
     }
  
     # resolve a records / provide sockaddr structures
     my $resolve = sub {
        my @target = @_;
  
        my @res;
        my $cv = AE::cv {
           $cb->(
              map $_->[2],
              sort {
                 $AnyEvent::PROTOCOL{$b->[1]} <=> $AnyEvent::PROTOCOL{$a->[1]}
                    or $a->[0] <=> $b->[0]
              }
              @res
           )
        };
  
        $cv->begin;
        for my $idx (0 .. $#target) {
           my ($node, $port) = @{ $target[$idx] };
  
           if (my $noden = parse_address $node) {
              my $af = address_family $noden;
  
              if ($af == AF_INET && $family != 6) {
                 push @res, [$idx, "ipv4", [AF_INET, $type, $proton,
                             pack_sockaddr $port, $noden]]
              }
  
              if ($af == AF_INET6 && $family != 4) {
                 push @res, [$idx, "ipv6", [AF_INET6, $type, $proton,
                             pack_sockaddr $port, $noden]]
              }
           } else {
              $node =~ y/A-Z/a-z/;
  
              # a records
              if ($family != 6) {
                 $cv->begin;
                 AnyEvent::DNS::a $node, sub {
                    push @res, [$idx, "ipv4", [AF_INET, $type, $proton, pack_sockaddr $port, parse_ipv4 $_]]
                       for @_;
  
                    # dns takes precedence over hosts
                    _load_hosts_unless {
                       push @res,
                          map [$idx, "ipv4", [AF_INET, $type, $proton, pack_sockaddr $port, $_]],
                             @{ ($HOSTS{$node} || [])->[0] };
                    } $cv, @_;
                 };
              }
  
              # aaaa records
              if ($family != 4) {
                 $cv->begin;
                 AnyEvent::DNS::aaaa $node, sub {
                    push @res, [$idx, "ipv6", [AF_INET6, $type, $proton, pack_sockaddr $port, parse_ipv6 $_]]
                       for @_;
  
                    _load_hosts_unless {
                       push @res,
                          map [$idx + 0.5, "ipv6", [AF_INET6, $type, $proton, pack_sockaddr $port, $_]],
                             @{ ($HOSTS{$node} || [])->[1] }
                    } $cv, @_;
                 };
              }
           }
        }
        $cv->end;
     };
  
     $node = AnyEvent::Util::idn_to_ascii $node
        if $node =~ /[^\x00-\x7f]/;
  
     # try srv records, if applicable
     if ($node eq "localhost") {
        $resolve->(["127.0.0.1", $port], ["::1", $port]);
     } elsif (defined $service && !parse_address $node) {
        AnyEvent::DNS::srv $service, $proto, $node, sub {
           my (@srv) = @_;
  
           if (@srv) {
              # the only srv record has "." ("" here) => abort
              $srv[0][2] ne "" || $#srv
                 or return $cb->();
  
              # use srv records then
              $resolve->(
                 map ["$_->[3].", $_->[2]],
                    grep $_->[3] ne ".",
                       @srv
              );
           } else {
              # no srv records, continue traditionally
              $resolve->([$node, $port]);
           }
        };
     } else {
        # most common case
        $resolve->([$node, $port]);
     }
  }
  
  =item $guard = tcp_connect $host, $service, $connect_cb[, $prepare_cb]
  
  This is a convenience function that creates a TCP socket and makes a
  100% non-blocking connect to the given C<$host> (which can be a DNS/IDN
  hostname or a textual IP address, or the string C<unix/> for UNIX domain
  sockets) and C<$service> (which can be a numeric port number or a service
  name, or a C<servicename=portnumber> string, or the pathname to a UNIX
  domain socket).
  
  If both C<$host> and C<$port> are names, then this function will use SRV
  records to locate the real target(s).
  
  In either case, it will create a list of target hosts (e.g. for multihomed
  hosts or hosts with both IPv4 and IPv6 addresses) and try to connect to
  each in turn.
  
  After the connection is established, then the C<$connect_cb> will be
  invoked with the socket file handle (in non-blocking mode) as first, and
  the peer host (as a textual IP address) and peer port as second and third
  arguments, respectively. The fourth argument is a code reference that you
  can call if, for some reason, you don't like this connection, which will
  cause C<tcp_connect> to try the next one (or call your callback without
  any arguments if there are no more connections). In most cases, you can
  simply ignore this argument.
  
     $cb->($filehandle, $host, $port, $retry)
  
  If the connect is unsuccessful, then the C<$connect_cb> will be invoked
  without any arguments and C<$!> will be set appropriately (with C<ENXIO>
  indicating a DNS resolution failure).
  
  The callback will I<never> be invoked before C<tcp_connect> returns, even
  if C<tcp_connect> was able to connect immediately (e.g. on unix domain
  sockets).
  
  The file handle is perfect for being plugged into L<AnyEvent::Handle>, but
  can be used as a normal perl file handle as well.
  
  Unless called in void context, C<tcp_connect> returns a guard object that
  will automatically cancel the connection attempt when it gets destroyed
  - in which case the callback will not be invoked. Destroying it does not
  do anything to the socket after the connect was successful - you cannot
  "uncall" a callback that has been invoked already.
  
  Sometimes you need to "prepare" the socket before connecting, for example,
  to C<bind> it to some port, or you want a specific connect timeout that
  is lower than your kernel's default timeout. In this case you can specify
  a second callback, C<$prepare_cb>. It will be called with the file handle
  in not-yet-connected state as only argument and must return the connection
  timeout value (or C<0>, C<undef> or the empty list to indicate the default
  timeout is to be used).
  
  Note to the poor Microsoft Windows users: Windows (of course) doesn't
  correctly signal connection errors, so unless your event library works
  around this, failed connections will simply hang. The only event libraries
  that handle this condition correctly are L<EV> and L<Glib>. Additionally,
  AnyEvent works around this bug with L<Event> and in its pure-perl
  backend. All other libraries cannot correctly handle this condition. To
  lessen the impact of this windows bug, a default timeout of 30 seconds
  will be imposed on windows. Cygwin is not affected.
  
  Simple Example: connect to localhost on port 22.
  
     tcp_connect localhost => 22, sub {
        my $fh = shift
           or die "unable to connect: $!";
        # do something
     };
  
  Complex Example: connect to www.google.com on port 80 and make a simple
  GET request without much error handling. Also limit the connection timeout
  to 15 seconds.
  
     tcp_connect "www.google.com", "http",
        sub {
           my ($fh) = @_
              or die "unable to connect: $!";
  
           my $handle; # avoid direct assignment so on_eof has it in scope.
           $handle = new AnyEvent::Handle
              fh     => $fh,
              on_error => sub {
                 AE::log error => $_[2];
                 $_[0]->destroy;
              },
              on_eof => sub {
                 $handle->destroy; # destroy handle
                 AE::log info => "Done.";
              };
  
           $handle->push_write ("GET / HTTP/1.0\015\012\015\012");
  
           $handle->push_read (line => "\015\012\015\012", sub {
              my ($handle, $line) = @_;
  
              # print response header
              print "HEADER\n$line\n\nBODY\n";
  
              $handle->on_read (sub {
                 # print response body
                 print $_[0]->rbuf;
                 $_[0]->rbuf = "";
              });
           });
        }, sub {
           my ($fh) = @_;
           # could call $fh->bind etc. here
  
           15
        };
  
  Example: connect to a UNIX domain socket.
  
     tcp_connect "unix/", "/tmp/.X11-unix/X0", sub {
        ...
     }
  
  =cut
  
  sub tcp_connect($$$;$) {
     my ($host, $port, $connect, $prepare) = @_;
  
     # see http://cr.yp.to/docs/connect.html for some tricky aspects
     # also http://advogato.org/article/672.html
  
     my %state = ( fh => undef );
  
     # name/service to type/sockaddr resolution
     resolve_sockaddr $host, $port, 0, 0, undef, sub {
        my @target = @_;
  
        $state{next} = sub {
           return unless exists $state{fh};
  
           my $errno = $!;
           my $target = shift @target
              or return AE::postpone {
                 return unless exists $state{fh};
                 %state = ();
                 $! = $errno;
                 $connect->();
              };
  
           my ($domain, $type, $proto, $sockaddr) = @$target;
  
           # socket creation
           socket $state{fh}, $domain, $type, $proto
              or return $state{next}();
  
           AnyEvent::fh_unblock $state{fh};
           
           my $timeout = $prepare && $prepare->($state{fh});
  
           $timeout ||= 30 if AnyEvent::WIN32;
  
           $state{to} = AE::timer $timeout, 0, sub {
              $! = Errno::ETIMEDOUT;
              $state{next}();
           } if $timeout;
  
           # now connect
           if (
              (connect $state{fh}, $sockaddr)
              || ($! == Errno::EINPROGRESS # POSIX
                  || $! == Errno::EWOULDBLOCK
                  # WSAEINPROGRESS intentionally not checked - it means something else entirely
                  || $! == AnyEvent::Util::WSAEINVAL # not convinced, but doesn't hurt
                  || $! == AnyEvent::Util::WSAEWOULDBLOCK)
           ) {
              $state{ww} = AE::io $state{fh}, 1, sub {
                 # we are connected, or maybe there was an error
                 if (my $sin = getpeername $state{fh}) {
                    my ($port, $host) = unpack_sockaddr $sin;
  
                    delete $state{ww}; delete $state{to};
  
                    my $guard = guard { %state = () };
  
                    $connect->(delete $state{fh}, format_address $host, $port, sub {
                       $guard->cancel;
                       $state{next}();
                    });
                 } else {
                    if ($! == Errno::ENOTCONN) {
                       # dummy read to fetch real error code if !cygwin
                       sysread $state{fh}, my $buf, 1;
  
                       # cygwin 1.5 continously reports "ready' but never delivers
                       # an error with getpeername or sysread.
                       # cygwin 1.7 only reports readyness *once*, but is otherwise
                       # the same, which is actually more broken.
                       # Work around both by using unportable SO_ERROR for cygwin.
                       $! = (unpack "l", getsockopt $state{fh}, Socket::SOL_SOCKET(), Socket::SO_ERROR()) || Errno::EAGAIN
                          if AnyEvent::CYGWIN && $! == Errno::EAGAIN;
                    }
  
                    return if $! == Errno::EAGAIN; # skip spurious wake-ups
  
                    delete $state{ww}; delete $state{to};
  
                    $state{next}();
                 }
              };
           } else {
              $state{next}();
           }
        };
  
        $! = Errno::ENXIO;
        $state{next}();
     };
  
     defined wantarray && guard { %state = () }
  }
  
  =item $guard = tcp_server $host, $service, $accept_cb[, $prepare_cb]
  
  Create and bind a stream socket to the given host address and port, set
  the SO_REUSEADDR flag (if applicable) and call C<listen>. Unlike the name
  implies, this function can also bind on UNIX domain sockets.
  
  For internet sockets, C<$host> must be an IPv4 or IPv6 address (or
  C<undef>, in which case it binds either to C<0> or to C<::>, depending
  on whether IPv4 or IPv6 is the preferred protocol, and maybe to both in
  future versions, as applicable).
  
  To bind to the IPv4 wildcard address, use C<0>, to bind to the IPv6
  wildcard address, use C<::>.
  
  The port is specified by C<$service>, which must be either a service name
  or a numeric port number (or C<0> or C<undef>, in which case an ephemeral
  port will be used).
  
  For UNIX domain sockets, C<$host> must be C<unix/> and C<$service> must be
  the absolute pathname of the socket. This function will try to C<unlink>
  the socket before it tries to bind to it, and will try to unlink it after
  it stops using it. See SECURITY CONSIDERATIONS, below.
  
  For each new connection that could be C<accept>ed, call the C<<
  $accept_cb->($fh, $host, $port) >> with the file handle (in non-blocking
  mode) as first, and the peer host and port as second and third arguments
  (see C<tcp_connect> for details).
  
  Croaks on any errors it can detect before the listen.
  
  In non-void context, this function returns a guard object whose lifetime
  it tied to the TCP server: If the object gets destroyed, the server will
  be stopped and the listening socket will be cleaned up/unlinked (already
  accepted connections will not be affected).
  
  When called in void-context, AnyEvent will keep the listening socket alive
  internally. In this case, there is no guarantee that the listening socket
  will be cleaned up or unlinked.
  
  In all cases, when the function returns to the caller, the socket is bound
  and in listening state.
  
  If you need more control over the listening socket, you can provide a
  C<< $prepare_cb->($fh, $host, $port) >>, which is called just before the
  C<listen ()> call, with the listen file handle as first argument, and IP
  address and port number of the local socket endpoint as second and third
  arguments.
  
  It should return the length of the listen queue (or C<0> for the default).
  
  Note to IPv6 users: RFC-compliant behaviour for IPv6 sockets listening on
  C<::> is to bind to both IPv6 and IPv4 addresses by default on dual-stack
  hosts. Unfortunately, only GNU/Linux seems to implement this properly, so
  if you want both IPv4 and IPv6 listening sockets you should create the
  IPv6 socket first and then attempt to bind on the IPv4 socket, but ignore
  any C<EADDRINUSE> errors.
  
  Example: bind on some TCP port on the local machine and tell each client
  to go away.
  
     tcp_server undef, undef, sub {
        my ($fh, $host, $port) = @_;
  
        syswrite $fh, "The internet is full, $host:$port. Go away!\015\012";
     }, sub {
        my ($fh, $thishost, $thisport) = @_;
        AE::log info => "Bound to $thishost, port $thisport.";
     };
  
  Example: bind a server on a unix domain socket.
  
     tcp_server "unix/", "/tmp/mydir/mysocket", sub {
        my ($fh) = @_;
     };
  
  =item $guard = AnyEvent::Socket::tcp_bind $host, $service, $done_cb[, $prepare_cb]
  
  Same as C<tcp_server>, except it doesn't call C<accept> in a loop for you
  but simply passes the listen socket to the C<$done_cb>. This is useful
  when you want to have a convenient set up for your listen socket, but want
  to do the C<accept>'ing yourself, for example, in another process.
  
  In case of an error, C<tcp_bind> either croaks, or passes C<undef> to the
  C<$done_cb>.
  
  In non-void context, a guard will be returned. It will clean up/unlink the
  listening socket when destroyed. In void context, no automatic clean up
  might be performed.
  
  =cut
  
  sub _tcp_bind($$$;$) {
     my ($host, $service, $done, $prepare) = @_;
  
     $host = $AnyEvent::PROTOCOL{ipv4} < $AnyEvent::PROTOCOL{ipv6} && AF_INET6
             ? "::" : "0"
        unless defined $host;
  
     my $ipn = parse_address $host
        or Carp::croak "tcp_bind: cannot parse '$host' as host address";
  
     my $af = address_family $ipn;
  
     my %state;
  
     # win32 perl is too stupid to get this right :/
     Carp::croak "tcp_bind: AF_UNIX address family not supported on win32"
        if AnyEvent::WIN32 && $af == AF_UNIX;
  
     socket my $fh, $af, SOCK_STREAM, 0
        or Carp::croak "tcp_bind: $!";
  
     $state{fh} = $fh;
  
     if ($af == AF_INET || $af == AF_INET6) {
        setsockopt $fh, SOL_SOCKET, SO_REUSEADDR, 1
           or Carp::croak "tcp_bind: so_reuseaddr: $!"
              unless AnyEvent::WIN32; # work around windows bug
  
        unless ($service =~ /^\d*$/) {
           $service = (getservbyname $service, "tcp")[2]
                      or Carp::croak "tcp_bind: unknown service '$service'"
        }
     } elsif ($af == AF_UNIX) {
        unlink $service;
     }
  
     bind $fh, pack_sockaddr $service, $ipn
        or Carp::croak "tcp_bind: $!";
  
     if ($af == AF_UNIX and defined wantarray) {
        # this is racy, but is not designed to be foolproof, just best-effort
        my $ino = (lstat $service)[1];
        $state{unlink} = guard {
           unlink $service
              if (lstat $service)[1] == $ino;
        };
     }
  
     AnyEvent::fh_unblock $fh;
  
     my $len;
  
     if ($prepare) {
        my ($service, $host) = unpack_sockaddr getsockname $fh;
        $len = $prepare && $prepare->($fh, format_address $host, $service);
     }
     
     $len ||= 128;
  
     listen $fh, $len
        or Carp::croak "tcp_bind: $!";
  
     $done->(\%state);
  
     defined wantarray
        ? guard { %state = () } # clear fh, unlink
        : ()
  }
  
  sub tcp_bind($$$;$) {
     my ($host, $service, $done, $prepare) = @_;
  
     _tcp_bind $host, $service, sub {
        $done->(delete shift->{fh});
     }, $prepare
  }
  
  sub tcp_server($$$;$) {
     my ($host, $service, $accept, $prepare) = @_;
  
     _tcp_bind $host, $service, sub {
        my $rstate = shift;
  
        $rstate->{aw} = AE::io $rstate->{fh}, 0, sub {
           # this closure keeps $state alive
           while ($rstate->{fh} && (my $peer = accept my $fh, $rstate->{fh})) {
              AnyEvent::fh_unblock $fh; # POSIX requires inheritance, the outside world does not
  
              my ($service, $host) = unpack_sockaddr $peer;
              $accept->($fh, format_address $host, $service);
           }
        };
     }, $prepare
  }
  
  =item tcp_nodelay $fh, $enable
  
  Enables (or disables) the C<TCP_NODELAY> socket option (also known as
  Nagle's algorithm). Returns false on error, true otherwise.
  
  =cut
  
  sub tcp_nodelay($$) {
     my $onoff = int ! ! $_[1];
  
     setsockopt $_[0], Socket::IPPROTO_TCP (), Socket::TCP_NODELAY (), $onoff
  }
  
  =item tcp_congestion $fh, $algorithm
  
  Sets the tcp congestion avoidance algorithm (via the C<TCP_CONGESTION>
  socket option). The default is OS-specific, but is usually
  C<reno>. Typical other available choices include C<cubic>, C<lp>, C<bic>,
  C<highspeed>, C<htcp>, C<hybla>, C<illinois>, C<scalable>, C<vegas>,
  C<veno>, C<westwood> and C<yeah>.
  
  =cut
  
  sub tcp_congestion($$) {
     defined TCP_CONGESTION
        ? setsockopt $_[0], Socket::IPPROTO_TCP (), TCP_CONGESTION, "$_[1]"
        : undef
  }
  
  =back
  
  =head1 SECURITY CONSIDERATIONS
  
  This module is quite powerful, with with power comes the ability to abuse
  as well: If you accept "hostnames" and ports from untrusted sources,
  then note that this can be abused to delete files (host=C<unix/>). This
  is not really a problem with this module, however, as blindly accepting
  any address and protocol and trying to bind a server or connect to it is
  harmful in general.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_SOCKET

$fatpacked{"AnyEvent/Strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_STRICT';
  =head1 NAME
  
  AnyEvent::Strict - force strict mode on for the whole process
  
  =head1 SYNOPSIS
  
     use AnyEvent::Strict;
     # strict mode now switched on
  
  =head1 DESCRIPTION
  
  This module implements AnyEvent's strict mode.
  
  Loading it makes AnyEvent check all arguments to AnyEvent-methods, at the
  expense of being slower (often the argument checking takes longer than the
  actual function). It also wraps all callbacks to check for modifications
  of C<$_>, which indicates a programming bug inside the watcher callback.
  
  Normally, you don't load this module yourself but instead use it
  indirectly via the C<PERL_ANYEVENT_STRICT> environment variable (see
  L<AnyEvent>). However, this module can be loaded manually at any time.
  
  =cut
  
  package AnyEvent::Strict;
  
  use Carp qw(confess);
  use Errno ();
  use POSIX ();
  
  $Carp::Internal{AE}               = 1;
  $Carp::Internal{AnyEvent::Strict} = 1;
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  AnyEvent::_isa_hook 1 => "AnyEvent::Strict", 1;
  
  BEGIN {
     if (defined &Internals::SvREADONLY) {
        # readonly available (at least 5.8.9+, working better in 5.10.1+)
        *wrap = sub {
           my $cb = shift;
  
           sub {
              local $_;
              Internals::SvREADONLY $_, 1;
              &$cb;
           }
        };
     } else {
        # or not :/
        my $magic = []; # a unique magic value
  
        *wrap = sub {
           my $cb = shift;
  
           sub {
              local $_ = $magic;
  
              &$cb;
  
              if (!ref $_ || $_ != $magic) {
                 require AnyEvent::Debug;
                 die "callback $cb (" . AnyEvent::Debug::cb2str ($cb) . ") modified \$_ without restoring it.\n";
              }
           }
        };
     }
  }
  
  our (@FD_INUSE, $FD_I);
  our $FD_CHECK_W = AE::timer 4, 4, sub {
     my $cnt = (@FD_INUSE < 100 * 10 ? int @FD_INUSE * 0.1 : 100) || 10;
  
     if ($FD_I <= 0) {
        #pop @FD_INUSE while @FD_INUSE && !$FD_INUSE[-1];
        $FD_I = @FD_INUSE
           or return; # empty
     }
  
     $cnt = $FD_I if $cnt > $FD_I;
  
     eval {
        do {
           !$FD_INUSE[--$FD_I]
              or (POSIX::lseek $FD_I, 0, 1) != -1
              or $! != Errno::EBADF
              or die;
        } while --$cnt;
        1
     } or AE::log crit => "File descriptor $FD_I registered with AnyEvent but prematurely closed, event loop might malfunction.";
  };
  
  sub io {
     my $class = shift;
     my (%arg, $fh, $cb, $fd) = @_;
  
     ref $arg{cb}
        or confess "AnyEvent->io called with illegal cb argument '$arg{cb}'";
     $cb = wrap delete $arg{cb};
   
     $arg{poll} =~ /^[rw]$/
        or confess "AnyEvent->io called with illegal poll argument '$arg{poll}'";
  
     $fh = delete $arg{fh};
  
     if ($fh =~ /^\s*\d+\s*$/) {
        $fd = $fh;
        ($fh) = AnyEvent::_dupfh $arg{poll}, $fh;
     } else {
        defined eval { $fd = fileno $fh }
           or confess "AnyEvent->io called with illegal fh argument '$fh'";
     }
  
     -f $fh
        and confess "AnyEvent->io called with fh argument pointing to a file";
  
     delete $arg{poll};
   
     confess "AnyEvent->io called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     ++$FD_INUSE[$fd];
  
     bless [
        $fd,
        $class->SUPER::io (@_, cb => $cb)
     ], "AnyEvent::Strict::io";
  }
  
  sub AnyEvent::Strict::io::DESTROY {
     --$FD_INUSE[$_[0][0]];
  }
  
  sub timer {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or confess "AnyEvent->timer called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     exists $arg{after}
        or confess "AnyEvent->timer called without mandatory 'after' parameter";
     delete $arg{after};
   
     !$arg{interval} or $arg{interval} > 0
        or confess "AnyEvent->timer called with illegal interval argument '$arg{interval}'";
     delete $arg{interval};
   
     confess "AnyEvent->timer called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::timer (@_, cb => $cb)
  }
  
  sub signal {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or confess "AnyEvent->signal called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     defined AnyEvent::Base::sig2num $arg{signal} and $arg{signal} == 0
        or confess "AnyEvent->signal called with illegal signal name '$arg{signal}'";
     delete $arg{signal};
   
     confess "AnyEvent->signal called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::signal (@_, cb => $cb)
  }
  
  sub child {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or confess "AnyEvent->child called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     $arg{pid} =~ /^-?\d+$/
        or confess "AnyEvent->child called with malformed pid value '$arg{pid}'";
     delete $arg{pid};
   
     confess "AnyEvent->child called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::child (@_, cb => $cb)
  }
  
  sub idle {
     my $class = shift;
     my %arg = @_;
  
     ref $arg{cb}
        or confess "AnyEvent->idle called with illegal cb argument '$arg{cb}'";
     my $cb = wrap delete $arg{cb};
   
     confess "AnyEvent->idle called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::idle (@_, cb => $cb)
  }
  
  sub condvar {
     my $class = shift;
     my %arg = @_;
  
     !exists $arg{cb} or ref $arg{cb}
        or confess "AnyEvent->condvar called with illegal cb argument '$arg{cb}'";
     my @cb = exists $arg{cb} ? (cb => wrap delete $arg{cb}) : ();
   
     confess "AnyEvent->condvar called with unsupported parameter(s) " . join ", ", keys %arg
        if keys %arg;
  
     $class->SUPER::condvar (@cb);
  }
  
  sub time {
     my $class = shift;
  
     @_
        and confess "AnyEvent->time wrongly called with paramaters";
  
     $class->SUPER::time (@_)
  }
  
  sub now {
     my $class = shift;
  
     @_
        and confess "AnyEvent->now wrongly called with paramaters";
  
     $class->SUPER::now (@_)
  }
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_STRICT

$fatpacked{"AnyEvent/TLS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_TLS';
  package AnyEvent::TLS;
  
  use Carp qw(croak);
  use Scalar::Util ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  use AnyEvent::Util ();
  
  use Net::SSLeay;
  
  =head1 NAME
  
  AnyEvent::TLS - SSLv2/SSLv3/TLSv1 contexts for use in AnyEvent::Handle
  
  =cut
  
  our $VERSION = $AnyEvent::VERSION;
  
  =head1 SYNOPSIS
  
     # via AnyEvent::Handle
  
     use AnyEvent;
     use AnyEvent::Handle;
     use AnyEvent::Socket;
  
     # simple https-client
     my $handle = new AnyEvent::Handle
        connect  => [$host, $port],
        tls      => "connect",
        tls_ctx  => { verify => 1, verify_peername => "https" },
        ...
  
     # simple ssl-server
     tcp_server undef, $port, sub {
        my ($fh) = @_;
  
        my $handle = new AnyEvent::Handle
           fh       => $fh,
           tls      => "accept",
           tls_ctx  => { cert_file => "my-server-keycert.pem" },
           ...
  
     # directly
  
     my $tls = new AnyEvent::TLS
        verify => 1,
        verify_peername => "ldaps",
        ca_file => "/etc/cacertificates.pem";
  
  =head1 DESCRIPTION
  
  This module is a helper module that implements TLS/SSL (Transport Layer
  Security/Secure Sockets Layer) contexts. A TLS context is a common set of
  configuration values for use in establishing TLS connections.
  
  For some quick facts about SSL/TLS, see the section of the same name near
  the end of the document.
  
  A single TLS context can be used for any number of TLS connections that
  wish to use the same certificates, policies etc.
  
  Note that this module is inherently tied to L<Net::SSLeay>, as this
  library is used to implement it. Since that perl module is rather ugly,
  and OpenSSL has a rather ugly license, AnyEvent might switch TLS providers
  at some future point, at which this API will change dramatically, at least
  in the Net::SSLeay-specific parts (most constructor arguments should still
  work, though).
  
  Although this module does not require a specific version of Net::SSLeay,
  many features will gradually stop working, or bugs will be introduced with
  old versions (verification might succeed when it shouldn't - this is a
  real security issue). Version 1.35 is recommended, 1.33 should work, 1.32
  might, and older versions are yours to keep.
  
  =head1 USAGE EXAMPLES
  
  See the L<AnyEvent::Handle> manpage, NONFREQUENTLY ASKED QUESTIONS, for
  some actual usage examples.
  
  =head1 PUBLIC METHODS AND FUNCTIONS
  
  =over 4
  
  =cut
  
  our $REF_IDX; # our session ex_data id
  
  # create temp file, populate it, and return a guard and filename
  sub _tmpfile($) {
     require File::Temp unless $File::Temp::VERSION;
  
     # File::Temp opens the file with mode 0600
     my ($fh, $path) = File::Temp::tempfile ("aetlsXXXXXXXXX", TMPDIR => 1, EXLOCK => 0);
     my $guard = AnyEvent::Util::guard { unlink $path };
  
     syswrite $fh, $_[0];
     close $fh;
  
     ($path, $guard)
  }
  
  our %DH_PARAMS = (
     # These are the DH parameters from "Assigned Number for SKIP Protocols"
     # (http://www.skip-vpn.org/spec/numbers.html).
     # (or http://web.archive.org/web/20011212141438/http://www.skip-vpn.org/spec/numbers.html#params)
     # See there for how they were generated.
     # Note that g might not be a generator,
     # but this is not a problem since p is a safe prime.
     skip512 => "MEYCQQD1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWak|XUGfnHy9iUsiGSa6q6Jew1XpKgVfAgEC",
     skip1024 => "MIGHAoGBAPSI/VhOSdvNILSd5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsY|jY67VYy4XTjTNP18F1dDox0YbN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6|ypUM2Zafq9AKUJsCRtMIPWakXUGfnHy9iUsiGSa6q6Jew1XpL3jHAgEC",
     skip2048 => "MIIBCAKCAQEA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadWoxTpj0BV|89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeSWc39uK50|T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0iP1YTknb|zSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF040zT9fBdX|Q6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQClCbAkbT|CD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwIBAg==",
     skip4096 => "MIICCAKCAgEA+hRyUsFN4VpJ1O8JLcCo/VWr19k3BCgJ4uk+d+KhehjdRqNDNyOQ|l/MOyQNQfWXPeGKmOmIig6Ev/nm6Nf9Z2B1h3R4hExf+zTiHnvVPeRBhjdQi81rt|Xeoh6TNrSBIKIHfUJWBh3va0TxxjQIs6IZOLeVNRLMqzeylWqMf49HsIXqbcokUS|Vt1BkvLdW48j8PPv5DsKRN3tloTxqDJGo9tKvj1Fuk74A+Xda1kNhB7KFlqMyN98|VETEJ6c7KpfOo30mnK30wqw3S8OtaIR/maYX72tGOno2ehFDkq3pnPtEbD2CScxc|alJC+EL7RPk5c/tgeTvCngvc1KZn92Y//EI7G9tPZtylj2b56sHtMftIoYJ9+ODM|sccD5Piz/rejE3Ome8EOOceUSCYAhXn8b3qvxVI1ddd1pED6FHRhFvLrZxFvBEM9|ERRMp5QqOaHJkM+Dxv8Cj6MqrCbfC4u+ZErxodzuusgDgvZiLF22uxMZbobFWyte|OvOzKGtwcTqO/1wV5gKkzu1ZVswVUQd5Gg8lJicwqRWyyNRczDDoG9jVDxmogKTH|AaqLulO7R8Ifa1SwF2DteSGVtgWEN8gDpN3RBmmPTDngyF2DHb5qmpnznwtFKdTL|KWbuHn491xNO25CQWMtem80uKw+pTnisBRF/454n1Jnhub144YRBoN8CAQI=",
  
     # generated on a linux desktop with openssl using /dev/urandom - entropy_avail was >= 3600 each time
     # the 8192 bit key took 25 hours to generate :/
     schmorp1024 => "MIGHAoGBAN+GjqAhNxLesSuGfDzYe6HdexXtHuxe85umshfPHfnmLSkGWl/FE27+|v+50mwY5XaNnCmo1VvGju4iTKxWoZTGgslUSc8KX197XWAXIpab8ESyg442if9Kr|vSOuu0fopwvvTOgHK8mkEWI4joU5G4/MQy+pnC5NIEVBP4HtGiTrAgEC",
     schmorp1539 => "MIHHAoHBByJzpVGUsXysX8w/+uuXRUCL9exhAixoHkaJU5lf4noJUtp9F0yr/5rb|hF8M9mSZJ+RlPyB+Zt37GPp1WQDO1+/2yZJX9kHE3+h5JCRoR8PKc2G+ts9jhM7r|CnTQ0z0b6s12Pusf+UhQPwLust4JAYE/LPuTK8yFiVx5L2a+aZhGMVlYN/12SEtY|jRl3lGXdZj9g8E2PzTQbA9CGy5dGIvz/ENTzTVleKuQ+80bzpVEPjZL9tv43Zc+l|MFLzxuE5uwIBAg==",
     schmorp2048 => "MIIBCAKCAQEAhR5Fn9h3Tgnc+q4o3CMkZtre3lLUyDT+1bf3aiVOt22JdDQndZLc|FeKz8AqliB3UIgNExc6oDtuG4znKPgklfOnHv/a9tl1AYQbV+QFM/E0jYl6oG8tF|Epgxezt1GCivvtu64ql0s213wr64QffNMt3hva8lNqK1PXfqp13PzzLzAVsfghrv|fMAX7/bYm1T5fAJdcah6FeZkKof+mqbs8HtRjfvrUF2npEM2WdupFu190vcwABnN|TTJheXCWv2BF2f9EEr61q3OUhSNWIThtZP+NKe2bACm1PebT0drAcaxKoMz9LjKr|y5onGs0TOuQ7JmhtZL45Zr4LwBcyTucLUwIBAg==",
     schmorp4096 => "MIICCAKCAgEA5WwA5lQg09YRYqc/JILCd2AfBmYBkF19wmCEJB8G3JhTxv8EGvYk|xyP2ecKVUvHTG8Xw/qpW8nRqzPIyV8QRf6YFYSf33Qnx2xYhcnqOumU3nfC0SNOL|/w2q1BA9BbHtW4574P+6hOQx9ftRtbtZ2HPKBMRcAKGjpYZiKopv0+UAM4NpEC2p|bfajp7pyVLeb/Aqm/oWP3L63wPlY1SDp+XRzrOAKB+/uLGqEwV0bBaxxGL29BpOp|O2z1ALGXiDCcLs9WTn9WqUhWDzUN6fahm53rd7zxwpFCb6K2YhaK0peG95jzSUJ8|aoL0KgWuC6v5+gPJHRu0HrQIdfAdN4VchqYOKE46uNNkQl8VJGu4RjYB7lFBpRwO|g2HCsGMo2X7BRmA1st66fh+JOd1smXMZG/2ozTOooL+ixcx4spNneg4aQerWl5cb|nWXKtPCp8yPzt/zoNzL3Fon2Ses3sNgMos0M/ZbnigScDxz84Ms6V/X8Z0L4m/qX|mL42dP40tgvmgqi6BdsBzcIWeHlEcIhmGcsEBxxKEg7gjb0OjjvatpUCJhmRrGjJ|LtMkBR68qr42OBMN/PBB4KPOWNUqTauXZajfCwYdbpvV24ZhtkcRdw1zisyARBSh|aTKW/GV8iLsUzlYN27LgVEwMwnWQaoecW6eOTNKGUURC3In6XZSvVzsCAQI=",
     schmorp8192 => "MIIECAKCBAEA/SAEbRSSLenVxoInHiltm/ztSwehGOhOiUKfzDcKlRBZHlCC9jBl|S/aeklM6Ucg8E6J2bnfoh6CAdnE/glQOn6CifhZr8X/rnlL9/eP+r9m+aiAw4l0D|MBd8BondbEqwTZthMmLtx0SslnevsFAZ1Cj8WgmUNaSPOukvJ1N7aQ98U+E99Pw3|VG8ANBydXqLqW2sogS8FtZoMbVywcQuaGmC7M6i3Akxe3CCSIpR/JkEZIytREBSC|CH+x3oW/w+wHzq3w8DGB9hqz1iMXqDMiPIMSdXC0DaIPokLnd7X8u6N14yCAco2h|P0gspD3J8pS2FpUY8ZTVjzbVCjhNNmTryBZAxHSWBuX4xYcCHUtfGlUe/IGLSVE1|xIdFpZUfvlvAJjVq0/TtDMg3r2JSXrhQVlr8MPJwSApDVr5kOBHT/uABio4z+5yR|PAvundznfyo9GGAWhIA36GQqsxSQfoRTjWssFoR/cu+9aomRwwOLkvObu8nCVVLH|nLdKDk5cIR0TvNs9HZ6ZmkzL7ah7cPzEKl7U6eE6yZLVYMNecnPLS6PSAIG4gxcq|CVQrrZjQLfTDrJn0OGgpShX85RaDsuiRtp2bpDZ23YDqdwr4wRjvIargjqc2zcF+|jIb7dUS6ci7bVG/CGOQUuiMWAiXZ3a1f343SMf9A05/sf1xwnMeco6STBLZ3X+PA|4urU+grtpWaFtS/fPD2ILn8nrJ3WuSKKUeSnVM46mmJQsOkyn7z8l3jNLB17GYKo|qc+0UuU/2PM9qtZdZElSM/ACLV2vdCuaibop4B9UIP9z3F8kfZ72+zKxpGiE+Bo1|x8SfG8FQw90mYIx+qZzJ8MCvc2wh+l4wDX5KxrhwvcouE2tHQlwfDgv/DiIXp173|hAmUCV0+bPRW8IIJvBODdAWtJe9hNwxj1FFYmPA7l4wa3gXV4I6tb+iO1MbwVjZ/|116tD5MdCo3JuSisgPYCHfkQccwEO0FHEuBbmfN+fQimQ8H0dePP8XctwbkplsB+|aLT5hYKmva/j9smEswgyHglPwc3WvZ+2DgKk7A7DHi7a2gDwCRQlHaXtNWx3992R|dfNgkSeB1CvGSQoo95WpC9ZoqGmcSlVqdetDU8iglPmfYTKO8aIPA6TuTQ/lQ0IW|90LQmqP23FwnNFiyqX8+rztLq4KVkTyeHIQwig6vFxgD8N+SbZCW2PPiB72TVF2U|WePU8MRTv1OIGBUBajF49k28HnZPSGlILHtFEkYkbPvomcE5ENnoejwzjktOTS5d|/R3SIOvCauOzadtzwTYOXT78ORaR1KI1cm8DzkkwJTd/Rrk07Q5vnvnSJQMwFUeH|PwJIgWBQf/GZ/OsDHmkbYR2ZWDClbKw2mwIBAg==",
  
     # finite field dhe parameters, some taken from firefox, some directly from RFC 7919
     ffdhe2048 => "MIIBCAKCAQEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaD ssbzSibBsu/6iGtCOGEoXJf//////////wIBAg==",
     ffdhe3072 => "MIIBiAKCAYEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaDssbzSibBsu/6iGtCOGEfz9zeNVs7ZRkDW7w09N75nAI4YbRvydbmyQd62R0mkff37lmMsPrBhtkcrv4TCYUTknC0EwyTvEN5RPT9RFLi103TZPLiHnH1S/9croKrnJ32nuhtK8UiNjoNq8Uhl5sN6todv5pC1cRITgq80Gv6U93vPBsg7j/VnXwl5B0rZsYuN///////////AgEC",
     ffdhe4096 => "MIICCAKCAgEA///////////JD9qiIWjCNMTGYouA3BzRKQJOCIpnzHQCC76mOxObIlFKCHmONATd75UZs806QxswKwpt8l8UN0/hNW1tUcJF5IW1dmJefsb0TELppjftawv/XLb0Brft7jhr+1qJn6WunyQRfEsf5kkoZlHs5Fs9wgB8uKFjvwWY2kg2HFXTmmkWP6j9JM9fg2VdI9yjrZYcYvNWIIVSu57VKQdwlpZtZww1Tkq8mATxdGwIyhghfDKQXkYuNs474553LBgOhgObJ4Oi7Aeij7XFXfBvTFLJ3ivL9pVYFxg5lUl86pVq5RXSJhiY+gUQFXKOWoqqxC2tMxcNBFB6M6hVIavfHLpk7PuFBFjb7wqK6nFXXQYMfbOXD4Wm4eTHq/WujNsJM9cejJTgSiVhnc7j0iYa0u5r8S/6BtmKCGTYdgJzPshqZFIfKxgXeyAMu+EXV3phXWx3CYjAutlG4gjiT6B05asxQ9tb/OD9EI5LgtEgqSEIARpyPBKnh+bXiHGaEL26WyaZwycYavTiPBqUaDS2FQvaJYPpyirUTOjbu8LbBN6O+S6O/BQfvsqmKHxZR05rwF2ZspZPoJDDoiM7oYZRW+ftH2EpcM7i16+4G912IXBIHNAGkSfVsFqpk7TqmI2P3cGG/7fckKbAj030Nck0BjGZ//////////8CAQI=",
     ffdhe6144 =>
     "MIIDCAKCAwEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaDssbzSibBsu/6iGtCOGEfz9zeNVs7ZRkDW7w09N75nAI4YbRvydbmyQd62R0mkff37lmMsPrBhtkcrv4TCYUTknC0EwyTvEN5RPT9RFLi103TZPLiHnH1S/9croKrnJ32nuhtK8UiNjoNq8Uhl5sN6todv5pC1cRITgq80Gv6U93vPBsg7j/VnXwl5B0rZp4e8W5vUsMWTfT7eTDp5OWIV7asfV9C1p9tGHdjzx1VA0AEh/VbpX4xzHpxNciG77Qxiu1qHgEtnmgyqQdgCpGBMMRtx3j5ca0AOAkpmaMzy4t6Gh25PXFAADwqTs6p+Y0KzAqCkc3OyX3Pjsm1Wn+IpGtNtahR9EGC4caKAH5eDdkCC/1ktkUDbHpOZ30sOFMqOiO6RELK9T6mO7RUMpt2JMiRe91kscD9TLOOjDNMcBw6za0GV/zP7HGbH1w+TkYEHziBR/tM/bR3pSRx96mpaRC4VTIu22NA2KAO8JI1BRHjCr7B//njom5/sp+MGDAjw1h+ONoAd9m0dj5OS5Syu8GUxmUed8r5ku6qwCMqKBv2s6c5wSJhFoIK6NtYR6Z8vvnJCRtGLVOM1ysDdGrnf15iKSwxFWKoRlBdyC24VDOK5J9SNclbkReMzy3Vys70A+ydGBDGJysEWztx+dxrgNY/3UqOmtseaWKmlSbUMWHBpB1XDXk42tSkDjKc0OQOZf//////////AgEC",
     ffdhe8192 => "MIIECAKCBAEA//////////+t+FRYortKmq/cViAnPTzx2LnFg84tNpWp4TZBFGQz+8yTnc4kmz75fS/jY2MMddj2gbICrsRhetPfHtXV/WVhJDP1H18GbtCFY2VVPe0a87VXE15/V8k1mE8McODmi3fipona8+/och3xWKE2rec1MKzKT0g6eXq8CrGCsyT7YdEIqUuyyOP7uWrat2DX9GgdT0Kj3jlN9K5W7edjcrsZCwenyO4KbXCeAvzhzffi7MA0BM0oNC9hkXL+nOmFg/+OTxIy7vKBg8P+OxtMb61zO7X8vC7CIAXFjvGDfRaDssbzSibBsu/6iGtCOGEfz9zeNVs7ZRkDW7w09N75nAI4YbRvydbmyQd62R0mkff37lmMsPrBhtkcrv4TCYUTknC0EwyTvEN5RPT9RFLi103TZPLiHnH1S/9croKrnJ32nuhtK8UiNjoNq8Uhl5sN6todv5pC1cRITgq80Gv6U93vPBsg7j/VnXwl5B0rZp4e8W5vUsMWTfT7eTDp5OWIV7asfV9C1p9tGHdjzx1VA0AEh/VbpX4xzHpxNciG77Qxiu1qHgEtnmgyqQdgCpGBMMRtx3j5ca0AOAkpmaMzy4t6Gh25PXFAADwqTs6p+Y0KzAqCkc3OyX3Pjsm1Wn+IpGtNtahR9EGC4caKAH5eDdkCC/1ktkUDbHpOZ30sOFMqOiO6RELK9T6mO7RUMpt2JMiRe91kscD9TLOOjDNMcBw6za0GV/zP7HGbH1w+TkYEHziBR/tM/bR3pSRx96mpaRC4VTIu22NA2KAO8JI1BRHjCr7B//njom5/sp+MGDAjw1h+ONoAd9m0dj5OS5Syu8GUxmUed8r5ku6qwCMqKBv2s6c5wSJhFoIK6NtYR6Z8vvnJCRtGLVOM1ysDdGrnf15iKSwxFWKoRlBdyC24VDOK5J9SNclbkReMzy3Vys70A+ydGBDGJysEWztx+dxrgNY/3UqOmtseaWKmlSbUMWHBpB1XDXk42tSkDjKcz/RqqjatAEz2AMg4HkJaMdlRrmT9sj/OyVCdQ2h/62nt0cxeC4zDvfZLEO+GtjFCo6uIKVVbL3R8kyZlyywPHMAb1wIpOIg50q8F5FRQSseLdYKCKEbAujXDX1xZFgzARv2CUVQfxoychrAiu3CZh2pGDnRRqKkxCXA/7hwhfmw4JuUsUappHg5CPPyZ6eMWUMEhe2JIFs2tmpX51bgBlIjZwKCh/jB1pXfiMYP4HUo/L6RXHvyM4LqKT+i2hV3+crCmbt7S+6v75Yow+vq+HF1xqH4vdB74wf6G/qa7/eUwZ38Nl9EdSfeoRD0IIuUGqfRhTgEeKpSDj/iM1oyLt8XGQkz//////////wIBAg==",
  );
  
  =item $tls = new AnyEvent::TLS key => value...
  
  The constructor supports these arguments (all as key => value pairs).
  
  =over 4
  
  =item method => "SSLv2" | "SSLv3" | "TLSv1" | "TLSv1_1" | "TLSv1_2" | "any"
  
  The protocol parser to use. C<SSLv2>, C<SSLv3>, C<TLSv1>, C<TLSv1_1>
  and C<TLSv1_2> will use a parser for those protocols only (so will
  I<not> accept or create connections with/to other protocol versions),
  while C<any> (the default) uses a parser capable of all three
  protocols.
  
  The default is to use C<"any"> but disable SSLv2. This has the effect of
  sending a SSLv2 hello, indicating the support for SSLv3 and TLSv1, but not
  actually negotiating an (insecure) SSLv2 connection.
  
  Specifying a specific version is almost always wrong to use for a server
  speaking to a wide variety of clients (e.g. web browsers), and often wrong
  for a client. If you only want to allow a specific protocol version, use
  the C<sslv2>, C<sslv3>, C<tlsv1>, C<tlsv1_1> or C<tlsv1_2> arguments instead.
  
  For new services it is usually a good idea to enforce a C<TLSv1> method
  from the beginning.
  
  C<TLSv1_1> and C<TLSv1_2> require L<Net::SSLeay> >= 1.55 and OpenSSL
  >= 1.0.1. Check the L<Net::SSLeay> and OpenSSL documentations for more
  details.
  
  =item sslv2 => $enabled
  
  Enable or disable SSLv2 (normally I<disabled>).
  
  =item sslv3 => $enabled
  
  Enable or disable SSLv3 (normally I<enabled>).
  
  =item tlsv1 => $enabled
  
  Enable or disable TLSv1 (normally I<enabled>).
  
  =item tlsv1_1 => $enabled
  
  Enable or disable TLSv1_1 (normally I<enabled>).
  
  This requires L<Net::SSLeay> >= 1.55 and OpenSSL >= 1.0.1. Check the
  L<Net::SSLeay> and OpenSSL documentations for more details.
  
  =item tlsv1_2 => $enabled
  
  Enable or disable TLSv1_2 (normally I<enabled>).
  
  This requires L<Net::SSLeay> >= 1.55 and OpenSSL >= 1.0.1. Check the
  L<Net::SSLeay> and OpenSSL documentations for more details.
  
  =item verify => $enable
  
  Enable or disable peer certificate checking (default is I<disabled>, which
  is I<not recommended>).
  
  This is the "master switch" for all verify-related parameters and
  functions.
  
  If it is disabled, then no peer certificate verification will be done
  - the connection will be encrypted, but the peer certificate won't be
  verified against any known CAs, or whether it is still valid or not. No
  peername verification or custom verification will be done either.
  
  If enabled, then the peer certificate (required in client mode, optional
  in server mode, see C<verify_require_client_cert>) will be checked against
  its CA certificate chain - that means there must be a signing chain from
  the peer certificate to any of the CA certificates you trust locally, as
  specified by the C<ca_file> and/or C<ca_path> and/or C<ca_cert> parameters
  (or the system default CA repository, if all of those parameters are
  missing - see also the L<AnyEvent> manpage for the description of
  PERL_ANYEVENT_CA_FILE).
  
  Other basic checks, such as checking the validity period, will also be
  done, as well as optional peername/hostname/common name verification
  C<verify_peername>.
  
  An optional C<verify_cb> callback can also be set, which will be invoked
  with the verification results, and which can override the decision.
  
  =item verify_require_client_cert => $enable
  
  Enable or disable mandatory client certificates (default is
  I<disabled>). When this mode is enabled, then a client certificate will be
  required in server mode (a server certificate is mandatory, so in client
  mode, this switch has no effect).
  
  =item verify_peername => $scheme | $callback->($tls, $cert, $peername)
  
  TLS only protects the data that is sent - it cannot automatically verify
  that you are really talking to the right peer. The reason is that
  certificates contain a "common name" (and a set of possible alternative
  "names") that need to be checked against the peername (usually, but not
  always, the DNS name of the server) in a protocol-dependent way.
  
  This can be implemented by specifying a callback that has to verify that
  the actual C<$peername> matches the given certificate in C<$cert>.
  
  Since this can be rather hard to implement, AnyEvent::TLS offers a variety
  of predefined "schemes" (lifted from L<IO::Socket::SSL>) that are named
  like the protocols that use them:
  
  =over 4
  
  =item ldap (rfc4513), pop3,imap,acap (rfc2995), nntp (rfc4642)
  
  Simple wildcards in subjectAltNames are possible, e.g. *.example.org
  matches www.example.org but not lala.www.example.org. If nothing from
  subjectAltNames matches, it checks against the common name, but there are
  no wildcards allowed.
  
  =item http (rfc2818)
  
  Extended wildcards in subjectAltNames are possible, e.g. *.example.org or
  even www*.example.org. Wildcards in the common name are not allowed. The
  common name will be only checked if no host names are given in
  subjectAltNames.
  
  =item smtp (rfc3207)
  
  This RFC isn't very useful in determining how to do verification so it
  just assumes that subjectAltNames are possible, but no wildcards are
  possible anywhere.
  
  =item [$wildcards_in_alt, $wildcards_in_cn, $check_cn]
  
  You can also specify a scheme yourself by using an array reference with
  three integers.
  
  C<$wildcards_in_alt> and C<$wildcards_in_cn> specify whether and where
  wildcards (C<*>) are allowed in subjectAltNames and the common name,
  respectively. C<0> means no wildcards are allowed, C<1> means they
  are allowed only as the first component (C<*.example.org>), and C<2>
  means they can be used anywhere (C<www*.example.org>), except that very
  dangerous matches will not be allowed (C<*.org> or C<*>).
  
  C<$check_cn> specifies if and how the common name field is checked: C<0>
  means it will be completely ignored, C<1> means it will only be used if
  no host names have been found in the subjectAltNames, and C<2> means the
  common name will always be checked against the peername.
  
  =back
  
  You can specify either the name of the parent protocol (recommended,
  e.g. C<http>, C<ldap>), the protocol name as usually used in URIs
  (e.g. C<https>, C<ldaps>) or the RFC (not recommended, e.g. C<rfc2995>,
  C<rfc3920>).
  
  This verification will only be done when verification is enabled (C<<
  verify => 1 >>).
  
  =item verify_cb => $callback->($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)
  
  Provide a custom peer verification callback used by TLS sessions,
  which is called with the result of any other verification (C<verify>,
  C<verify_peername>).
  
  This callback will only be called when verification is enabled (C<< verify
  => 1 >>).
  
  C<$tls> is the C<AnyEvent::TLS> object associated with the session,
  while C<$ref> is whatever the user associated with the session (usually
  an L<AnyEvent::Handle> object when used by AnyEvent::Handle).
  
  C<$depth> is the current verification depth - C<$depth = 0> means the
  certificate to verify is the peer certificate, higher levels are its CA
  certificate and so on. In most cases, you can just return C<$preverify_ok>
  if the C<$depth> is non-zero:
  
     verify_cb => sub {
        my ($tls, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert) = @_;
  
        return $preverify_ok
           if $depth;
  
        # more verification
     },
  
  C<$preverify_ok> is true iff the basic verification of the certificates
  was successful (a valid CA chain must exist, the certificate has passed
  basic validity checks, peername verification succeeded).
  
  C<$x509_store_ctx> is the Net::SSLeay::X509_CTX> object.
  
  C<$cert> is the C<Net::SSLeay::X509> object representing the
  peer certificate, or zero if there was an error. You can call
  C<AnyEvent::TLS::certname $cert> to get a nice user-readable string to
  identify the certificate.
  
  The callback must return either C<0> to indicate failure, or C<1> to
  indicate success.
  
  =item verify_client_once => $enable
  
  Enable or disable skipping the client certificate verification on
  renegotiations (default is I<disabled>, the certificate will always be
  checked). Only makes sense in server mode.
  
  =item ca_file => $path
  
  If this parameter is specified and non-empty, it will be the path to a
  file with (server) CA certificates in PEM format that will be loaded. Each
  certificate will look like:
  
     -----BEGIN CERTIFICATE-----
     ... (CA certificate in base64 encoding) ...
     -----END CERTIFICATE-----
  
  You have to enable verify mode (C<< verify => 1 >>) for this parameter to
  have any effect.
  
  =item ca_path => $path
  
  If this parameter is specified and non-empty, it will be
  the path to a directory with hashed CA certificate files in
  PEM format. When the ca certificate is being verified, the
  certificate will be hashed and looked up in that directory (see
  L<http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html> for
  details)
  
  The certificates specified via C<ca_file> take precedence over the ones
  found in C<ca_path>.
  
  You have to enable verify mode (C<< verify => 1 >>) for this parameter to
  have any effect.
  
  =item ca_cert => $string
  
  In addition or instead of using C<ca_file> and/or C<ca_path>, you can
  also use C<ca_cert> to directly specify the CA certificates (there can be
  multiple) in PEM format, in a string.
  
  =item check_crl => $enable
  
  Enable or disable certificate revocation list checking. If enabled, then
  peer certificates will be checked against a list of revoked certificates
  issued by the CA. The revocation lists will be expected in the C<ca_path>
  directory.
  
  certificate verification will fail if this is enabled but no revocation
  list was found.
  
  This requires OpenSSL >= 0.9.7b. Check the OpenSSL documentation for more
  details.
  
  =item key_file => $path
  
  Path to the local private key file in PEM format (might be a combined
  certificate/private key file).
  
  The local certificate is used to authenticate against the peer - servers
  mandatorily need a certificate and key, clients can use a certificate and
  key optionally to authenticate, e.g. for log-in purposes.
  
  The key in the file should look similar this:
  
     -----BEGIN RSA PRIVATE KEY-----
     ...header data
     ... (key data in base64 encoding) ...
     -----END RSA PRIVATE KEY-----
  
  =item key => $string
  
  The private key string in PEM format (see C<key_file>, only one of
  C<key_file> or C<key> can be specified).
  
  The idea behind being able to specify a string is to avoid blocking in
  I/O. Unfortunately, Net::SSLeay fails to implement any interface to the
  needed OpenSSL functionality, this is currently implemented by writing to
  a temporary file.
  
  =item cert_file => $path
  
  The path to the local certificate file in PEM format (might be a combined
  certificate/private key file, including chained certificates).
  
  The local certificate (and key) are used to authenticate against the
  peer - servers mandatorily need a certificate and key, clients can use
  certificate and key optionally to authenticate, e.g. for log-in purposes.
  
  The certificate in the file should look like this:
  
     -----BEGIN CERTIFICATE-----
     ... (certificate in base64 encoding) ...
     -----END CERTIFICATE-----
  
  If the certificate file or string contain both the certificate and
  private key, then there is no need to specify a separate C<key_file> or
  C<key>.
  
  Additional signing certifiates to send to the peer (in SSLv3 and newer)
  can be specified by appending them to the certificate proper: the order
  must be from issuer certificate over any intermediate CA certificates to
  the root CA.
  
  So the recommended ordering for a combined key/cert/chain file, specified
  via C<cert_file> or C<cert> looks like this:
  
    certificate private key
    client/server certificate
    ca 1, signing client/server certficate
    ca 2, signing ca 1
    ...
  
  =item cert => $string
  
  The local certificate in PEM format (might be a combined
  certificate/private key file). See C<cert_file>.
  
  The idea behind being able to specify a string is to avoid blocking in
  I/O. Unfortunately, Net::SSLeay fails to implement any interface to the
  needed OpenSSL functionality, this is currently implemented by writing to
  a temporary file.
  
  =item cert_password => $string | $callback->($tls)
  
  The certificate password - if the certificate is password-protected, then
  you can specify its password here.
  
  Instead of providing a password directly (which is not so recommended),
  you can also provide a password-query callback. The callback will be
  called whenever a password is required to decode a local certificate, and
  is supposed to return the password.
  
  =item dh_file => $path
  
  Path to a file containing Diffie-Hellman parameters in PEM format, for
  use in servers. See also C<dh> on how to specify them directly, or use a
  pre-generated set.
  
  Diffie-Hellman key exchange generates temporary encryption keys that
  are not transferred over the connection, which means that even if the
  certificate key(s) are made public at a later time and a full dump of the
  connection exists, the key still cannot be deduced.
  
  These ciphers are only available with SSLv3 and later (which is the
  default with AnyEvent::TLS), and are only used in server/accept
  mode. Anonymous DH protocols are usually disabled by default, and usually
  not even compiled into the underlying library, as they provide no direct
  protection against man-in-the-middle attacks. The same is true for the
  common practise of self-signed certificates that you have to accept first,
  of course.
  
  =item dh => $string
  
  Specify the Diffie-Hellman parameters in PEM format directly as a string
  (see C<dh_file>), the default is C<ffdhe3072> unless C<dh_file> was
  specified.
  
  AnyEvent::TLS supports supports a number of precomputed DH parameters,
  since computing them is expensive. They are:
  
     # from RFC 7919 - recommended
     ffdhe2048, ffdhe3072, ffdhe4096, ffdhe6144, ffdhe8192
  
     # from "Assigned Number for SKIP Protocols"
     skip512, skip1024, skip2048, skip4096
  
     # from schmorp
     schmorp1024, schmorp1539, schmorp2048, schmorp4096, schmorp8192
  
  It is said that 2048 bit DH parameters are safe till 2030, and DH
  parameters shorter than 900 bits are totally insecure.
  
  To disable DH protocols completely, specify C<undef> as C<dh> parameter.
  
  =item dh_single_use => $enable
  
  Enables or disables "use only once" mode when using Diffie-Hellman key
  exchange. When enabled (default), each time a new key is exchanged a new
  Diffie-Hellman key is generated, which improves security as each key is
  only used once. When disabled, the key will be created as soon as the
  AnyEvent::TLS object is created and will be reused.
  
  All the DH parameters supplied with AnyEvent::TLS should be safe with
  C<dh_single_use> switched off, but YMMV.
  
  =item cipher_list => $string
  
  The list of ciphers to use, as a string (example:
  C<AES:ALL:!aNULL:!eNULL:+RC4:@STRENGTH>). The format
  of this string and its default value is documented at
  L<http://www.openssl.org/docs/apps/ciphers.html#CIPHER_STRINGS>.
  
  =item session_ticket => $enable
  
  Enables or disables RC5077 support (Session Resumption without Server-Side
  State). The default is disabled for clients, as many (buggy) TLS/SSL
  servers choke on it, but enabled for servers.
  
  When enabled and supported by the server, a session ticket will be
  provided to the client, which allows fast resuming of connections.
  
  =item prepare => $coderef->($tls)
  
  If this argument is present, then it will be called with the new
  AnyEvent::TLS object after any other initialisation has bee done, in case
  you wish to fine-tune something...
  
  =cut
  
  #=item trust => $trust
  #
  #Sets the expected (root) certificate use on this context, i.e. what 
  #certificates to trust. The default is C<compat>, and the following strings
  #are supported:
  #
  #   compat          any certifictae will do
  #   ssl_client      only trust client certificates
  #   ssl_server      only trust server certificates
  #   email           only trust e-mail certificates
  #   object_sign     only trust signing (CA) certificates
  #   ocsp_sign       only trust ocsp signing certs
  #   ocsp_request    only trust ocsp request certs
  
  # purpose?
  
  #TODO
  # verify_depth?
  # reuse_ctx
  # session_cache_size
  # session_cache
  
  #=item debug => $level
  #
  #Enable or disable sending debugging output to STDERR. This is, as
  #the name says, mostly for debugging. The default is taken from the
  #C<PERL_ANYEVENT_TLS_DEBUG> environment variable.
  #
  #=cut
  
  =back
  
  =cut
  
  sub init ();
  
  #our %X509_TRUST = (
  #   compat       => 1,
  #   ssl_client   => 2,
  #   ssl_server   => 3,
  #   email        => 4,
  #   object_sign  => 5,
  #   ocsp_sign    => 6,
  #   ocsp_request => 7,
  #);
  
  BEGIN {
     eval 'sub _check_tls_gt_1 (){'
        . (($Net::SSLeay::VERSION >= 1.55 && Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x1000100f) * 1)
        . '}';
  
     # as of this writing, Net::SSLeay (1.85-2) has not been ported to OpenSSL 1.1,
     # but many distributions and users compile it against openssl 1.1, leading to
     # many symbols not being defined because they are now enums instead of macros
     # and have different prefixes.
     # The only one we use is SSL_ST_OK, or TLS_ST_OK, which should be available
     # as Net::SSLeay::ST_OK. If it is not callable, we define it to be 1, which
     # hopefully will not change.
     eval 'Net::SSLeay::ST_OK (); 1'
        or *Net::SSLeay::ST_OK = sub () { 1 };
  }
  
  our %SSL_METHODS = (
     any     => \&Net::SSLeay::CTX_new,
     sslv23  => \&Net::SSLeay::CTX_new, # deliberately undocumented
     sslv2   => \&Net::SSLeay::CTX_v2_new,
     sslv3   => \&Net::SSLeay::CTX_v3_new,
     tlsv1   => \&Net::SSLeay::CTX_tlsv1_new,
  );
  
  # Add TLSv1_1 and TLSv1_2 if Net::SSLeay and openssl allow them
  if (_check_tls_gt_1) {
     $SSL_METHODS{tlsv1_1} = \&Net::SSLeay::CTX_tlsv1_1_new;
     $SSL_METHODS{tlsv1_2} = \&Net::SSLeay::CTX_tlsv1_2_new;
  } else {
     for my $method (qw(tlsv1_1 tlsv1_2)) {
        $SSL_METHODS{$method} = sub { croak "AnyEvent::TLS method '$method' requires openssl v1.0.1 and Net::SSLeay 1.55 or higher" };
     }
  }
  
  sub new {
     my ($class, %arg) = @_;
  
     init unless $REF_IDX;
  
     my $method = lc $arg{method} || "any";
  
     my $ctx = ($SSL_METHODS{$method}
                || croak "'$method' is not a valid AnyEvent::TLS method (must be one of @{[ sort keys %SSL_METHODS ]})")->();
  
     my $self = bless { ctx => $ctx }, $class; # to make sure it's destroyed if we croak
  
     my $op = Net::SSLeay::OP_ALL ();
  
     $op |= Net::SSLeay::OP_NO_SSLv2      () unless $arg{sslv2};
     $op |= Net::SSLeay::OP_NO_SSLv3      () if exists $arg{sslv3} && !$arg{sslv3};
     $op |= Net::SSLeay::OP_NO_TLSv1      () if exists $arg{tlsv1} && !$arg{tlsv1};
     $op |= Net::SSLeay::OP_NO_TLSv1_1    () if exists $arg{tlsv1_1} && !$arg{tlsv1_1} && _check_tls_gt_1;
     $op |= Net::SSLeay::OP_NO_TLSv1_2    () if exists $arg{tlsv1_2} && !$arg{tlsv1_2} && _check_tls_gt_1;
     $op |= Net::SSLeay::OP_SINGLE_DH_USE () if !exists $arg{dh_single_use} || $arg{dh_single_use};
  
     Net::SSLeay::CTX_set_options ($ctx, $op);
  
     Net::SSLeay::CTX_set_cipher_list ($ctx, $arg{cipher_list})
        or croak "'$arg{cipher_list}' was not accepted as a valid cipher list by AnyEvent::TLS"
           if exists $arg{cipher_list};
  
     my ($dh_bio, $dh_file);
  
     if (exists $arg{dh_file}) {
        $dh_file = $arg{dh_file};
  
        $dh_bio = Net::SSLeay::BIO_new_file ($dh_file, "r")
           or croak "$dh_file: failed to open DH parameter file: $!";
     } else {
        $arg{dh} = "ffdhe3072" unless exists $arg{dh};
  
        if (defined $arg{dh}) {
           $dh_file = "dh string";
  
           if ($arg{dh} =~ /^\w+$/) {
              $dh_file = "dh params $arg{dh}";
              $arg{dh} = "-----BEGIN DH PARAMETERS-----\n"
                       . (join "\n", unpack "(a74)*", $DH_PARAMS{$arg{dh}}) . "\n"
                       . "-----END DH PARAMETERS-----";
              $arg{dh} =~ s/\|/\n/g;
           }
  
           $dh_bio = Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());
           Net::SSLeay::BIO_write ($dh_bio, $arg{dh});
        }
     }
  
     if ($dh_bio) {
        my $dh = Net::SSLeay::PEM_read_bio_DHparams ($dh_bio);
        Net::SSLeay::BIO_free ($dh_bio);
        $dh or croak "$dh_file: failed to parse DH parameters - not PEM format?";
        my $rv = Net::SSLeay::CTX_set_tmp_dh ($ctx, $dh);
        Net::SSLeay::DH_free ($dh);
        $rv or croak "$dh_file: failed to set DH parameters";
     }
  
     if ($arg{verify}) {
        $self->{verify_mode} = Net::SSLeay::VERIFY_PEER ();
  
        $self->{verify_mode} |= Net::SSLeay::VERIFY_FAIL_IF_NO_PEER_CERT ()
           if $arg{verify_require_client_cert};
  
        $self->{verify_mode} |= Net::SSLeay::VERIFY_CLIENT_ONCE ()
           if $arg{verify_client_once};
  
     } else {
        $self->{verify_mode} = Net::SSLeay::VERIFY_NONE ();
     }
  
     $self->{verify_peername} = $arg{verify_peername}
        if exists $arg{verify_peername};
  
     $self->{verify_cb} = $arg{verify_cb}
        if exists $arg{verify_cb};
  
     $self->{session_ticket} = $arg{session_ticket}
        if exists $arg{session_ticket};
  
     $self->{debug} = $ENV{PERL_ANYEVENT_TLS_DEBUG}
        if length $ENV{PERL_ANYEVENT_TLS_DEBUG};
  
     $self->{debug} = $arg{debug}
        if exists $arg{debug};
  
     my $pw = $arg{cert_password};
     Net::SSLeay::CTX_set_default_passwd_cb ($ctx, ref $pw ? $pw : sub { $pw });
  
     if ($self->{verify_mode}) {
        if (exists $arg{ca_file} or exists $arg{ca_path} or exists $arg{ca_cert}) {
           # either specified: use them
           if (exists $arg{ca_cert}) {
              my ($ca_file, $g1) = _tmpfile delete $arg{ca_cert};
              Net::SSLeay::CTX_load_verify_locations ($ctx, $ca_file, undef);
           }
           if (exists $arg{ca_file} or exists $arg{ca_path}) {
              Net::SSLeay::CTX_load_verify_locations ($ctx, $arg{ca_file}, $arg{ca_path});
           }
        } elsif (length $ENV{PERL_ANYEVENT_CA_FILE} or length $ENV{PERL_ANYEVENT_CA_PATH}) {
           Net::SSLeay::CTX_load_verify_locations (
              $ctx,
              $ENV{PERL_ANYEVENT_CA_FILE},
              $ENV{PERL_ANYEVENT_CA_PATH},
           );
        } else {
           # else fall back to defaults
           Net::SSLeay::CTX_set_default_verify_paths ($ctx);
        }
     }
  
     if (exists $arg{cert} or exists $arg{cert_file}) {
        my ($g1, $g2);
  
        if (exists $arg{cert}) {
           croak "specifying both cert_file and cert is not allowed"
              if exists $arg{cert_file};
  
          ($arg{cert_file}, $g1) = _tmpfile delete $arg{cert};
        }
  
        if (exists $arg{key} or exists $arg{key_file}) {
           if (exists $arg{key}) {
              croak "specifying both key_file and key is not allowed"
                 if exists $arg{key_file};
             ($arg{key_file}, $g2) = _tmpfile delete $arg{key};
           }
        } else {
           $arg{key_file} = $arg{cert_file};
        }
  
        Net::SSLeay::CTX_use_PrivateKey_file
              ($ctx, $arg{key_file}, Net::SSLeay::FILETYPE_PEM ())
           or croak "$arg{key_file}: failed to load local private key (key_file or key)";
  
        Net::SSLeay::CTX_use_certificate_chain_file ($ctx, $arg{cert_file})
           or croak "$arg{cert_file}: failed to use local certificate chain (cert_file or cert)";
     }
  
     if ($arg{check_crl}) {
        Net::SSLeay::OPENSSL_VERSION_NUMBER () >= 0x00090702f
           or croak "check_crl requires openssl v0.9.7b or higher";
  
        Net::SSLeay::X509_STORE_set_flags (
           Net::SSLeay::CTX_get_cert_store ($ctx),
           Net::SSLeay::X509_V_FLAG_CRL_CHECK ());
     }
  
     Net::SSLeay::CTX_set_read_ahead ($ctx, 1);
  
     $arg{prepare}->($self)
        if $arg{prepare};
  
     $self
  }
  
  =item $tls = new_from_ssleay AnyEvent::TLS $ctx
  
  This constructor takes an existing L<Net::SSLeay> SSL_CTX object
  (which is just an integer) and converts it into an C<AnyEvent::TLS>
  object. This only works because AnyEvent::TLS is currently implemented
  using Net::SSLeay. As this is such a horrible perl module and OpenSSL has
  such an annoying license, this might change in the future, in which case
  this method might vanish.
  
  =cut
  
  sub new_from_ssleay {
     my ($class, $ctx) = @_;
  
     bless { ctx => $ctx }, $class
  }
  
  =item $ctx = $tls->ctx
  
  Returns the actual L<Net::SSLeay::CTX> object (just an integer).
  
  =cut
  
  sub ctx {
     $_[0]{ctx}
  }
  
  sub verify_hostname($$$);
  
  sub _verify_hostname {
     my ($self, $cn, $cert) = @_;
     
     return 1
        unless defined $cn;
  
     return 1
        unless exists $self->{verify_peername} && "none" ne lc $self->{verify_peername};
  
     return $self->{verify_peername}->($self, $cn, $cert)
        if ref $self->{verify_peername} && "ARRAY" ne ref $self->{verify_peername};
  
     verify_hostname $cn, $cert, $self->{verify_peername}
  }
  
  sub verify {
     my ($self, $session, $ref, $cn, $preverify_ok, $x509_store_ctx) = @_;
  
     my $cert = $x509_store_ctx
        ? Net::SSLeay::X509_STORE_CTX_get_current_cert ($x509_store_ctx)
        : undef;
     my $depth = Net::SSLeay::X509_STORE_CTX_get_error_depth ($x509_store_ctx);
  
     $preverify_ok &&= $self->_verify_hostname ($cn, $cert)
        unless $depth;
  
     $preverify_ok = $self->{verify_cb}->($self, $ref, $cn, $depth, $preverify_ok, $x509_store_ctx, $cert)
        if $self->{verify_cb};
  
     $preverify_ok
  }
  
  #=item $ssl = $tls->_get_session ($mode[, $ref])
  #
  #Creates a new Net::SSLeay::SSL session object, puts it into C<$mode>
  #(C<accept> or C<connect>) and optionally associates it with the given
  #C<$ref>. If C<$mode> is already a C<Net::SSLeay::SSL> object, then just
  #associate data with it.
  #
  #=cut
  
  #our %REF_MAP;
  our $TLS_SNI_WARNED;
  
  sub _get_session($$;$$) {
     my ($self, $mode, $ref, $cn) = @_;
  
     my $session;
  
     if ($mode eq "accept") {
        $session = Net::SSLeay::new ($self->{ctx});
        Net::SSLeay::set_accept_state ($session);
  
        Net::SSLeay::set_options ($session, eval { Net::SSLeay::OP_NO_TICKET () })
           unless $self->{session_ticket} || !exists $self->{session_ticket};
  
     } elsif ($mode eq "connect") {
        $session = Net::SSLeay::new ($self->{ctx});
  
        if (defined &Net::SSLeay::set_tlsext_host_name) {
           Net::SSLeay::set_tlsext_host_name ($session, $cn)
              if length $cn;
        } else {
           AE::log 6 => "TLS SNI not supported by your Net::SSLeay module, connecting without"
              unless $TLS_SNI_WARNED++;
        }
  
        Net::SSLeay::set_connect_state ($session);
  
        Net::SSLeay::set_options ($session, eval { Net::SSLeay::OP_NO_TICKET () })
           unless $self->{session_ticket};
     } else {
        croak "'$mode': unsupported TLS mode (must be either 'connect' or 'accept')"
     }
  
  #   # associate data
  #   Net::SSLeay::set_ex_data ($session, $REF_IDX, $ref+0);
  #   Scalar::Util::weaken ($REF_MAP{$ref+0} = $ref)
  #      if ref $ref;
     
     if ($self->{debug}) {
        #d# Net::SSLeay::set_info_callback ($session, 50000);
     }
  
     if ($self->{verify_mode}) {
        Scalar::Util::weaken $self;
        Scalar::Util::weaken $ref;
  
        # we have to provide a dummy callbacks as at least Net::SSLeay <= 1.35
        # try to call it even if specified as 0 or undef.
        Net::SSLeay::set_verify
           $session,
           $self->{verify_mode},
           sub { $self->verify ($session, $ref, $cn, @_) };
     }
  
     $session
  }
  
  sub _put_session($$) {
     my ($self, $session) = @_;
  
     # clear callback, if any
     # this leaks memoryin Net::SSLeay up to at least 1.35, but there
     # apparently is no other way.
     Net::SSLeay::set_verify $session, 0, undef;
  
  #   # disassociate data
  #   delete $REF_MAP{Net::SSLeay::get_ex_data ($session, $REF_IDX)};
  
     Net::SSLeay::free ($session);
  }
  
  #sub _ref($) {
  #   $REF_MAP{Net::SSLeay::get_ex_data ($_[0], $REF_IDX)}
  #}
  
  sub DESTROY {
     my ($self) = @_;
  
     # better be safe than sorry with net-ssleay
     Net::SSLeay::CTX_set_default_passwd_cb ($self->{ctx});
  
     Net::SSLeay::CTX_free ($self->{ctx});
  }
  
  =item AnyEvent::TLS::init
  
  AnyEvent::TLS does on-demand initialisation, and normally there is no need to call an initialise
  function.
  
  As initialisation might take some time (to read e.g. C</dev/urandom>), this
  could be annoying in some highly interactive programs. In that case, you can
  call C<AnyEvent::TLS::init> to make sure there will be no costly initialisation
  later. It is harmless to call C<AnyEvent::TLS::init> multiple times.
  
  =cut
  
  sub init() {
     return if $REF_IDX;
  
     AE::log 5 => "Net::SSLeay versions older than 1.33 might malfunction."
        if $Net::SSLeay::VERSION < 1.33;
  
     Net::SSLeay::load_error_strings ();
     Net::SSLeay::SSLeay_add_ssl_algorithms ();
     Net::SSLeay::randomize ();
  
     $REF_IDX = Net::SSLeay::get_ex_new_index (0, 0, 0, 0, 0)
        until $REF_IDX; # Net::SSLeay uses id #0 for its own stuff without allocating it
  }
  
  =item $certname = AnyEvent::TLS::certname $x509
  
  Utility function that returns a user-readable string identifying the X509
  certificate object.
  
  =cut
  
  sub certname {
     $_[0]
        ? Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_issuer_name ($_[0]))
          . Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_subject_name ($_[0]))
        : undef
  }
  
  our %CN_SCHEME = (
     # each tuple is [$cn_wildcards, $alt_wildcards, $check_cn]
     # where *_wildcards is 0 for none allowed, 1 for allowed at beginning and 2 for allowed everywhere
     # and check_cn is 0 for do not check, 1 for check when no alternate dns names and 2 always
     # all of this is from IO::Socket::SSL
  
     rfc4513 => [0, 1, 2],
     rfc2818 => [0, 2, 1],
     rfc3207 => [0, 0, 2], # see IO::Socket::SSL, rfc seems unclear
     none    => [],        # do not check
  
     ldap    => "rfc4513",                    ldaps => "ldap",
     http    => "rfc2818",                    https => "http",
     smtp    => "rfc3207",                    smtps => "smtp",
  
     xmpp    => "rfc3920", rfc3920 => "http",
     pop3    => "rfc2595", rfc2595 => "ldap", pop3s => "pop3",
     imap    => "rfc2595", rfc2595 => "ldap", imaps => "imap",
     acap    => "rfc2595", rfc2595 => "ldap",
     nntp    => "rfc4642", rfc4642 => "ldap", nntps => "nntp",
     ftp     => "rfc4217", rfc4217 => "http", ftps  => "ftp" ,
  );
  
  sub match_cn($$$) {
     my ($name, $cn, $type) = @_;
  
     # remove leading and trailing garbage
     for ($name, $cn) {
        s/[\x00-\x1f]+$//;
        s/^[\x00-\x1f]+//;
     }
  
     my $pattern;
  
     ### IMPORTANT!
     # we accept only a single wildcard and only for a single part of the FQDN
     # e.g *.example.org does match www.example.org but not bla.www.example.org
     # The RFCs are in this regard unspecific but we don't want to have to
     # deal with certificates like *.com, *.co.uk or even *
     # see also http://nils.toedtmann.net/pub/subjectAltName.txt
     if ($type == 2 and $name =~m{^([^.]*)\*(.+)} ) {
        $pattern = qr{^\Q$1\E[^.]*\Q$2\E$}i;
     } elsif ($type == 1 and $name =~m{^\*(\..+)$} ) {
        $pattern = qr{^[^.]*\Q$1\E$}i;
     } else {
        $pattern = qr{^\Q$name\E$}i;
     }
  
     $cn =~ $pattern
  }
  
  # taken verbatim from IO::Socket::SSL, then changed to take advantage of
  # AnyEvent utilities.
  sub verify_hostname($$$) {
     my ($cn, $cert, $scheme) = @_;
  
     while (!ref $scheme) {
        $scheme = $CN_SCHEME{$scheme}
           or return 1;
     }
  
     my $cert_cn =
        Net::SSLeay::X509_NAME_get_text_by_NID (
           Net::SSLeay::X509_get_subject_name ($cert), Net::SSLeay::NID_commonName ());
  
     my @cert_alt = Net::SSLeay::X509_get_subjectAltNames ($cert);
  
     # rfc2460 - convert to network byte order
     require AnyEvent::Socket;
     my $ip = AnyEvent::Socket::parse_address ($cn);
  
     my $alt_dns_count;
  
     while (my ($type, $name) = splice @cert_alt, 0, 2) {
        if ($type == Net::SSLeay::GEN_IPADD ()) {
           # $name is already packed format (inet_xton)
           return 1 if $ip eq $name;
        } elsif ($type == Net::SSLeay::GEN_DNS ()) {
           $alt_dns_count++;
  
           return 1 if match_cn $name, $cn, $scheme->[1];
        }
     }
  
     if ($scheme->[2] == 2
         || ($scheme->[2] == 1 && !$alt_dns_count)) {
        return 1 if match_cn $cert_cn, $cn, $scheme->[0];
     }
  
     0
  }
  
  =back
  
  =head1 SSL/TLS QUICK FACTS
  
  Here are some quick facts about TLS/SSL that might help you:
  
  =over 4
  
  =item * A certificate is the public key part, a key is the private key part.
  
  While not strictly true, certificates are the things you can hand around
  publicly as a kind of identity, while keys should really be kept private,
  as proving that you have the private key is usually interpreted as being
  the entity behind the certificate.
  
  =item * A certificate is signed by a CA (Certificate Authority).
  
  By signing, the CA basically claims that the certificate it signs
  really belongs to the identity named in it, verified according to the
  CA policies. For e.g. HTTPS, the CA usually makes some checks that the
  hostname mentioned in the certificate really belongs to the company/person
  that requested the signing and owns the domain.
  
  =item * CAs can be certified by other CAs.
  
  Or by themselves - a certificate that is signed by a CA that is itself
  is called a self-signed certificate, a trust chain of length zero. When
  you find a certificate signed by another CA, which is in turn signed by
  another CA you trust, you have a trust chain of depth two.
  
  =item * "Trusting" a CA means trusting all certificates it has signed.
  
  If you "trust" a CA certificate, then all certificates signed by it are
  automatically considered trusted as well.
  
  =item * A successfully verified certificate means that you can be
  reasonably sure that whoever you are talking with really is who he claims
  he is.
  
  By verifying certificates against a number of CAs that you trust (meaning
  it is signed directly or indirectly by such a CA), you can find out that
  the other side really is whoever he claims, according to the CA policies,
  and your belief in the integrity of the CA.
  
  =item * Verifying the certificate signature is not everything.
  
  Even when the certificate is correct, it might belong to somebody else: if
  www.attacker.com can make your computer believe that it is really called
  www.mybank.com (by making your DNS server believe this for example),
  then it could send you the certificate for www.attacker.com that your
  software trusts because it is signed by a CA you trust, and intercept
  all your traffic that you think goes to www.mybank.com. This works
  because your software sees that the certificate is correctly signed (for
  www.attacker.com) and you think you are talking to your bank.
  
  To thwart this attack vector, peername verification should be used, which
  basically checks that the certificate (for www.attacker.com) really
  belongs to the host you are trying to talk to (www.mybank.com), which in
  this example is not the case, as www.attacker.com (from the certificate)
  doesn't match www.mybank.com (the hostname used to create the connection).
  
  So peername verification is almost as important as checking the CA
  signing. Unfortunately, every protocol implements this differently, if at
  all...
  
  =item * Switching off verification is sometimes reasonable.
  
  You can switch off verification. You still get an encrypted connection
  that is protected against eavesdropping and injection - you just lose
  protection against man in the middle attacks, i.e. somebody else with
  enough abilities to intercept all traffic can masquerade herself as the
  other side.
  
  For many applications, switching off verification is entirely
  reasonable. Downloading random stuff from websites using HTTPS for no
  reason is such an application. Talking to your bank and entering TANs is
  not such an application.
  
  =item * A SSL/TLS server always needs a certificate/key pair to operate,
  for clients this is optional.
  
  Apart from (usually disabled) anonymous cipher suites, a server always
  needs a certificate/key pair to operate.
  
  Clients almost never use certificates, but if they do, they can be used
  to authenticate the client, just as server certificates can be used to
  authenticate the server.
  
  =item * SSL version 2 is very insecure.
  
  SSL version 2 is old and not only has it some security issues, SSLv2-only
  implementations are usually buggy, too, due to their age.
  
  =item * Sometimes, even losing your "private" key might not expose all your
  data.
  
  With Diffie-Hellman ephemeral key exchange, you can lose the DH parameters
  (the "keys"), but all your connections are still protected. Diffie-Hellman
  needs special set-up (done by default by AnyEvent::TLS).
  
  =back
  
  =head1 SECURITY CONSIDERATIONS
  
  When you use any of the options that pass in keys or certificates
  as strings (e.g. C<ca_cert>), then, due to serious shortcomings in
  L<Net::SSLeay>, this module creates a temporary file to store the string -
  see L<File::Temp> and possibly its C<safe_level> setting for more details
  on what to watch out for.
  
  =head1 BUGS
  
  Due to the abysmal code quality of Net::SSLeay, this module will leak small
  amounts of memory per TLS connection (currently at least one perl scalar).
  
  =head1 AUTHORS
  
  Marc Lehmann <schmorp@schmorp.de>.
  
  Some of the API, documentation and implementation (verify_hostname),
  and a lot of ideas/workarounds/knowledge have been taken from the
  L<IO::Socket::SSL> module. Care has been taken to keep the API similar to
  that and other modules, to the extent possible while providing a sensible
  API for AnyEvent.
  
  =cut
  
  1
  
ANYEVENT_TLS

$fatpacked{"AnyEvent/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL';
  =encoding utf-8
  
  =head1 NAME
  
  AnyEvent::Util - various utility functions.
  
  =head1 SYNOPSIS
  
     use AnyEvent::Util;
  
  =head1 DESCRIPTION
  
  This module implements various utility functions, mostly replacing
  well-known functions by event-ised counterparts.
  
  All functions documented without C<AnyEvent::Util::> prefix are exported
  by default.
  
  =over 4
  
  =cut
  
  package AnyEvent::Util;
  
  use Carp ();
  use Errno ();
  use Socket ();
  
  use AnyEvent (); BEGIN { AnyEvent::common_sense }
  
  use base 'Exporter';
  
  our @EXPORT = qw(fh_nonblocking guard fork_call portable_pipe portable_socketpair run_cmd);
  our @EXPORT_OK = qw(
     AF_INET6 WSAEWOULDBLOCK WSAEINPROGRESS WSAEINVAL
     close_all_fds_except
     punycode_encode punycode_decode idn_nameprep idn_to_ascii idn_to_unicode
  );
  
  our $VERSION = $AnyEvent::VERSION;
  
  BEGIN {
     # provide us with AF_INET6, but only if allowed
     if (
        $AnyEvent::PROTOCOL{ipv6}
        && _AF_INET6
        && socket my $ipv6_socket, _AF_INET6, Socket::SOCK_DGRAM(), 0 # check if they can be created
     ) {
        *AF_INET6 = \&_AF_INET6;
     } else {
        # disable ipv6
        *AF_INET6 = sub () { 0 };
        delete $AnyEvent::PROTOCOL{ipv6};
     }
  
     # fix buggy Errno on some non-POSIX platforms
     # such as openbsd and windows.
     my %ERR = (
        EBADMSG => Errno::EDOM   (),
        EPROTO  => Errno::ESPIPE (),
     );
  
     while (my ($k, $v) = each %ERR) {
        next if eval "Errno::$k ()";
        AE::log 8 => "Broken Errno module, adding Errno::$k.";
  
        eval "sub Errno::$k () { $v }";
        push @Errno::EXPORT_OK, $k;
        push @{ $Errno::EXPORT_TAGS{POSIX} }, $k;
     }
  }
  
  =item ($r, $w) = portable_pipe
  
  Calling C<pipe> in Perl is portable - except it doesn't really work on
  sucky windows platforms (at least not with most perls - cygwin's perl
  notably works fine): On windows, you actually get two file handles you
  cannot use select on.
  
  This function gives you a pipe that actually works even on the broken
  windows platform (by creating a pair of TCP sockets on windows, so do not
  expect any speed from that) and using C<pipe> everywhere else.
  
  See C<portable_socketpair>, below, for a bidirectional "pipe".
  
  Returns the empty list on any errors.
  
  =item ($fh1, $fh2) = portable_socketpair
  
  Just like C<portable_pipe>, above, but returns a bidirectional pipe
  (usually by calling C<socketpair> to create a local loopback socket pair,
  except on windows, where it again returns two interconnected TCP sockets).
  
  Returns the empty list on any errors.
  
  =cut
  
  BEGIN {
     if (AnyEvent::WIN32) {
        *_win32_socketpair = sub () {
           # perl's socketpair emulation fails on many vista machines, because
           # vista returns fantasy port numbers.
  
           for (1..10) {
              socket my $l, Socket::AF_INET(), Socket::SOCK_STREAM(), 0
                 or next;
  
              bind $l, Socket::pack_sockaddr_in 0, "\x7f\x00\x00\x01"
                 or next;
  
              my $sa = getsockname $l
                 or next;
  
              listen $l, 1
                 or next;
  
              socket my $r, Socket::AF_INET(), Socket::SOCK_STREAM(), 0
                 or next;
  
              bind $r, Socket::pack_sockaddr_in 0, "\x7f\x00\x00\x01"
                 or next;
  
              connect $r, $sa
                 or next;
  
              accept my $w, $l
                 or next;
  
              # vista has completely broken peername/sockname that return
              # fantasy ports. this combo seems to work, though.
              (Socket::unpack_sockaddr_in getpeername $r)[0]
              == (Socket::unpack_sockaddr_in getsockname $w)[0]
                 or (($! = WSAEINVAL), next);
  
              # vista example (you can't make this shit up...):
              #(Socket::unpack_sockaddr_in getsockname $r)[0] == 53364
              #(Socket::unpack_sockaddr_in getpeername $r)[0] == 53363
              #(Socket::unpack_sockaddr_in getsockname $w)[0] == 53363
              #(Socket::unpack_sockaddr_in getpeername $w)[0] == 53365
  
              return ($r, $w);
           }
  
           ()
        };
  
        *portable_socketpair = \&_win32_socketpair;
        *portable_pipe       = \&_win32_socketpair;
     } else {
        *portable_pipe = sub () {
           my ($r, $w);
  
           pipe $r, $w
              or return;
  
           ($r, $w);
        };
  
        *portable_socketpair = sub () {
           socketpair my $fh1, my $fh2, Socket::AF_UNIX(), Socket::SOCK_STREAM(), 0
              or return;
  
           ($fh1, $fh2)
        };
     }
  }
  
  =item fork_call { CODE } @args, $cb->(@res)
  
  Executes the given code block asynchronously, by forking. Everything the
  block returns will be transferred to the calling process (by serialising and
  deserialising via L<Storable>).
  
  If there are any errors, then the C<$cb> will be called without any
  arguments. In that case, either C<$@> contains the exception (and C<$!> is
  irrelevant), or C<$!> contains an error number. In all other cases, C<$@>
  will be C<undef>ined.
  
  The code block must not ever call an event-polling function or use
  event-based programming that might cause any callbacks registered in the
  parent to run.
  
  Win32 spoilers: Due to the endlessly sucky and broken native windows
  perls (there is no way to cleanly exit a child process on that platform
  that doesn't also kill the parent), you have to make sure that your main
  program doesn't exit as long as any C<fork_calls> are still in progress,
  otherwise the program won't exit. Also, on most windows platforms some
  memory will leak for every invocation. We are open for improvements that
  don't require XS hackery.
  
  Note that forking can be expensive in large programs (RSS 200MB+). On
  windows, it is abysmally slow, do not expect more than 5..20 forks/s on
  that sucky platform (note this uses perl's pseudo-threads, so avoid those
  like the plague).
  
  Example: poor man's async disk I/O (better use L<AnyEvent::IO> together
  with L<IO::AIO>).
  
     fork_call {
        open my $fh, "</etc/passwd"
           or die "passwd: $!";
        local $/;
        <$fh>
     } sub {
        my ($passwd) = @_;
        ...
     };
  
  =item $AnyEvent::Util::MAX_FORKS [default: 10]
  
  The maximum number of child processes that C<fork_call> will fork in
  parallel. Any additional requests will be queued until a slot becomes free
  again.
  
  The environment variable C<PERL_ANYEVENT_MAX_FORKS> is used to initialise
  this value.
  
  =cut
  
  our $MAX_FORKS = int 1 * $ENV{PERL_ANYEVENT_MAX_FORKS};
  $MAX_FORKS = 10 if $MAX_FORKS <= 0;
  
  my $forks;
  my @fork_queue;
  
  sub _fork_schedule;
  sub _fork_schedule {
     require Storable unless $Storable::VERSION;
     require POSIX    unless $POSIX::VERSION;
  
     while ($forks < $MAX_FORKS) {
        my $job = shift @fork_queue
           or last;
  
        ++$forks;
  
        my $coderef = shift @$job;
        my $cb = pop @$job;
        
        # gimme a break...
        my ($r, $w) = portable_pipe
           or ($forks and last) # allow failures when we have at least one job
           or die "fork_call: $!";
  
        my $pid = fork;
  
        if ($pid != 0) {
           # parent
           close $w;
  
           my $buf;
  
           my $ww; $ww = AE::io $r, 0, sub {
              my $len = sysread $r, $buf, 65536, length $buf;
  
              return unless defined $len or $! != Errno::EINTR;
  
              if (!$len) {
                 undef $ww;
                 close $r;
                 --$forks;
                 _fork_schedule;
                 
                 my $result = eval { Storable::thaw ($buf) };
                 $result = [$@] unless $result;
                 $@ = shift @$result;
  
                 $cb->(@$result);
  
                 # work around the endlessly broken windows perls
                 kill 9, $pid if AnyEvent::WIN32;
  
                 # clean up the pid
                 waitpid $pid, 0;
              }
           };
  
        } elsif (defined $pid) {
           # child
           close $r;
  
           my $result = eval {
              local $SIG{__DIE__};
  
              Storable::freeze ([undef, $coderef->(@$job)])
           };
  
           $result = Storable::freeze (["$@"])
              if $@;
  
           # windows forces us to these contortions
           my $ofs;
  
           while () {
              my $len = (length $result) - $ofs
                 or last;
  
              $len = syswrite $w, $result, $len < 65536 ? $len : 65536, $ofs;
  
              last unless $len || (!defined $len && $! == Errno::EINTR);
  
              $ofs += $len;
           }
  
           # on native windows, _exit KILLS YOUR FORKED CHILDREN!
           if (AnyEvent::WIN32) {
              shutdown $w, 1; # signal parent to please kill us
              sleep 10; # give parent a chance to clean up
              sysread $w, (my $buf), 1; # this *might* detect the parent exiting in some cases.
           }
           POSIX::_exit (0);
           exit 1;
           
        } elsif (($! != &Errno::EAGAIN && $! != &Errno::EWOULDBLOCK && $! != &Errno::ENOMEM) || !$forks) {
           # we ignore some errors as long as we can run at least one job
           # maybe we should wait a few seconds and retry instead
           die "fork_call: $!";
        }
     }
  }
  
  sub fork_call(&@) {
     push @fork_queue, [@_];
     _fork_schedule;
  }
  
  END {
     if (AnyEvent::WIN32) {
        while ($forks) {
           @fork_queue = ();
           AnyEvent->one_event;
        }
     }
  }
  
  # to be removed
  sub dotted_quad($) {
     $_[0] =~ /^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)$/x
  }
  
  # just a forwarder
  sub inet_aton {
     require AnyEvent::Socket;
     *inet_aton = \&AnyEvent::Socket::inet_aton;
     goto &inet_aton
  }
  
  =item fh_nonblocking $fh, $nonblocking
  
  Sets the blocking state of the given filehandle (true == nonblocking,
  false == blocking). Uses fcntl on anything sensible and ioctl FIONBIO on
  broken (i.e. windows) platforms.
  
  Instead of using this function, you could use C<AnyEvent::fh_block> or
  C<AnyEvent::fh_unblock>.
  
  =cut
  
  BEGIN {
     *fh_nonblocking = \&AnyEvent::_fh_nonblocking;
  }
  
  =item $guard = guard { CODE }
  
  This function creates a special object that, when destroyed, will execute
  the code block.
  
  This is often handy in continuation-passing style code to clean up some
  resource regardless of where you break out of a process.
  
  The L<Guard> module will be used to implement this function, if it is
  available. Otherwise a pure-perl implementation is used.
  
  While the code is allowed to throw exceptions in unusual conditions, it is
  not defined whether this exception will be reported (at the moment, the
  Guard module and AnyEvent's pure-perl implementation both try to report
  the error and continue).
  
  You can call one method on the returned object:
  
  =item $guard->cancel
  
  This simply causes the code block not to be invoked: it "cancels" the
  guard.
  
  =cut
  
  BEGIN {
     if (!$ENV{PERL_ANYEVENT_AVOID_GUARD} && eval { require Guard; $Guard::VERSION >= 0.5 }) {
        *guard = \&Guard::guard;
        AE::log 8 => "Using Guard module to implement guards.";
     } else {
        *AnyEvent::Util::guard::DESTROY = sub {
           local $@;
  
           eval {
              local $SIG{__DIE__};
              ${$_[0]}->();
           };
  
           AE::log 4 => "Runtime error in AnyEvent::guard callback: $@" if $@;
        };
  
        *AnyEvent::Util::guard::cancel = sub ($) {
           ${$_[0]} = sub { };
        };
  
        *guard = sub (&) {
           bless \(my $cb = shift), "AnyEvent::Util::guard"
        };
  
        AE::log 8 => "Using pure-perl guard implementation.";
     }
  }
  
  =item AnyEvent::Util::close_all_fds_except @fds
  
  This rarely-used function simply closes all file descriptors (or tries to)
  of the current process except the ones given as arguments.
  
  When you want to start a long-running background server, then it is often
  beneficial to do this, as too many C-libraries are too stupid to mark
  their internal fd's as close-on-exec.
  
  The function expects to be called shortly before an C<exec> call.
  
  Example: close all fds except 0, 1, 2.
  
     close_all_fds_except 0, 2, 1;
  
  =cut
  
  sub close_all_fds_except {
     my %except; @except{@_} = ();
  
     require POSIX unless $POSIX::VERSION;
  
     # some OSes have a usable /dev/fd, sadly, very few
     if ($^O =~ /(freebsd|cygwin|linux)/) {
        # netbsd, openbsd, solaris have a broken /dev/fd
        my $dir;
        if (opendir $dir, "/dev/fd" or opendir $dir, "/proc/self/fd") {
           my @fds = sort { $a <=> $b } grep /^\d+$/, readdir $dir;
           # broken OS's have device nodes for 0..63 usually, solaris 0..255
           if (@fds < 20 or "@fds" ne join " ", 0..$#fds) {
              # assume the fds array is valid now
              exists $except{$_} or POSIX::close ($_)
                 for @fds;
              return;
           }
        }
     }
  
     my $fd_max = eval { POSIX::sysconf (POSIX::_SC_OPEN_MAX ()) - 1 } || 1023;
  
     exists $except{$_} or POSIX::close ($_)
        for 0..$fd_max;
  }
  
  =item $cv = run_cmd $cmd, key => value...
  
  Run a given external command, potentially redirecting file descriptors and
  return a condition variable that gets sent the exit status (like C<$?>)
  when the program exits I<and> all redirected file descriptors have been
  exhausted.
  
  The C<$cmd> is either a single string, which is then passed to a shell, or
  an arrayref, which is passed to the C<execvp> function (the first array
  element is used both for the executable name and argv[0]).
  
  The key-value pairs can be:
  
  =over 4
  
  =item ">" => $filename
  
  Redirects program standard output into the specified filename, similar to C<<
  >filename >> in the shell.
  
  =item ">" => \$data
  
  Appends program standard output to the referenced scalar. The condvar will
  not be signalled before EOF or an error is signalled.
  
  Specifying the same scalar in multiple ">" pairs is allowed, e.g. to
  redirect both stdout and stderr into the same scalar:
  
      ">"  => \$output,
      "2>" => \$output,
  
  =item ">" => $filehandle
  
  Redirects program standard output to the given filehandle (or actually its
  underlying file descriptor).
  
  =item ">" => $callback->($data)
  
  Calls the given callback each time standard output receives some data,
  passing it the data received. On EOF or error, the callback will be
  invoked once without any arguments.
  
  The condvar will not be signalled before EOF or an error is signalled.
  
  =item "fd>" => $see_above
  
  Like ">", but redirects the specified fd number instead.
  
  =item "<" => $see_above
  
  The same, but redirects the program's standard input instead. The same
  forms as for ">" are allowed.
  
  In the callback form, the callback is supposed to return data to be
  written, or the empty list or C<undef> or a zero-length scalar to signal
  EOF.
  
  Similarly, either the write data must be exhausted or an error is to be
  signalled before the condvar is signalled, for both string-reference and
  callback forms.
  
  =item "fd<" => $see_above
  
  Like "<", but redirects the specified file descriptor instead.
  
  =item on_prepare => $cb
  
  Specify a callback that is executed just before the command is C<exec>'ed,
  in the child process. Be careful not to use any event handling or other
  services not available in the child.
  
  This can be useful to set up the environment in special ways, such as
  changing the priority of the command or manipulating signal handlers (e.g.
  setting C<SIGINT> to C<IGNORE>).
  
  =item close_all => $boolean
  
  When C<close_all> is enabled (default is disabled), then all extra file
  descriptors will be closed, except the ones that were redirected and C<0>,
  C<1> and C<2>.
  
  See C<close_all_fds_except> for more details.
  
  =item '$$' => \$pid
  
  A reference to a scalar which will receive the PID of the newly-created
  subprocess after C<run_cmd> returns.
  
  Note the the PID might already have been recycled and used by an unrelated
  process at the time C<run_cmd> returns, so it's not useful to send
  signals, use as a unique key in data structures and so on.
  
  =back
  
  Example: run C<rm -rf />, redirecting standard input, output and error to
  F</dev/null>.
  
     my $cv = run_cmd [qw(rm -rf /)],
        "<", "/dev/null",
        ">", "/dev/null",
        "2>", "/dev/null";
     $cv->recv and die "d'oh! something survived!"
  
  Example: run F<openssl> and create a self-signed certificate and key,
  storing them in C<$cert> and C<$key>. When finished, check the exit status
  in the callback and print key and certificate.
  
     my $cv = run_cmd [qw(openssl req
                       -new -nodes -x509 -days 3650
                       -newkey rsa:2048 -keyout /dev/fd/3
                       -batch -subj /CN=AnyEvent
                      )],
        "<", "/dev/null",
        ">" , \my $cert,
        "3>", \my $key,
        "2>", "/dev/null";
  
     $cv->cb (sub {
        shift->recv and die "openssl failed";
  
        print "$key\n$cert\n";
     });
  
  =cut
  
  sub run_cmd {
     my $cmd = shift;
  
     require POSIX unless $POSIX::VERSION;
  
     my $cv = AE::cv;
  
     my %arg;
     my %redir;
     my @exe;
  
     while (@_) {
        my ($type, $ob) = splice @_, 0, 2;
  
        my $fd = $type =~ s/^(\d+)// ? $1 : undef;
  
        if ($type eq ">") {
           $fd = 1 unless defined $fd;
  
           if (defined eval { fileno $ob }) {
              $redir{$fd} = $ob;
           } elsif (ref $ob) {
              my ($pr, $pw) = AnyEvent::Util::portable_pipe;
              $cv->begin;
  
              fcntl $pr, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fh_nonblocking $pr, 1;
              my $w; $w = AE::io $pr, 0,
                 "SCALAR" eq ref $ob
                    ? sub {
                         defined (sysread $pr, $$ob, 16384, length $$ob
                                  and return)
                            or ($! == Errno::EINTR and return);
                         undef $w; $cv->end;
                      }
                    : sub {
                         my $buf;
                         defined (sysread $pr, $buf, 16384
                                  and return $ob->($buf))
                            or ($! == Errno::EINTR and return);
                         undef $w; $cv->end;
                         $ob->();
                      }
              ;
              $redir{$fd} = $pw;
           } else {
              push @exe, sub {
                 open my $fh, ">", $ob
                    or POSIX::_exit (125);
                 $redir{$fd} = $fh;
              };
           }
  
        } elsif ($type eq "<") {
           $fd = 0 unless defined $fd;
  
           if (defined eval { fileno $ob }) {
              $redir{$fd} = $ob;
           } elsif (ref $ob) {
              my ($pr, $pw) = AnyEvent::Util::portable_pipe;
              $cv->begin;
  
              my $data;
              if ("SCALAR" eq ref $ob) {
                 $data = $$ob;
                 $ob = sub { };
              } else {
                 $data = $ob->();
              }
  
              fcntl $pw, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fh_nonblocking $pw, 1;
              my $w; $w = AE::io $pw, 1, sub {
                 my $len = syswrite $pw, $data;
  
                 return unless defined $len or $! != Errno::EINTR;
  
                 if (!$len) {
                    undef $w; $cv->end;
                 } else {
                    substr $data, 0, $len, "";
                    unless (length $data) {
                       $data = $ob->();
                       unless (length $data) {
                          undef $w; $cv->end
                       }
                    }
                 }
              };
  
              $redir{$fd} = $pr;
           } else {
              push @exe, sub {
                 open my $fh, "<", $ob
                    or POSIX::_exit (125);
                 $redir{$fd} = $fh;
              };
           }
  
        } else {
           $arg{$type} = $ob;
        }
     }
  
     my $pid = fork;
  
     defined $pid
        or Carp::croak "fork: $!";
  
     unless ($pid) {
        # step 1, execute
        $_->() for @exe;
  
        # step 2, move any existing fd's out of the way
        # this also ensures that dup2 is never called with fd1==fd2
        # so the cloexec flag is always cleared
        my (@oldfh, @close);
        for my $fh (values %redir) {
           push @oldfh, $fh; # make sure we keep it open
           $fh = fileno $fh; # we only want the fd
  
           # dup if we are in the way
           # if we "leak" fds here, they will be dup2'ed over later
           defined ($fh = POSIX::dup ($fh)) or POSIX::_exit (124)
              while exists $redir{$fh};
        }
  
        # step 3, execute redirects
        while (my ($k, $v) = each %redir) {
           defined POSIX::dup2 ($v, $k)
              or POSIX::_exit (123);
        }
  
        # step 4, close everything else, except 0, 1, 2
        if ($arg{close_all}) {
           close_all_fds_except 0, 1, 2, keys %redir
        } else {
           POSIX::close ($_)
              for values %redir;
        }
  
        eval { $arg{on_prepare}(); 1 } or POSIX::_exit (123)
           if exists $arg{on_prepare};
  
        ref $cmd
           ? exec {$cmd->[0]} @$cmd
           : exec $cmd;
  
        POSIX::_exit (126);
     }
  
     ${$arg{'$$'}} = $pid
        if $arg{'$$'};
  
     %redir = (); # close child side of the fds
  
     my $status;
     $cv->begin (sub { shift->send ($status) });
     my $cw; $cw = AE::child $pid, sub {
        $status = $_[1];
        undef $cw; $cv->end;
     };
  
     $cv
  }
  
  =item AnyEvent::Util::punycode_encode $string
  
  Punycode-encodes the given C<$string> and returns its punycode form. Note
  that uppercase letters are I<not> casefolded - you have to do that
  yourself.
  
  Croaks when it cannot encode the string.
  
  =item AnyEvent::Util::punycode_decode $string
  
  Tries to punycode-decode the given C<$string> and return its unicode
  form. Again, uppercase letters are not casefoled, you have to do that
  yourself.
  
  Croaks when it cannot decode the string.
  
  =cut
  
  sub punycode_encode($) {
     require "AnyEvent/Util/idna.pl";
     goto &punycode_encode;
  }
  
  sub punycode_decode($) {
     require "AnyEvent/Util/idna.pl";
     goto &punycode_decode;
  }
  
  =item AnyEvent::Util::idn_nameprep $idn[, $display]
  
  Implements the IDNA nameprep normalisation algorithm. Or actually the
  UTS#46 algorithm. Or maybe something similar - reality is complicated
  between IDNA2003, UTS#46 and IDNA2008. If C<$display> is true then the name
  is prepared for display, otherwise it is prepared for lookup (default).
  
  If you have no clue what this means, look at C<idn_to_ascii> instead.
  
  This function is designed to avoid using a lot of resources - it uses
  about 1MB of RAM (most of this due to Unicode::Normalize). Also, names
  that are already "simple" will only be checked for basic validity, without
  the overhead of full nameprep processing.
  
  =cut
  
  our ($uts46_valid, $uts46_imap);
  
  sub idn_nameprep($;$) {
     local $_ = $_[0];
  
     # lowercasing these should always be valid, and is required for xn-- detection
     y/A-Z/a-z/;
  
     if (/[^0-9a-z\-.]/) {
        # load the mapping data
        unless (defined $uts46_imap) {
           require Unicode::Normalize;
           require "AnyEvent/Util/uts46data.pl";
        }
  
        # uts46 nameprep
  
        # I naively tried to use a regex/transliterate approach first,
        # with one regex and one y///, but the compiled code was 4.5MB.
        # this version has a bit-table for the valid class, and
        # a char-replacement search string
  
        # for speed (cough) reasons, we skip-case 0-9a-z, -, ., which
        # really ought to be trivially valid. A-Z is valid, but already lowercased.
        s{
           ([^0-9a-z\-.])
        }{
           my $chr = $1;
           unless (vec $uts46_valid, ord $chr, 1) {
              # not in valid class, search for mapping
              utf8::encode $chr; # the imap table is in utf-8
              (my $rep = index $uts46_imap, "\x00$chr") >= 0
                 or Carp::croak "$_[0]: disallowed characters (U+" . (unpack "H*", $chr) . ") during idn_nameprep";
  
              (substr $uts46_imap, $rep, 128) =~ /\x00 .[\x80-\xbf]* ([^\x00]*) \x00/x
                 or die "FATAL: idn_nameprep imap table has unexpected contents";
  
              $rep = $1;
              $chr = $rep unless $rep =~ s/^\x01// && $_[1]; # replace unless deviation and display
              utf8::decode $chr;
           }
           $chr
        }gex;
  
        # KC
        $_ = Unicode::Normalize::NFKC ($_);
     }
  
     # decode punycode components, check for invalid xx-- prefixes
     s{
        (^|\.)(..)--([^\.]*)
     }{
        my ($pfx, $ace, $pc) = ($1, $2, $3);
  
        if ($ace eq "xn") {
           $pc = punycode_decode $pc; # will croak on error (we hope :)
  
           require Unicode::Normalize;
           $pc eq Unicode::Normalize::NFC ($pc)
              or Carp::croak "$_[0]: punycode label not in NFC detected during idn_nameprep";
  
           "$pfx$pc"
        } elsif ($ace !~ /^[a-z0-9]{2}$/) {
           "$pfx$ace--$pc"
        } else {
           Carp::croak "$_[0]: hyphens in 3rd/4th position of a label are not allowed";
        }
     }gex;
  
     # uts46 verification
     /\.-|-\./
        and Carp::croak "$_[0]: invalid hyphens detected during idn_nameprep";
  
     # missing: label begin with combining mark, idna2008 bidi
  
     # now check validity of each codepoint
     if (/[^0-9a-z\-.]/) {
        # load the mapping data
        unless (defined $uts46_imap) {
           require "AnyEvent/Util/uts46data.pl";
        }
  
        vec $uts46_valid, ord, 1
           or $_[1] && 0 <= index $uts46_imap, pack "C0U*", 0, ord, 1 # deviation == \x00$chr\x01
           or Carp::croak "$_[0]: disallowed characters during idn_nameprep"
           for split //;
     }
  
     $_
  }
  
  =item $domainname = AnyEvent::Util::idn_to_ascii $idn
  
  Converts the given unicode string (C<$idn>, international domain name,
  e.g. ) to a pure-ASCII domain name (this is usually
  called the "IDN ToAscii" transform). This transformation is idempotent,
  which means you can call it just in case and it will do the right thing.
  
  Unlike some other "ToAscii" implementations, this one works on full domain
  names and should never fail - if it cannot convert the name, then it will
  return it unchanged.
  
  This function is an amalgam of IDNA2003, UTS#46 and IDNA2008 - it tries to
  be reasonably compatible to other implementations, reasonably secure, as
  much as IDNs can be secure, and reasonably efficient when confronted with
  IDNs that are already valid DNS names.
  
  =cut
  
  sub idn_to_ascii($) {
     return $_[0]
        unless $_[0] =~ /[^\x00-\x7f]/;
  
     my @output;
  
     eval {
        # punycode by label
        for (split /\./, (idn_nameprep $_[0]), -1) {
           if (/[^\x00-\x7f]/) {
              eval {
                 push @output, "xn--" . punycode_encode $_;
                 1;
              } or do {
                 push @output, $_;
              };
           } else {
              push @output, $_;
           }
        }
  
        1
     } or return $_[0];
  
     shift @output
        while !length $output[0] && @output > 1;
  
     join ".", @output
  }
  
  =item $idn = AnyEvent::Util::idn_to_unicode $idn
  
  Converts the given unicode string (C<$idn>, international domain name,
  e.g. , www.deliantra.net, www.xn--l-0ga.de) to
  unicode form (this is usually called the "IDN ToUnicode" transform). This
  transformation is idempotent, which means you can call it just in case and
  it will do the right thing.
  
  Unlike some other "ToUnicode" implementations, this one works on full
  domain names and should never fail - if it cannot convert the name, then
  it will return it unchanged.
  
  This function is an amalgam of IDNA2003, UTS#46 and IDNA2008 - it tries to
  be reasonably compatible to other implementations, reasonably secure, as
  much as IDNs can be secure, and reasonably efficient when confronted with
  IDNs that are already valid DNS names.
  
  At the moment, this function simply calls C<idn_nameprep $idn, 1>,
  returning its argument when that function fails.
  
  =cut
  
  sub idn_to_unicode($) {
     my $res = eval { idn_nameprep $_[0], 1 };
     defined $res ? $res : $_[0]
  }
  
  =back
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_UTIL

$fatpacked{"AnyEvent/constants.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_CONSTANTS';
  package AnyEvent;
  sub common_sense{}
  sub CYGWIN      (){ 0 }
  sub WIN32       (){ 0 }
  sub F_SETFD     (){ eval { Fcntl::F_SETFD() } || 2 }
  sub F_SETFL     (){ eval { Fcntl::F_SETFL() } || 4 }
  sub O_NONBLOCK  (){ eval { Fcntl::O_NONBLOCK() } || 04000 }
  sub FD_CLOEXEC  (){ eval { Fcntl::FD_CLOEXEC() } || 1 }
  package AnyEvent::Base;
  sub WNOHANG     (){ eval { POSIX::WNOHANG() } || 1 }
  package AnyEvent::IO;
  sub O_RDONLY    (){ eval { Fcntl::O_RDONLY() } || 0 }
  sub O_WRONLY    (){ eval { Fcntl::O_WRONLY() } || 1 }
  sub O_RDWR      (){ eval { Fcntl::O_RDWR  () } || 2 }
  sub O_CREAT     (){ eval { Fcntl::O_CREAT () } || 64 }
  sub O_EXCL      (){ eval { Fcntl::O_EXCL  () } || 128 }
  sub O_TRUNC     (){ eval { Fcntl::O_TRUNC () } || 512 }
  sub O_APPEND    (){ eval { Fcntl::O_APPEND() } || 1024 }
  package AnyEvent::Util;
  sub WSAEINVAL   (){ -1e99 }
  sub WSAEWOULDBLOCK(){ -1e99 }
  sub WSAEINPROGRESS(){ -1e99 }
  sub _AF_INET6   (){ 30 }
  1;
ANYEVENT_CONSTANTS

$fatpacked{"JE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE';
  package JE;
  
  # If you are looking at the source code (which you are obviously doing
  # if you are reading this),  note that  '# ~~~'  is my way of  marking
  # something to be done still (except in this sentence).
  
  # Note also that comments like "# E 7.1" refer to the indicated
  # clause (7.1 in this case) in the ECMA-262 standard.
  
  use 5.008004;
  use strict;
  use warnings; no warnings 'utf8';
  
  our $VERSION = '0.066';
  
  use Carp 'croak';
  use JE::Code 'add_line_number';
  use JE::_FieldHash;
  use Scalar::Util 1.09 qw'blessed refaddr weaken';
  
  our @ISA = 'JE::Object';
  
  require JE::Null     ;
  require JE::Number     ;
  require JE::Object      ;
  require JE::Object::Function;
  require JE::Parser                             ;
  require JE::Scope                             ;
  require JE::String                          ;
  require JE::Undefined                     ;
  
  =encoding UTF-8
  
  =head1 NAME
  
  JE - Pure-Perl ECMAScript (JavaScript) Engine
  
  =head1 VERSION
  
  Version 0.066 (alpha release)
  
  The API is still subject to change. If you have the time and the interest, 
  please experiment with this module (or even lend a hand :-).
  If you have any ideas for the API, or would like to help with development,
  please e-mail the author.
  
  =head1 SYNOPSIS
  
    use JE;
  
    $j = new JE; # create a new global object
  
    $j->eval('({"this": "that", "the": "other"}["this"])');
    # returns "that"
  
    $parsed = $j->parse('new Array(1,2,3)');
   
    $rv = $parsed->execute; # returns a JE::Object::Array
    $rv->value;             # returns a Perl array ref
  
    $obj = $j->eval('new Object');
    # create a new object
  
    $foo = $j->{document}; # get property
    $j->{document} = $obj; # set property
    $j->{document} = {};   # gets converted to a JE::Object
    $j->{document}{location}{href}; # autovivification
  
    $j->method(alert => "text"); # invoke a method
  
  
    # create global function from a Perl subroutine:
    $j->new_function(print => sub { print @_, "\n" } );
  
    $j->eval(<<'--end--');
            function correct(s) {
                    s = s.replace(/[EA]/g, function(s){
                            return ['E','A'][+(s=='E')]
                    })
                    return s.charAt(0) +
                           s.substring(1,4).toLowerCase() +
                           s.substring(4)
            }
            print(correct("ECMAScript")) // :-)
    --end--
  
  =head1 DESCRIPTION
  
  JE, short for JavaScript::Engine (imaginative, isn't it?), is a pure-Perl 
  JavaScript engine. Here are some of its
  strengths:
  
  =over 4
  
  =item -
  
  Easy to install (no C compiler necessary*)
  
  =item -
  
  The parser can be extended/customised to support extra (or
  fewer) language features (not yet complete)
  
  =item -
  
  All JavaScript datatypes can be manipulated directly from Perl (they all
  have overloaded operators)
  
  =item -
  
  The JavaScript datatypes provide C<TO_JSON> methods for compatibility with
  L<JSON.pm|JSON>.
  
  =back
  
  JE's greatest weakness is that it's slow (well, what did you expect?).  It
  also uses and leaks lots of memory.  (There is an experimental
  L<JE::Destroyer (q.v.)|JE::Destroyer> module that solves this if you load
  it first and then call C<JE::Destroyer::destroy($j)> on the JE object when
  you have finished with it.)
  
  * If you are using perl 5.9.3 or lower, then L<Tie::RefHash::Weak> is
  required. Recent versions of it require L<Variable::Magic>, an XS module
  (which requires a compiler of course), but version 0.02 of the former is
  just pure Perl with no XS dependencies.
  
  There is currently an experimental version of the run-time engine, which is
  supposed to be faster, although it currently makes compilation slower. (If
  you serialise the compiled code and use that, you should notice a
  speed-up.) It will eventually replace the current one when it is complete.
  (It does not yet respect tainting or max_ops, or report line numbers
  correctly.) You can activate it by setting to 1 the ridiculously named
  YES_I_WANT_JE_TO_OPTIMISE environment variable, which is just a
  temporary hack that will later be removed.
  
  =head1 USAGE
  
  =head2 Simple Use
  
  If you simply need to run a few JS functions from Perl, create a new JS
  environment like this:
  
    my $je = new JE;
  
  If necessary, make Perl subroutines available to JavaScript:
  
    $je->new_function(warn => sub { warn @_ });
    $je->new_function(ok => \&Test::More::ok);
  
  Then pass the JavaScript functions to C<eval>:
  
    $je->eval(<<'___');
  
    function foo() {
        return 42
    }
    // etc.
    ___
  
    # or perhaps:
    use File::Slurp;
    $je->eval(scalar read_file 'functions.js');
  
  Then you can access those function from Perl like this:
  
    $return_val = $je->{foo}->();
    $return_val = $je->eval('foo()');
  
  The return value will be a special object that, when converted to a string,
  boolean or number, will behave exactly as in JavaScript. You can also use
  it as a hash, to access or modify its properties. (Array objects can be
  used as arrays, too.) To call one of its
  JS methods, you should use the C<method> method:
  C<< $return_val->method('foo') >>. See L<JE::Types> for more information.
  
  =head2 Custom Global Objects
  
  To create a custom global object, you have to subclass JE. For instance,
  if all you need to do is add a C<self> property that refers to the global
  object, then override the C<new> method like this:
  
    package JEx::WithSelf;
    @ISA = 'JE';
    sub new {
        my $self = shift->SUPER::new(@_);
        $self->{self} = $self;
        return $self;
    }
  
  =head2 Using Perl Objects from JS
  
  See C<bind_class>, below.
  
  =head2 Writing Custom Data Types
  
  See L<JE::Types>.
  
  =head1 METHODS
  
  See also L<< C<JE::Object> >>, which this
  class inherits from, and L<< C<JE::Types> >>.
  
  =over 4
  
  =item $j = JE->new( %opts )
  
  This class method constructs and returns a new JavaScript environment, the
  JE object itself being the global object.
  
  The (optional) options it can take are C<max_ops> and C<html_mode>, which
  correspond to the methods listed below.
  
  =cut
  
  our $s = qr.[\p{Zs}\s\ck]*.;
  
  sub new {
  	my $class = shift;
  
  	# I can't use the usual object and function constructors, since
  	# they both rely on the existence of  the global object and its
  	# 'Object' and 'Function' properties.
  
  	if(ref $class) {
  		croak "JE->new is a class method and cannot be called " .
  			"on a" . ('n' x ref($class) =~ /^[aoeui]/i) . ' ' .
  			 ref($class). " object."
  	}
  
  	# Commented lines here are just for reference:
  	my $self = bless \{
  		#prototype => (Object.prototype)
  		#global => ...
  		keys => [],
  		props => {
  			Object => bless(\{
  				#prototype => (Function.prototype)
  				#global => ...
  				#scope => bless [global], JE::Scope
  				func_name => 'Object',
  				func_argnames => [],
  				func_args => ['global','args'],
  				function => sub { # E 15.2.1
  					return JE::Object->new( @_ );
  				},
  				constructor_args => ['global','args'],
  				constructor => sub {
  					return JE::Object->new( @_ );
  				},
  				keys => [],
  				props => {
  					#length => JE::Number->new(1),
  					prototype => bless(\{
  						#global => ...
  						keys => [],
  						props => {},
  					}, 'JE::Object')
  				},
  				prop_readonly => {
  					prototype => 1,
  					length    => 1,
  				 },
  				prop_dontdel  => {
  					prototype => 1,
  					length    => 1,
  				 },
  			}, 'JE::Object::Function'),
  			Function => bless(\{
  				#prototype => (Function.prototype)
  				#global => ...
  				#scope => bless [global], JE::Scope
  				func_name => 'Function',
  				func_argnames => [],
  				func_args => ['scope','args'],
  				function => sub { # E 15.3.1
  					JE::Object::Function->new(
  						$${$_[0][0]}{global},
  						@_[1..$#_]
  					);
  				},
  				constructor_args => ['scope','args'],
  				constructor => sub {
  					JE::Object::Function->new(
  						$${$_[0][0]}{global},
  						@_[1..$#_]
  					);
  				},
  				keys => [],
  				props => {
  					#length => JE::Number->new(1),
  					prototype => bless(\{
  						#prototype=>(Object.proto)
  						#global => ...
  						func_argnames => [],
  						func_args => [],
  						function => '',
  						keys => [],
  						props => {},
  					}, 'JE::Object::Function')
  				},
  				prop_readonly => {
  					prototype => 1,
  					length    => 1,
  				 },
  				prop_dontdel  => {
  					prototype => 1,
  					length    => 1,
  				 },
  			}, 'JE::Object::Function'),
  		},
  	}, $class;
  
  	my $obj_proto =
  	    (my $obj_constr  = $self->prop('Object'))  ->prop('prototype');
  	my $func_proto =
  	    (my $func_constr = $self->prop('Function'))->prop('prototype');
  
  	$self->prototype( $obj_proto );
  	$$$self{global} = $self;
  
  	$obj_constr->prototype( $func_proto );
  	$$$obj_constr{global} = $self;
  	my $scope = $$$obj_constr{scope} =  bless [$self], 'JE::Scope';
  
  	$func_constr->prototype( $func_proto );
  	$$$func_constr{global} = $self;
  	$$$func_constr{scope} = $scope;
  
  	$$$obj_proto{global} = $self;
  
  	$func_proto->prototype( $obj_proto );
  	$$$func_proto{global} = $self;
  
  	$obj_constr ->prop(
  	    {name=>'length',dontenum=>1,value=>new JE::Number $self,1}
  	);
  	$func_constr->prop(
  	    {name=>'length',dontenum=>1,value=>new JE::Number $self,1}
  	);
  	$func_proto->prop({name=>'length', value=>0, dontenum=>1});
  
  	if($JE::Destroyer) {
  		JE::Destroyer'register($_) for $obj_constr, $func_constr;
  	}
  
  	# Before we add anything else, we need to make sure that our global
  	# true/false/undefined/null values are available.
  	@{$$self}{qw{ t f u n }} = (
  		JE::Boolean->new($self, 1),
  		JE::Boolean->new($self, 0),
  		JE::Undefined->new($self),
  		JE::Null->new($self),
  	);
  
  	$self->prototype_for('Object', $obj_proto);
  	$self->prototype_for('Function', $func_proto);
  	JE::Object::_init_proto($obj_proto);
  	JE::Object::Function::_init_proto($func_proto);
  
  
  	# The rest of the constructors
  	# E 15.1.4
  	$self->prop({
  		name => 'Array',
  		autoload =>
  			'require JE::Object::Array;
  			 JE::Object::Array::_new_constructor($global)',
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'String',
  		autoload =>
  			'require JE::Object::String;
  			JE::Object::String::_new_constructor($global)',
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'Boolean',
  		autoload =>
  		    'require JE::Object::Boolean;
  		    JE::Object::Boolean::_new_constructor($global)',
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'Number',
  		autoload =>
  			'require JE::Object::Number;
  			JE::Object::Number::_new_constructor($global)',
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'Date',
  		autoload =>
  			'require JE::Object::Date;
  			JE::Object::Date::_new_constructor($global)',
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'RegExp',
  		autoload => 
  			'require JE::Object::RegExp;
  			 JE::Object::RegExp->new_constructor($global)',
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'Error',
  		autoload =>
  			'require JE::Object::Error;
  			 JE::Object::Error::_new_constructor($global)',
  		dontenum => 1,
  	});
  	# No EvalError
  	$self->prop({
  		name => 'RangeError',
  		autoload => 'require JE::Object::Error::RangeError;
  		             JE::Object::Error::RangeError
  		              ->_new_subclass_constructor($global)',
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'ReferenceError',
  		autoload => 'require JE::Object::Error::ReferenceError;
  		             JE::Object::Error::ReferenceError
  		              ->_new_subclass_constructor($global)',
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'SyntaxError',
  		autoload => 'require JE::Object::Error::SyntaxError;
  		             JE::Object::Error::SyntaxError
  		              ->_new_subclass_constructor($global)',
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'TypeError',
  		autoload => 'require JE::Object::Error::TypeError;
  		             JE::Object::Error::TypeError
  		              ->_new_subclass_constructor($global)',
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'URIError',
  		autoload => 'require JE::Object::Error::URIError;
  		             JE::Object::Error::URIError
  		              ->_new_subclass_constructor($global)',
  		dontenum => 1,
  	});
  
  	# E 15.1.1
  	$self->prop({
  		name      => 'NaN',
  		value     => JE::Number->new($self, 'NaN'),
  		dontenum  => 1,
  		dontdel   => 1,
  	});
  	$self->prop({
  		name      => 'Infinity',
  		value     => JE::Number->new($self, 'Infinity'),
  		dontenum  => 1,
  		dontdel   => 1,
  	});
  	$self->prop({
  		name      => 'undefined',
  		value     => $self->undefined,
  		dontenum  => 1,
  		dontdel   => 1,
  	});
  
  
  	# E 15.1.2
  	$self->prop({
  		name      => 'eval',
  		value     => JE::Object::Function->new({
  			scope    => $self,
  			name     => 'eval',
  			argnames => ['x'],
  			function_args => [qw< args >],
  			function => sub {
  				my($code) = @_;
  				return $self->undefined unless defined
  					$code;
  				return $code if typeof $code ne 'string';
  				my $old_at = $@; # hope it's not tied
  				defined (my $tree = 
  					($JE::Code::parser||$self)
  					->parse($code))
  					or die;
  				my $ret = execute $tree
  					$JE::Code::this,
  					$JE::Code::scope, 1;
  
  				ref $@ ne '' and die;
  				
  				$@ = $old_at;
  				$ret;
  			},
  			no_proto => 1,
  		}),
  		dontenum  => 1,
  	});
  	$self->prop({
  		name  => 'parseInt',
  		value => JE::Object::Function->new({
  			scope  => $self,
  			name   => 'parseInt', # E 15.1.2.2
  			argnames => [qw/string radix/],
  			no_proto => 1,
  			function_args => [qw< scope args >],
  			function => sub {
  				my($scope,$str,$radix) = @_;
  				$radix = defined $radix
  				 ? $radix->to_number->value
  				 : 0;
  				$radix == $radix and $radix != $radix+1
  					or $radix = 0;
  				
  				if(defined $str) {
  					($str = $str->to_string)
  						=~ s/^$s//;
  				} else { $str = 'undefined' };
  				my $sign = $str =~ s/^([+-])//
  					? (-1,1)[$1 eq '+']
  					:  1;
  				$radix = (int $radix) % 2 ** 32;
  				$radix -= 2**32 if $radix >= 2**31;
  				$radix ||= $str =~ /^0x/i
  				?	16
  				:	10
  				;
  				$radix == 16 and
  					$str =~ s/^0x//i;
  
  				$radix < 2 || $radix > 36 and return
  					JE::Number->new($self,'nan');
  					
  				my @digits = (0..9, 'a'..'z')[0
  					..$radix-1];
  				my $digits = join '', @digits;
  				$str =~ /^([$digits]*)/i;
  				$str = $1;
  
  				my $ret;
  				if(!length $str){
  					$ret= 'nan' ;
  				}
  				elsif($radix == 10) {
  					$ret= $sign * $str;
  				}
  				elsif($radix == 16) {
  					$ret= $sign * hex $str;
  				}
  				elsif($radix == 8) {
  					$ret= $sign * oct $str;
  				}
  				elsif($radix == 2) {
  					$ret= $sign * eval
  						"0b$str";
  				}
  				else { my($num, $place);
  				for (reverse split //, $str){
  					$num += ($_ =~ /[0-9]/ ? $_
  					    : ord(uc) - 55) 
  					    * $radix**$place++
  				}
  				$ret= $num*$sign;
  				}
  
  				return JE::Number->new($self,$ret);
  			},
  		}),
  		dontenum  => 1,
  	});
  	$self->prop({
  		name  => 'parseFloat',
  		value => JE::Object::Function->new({
  			scope  => $self,
  			name   => 'parseFloat', # E 15.1.2.3
  			argnames => [qw/string/],
  			no_proto => 1,
  			function_args => [qw< scope args >],
  			function => sub {
  				my($scope,$str,$radix) = @_;
  				
  				defined $str or $str = '';
  				ref $str eq 'JE::Number' and return $str;
  				ref $str eq 'JE::Object::Number'
  				 and return $str->to_number;
  				return JE::Number->new($self, $str =~
  					/^$s
  					  (
  					    [+-]?
  					    (?:
  					      (?=[0-9]|\.[0-9]) [0-9]*
  					      (?:\.[0-9]*)?
  					      (?:[Ee][+-]?[0-9]+)?
  					        |
  					      Infinity
  					    )
  					  )
  					/ox
  					?  $1 : 'nan');
  			},
  		}),
  		dontenum  => 1,
  	});
  	$self->prop({
  		name  => 'isNaN',
  		value => JE::Object::Function->new({
  			scope  => $self,
  			name   => 'isNaN',
  			argnames => [qw/number/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				JE::Boolean->new($self,
  					!defined $_[0] ||
  					shift->to_number->id eq 'num:nan');
  			},
  		}),
  		dontenum  => 1,
  	});
  	$self->prop({
  		name  => 'isFinite',
  		value => JE::Object::Function->new({
  			scope  => $self,
  			name   => 'isFinite',
  			argnames => [qw/number/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				my $val = shift;
  				JE::Boolean->new($self,
  					defined $val &&
  					($val = $val->to_number->value)
  						== $val &&
  					$val + 1 != $val
  				);
  			},
  		}),
  		dontenum  => 1,
  	});
  
  	# E 15.1.3
  	$self->prop({
  		name  => 'decodeURI',
  		autoload => q{ require 'JE/escape.pl';
  		    JE::Object::Function->new({
  		        scope  => $global,
  		        name   => 'decodeURI',
  		        argnames => [qw/encodedURI/],
  		        no_proto => 1,
  		        function_args => ['scope','args'],
  		        function => \&JE'_decodeURI,
  		    })
  		},
  		dontenum  => 1,
  	});
  	$self->prop({
  		name  => 'decodeURIComponent',
  		autoload => q{ require 'JE/escape.pl';
  		    JE::Object::Function->new({
  			scope  => $global,
  			name   => 'decodeURIComponent',
  			argnames => [qw/encodedURIComponent/],
  			no_proto => 1,
  			function_args => ['scope','args'],
  			function => \&JE'_decodeURIComponent
  		    })
  		},
  		dontenum  => 1,
  	});
  	$self->prop({
  		name  => 'encodeURI',
  		autoload => q{ require 'JE/escape.pl';
  		    JE::Object::Function->new({
  			scope  => $global,
  			name   => 'encodeURI',
  			argnames => [qw/uri/],
  			no_proto => 1,
  			function_args => ['scope','args'],
  			function => \&JE'_encodeURI,
  		    })
  		},
  		dontenum  => 1,
  	});
  	$self->prop({
  		name  => 'encodeURIComponent',
  		autoload => q{ require 'JE/escape.pl';
  		    JE::Object::Function->new({
  			scope  => $global,
  			name   => 'encodeURIComponent',
  			argnames => [qw/uriComponent/],
  			no_proto => 1,
  			function_args => ['scope','args'],
  			function => \&JE'_encodeURIComponent,
  		    })
  		},
  		dontenum  => 1,
  	});
  
  	# E 15.1.5 / 15.8
  	$self->prop({
  		name  => 'Math',
  		autoload => 'require JE::Object::Math;
  		             JE::Object::Math->new($global)',
  		dontenum  => 1,
  	});
  
  	# E B.2
  	$self->prop({
  		name  => 'escape',
  		autoload => q{
  			require 'JE/escape.pl';
  			JE::Object::Function->new({
  				scope  => $global,
  				name   => 'escape',
  				argnames => [qw/string/],
  				no_proto => 1,
  				function_args => ['scope','args'],
  				function => \&JE'_escape,
  			})
  		},
  		dontenum  => 1,
  	});
  	$self->prop({
  		name  => 'unescape',
  		autoload => q{
  			require 'JE/escape.pl';
  			JE::Object::Function->new({
  				scope  => $global,
  				name   => 'unescape',
  				argnames => [qw/string/],
  				no_proto => 1,
  				function_args => ['scope','args'],
  				function => \&JE'_unescape,
  			})
  		},
  		dontenum  => 1,
  	});
  
  
  	# Constructor args
  	my %args = @_;
  	$$$self{max_ops} = delete $args{max_ops};
  	$$$self{html_mode} = delete $args{html_mode};
  
  	$self;
  }
  
  
  
  
  =item $j->parse( $code, $filename, $first_line_no )
  
  C<parse> parses the code contained in C<$code> and returns a parse
  tree (a JE::Code object).
  
  If the syntax is not valid, C<undef> will be returned and C<$@> will 
  contain an
  error message. Otherwise C<$@> will be a null string.
  
  The JE::Code class provides the method 
  C<execute> for executing the 
  pre-compiled syntax tree.
  
  C<$filename> and C<$first_line_no>, which are both optional, will be stored
  inside the JE::Code object and used for JS error messages. (See also
  L<add_line_number|JE::Code/FUNCTIONS> in the JE::Code man page.)
  
  =item $j->compile( STRING )
  
  Just an alias for C<parse>.
  
  =cut
  
  sub parse {
  	goto &JE::Code::parse;
  }
  *compile = \&parse;
  
  
  =item $j->eval( $code, $filename, $lineno )
  
  C<eval> evaluates the JavaScript code contained in C<$code>. E.g.:
  
    $j->eval('[1,2,3]') # returns a JE::Object::Array which can be used as
                        # an array ref
  
  If C<$filename> and C<$lineno> are specified, they will be used in error
  messages. C<$lineno> is the number of the first line; it defaults to 1.
  
  If an error occurs, C<undef> will be returned and C<$@> will contain the
  error message. If no error occurs, C<$@> will be a null string.
  
  This is actually just
  a wrapper around C<parse> and the C<execute> method of the
  JE::Code class.
  
  If the JavaScript code evaluates to an lvalue, a JE::LValue object will be
  returned. You can use this like any other return value (e.g., as an array
  ref if it points to a JS array). In addition, you can use the C<set> and
  C<get> methods to set/get the value of the property to which the lvalue
  refers. (See also L<JE::LValue>.) E.g., this will create a new object
  named C<document>:
  
    $j->eval('this.document')->set({});
  
  Note that I used C<this.document> rather than just C<document>, since the
  latter would throw an error if the variable did not exist.
  
  =cut
  
  sub eval {
  	my $code = shift->parse(@_);
  	$@ and return;
  
  	$code->execute;
  }
  
  
  
  
  =item $j->new_function($name, sub { ... })
  
  =item $j->new_function(sub { ... })
  
  This creates and returns a new function object. If $name is given,
  it will become a property of the global object.
  
  Use this to make a Perl subroutine accessible from JavaScript.
  
  For more ways to create functions, see L<JE::Object::Function>.
  
  This is actually a method of JE::Object, so you can use it on any object:
  
    $j->{Math}->new_function(double => sub { 2 * shift });
  
  
  =item $j->new_method($name, sub { ... })
  
  This is just like C<new_function>, except that, when the function is
  called, the subroutine's first argument (number 0) will be the object
  with which the function is called. E.g.:
  
    $j->eval('String.prototype')->new_method(
            reverse => sub { scalar reverse shift }
    );
    # ... then later ...
    $j->eval(q[ 'a string'.reverse() ]); # returns 'gnirts a'
  
  
  =item $j->max_ops
  
  =item $j->max_ops( $new_value )
  
  Use this to set the maximum number of operations that C<eval> (or
  JE::Code's C<execute>) will run before terminating. (You can use this for
  runaway scripts.) The exact method of counting operations 
  is consistent from one run to another, but is not guaranteed to be consistent between versions of JE. In the current implementation, an
  operation means an expression or sub-expression, so a simple C<return>
  statement with no arguments is not counted.
  
  With no arguments, this method returns the current value.
  
  As shorthand, you can pass C<< max_ops => $foo >> to the constructor.
  
  If the number of operations is exceeded, then C<eval> will return undef and
  set C<$@> to a 'max_ops (xxx) exceeded.
  
  =cut
  
  sub max_ops {
  	my $self = shift;
  	if(@_) { $$$self{max_ops} = shift; return }
  	else { return $$$self{max_ops} }
  }
  
  
  =item $j->html_mode
  
  =item $j->html_mode( $new_value )
  
  Use this to turn on 'HTML mode', in which HTML comment delimiters are
  treated much like C<//>. C<new_value> is a boolean. Since this violates 
  ECMAScript, it is off by  default. 
  
  With no arguments, this method returns the current value.
  
  As shorthand, you can pass C<< html_mode => 1 >> to the constructor.
  
  =cut
  
  sub html_mode {
  	my $self = shift;
  	if(@_) { $$$self{html_mode} = shift; return }
  	else { return $$$self{html_mode} }
  }
  
  
  =item $j->upgrade( @values )
  
  This method upgrades the value or values given to it. See 
  L<JE::Types/UPGRADING VALUES> for more detail.
  
  
  If you pass it more
  than one
  argument in scalar context, it returns the number of arguments--but that 
  is subject to change, so don't do that.
  
  =cut
  
  fieldhash my %wrappees;
  
  sub upgrade {
  	my @__;
  	my $self = shift;
  	my($classes,$proxy_cache);
  	for (@_) {
  		if (defined blessed $_) {
  			$classes or ($classes,$proxy_cache) =
  				@$$self{'classes','proxy_cache'};
  			my $ident = refaddr $_;
  			my $class = ref;
  			push @__, exists $$classes{$class}
  			    ? exists $$proxy_cache{$ident}
  			        ? $$proxy_cache{$ident}
  			        : ($$proxy_cache{$ident} =
  			            exists $$classes{$class}{wrapper}
  			                ? do {
  			                   weaken( $wrappees{
  			                    my $proxy
  			                     = $$classes{$class}{wrapper}(
  			                        $self,$_
  			                       )
  			                   } = $_);
  			                   $proxy
  			                  }
  			                : JE::Object::Proxy->new($self,$_)
  			           )
  			    : $_;
  		} else {
  			push @__,
  			  !defined()
  			?	$self->undefined
  			: ref($_) eq 'ARRAY'
  			?	JE::Object::Array->new($self, $_)
  			: ref($_) eq 'HASH'
  			?	JE::Object->new($self, { value => $_ })
  			: ref($_) eq 'CODE'
  			?	JE::Object::Function->new($self, $_)
  			: $_ eq '0' || $_ eq '-0'
  			?	JE::Number->new($self, 0)
  			:	JE::String->new($self, $_)
  			;
  		}
  	}
  	@__ > 1 ? @__ : @__ == 1 ? $__[0] : ();
  }
  
  sub _upgr_def {
  # ~~~ maybe I should make this a public method named upgrade_defined
  	return defined $_[1] ? shift->upgrade(shift) : undef
  }
  
  
  =item $j->undefined
  
  Returns the JavaScript undefined value.
  
  =cut
  
  sub undefined {
  	$${+shift}{u}
  }
  
  
  
  
  =item $j->null
  
  Returns the JavaScript null value.
  
  =cut
  
  sub null {
  	$${+shift}{n}
  }
  
  
  
  =item $j->true
  
  Returns the JavaScript true value.
  
  =item $j->false
  
  Returns the JavaScript false value.
  
  =cut
  
  sub true  { $${+shift}{t} }
  sub false { $${+shift}{f} }
  
  
  
  
  =item $j->bind_class( LIST )
  
  (This method can create a potential security hole. Please see L</BUGS>,
  below.)
  
  =back
  
  =head2 Synopsis
  
   $j->bind_class(
       package => 'Net::FTP',
       name    => 'FTP', # if different from package
       constructor => 'new', # or sub { Net::FTP->new(@_) }
  
       methods => [ 'login','get','put' ],
       # OR:
       methods => {
           log_me_in => 'login', # or sub { shift->login(@_) }
           chicken_out => 'quit',
       }
       static_methods => {
           # etc. etc. etc.
       }
       to_primitive => \&to_primitive # or a method name
       to_number    => \&to_number
       to_string    => \&to_string
  
       props => [ 'status' ],
       # OR:
       props => {
           status => {
               fetch => sub { 'this var never changes' }
               store => sub { system 'say -vHysterical hah hah' }
           },
           # OR:
           status => \&fetch_store # or method name
       },
       static_props => { ... }
  
       hash  => 1, # Perl obj can be used as a hash
       array => 1, # or as an array
       # OR (not yet implemented):
       hash  => 'namedItem', # method name or code ref
       array => 'item',       # likewise
       # OR (not yet implemented):
       hash => {
           fetch => 'namedItem',
           store => sub { shift->{+shift} = shift },
       },
       array => {
           fetch => 'item',
           store => sub { shift->[shift] = shift },
       },
  
       isa => 'Object',
       # OR:
       isa => $j->{Object}{prototype},
   );
   
   # OR:
   
   $j->bind_class(
       package => 'Net::FTP',
       wrapper => sub { new JE_Proxy_for_Net_FTP @_ }
   );
  
  
  =head2 Description
  
  (Some of this is random order, and probably needs to be rearranged.)
  
  This method binds a Perl class to JavaScript. LIST is a hash-style list of 
  key/value pairs. The keys, listed below, are all optional except for 
  C<package> or
  C<name>--you must specify at least one of the two.
  
  Whenever it says you can pass a method name to a particular option, and
  that method is expected to return a value (i.e., this does not apply to
  C<< props => { property_name => { store => 'method' } } >>), you may append
  a colon and a data type (such as ':String') to the method name, to indicate
  to what JavaScript type to convert the return value. Actually, this is the
  name of a JS function to which the return value will be passed, so 'String'
  has to be capitalised. This also means than you can use 'method:eval' to
  evaluate the return value of 'method' as JavaScript code. One exception to
  this is that the special string ':null' indicates that Perl's C<undef>
  should become JS's C<null>, but other values will be converted the default
  way. This is useful, for instance, if a method should return an object or
  C<null>, from JavaScript's point of view. This ':' feature does not stop
  you from using double colons in method names, so you can write
  C<'Package::method:null'> if you like, and rest assured that it will split
  on the last colon. Furthermore, just C<'Package::method'> will also work.
  It won't split it at all.
  
  =over 4
  
  =item package
  
  The name of the Perl class. If this is omitted, C<name> will be used
  instead.
  
  =item name
  
  The name the class will have in JavaScript. This is used by
  C<Object.prototype.toString> and as the name of the constructor. If 
  omitted, C<package> will be used.
  
  =item constructor => 'method_name'
  
  =item constructor => sub { ... }
  
  If C<constructor> is given a string, the constructor will treat it as the
  name of a class method of C<package>.
  
  If it is a coderef, it will be used as the constructor.
  
  If this is omitted, the constructor will raise an error when called. If
  there is already a constructor with the same name, however, it will be left
  as it is (though methods will still be added to its prototype object). This
  allows two Perl classes to be bound to a single JavaScript class:
  
   $j->bind_class( name => 'Foo', package => 'Class::One', methods => ... );
   $j->bind_class( name => 'Foo', package => 'Class::Two' );
  
  =item methods => [ ... ]
  
  =item methods => { ... }
  
  If an array ref is supplied, the named methods will be bound to JavaScript
  functions of the same names.
  
  If a hash ref is used, the keys will be the
  names of the methods from JavaScript's point of view. The values can be
  either the names of the Perl methods, or code references.
  
  =item static_methods
  
  Like C<methods> but they will become methods of the constructor itself, not
  of its C<prototype> property.
  
  =item to_primitive => sub { ... }
  
  =item to_primitive => 'method_name'
  
  When the object is converted to a primitive value in JavaScript, this
  coderef or method will be called. The first argument passed will, of
  course, be the object. The second argument will be the hint ('number' or
  'string') or will be omitted.
  
  If to_primitive is omitted, the usual valueOf and
  toString methods will be tried as with built-in JS
  objects, if the object does not have overloaded string/boolean/number
  conversions. If the object has even one of those three, then conversion to
  a primitive will be the same as in Perl.
  
  If C<< to_primitive => undef >> is specified, primitivisation
  without a hint (which happens with C<< < >> and C<==>) will throw a 
  TypeError.
  
  =item to_number
  
  If this is omitted, C<to_primitive($obj, 'number')> will be
  used.
  If set to undef, a TypeError will be thrown whenever the
  object is numified.
  
  =item to_string
  
  If this is omitted, C<to_primitive($obj, 'string')> will be
  used.
  If set to undef, a TypeError will be thrown whenever the
  object is strung.
  
  =item props => [ ... ]
  
  =item props => { ... }
  
  Use this to add properties that will trigger the provided methods or
  subroutines when accessed. These property definitions can also be inherited
  by subclasses, as long as, when the subclass is registered with 
  C<bind_class>, the superclass is specified as a string (via C<isa>, below).
  
  If this is an array ref, its elements will be the names of the properties.
  When a property is retrieved, a method of the same name is called. When a
  property is set, the same method is called, with the new value as the
  argument.
  
  If a hash ref is given, for each element, if the value is a simple scalar,
  the property named by the key will trigger the method named by the value.
  If the value is a coderef, it will be called with the object as its
  argument when the variable is read, and with the object and
  the new
  value as its two arguments when the variable is set.
  If the value is a hash ref, the C<fetch> and C<store> keys will be
  expected to be either coderefs or method names. If only C<fetch> is given,
  the property will be read-only. If only C<store> is given, the property 
  will
  be write-only and will appear undefined when accessed. (If neither is 
  given,
  it will be a read-only undefined property--really useful.)
  
  =item static_props
  
  Like C<props> but they will become properties of the constructor itself, 
  not
  of its C<prototype> property.
  
  =item hash
  
  If this option is present, then this indicates that the Perl object 
  can be used
  as a hash. An attempt to access a property not defined by C<props> or
  C<methods> will result in the retrieval of a hash element instead (unless
  the property name is a number and C<array> is specified as well).
  
  =begin comment
  
  There are several values this option can take:
  
   =over 4
  
   =item *
  
  One of the strings '1-way' and '2-way' (also 1 and 2 for short). This will
  indicate that the object being wrapped can itself be used as a hash.
  
  =end comment
  
  The value you give this option should be one of the strings '1-way' and
  '2-way' (also 1 and 2 for short).
  
  If
  you specify '1-way', only properties corresponding to existing hash 
  elements will be linked to those elements;
  properties added to the object from JavaScript will
  be JavaScript's own, and will not affect the wrapped object. (Consider how
  node lists and collections work in web browsers.)
  
  If you specify '2-way', an attempt to create a property in JavaScript will
  be reflected in the underlying object.
  
  =begin comment
  
  =item *
  
  A method name (that does not begin with a number). This method will be
  called on the object with the object as the first arg (C<$_[0]>), the
  property name as the second, and, if an assignment is being made, the new
  value as the third. This will be a one-way hash.
  
  =item *
  
  A reference to a subroutine. This sub will be called with the same
  arguments as a method. Again, this will be a one-way hash.
  
  =item *
  
  A hash with C<store> and C<fetch> keys, which should be set to method names
  or coderefs. Actually, you may omit C<store> to create a one-way binding,
  as per '1-way', above, except that the properties that correspond to hash
  keys will be read-only as well.
  
   =back
  
  =end comment
  
  B<To do:> Make this accept '1-way:String', etc.
  
  =item array
  
  This is just like C<hash>, but for arrays. This will also create a property
  named 'length'.
  
  =for comment
  if passed '1-way' or '2-way'.
  
  B<To do:> Make this accept '1-way:String', etc.
  
  =begin comment
  
  =item keys
  
  This should be a method name or coderef that takes the object as its first 
  argument and
  returns a list of hash keys. This only applies if C<hash> is specified
  and passed a method name, coderef, or hash.
  
  =end comment
  
  =item unwrap => 1
  
  If you specify this and it's true, objects passed as arguments to the 
  methods or code
  refs specified above are 'unwrapped' if they are proxies for Perl objects
  (see below). And null and undefined are converted to C<undef>.
  
  This is experimental right now. I might actually make this the default.
  Maybe this should provide more options for fine-tuning, or maybe what is
  currently the default behaviour should be removed. If
  anyone has any opinions on this, please e-mail the author. 
  
  =item isa => 'ClassName'
  
  =item isa => $prototype_object
  
  (Maybe this should be renamed 'super'.)
  
  The name of the superclass. 'Object' is the default. To make this new
  class's prototype object have no prototype, specify
  C<undef>. Instead of specifying the name of the superclass, you 
  can
  provide the superclass's prototype object.
  
  If you specify a name, a constructor function by that name must already
  exist, or an exception will be thrown. (I supposed I could make JE smart
  enough to defer retrieving the prototype object until the superclass is
  registered. Well, maybe later.)
  
  =item wrapper => sub { ... }
  
  If C<wrapper> is specified, all other arguments will be ignored except for
  C<package> (or C<name> if C<package> is not present).
  
  When an object of the Perl class in question is 'upgraded,' this subroutine
  will be called with the global object as its first argument and the object
  to be 'wrapped' as the second. The subroutine is expected to return
  an object compatible with the interface described in L<JE::Types>.
  
  If C<wrapper> is supplied, no constructor will be created.
  
  =back
  
  After a class has been bound, objects of the Perl class will, when passed
  to JavaScript (or the C<upgrade> method), appear as instances of the
  corresponding JS class. Actually, they are 'wrapped up' in a proxy object 
  (a JE::Object::Proxy 
  object), that provides the interface that JS operators require (see 
  L<JE::Types>). If the 
  object is passed back to Perl, it is the I<proxy,>
  not the original object that is returned. The proxy's C<value> method will
  return the original object. I<But,> if the C<unwrap> option above is used
  when a class is bound, the original Perl object will be passed to any 
  methods or properties belonging to that class. B<This behaviour is still
  subject to change.> See L</unwrap>, above. 
  
  Note that, if you pass a Perl object to JavaScript before binding its 
  class,
  JavaScript's reference to it (if any) will remain as it is, and will not be
  wrapped up inside a proxy object.
  
  To use Perl's overloading within JavaScript, well...er, you don't have to
  do
  anything. If the object has C<"">, C<0+> or C<bool> overloading, that will
  automatically be detected and used.
  
  =cut
  
  sub _split_meth { $_[0] =~ /(.*[^:]):([^:].*)/s ? ($1, $2) : $_[0] }
  # This function splits a method specification  of  the  form  'method:Func'
  # into its two constituent parts, returning ($_[0],undef) if it is a simple
  # method name.  The  [^:]  parts of the regexp are  to  allow  things  like
  # "HTML::Element::new:null"  and to prevent  "Foo::bar"  from being turned
  # into qw(Foo: bar).
  
  sub _cast {
  	my ($self,$val,$type) = @_;
  	return $self->upgrade($val) unless defined $type;
  	if($type eq 'null') {
  		defined $val ? $self->upgrade($val) : $self->null
  	}
  	else {
  		$self->prop($type)->call($self->upgrade($val));
  	}
  }
  
  sub _unwrap {
  	my ($self)  = shift;
  	my @ret;
  	for(@_){
  		push @ret,
  		   ref =~  # Check the most common classes for efficiency.
  		    /^JE::(?:Object::Proxy(?:::Array)?|Undefined|Null)\z/
  			? $_->value
  		 : exists $wrappees{$_}
  			? $wrappees{$_}
  			: $_
  	}
  	@ret;
  }
  
  sub bind_class {
  	require JE::Object::Proxy;
  
  	my $self = shift;
  	my %opts = @_;
  #{ no warnings;
  #warn refaddr $self, " ", $opts{name} , ' ' ,$opts{package}; }
  
  
  	# &upgrade relies on this, because it
  	# takes the value of  ->{proxy_cache},
  	# sticks it in a scalar, then modifies
  	# it through that scalar.
  	$$$self{proxy_cache} ||= &fieldhash({}); # & to bypass prototyping
  
  	if(exists $opts{wrapper}) { # special case
  		my $pack = $opts{qw/name package/[exists $opts{package}]};
  		$$$self{classes}{$pack} = {wrapper => $opts{wrapper}};
  		return;
  	}
  
  	my($pack, $class);
  	if(exists $opts{package}) {
  		$pack = "$opts{package}";
  		$class = exists $opts{name} ? $opts{name} : $pack;
  	}
  	else {
  		$class = $opts{name};
  		$pack = "$class";
  	}
  		
  	my %class = ( name => $class );
  	$$$self{classes}{$pack} = $$$self{classes_by_name}{$class} =
  		\%class;
  
  	my $unwrap = delete $opts{unwrap};
  
  	my ($constructor,$proto,$coderef);
  	if (exists $opts{constructor}) {
  		my $c = $opts{constructor};
  
  		$coderef = ref eq 'CODE'
  			? sub { $self->upgrade(scalar &$c(@_)) }
  			: sub { $self->upgrade(scalar $pack->$c(@_)) };
  	}
  	else {
  		$coderef = sub {
  			die JE::Code::add_line_number(
  				"$class cannot be instantiated");
  		 };
  		$constructor = $self->prop($class);
  		defined $constructor and $constructor->typeof ne 'function'
  		 and $constructor = undef;
  	}
  	$class{prototype} = $proto = ( $constructor || $self->prop({
  		name => $class,
  		value => $constructor = JE::Object::Function->new({
  			name => $class,
  			scope => $self,
  			function => $coderef,
  			function_args => ['args'],
  			constructor => $coderef,
  			constructor_args => ['args'],
  		}),
  	}) )->prop('prototype');
  
  	my $super;
  	if(exists $opts{isa}) {
  		my $isa = $opts{isa};
  		$proto->prototype(
  		    !defined $isa || defined blessed $isa
  		      ? $isa
  		      : do {
  		        $super = $isa;
  		        defined(my $super_constr = $self->prop($isa)) ||
  			  croak("JE::bind_class: The $isa" .
  		                " constructor does not exist");
  		        $super_constr->prop('prototype')
  		      }
  		);
  	}
  
  	if(exists $opts{methods}) {
  		my $methods = $opts{methods};
  		if (ref $methods eq 'ARRAY') { for (@$methods) {
  			my($m, $type) = _split_meth $_;
  			if (defined $type) {
  				$proto->new_method(
  					$m => $unwrap
  					? sub {
  					  $self->_cast(
  					    scalar shift->value->$m(
  					      $self->_unwrap(@_)),
  					    $type
  					  );
  					}
  					: sub {
  					  $self->_cast(
  					    scalar shift->value->$m(@_),
  					    $type
  					  );
  					}
  				);
  			}else {
  				$proto->new_method(
  					$m => $unwrap
  					? sub { shift->value->$m(
  						$self->_unwrap(@_)) }
  					: sub { shift->value->$m(@_) },
  				);
  			}
  		}} else { # it'd better be a hash!
  		while( my($name, $m) = each %$methods) {
  			if(ref $m eq 'CODE') {
  				$proto->new_method(
  					$name => $unwrap
  					? sub {
  					    &$m($self->_unwrap(@_))
  					  }
  					: sub {
  					    &$m($_[0]->value,@_[1..$#_])
  					  }
  				);
  			} else {
  				my ($method, $type) = _split_meth $m;
  				$proto->new_method(
  				  $name => defined $type
  				    ? $unwrap
  				      ? sub {
  				        $self->_cast(
  				          scalar shift->value->$method(
  				            $self->_unwrap(@_)),
  				          $type
  				        );
  				      }
  				      : sub {
  				        $self->_cast(
  				          scalar shift->value->$method(@_),
  				          $type
  				        );
  				      }
  				    : $unwrap
  				      ? sub { shift->value->$m(
  				              $self->_unwrap(@_)) }
  				      : sub { shift->value->$m(@_) },
  				);
  			}
  		}}
  	}
  
  	if(exists $opts{static_methods}) {
  		my $methods = $opts{static_methods};
  		if (ref $methods eq 'ARRAY') { for (@$methods) {
  			my($m, $type) = _split_meth $_;
  			$constructor->new_function(
  				$m => defined $type
  					? $unwrap
  					  ? sub { $self->_cast(
  					      scalar $pack->$m(
  					        $self->_unwrap(@_)), $type
  					  ) }
  					  : sub { $self->_cast(
  						scalar $pack->$m(@_), $type
  					  ) }
  					: $unwrap
  					  ? sub { $pack->$m(
  						$self->_unwrap(@_)) }
  					  : sub { $pack->$m(@_) }
  			);
  			 # new_function makes the functions  enumerable,
  			 # unlike new_method. This code is here to make
  			 # things consistent. I'll delete it if someone
  			 # convinces me otherwise. (I can't make
  			 # up my mind.)
  			$constructor->prop({
  				name => $m, dontenum => 1
  			});
  		}} else { # it'd better be a hash!
  		while( my($name, $m) = each %$methods) {
  			if(ref $m eq 'CODE') {
  				$constructor->new_function(
  					$name => $unwrap
  					? sub {
  					    @_ = $self->_unwrap(@_);
  					    unshift @_, $pack;
  					    goto $m;
  					}
  					: sub {
  					    unshift @_, $pack;
  					    goto $m;
  					}
  				);
  			} else {
  				($m, my $type) = _split_meth $m;
  				$constructor->new_function(
  					$name => defined $type
  						? sub { $self->_cast(
  							scalar $pack->$m,
  							$type
  						) }
  						: $unwrap
  						  ? sub { $pack->$m(
  						    $self->_unwrap(@_)) }
  						  : sub { $pack->$m(@_) },
  				);
  			}
  			 # new_function makes the functions  enumerable,
  			 # unlike new_method. This code is here to make
  			 # things consistent. I'll delete it if someone
  			 # convinces me otherwise. (I can't make
  			 # up my mind.)
  			$constructor->prop({
  				name => $name, dontenum => 1
  			});
  		}}
  	}
  
  	for(qw/to_primitive to_string to_number/) {
  		exists $opts{$_} and $class{$_} = $opts{$_}
  	}
  
  	# The properties enumerated by the 'props' option need to be made
  	# instance properties, since assignment never falls through to the
  	# prototype,  and a fetch routine is passed the property's  actual
  	# owner;  i.e., the prototype, if it is an inherited property.  So
  	# we'll make a list of argument lists which &JE::Object::Proxy::new
  	# will take care of passing to each object's prop method.
  	{ my %props;
  	if(exists $opts{props}) {
  		my $props = $opts{props};
  		$class{props} = \%props;
  		if (ref $props eq 'ARRAY') {
  		    for(@$props) {
  			my ($p,$type) = _split_meth $_;
  			$props{$p} = [
  				fetch => defined $type
  				  ? sub {
  				    $self->_cast(
  				      scalar $_[0]->value->$p, $type
  				    )
  				  }
  				  : sub {
  				    $self->upgrade(scalar $_[0]->value->$p)
  				  },
  				store => $unwrap
  					? sub { $_[0]->value->$p(
  						$self->_unwrap($_[1])) }
  					: sub { $_[0]->value->$p($_[1]) },
  			];
  		    }
  		} else { # it'd better be a hash!
  		while( my($name, $p) = each %$props) {
  			my @prop_args;
  			if (ref $p eq 'HASH') {
  				if(exists $$p{fetch}) {
  				    my $fetch = $$p{fetch};
  				    @prop_args = ( fetch =>
  				        ref $fetch eq 'CODE'
  				        ? sub { $self->upgrade(
  				            scalar &$fetch($_[0]->value)
  				        ) }
  				        : do {
  					  my($f,$t) = _split_meth $fetch;
  					  defined $t ? sub { $self->_cast(
  				            scalar shift->value->$f, $t
  				          ) }
  				          : sub { $self->upgrade(
  				              scalar shift->value->$fetch
  				          ) }
  				        }
  				    );
  				}
  				else { @prop_args =
  					(value => $self->undefined);
  				}
  				if(exists $$p{store}) {
  				    my $store = $$p{store};
  				    push @prop_args, ( store =>
  				        ref $store eq 'CODE'
  				        ? $unwrap
  					  ? sub {
  				            &$store($_[0]->value,
  				              $self->_unwrap($_[1]))
  				          }
  				          : sub {
  				            &$store($_[0]->value, $_[1])
  				          }
  				        : $unwrap
  				          ? sub {
  				            $_[0]->value->$store(
  				              $self->_unwrap($_[1]))
  				          }
  				          : sub {
  				            $_[0]->value->$store($_[1])
  				          }
  				    );
  				}
  				else {
  					push @prop_args, readonly => 1;
  				}
  			}
  			else {
  				if(ref $p eq 'CODE') {
  					@prop_args = (
  					    fetch => sub { $self->upgrade(
  				                scalar &$p($_[0]->value)
  				            ) },
  					    store => $unwrap
  					    ? sub {
  				              &$p(
  					        scalar $_[0]->value,
  					        $self->_unwrap($_[1])
  					      )
  				            }
  					    : sub {
  				              &$p(
  					        scalar $_[0]->value, $_[1]
  					      )
  				            },
  					);
  				}else{
  					($p, my $t) = _split_meth($p);
  					@prop_args = (
  					    fetch => defined $t
  					    ? sub { $self->_cast(
  				                scalar $_[0]->value->$p, $t
  				              ) }
  					    : sub { $self->upgrade(
  				                scalar $_[0]->value->$p
  				              ) },
  					    store => $unwrap
  					    ? sub {
  				                $_[0]->value->$p(
  					          $self->_unwrap($_[1]))
  				            }
  					    : sub {
  				                $_[0]->value->$p($_[1])
  				            },
  					);
  				}
  			}
  			$props{$name} = \@prop_args;
  		}}
  	}
  	if(defined $super){
  		$class{props} ||= \%props;
  		{
  			my $super_props =
  				$$$self{classes_by_name}{$super}{props}
  				|| last;
  			for (keys %$super_props) {
  				exists $props{$_} or
  					$props{$_} = $$super_props{$_}
  			}
  		}
  	}}
  
  	if(exists $opts{static_props}) {
  		my $props = $opts{static_props};
  		if (ref $props eq 'ARRAY') { for (@$props) {
  			my($p,$t) = _split_meth $_;
  			$constructor->prop({
  				name => $p,
  				fetch => defined $t
  				  ? sub { $self->_cast(
  				      scalar $pack->$p, $t
  				    ) }
  				  : sub { $self->upgrade(
  				      scalar $pack->$p
  				    ) },
  				store => $unwrap
  				  ? sub {$pack->$p($self->_unwrap($_[1]))}
  				  : sub { $pack->$p($_[1]) },
  			});
  		}} else { # it'd better be a hash!
  		while( my($name, $p) = each %$props) {
  			my @prop_args;
  			if (ref $p eq 'HASH') {
  				if(exists $$p{fetch}) {
  				    my $fetch = $$p{fetch};
  				    @prop_args = ( fetch =>
  				        ref $fetch eq 'CODE'
  				        ? sub {
  				            $self->upgrade(
  					        scalar &$fetch($pack))
  				        }
  				        : do {
  				            my($f,$t) = _split_meth $fetch;
  				            defined $t ? sub {
  				              $self->_cast(
  				                scalar $pack->$f,$t)
  				            }
  				            : sub {
  				              $self->upgrade(
  				                scalar $pack->$f)
  				            }
  				        }
  				    );
  				}
  				else { @prop_args =
  					(value => $self->undefined);
  				}
  				if(exists $$p{store}) {
  				    my $store = $$p{store};
  				    push @prop_args, ( store =>
  				        ref $store eq 'CODE'
  				        ? $unwrap
  				          ? sub {
  				            &$store($pack,
  				                    $self->_unwrap($_[1]))
  				          }
  				          : sub {
  				            &$store($pack, $_[1])
  				          }
  				        : $unwrap
  				          ? sub {
  				            $pack->$store(
  				                  $self->_unwrap($_[1]))
  				          }
  				          : sub {
  				            $pack->$store($_[1])
  				          }
  				    );
  				}
  				else {
  					push @prop_args, readonly => 1;
  				}
  			}
  			else {
  				if(ref $p eq 'CODE') {
  					@prop_args = (
  					    fetch => sub {
  				                $self->upgrade(
  					          scalar &$p($pack))
  				            },
  					    store => $unwrap
  					    ? sub {
  				                &$p($pack,
  					            $self->_unwrap($_[1]))
  				            }
  					    : sub {
  				                &$p($pack, $_[1])
  				            },
  					);
  				} else {
  					($p, my $t) = _split_meth $p;
  					@prop_args = (
  					    fetch => defined $t
  					    ? sub {
  				                $self->_cast(
  					          scalar $pack->$p,$t)
  				              }
  					    : sub {
  				                $self->upgrade(
  					          scalar $pack->$p)
  				              },
  					    store => $unwrap
  					    ? sub {
  				                $pack->$p(
  					          $self->_unwrap($_[1]))
  				            }
  					    : sub {
  				                $pack->$p($_[1])
  				            },
  					);
  				}
  			}
  			$constructor->prop({name => $name, @prop_args});
  		}}
  	}
  
  	# ~~~ needs to be made more elaborate
  # ~~~ for later:	exists $opts{keys} and $class{keys} = $$opts{keys};
  
  
  
  	# $class{hash}{store} will be a coderef that returns true or false,
  	# depending on whether it was able to write the property. With two-
  	# way hash bindings, it will always return true
  
  	if($opts{hash}) {
  		if(!ref $opts{hash} # ) {
  			#if(
  			&& $opts{hash} =~ /^(?:1|(2))/) {
  				$class{hash} = {
  					fetch => sub { exists $_[0]{$_[1]}
  						? $self->upgrade(
  						    $_[0]{$_[1]})
  						: undef
  					},
  					store => $1 # two-way?
  					  ? sub { $_[0]{$_[1]}=$_[2]; 1 }
  					  : sub {
  						exists $_[0]{$_[1]} and
  						   ($_[0]{$_[1]}=$_[2], 1)
  					  },
  				};
  				$class{keys} ||= sub { keys %{$_[0]} };
  			}
  		else { croak
  			"Invalid value for the 'hash' option: $opts{hash}";
  		}
  
  =begin comment
  
  # I haven't yet figured out a logical way for this to work:
  
  			else { # method name
  				my $m = $opts{hash};
  				$class{hash} = {
  					fetch => sub {
  						$self->_upgr_def(
  						  $_[0]->value->$m($_[1])
  						)
  					},
  					store => sub {
  					  my $wrappee = shift->value;
  					  defined $wrappee->$m($_[0]) &&
  					    ($wrappee->$m(@_), 1)
  					},
  				};
  			}
  		} elsif (ref $opts{hash} eq 'CODE') {
  			my $cref = $opts{hash};
  			$class{hash} = {
  				fetch => sub {
  					$self->_upgr_def(
  				            &$cref($_[0]->value, $_[1])
  					)
  				},
  				store => sub {
  				  my $wrappee = shift->value;
  				  defined &$cref($wrappee, $_[0]) &&
  				    (&$cref($wrappee, @_), 1)
  				},
  			};
  		} else { # it'd better be a hash!
  			my $opt = $opts{hash_elem};
  			if(exists $$opt{fetch}) {
  				my $fetch = $$opt{fetch};
  				$class{hash}{fetch} =
  				        ref $fetch eq 'CODE'
  				        ? sub { $self-> _upgr_def(
  				            &$fetch($_[0]->value, $_[1])
  				        ) }
  				        : sub { $self-> _upgr_def(
  				            shift->value->$fetch(shift)
  				        ) }
  				;
  			}
  			if(exists $$opt{store}) {
  				my $store = $$opt{store};
  				$class{hash}{store} =
  				        ref $store eq 'CODE'
  				        ? sub {
  				  	  my $wrappee = shift->value;
  				  	  defined &$store($wrappee, $_[0])
  					  and &$store($wrappee, @_), 1
  				        }
  				        : sub {
  				  	  my $wrappee = shift->value;
  				  	  defined $wrappee->$store($_[0])
  					  and &$store($wrappee, @_), 1
  				            $_[0]->value->$store(@_[1,2])
  				        }
  				;
  			}
  		}
  
  =end comment
  
  =cut
  
  	}
  
  	if($opts{array}) {
  			if($opts{array} =~ /^(?:1|(2))/) {
  				$class{array} = {
  					fetch => sub { $_[1] < @{$_[0]}
  						? $self->upgrade(
  						    $_[0][$_[1]])
  						: undef
  					},
  					store => $1 # two-way?
  					  ? sub { $_[0][$_[1]]=$_[2]; 1 }
  					  : sub {
  						$_[1] < @{$_[0]} and
  						   ($_[0]{$_[1]}=$_[2], 1)
  					  },
  				};
  			}
  		else { croak
  		    "Invalid value for the 'array' option: $opts{array}";
  		}
  
  =begin comment
  
  	} elsif (exists $opts{array_elem}) {
  		if (!ref $opts{array_elem}) {
  			my $m = $opts{array_elem};
  			$class{array} = {
  				fetch => sub {
  					$self->upgrade(
  						$_[0]->value->$m($_[1])
  					)
  				},
  				store => sub { $_[0]->value->$m(@_[1,2]) },
  			};
  		} else { # it'd better be a hash!
  			my $opt = $opts{array_elem};
  			if(exists $$opt{fetch}) {
  				my $fetch = $$opt{fetch};
  				$class{array}{fetch} =
  				        ref $fetch eq 'CODE'
  				        ? sub { $self->upgrade(
  				            &$fetch($_[0]->value, $_[1])
  				        ) }
  				        : sub { $self->upgrade(
  				            shift->value->$fetch(shift)
  				        ) }
  				;
  			}
  			if(exists $$opt{store}) {
  				my $store = $$opt{store};
  				$class{array}{store} =
  				        ref $store eq 'CODE'
  				        ? sub {
  				            &$store($_[0]->value, @_[1,2])
  				        }
  				        : sub {
  				            $_[0]->value->$store(@_[1,2])
  				        }
  				;
  			}
  		}
  
  =end comment
  
  =cut
  
  	}
  
  	weaken $self; # we've got closures
  
  	return # nothing
  }
  
  =over
  
  =item $j->new_parser
  
  This returns a parser object (see L<JE::Parser>) which allows you to
  customise the way statements are parsed and executed (only partially
  implemented).
  
  =cut
  
  sub new_parser {
  	JE::Parser->new(shift);
  }
  
  
  
  
  =item $j->prototype_for( $class_name )
  
  =item $j->prototype_for( $class_name, $new_val )
  
  Mostly for internal use, this method is used to store/retrieve the
  prototype objects used by JS's built-in data types. The class name should
  be 'String', 'Number', etc., but you can actually store anything you like
  in here. :-)
  
  =cut
  
  sub prototype_for {
  	my $self = shift;
  	my $class = shift;
  	if(@_) {
  		return $$$self{pf}{$class} = shift
  	}
  	else {
  		return $$$self{pf}{$class} ||
  		  ($self->prop($class) || return undef)->prop('prototype');
  	}
  }
  
  
  
  =back
  
  =cut
  
  
  
  1;
  __END__
  
  =head1 TAINTING
  
  If a piece of JS code is tainted, you can still run it, but any strings or
  numbers returned, assigned or passed as arguments by the tainted code will
  be tainted (even if it did not originated from within the code). E.g.,
  
    use Taint::Util;
    taint($code = "String.length");
    $foo = 0 + new JE  ->eval($code);  # $foo is now tainted
  
  This does not apply to string or number I<objects>, but, if the code
  created the object, then its internal value I<will> be tainted, because it
  created the object by passing a simple string or number argument to a 
  constructor.
  
  =head1 IMPLEMENTATION NOTES
  
  Apart from items listed under L</BUGS>, below, JE follows the ECMAScript v3
  specification. There are cases in which ECMAScript leaves the precise
  semantics to the discretion of the implementation. Here is the behaviour in
  such cases:
  
  =over 4
  
  =item *
  
  The global C<parseInt> can interpret its first argument either as decimal 
  or octal if it begins with a 0 not followed by 'x', and the second argument
  is omitted. JE uses decimal.
  
  =item *
  
  Array.prototype.toLocaleString uses ',' as the separator.
  
  =back
  
  The spec. states that, whenever it (the spec.), say to throw a
  SyntaxError, an implementation may provide other behaviour instead. Here
  are some instances of this:
  
  =over
  
  =item *
  
  C<return> may be used outside a function. It's like an 'exit' statement,
  but it can return a value:
  
    var thing = eval('return "foo"; this = statement(is,not) + executed')
  
  =item *
  
  C<break> and C<continue> may be used outside of loops. In which case they
  act like C<return> without arguments.
  
  =item *
  
  Reserved words (except C<case> and C<break>) can be used as identifiers 
  when there is no ambiguity.
  
  =item *
  
  Regular expression syntax that is not valid ECMAScript in general follows
  Perl's behaviour. (See L<JE::Object::RegExp> for the exceptions.)
  
  =back
  
  JE also supports the C<escape> and C<unescape> global functions (not part
  of ECMAScript proper, but in the appendix).
  
  =head1 BUGS
  
  To report bugs, please e-mail the author.
  
  =head2 Bona Fide Bugs
  
  =over 4
  
  =item *
  
  C<bind_class> has a security hole: An object methods corresponding
  Function object can be applied to any Perl object or class from within JS.
  (E.g., if you have allowed a Foo object's C<wibbleton> method to be called
  from JS,
  then a Bar object's method of the same name can be, too.)
  
  Fixing this is a bit complicated. If anyone would like to help, please let
  me know. (The problem is that the same code would be repeated a dozen times
  in C<bind_class>'s closures--a maintenance nightmare likely to result in
  more security bugs. Is there any way to eliminate all those closures?)
  
  =item *
  
  The JE::Scope class, which has an C<AUTOLOAD> sub that 
  delegates methods to the global object, does not yet implement 
  the C<can> method, so if you call $scope->can('to_string')
  you will get a false return value, even though scope objects I<can>
  C<to_string>.
  
  =item *
  
  C<hasOwnProperty> does not work properly with arrays and arguments objects.
  
  =item *
  
  Sometimes line numbers reported in error messages are off. E.g., in the
  following code--
  
    foo(
        (4))
  
  --, if C<foo> is not a function, line 2 will be reported instead of line 1.
  
  =item *
  
  Currently, [:blahblahblah:]-style character classes dont work if followed
  by a character class escape (\s, \d, etc.) within the class.
  C</[[:alpha:]\d]/> is interpreted as C</[\[:alph]\d\]/>.
  
  =item *
  
  If, in perl 5.8.x, you call the C<value> method of a JE::Object that has a
  custom fetch subroutine for one of its enumerable properties that throws an
  exception, you'll get an 'Attempt to free unreferenced scalar' warning.
  
  =begin comment
  
  This is not really a bug, come to think of it. It probably should be an
  error (as it is); maybe the error message could be improved.
  
  =item *
  
  Currently, if you take a Perl object whose class has been bound with
  C<bind_class> and assign it to a JS function's C<prototype> property, and
  then call the function's constructor (via C<new> in JS or the C<construct>
  method in Perl), and then call a method that belongs to the aforementioned
  Perl class on the resulting object, you can't expect reasonable results.
  You'll probably just get a meaningless error message.
  
  =end comment
  
  =item *
  
  On Solaris in perl 5.10.0, the Date class can cause an 'Out of memory'
  error which I find totally inexplicable. Patches welcome. (I don't have
  Solaris, so I can't experiment with it.)
  
  =item *
  
  Case-tolerant regular expressions allow a single character to match
  multiple characters, and vice versa, in those cases where a character's
  uppercase equivalent is more than one character; e.g., C</ss/> can match 
  the double S ligature. This is contrary to the ECMAScript spec. See the
  source code of JE::Object::RegExp for more details.
  
  =item *
  
  Currently any assignment that causes an error will result in the 'Cannot assign to a non-lvalue' error message, even if it was for a different 
  cause. For instance, a custom C<fetch> routine might die.
  
  =item *
  
  The parser doesnt currently support Unicode escape sequences in a regular
  expression literals flags. It currently passes them through verbatim to
  the RegExp constructor, which then croaks.
  
  =item *
  
  Under perl 5.8.8, the following produces a double free; something I need to
  look into:
  
    "".new JE  ->eval(q| Function('foo','return[a]')() | )
  
  =item *
  
  The C<var> statement currently evaluates the rhs before the lhs, which is
  wrong. This affects the following, which should return 5, but returns
  undefined:
  
    with(o={x:1})var x = (delete x,5); return o.x
  
  =item *
  
  Currently if a try-(catch)-finally statements C<try> and C<catch> blocks
  don't return anything, the return value is taken from the C<finally> block.
  This is incorrect. There should be no return value. In other words, this
  should return 3:
  
    eval(' 3; try{}finally{5} ')
  
  =item *
  
  Compound assignment operators (+=, etc.) currently get the value of the rhs
  first, which is wrong. The following should produce "1b", but gives "2b":
  
    a = 1;  a += (a=2,"b")
  
  =item *
  
  Serialisation of RegExp objects with Data::Dump::Streamer is currently
  broken (and has been since 0.022).
  
  =back
  
  =head2 Limitations
  
  =over 4
  
  =item *
  
  JE is not necessarily IEEE 754-compliant. It depends on the OS. For this
  reason the Number.MIN_VALUE and Number.MAX_VALUE properties may not have
  the same values as ECMAScript,
  and sometimes rounding (via C<toPrecision>, etc.) goes the wrong way.
  
  =item *
  
  A Perl subroutine called from JavaScript can sneak past a C<finally> block and avoid triggering it:
  
    $j = new JE;
    $j->new_function(outta_here => sub { last outta });
    outta: {
        $j->eval('
            try { x = 1; outta_here() }
            finally { x = 2 }
        ');
    }
    print $j->{x}, "\n";
  
  =item *
  
  NaN and Infinity do not work properly on some Windows compilers.  32-bit
  ActivePerl seems not to work, but I have been told 64-bit is OK.
  Strawberry Perl works fine, which is what most people are using.
  
  =back
  
  =head2 Incompatibilities with ECMAScript...
  
  ...that are probably due to typos in the spec.
  
  =over 4
  
  =item *
  
  In a try-catch-finally statement, if the 'try' block throws an error and
  the 'catch' and 'finally' blocks exit normally--i.e., not as a result of
  throw/return/continue/break--, the error
  originally thrown within the 'try' block is supposed to be propagated,
  according to the spec. JE does not re-throw the error. (This is consistent 
  with other ECMAScript
  implementations.)
  
  I believe there is a typo in the spec. in clause 12.14, in the 'I<TryStatement> : B<try> I<Block Catch Finally>' algorithm. Step 5 should
  probably read 'Let I<C> = Result(4),' rather than 'If Result(4).type is not B<normal>, Let I<C> = Result(4).'
  
  =item *
  
  If the expression between the two colons in a C<for(;;)> loop header is
  omitted, the expression before the first colon is not supposed to be
  evaluated. JE does evaluate it, regardless of whether the expression
  between the two colons is present.
  
  I think this is also a typo in the spec. In the first algorithm in clause
  12.6.3, step 1 should probably read 'If I<ExpressionNoIn> is not present,
  go to step 4,' rather than 'If the first I<Expression> is not present, go
  to step 4.'
  
  =item *
  
  The C<setTime> method of a Date object does what one would expect (it sets
  the number of milliseconds stored in the Date object and returns that
  number).
  According to the obfuscated definition in the ECMAScript specification, it 
  should always set it to NaN and return NaN.
  
  I think I've found I<yet another> typo in the spec. In clause 15.9.5.27,
  'Result(1)' and and 'Result(2)' are probably supposed to be 'Result(2)' and
  'Result(3)', respectively.
  
  =back
  
  =head1 PREREQUISITES
  
  perl 5.8.4 or higher
  
  Scalar::Util 1.14 or higher
  
  Exporter 5.57 or higher
  
  Tie::RefHash::Weak, for perl versions earlier than 5.9.4
  
  The TimeDate distribution (more precisely, Time::Zone and 
  Date::Parse)
  
  Encode 2.08 or higher
  
  B<Note:> JE will probably end up with Unicode::Collate in
  the list of dependencies.
  
  =head1 AUTHOR, COPYRIGHT & LICENSE
  
  Copyright (C) 2007-14 Father Chrysostomos <sprout [at] cpan
  [dot] org>
  
  This program is free software; you may redistribute it and/or modify
  it under the same terms as perl.
  
  Some of the code was derived from L<Data::Float>, which is copyrighted (C)
  2006, 2007, 2008 by Andrew Main (Zefram).
  
  =head1 ACKNOWLEDGEMENTS
  
  Some of the
  
  Thanks to Max Maischein, Kevin Cameron, Chia-liang Kao and Damyan Ivanov
  for their
  contributions,
  
  to Andy Armstrong, Yair Lenga, Alex Robinson, Christian Forster, Imre Rad,
  Craig Mackenna and Toby Inkster
  for their suggestions,
  
  and to the CPAN Testers for their helpful reports.
  
  =head1 SEE ALSO
  
  The other JE man pages, especially the following (the rest are listed on
  the L<JE::Types> page):
  
  =over 4
  
  =item L<JE::Destroyer>
  
  =item L<JE::Types>
  
  =item L<JE::Object>
  
  =item L<JE::Object::Function>
  
  =item L<JE::LValue>
  
  =item L<JE::Scope>
  
  =item L<JE::Code>
  
  =item L<JE::Parser>
  
  =back
  
  I<ECMAScript Language Specification> (ECMA-262)
  
  =over 4
  
  L<http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf>
  
  =back
  
  L<JavaScript.pm|JavaScript>, L<JavaScript::SpiderMonkey> and
  L<JavaScript::Lite>--all 
  interfaces to
  Mozilla's open-source SpiderMonkey JavaScript engine.
  
  L<JavaScript::V8>
  
  L<WWW::Mechanize::Plugin::JavaScript>
JE

$fatpacked{"JE/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_BOOLEAN';
  package JE::Boolean;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  use overload fallback => 1,
  	'""' =>  sub { qw< false true >[shift->[0]] },
  #	 cmp =>  sub { "$_[0]" cmp $_[1] },
  	bool =>  sub { shift->[0] },
  	'0+' =>  sub { shift->[0] };
  
  # ~~~ to do: make sure it numifies properly (as 0 or 1)
  
  require JE::Object::Boolean;
  require JE::Number;
  require JE::String;
  
  
  sub new {
  	my($class, $global, $val) = @_;
  	bless [!!$val, $global], $class;
  }
  
  
  sub prop {
  	if(@_ > 2) { return $_[2] } # If there is a value, just return it
  
  	my ($self, $name) = @_;
  	
  	$$self[1]->prototype_for('Boolean')->prop($name);
  }
  
  sub keys {
  	my $self = shift;
  	$$self[1]->prototype_for('Boolean')->keys;
  }
  
  sub delete {1}
  
  sub method {
  	my $self = shift;
  	$$self[1]->prototype_for('Boolean')->prop(shift)->apply(
  		$self,$$self[1]->upgrade(@_)
  	);
  }
  
  
  sub value { warn caller if !ref $_[0];shift->[0] }
  sub TO_JSON { \(0+shift->[0]) }
  
  sub exists { !1 }
  
  sub typeof    { 'boolean' }
  sub class     { 'Boolean' }
  sub id        { 'bool:' . shift->value }
  sub primitive { 1 }
  
  sub to_primitive { $_[0] }
  sub to_boolean   { $_[0] }
  
  
  # $_[0][1] is the global object
  sub to_string { JE::String->_new($_[0][1], qw< false true >[shift->[0]]) }
  sub to_number { JE::Number->new($_[0][1], shift->[0]) }
  sub to_object { JE::Object::Boolean->new($_[0][1], shift) }
  
  sub global { $_[0][1] }
  
  
  
  1;
  __END__
  
  =head1 NAME
  
  JE::Boolean - JavaScript boolean value
  
  =head1 SYNOPSIS
  
    use JE;
    use JE::Boolean;
  
    $j = JE->new;
  
    $js_true  = new JE::Boolean $j, 1;
    $js_false = new JE::Boolean $j, 0;
  
    $js_true ->value; # returns 1
    $js_false->value; # returns ""
  
    "$js_true"; # returns "true"
   
    $js_true->to_object; # returns a new JE::Object::Boolean
  
  =head1 DESCRIPTION
  
  This class implements JavaScript boolean values for JE. The difference
  between this and JE::Object::Boolean is that that module implements
  boolean
  I<objects,> while this module implements the I<primitive> values.
  
  The stringification and boolean operators are overloaded.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<JE>
  
  =item L<JE::Types>
  
  =item L<JE::Object::Boolean>
  
  =back
JE_BOOLEAN

$fatpacked{"JE/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_CODE';
  package JE::Code;
  
  our $VERSION = '0.066';
  
  use strict;
  use warnings; no warnings 'utf8', 'recursion';
  
  #use Data::Dumper;
  use Carp 1.01 'shortmess';
  use Exporter 5.57 'import';
  use Scalar::Util 'tainted';
  
  our @CARP_NOT = 'JE';
  our @EXPORT_OK = 'add_line_number';
  
  use constant T => ${^TAINT}; # perl doesnt optimise if(${AINT}) away
  
  require JE::Object::Error;
  require JE::Object::Error::ReferenceError;
  require JE::Object::Error::SyntaxError;
  require JE::Object::Error::TypeError;
  require JE::Object::Function;
  require JE::Object::Array;
  require JE::Boolean;
  require JE::Object;
  require JE::Parser;
  require JE::Number;
  require JE::LValue;
  require JE::String;
  require JE::Scope;
  
  sub add_line_number; # so I can call it without parentheses in sub execute
  
  
  # This is documented in a POD comment at the bottom of the file.
  sub parse {
  	my($global, $src, $file, $line) = @_;
  
  	($src, my ($tree, $vars)) = JE::Parser::_parse(
  		program => $src, $global, $file, $line
  	);
  
  	$@ and return;
  
  #print Dumper $tree;
  
  	my $r= bless { global     => $global,
  	               ( $JE::Parser::_parser
  	                 ? (parser => $JE::Parser::_parser)
  	                 : () ),
  	               source     => \$src,
  	               file       => $file,
  	               line       => $line,
  	               vars       => $vars,
  	               tree       => $tree };
  	# $self->{source} is a reference, so that we can share the same
  	# source between code objects without the extra memory overhead
  	# that copying it  would  have.  (Some  JS  script  files  are
  	# rather large.)
  
  	$r->optimise
  	 if   $ENV{'YES_I_WANT_JE_TO_OPTIMISE'}
  	  and $ENV{'YES_I_WANT_JE_TO_OPTIMISE'} ne 2;
  
  	$r;
  }
  
  
  
  
  sub execute_till { # ~~~ Should this be made public?
  	(my $code, local our $counting) = (shift,shift);
  	local our $ops = 0;
  	JE_Code_OP: {
  		return $code->execute(@_);
  	}
  	# If we get here, then we reached the max number of ops.
  	$@ = shortmess "max_ops ($counting) exceeded";
  	return undef;
  }
  
  sub set_global {
  	my $code = shift;
  	my $old = $code->{global};
  	$code->{global} = $_[0];
  	{for(@{$code->{cache}||last}) {
  		ref eq 'JE::Code' and $_->set_global($_[0]);
  	}}
  	{for(@{$code->{vars}||last}){
  		ref && ref $$_[4] eq 'JE::Code'
  		    && $$_[4]->set_global($_[0])
  	}}
  	defined $old or return;
  	my @stack = $code->{tree};
  	local *@;
  	while(@stack) {
  	  for(shift @stack) {
  	    for(@$_[1..$#$_]) {
  	      my $r = ref || next;
  	      $r =~ /^(?:ARRAY\z|JE::Code::)/
  	        and push @stack, $_, =~ next;
  	      $r eq 'JE::Boolean'
  	        and $_ = qw(f t)[$_->value], next;
  	      $r eq 'JE::Number'
  	        and $_ = $_->value, next;
  	      $r eq 'JE::String'
  	        and $_ = "s".$_->value16, next;
  	      $r eq 'JE::Null' and $_ = 'n', next;
  	      $r eq 'JE::Object::RegExp'
  	          and $_ = [$_->{source}->value, $$$_{regexp_flags}],
  	              next;
  	    }
  	  }
  	}
  	return;
  }
  
  sub optimise {
  	require 'JE/toperl.pl';
  	goto &{'optimise'};
  }
  
  # Variables pertaining to the current execution context
  our $code; # JE::Code object, not source code
  our $this;
  our $scope;
  our $parser;
  our $pos; # position within the source code; used to calculate a line no.
  our $taint;
  our $ops;
  our $counting;
  our $global;
  our $return;
  our $cache;
  
  sub execute {
  	local $code = shift;
  	local $global = $$code{global};
  
  	# We check $ops definedness to avoid resetting the op count when
  	# called recursively.
  	if(!defined our $ops and my $max_ops = $global->max_ops) {
  		unshift @_, $code, $max_ops;
  		goto &execute_till;
  	}
  
  	local $this = defined $_[0] ? $_[0] : $global;
  	shift;
  
  	local $scope = shift || bless [$global], 'JE::Scope';
  
  	my $code_type = shift || 0;
  
  	local our $taint = substr(${$$code{source}},0,0) if T;
  
  	my $rv;
  	eval {
  		# passing these values around is too
  		# cumbersome
  		local $JE::Code::parser = $code->{parser}; # might be
  		local our $pos;                            # undef
  		local our $code = $code;
  		local $JE::Code::Expression::_eval   = $code_type == 1;
  
  		package JE::Code::Statement;
  		local our $_label;
  		package JE::Code;
  		# This $return variable has two uses. It holds the return
  		# value when the JS 'return' statement calls 'last RETURN'.
  		# It also is used by statements that return values. It is
  		# necessary to use this var, rather than simply returning
  		# the value (as in v0.016 and earlier), in order to make
  		# 'while(true) { 3; break }'  return  3,  rather  than
  		#  undefined.
  		local $return;
  		local $cache = $$code{cache}||=[];
  
  		RETURN: {
  		BREAK: {
  		CONT: {
  			JE'Code'Statement'_create_vars();
  			$$code{sub} ? &{$$code{sub}} :
  			$$code{psrc}? (
  			# ~~~ temporary hack:
  				($$code{psrc}) = $$code{psrc} =~/(.*)/s,
  				&{$$code{sub} =
  				eval{ eval("sub{$$code{psrc}}")||die }
  				|| die "Internal error that should never"
  				   . " happen (please report this): $@: "
  				   . $$code{psrc}
  			}):
  			$$code{tree}->eval;
  			$code_type == 2 # function
  				or defined $return && ($rv = $return);
  			goto FINISH;
  		} 
  
  		if($JE::Code::Statement::_label) {
  			 die new JE::Object::Error::SyntaxError $global,
  		  	 add_line_number
  			"continue $JE::Code::Statement::_label: label " .
  		  	"'$JE::Code::Statement::_label' not found";
  		} else { goto FINISH; }
  
  		} # end of BREAK
  
  		if($JE::Code::Statement::_label) {
  			 die new JE::Object::Error::SyntaxError $global,
  			 add_line_number
  		  	"break $JE::Code::Statement::_label: label " .
  		  	"'$JE::Code::Statement::_label' not found";
  		} else { goto FINISH; }
  
  		} # end of RETURN
  
  		$rv = $return;
  
  
  		FINISH:  # I have to  put  this  here  inside  the  eval,
  		         # because 'eval { goto label }; label:' causes a
  		         # a bus error in p5.8.8 if a tie handler  is  in
  		         # the call stack (fixed in 5.9.5).
  	};
  
  	T and defined $rv and tainted $taint and $rv->can('taint')
  		and $rv = taint $rv $taint;
  
  	if(ref $@ eq '' and $@ eq '') {
  		!defined $rv and $rv = $scope->undefined;
  	}
  	else {
  		# Catch-all for any errors not dealt with elsewhere
  		$@ = _objectify_error($@);
  	}
  
  	$rv;
  }
  
  sub add_line_number {
  	my $msg = shift;
  	my $code = @_ ? shift : $code;
  	my $pos  = @_ ? shift : $pos ;
  	$msg =~  /\n\z/ and return $msg;
  	defined(my $file = ($code || return $msg)->{file})
  		or defined $pos or return $msg;
  	my $first_line = $code->{line};
  	defined $first_line or $first_line = 1;
  	if(defined $pos) {
  	    no warnings 'uninitialized';
  	    "$msg at $file" . ', ' x defined($file) . 'line ' .
  	        ($first_line + (() = substr(${$code->{source}},0,$pos) =~
  	            /\cm\cj?|[\cj\x{2028}\x{2029}]/g))
  	        . ".\n";
  	} else {
  	    "$msg in $file.\n"
  	}
  }
  
  sub _objectify_error {
  	my $msg = shift;
  
  	ref $msg and return $global->upgrade($msg);
  
  	my $class = 'JE::Object::Error';
  
  	if($msg =~ /^Can't\ locate\ object\ method\ 
  	    "(?:c(?:all|onstruct)|apply|invoke_with)"/x) {
  	     # ~~~ the apply in there is legacy and can be removed b4 v1
  		$class = 'JE::Object::Error::TypeError';
  		$msg = "Argument to new is not a constructor";
  	}
  
  	new $class $global, add_line_number $msg;
  }
  
  sub DDS_freeze {
  	my $self = shift;
  	my $copy = bless {%$self}, ref $self;
  	delete $copy->{sub};
  	$copy;
  }
  
  
  
  package JE::Code::Statement; # This does not cover expression statements.
  
  our $VERSION = '0.066';
  
  use subs qw'_eval_term';
  use List::Util 'first';
  
  our( $_label);
  
  *_eval_term = *JE::Code::Expression::_eval_term;
  import JE::Code 'add_line_number';
  sub add_line_number;
  
  
  # Note: each statement object is an array ref. The elems are:
  # [0] - an array ref containing
  #       [0] - the starting position in the source code and
  #       [1] - the ending position
  # [1] - the type of statement
  # [2..$#] - the various expressions/statements that make up the statement
  
  sub eval {  # evaluate statement
  	my $stm = shift;
  
  	my $type = $$stm[1];
  	$type eq 'empty' || $type eq 'function' and return;
  
  	my @labels;
  	$pos = $$stm[0][0];
  
  	if ($type eq 'labelled') {
  		@labels = @$stm[2..$#$stm-1];
  		if ($$stm[-1][1] =~ /^(?:do|while|for|switch)\z/) {
  			$stm = $$stm[-1];
  			$type = $$stm[1];
  			no warnings 'deprecated';
  			goto LOOPS; # skip unnecessary if statements
  		}
  
  		BREAK: {
  			my $returned = $$stm[-1]->eval;
  			defined $returned and $return = $returned
  		}
  
  		# Note that this has 'defined' in it, whereas the similar
  		# 'if' statement further down where the loop constructs are
  		# doesn't. This is because 'break' without a label sets
  		# $_label to '' and exits loops and switches.
  		if(! defined $_label || first {$_ eq $_label} @labels) {
  			undef $_label;
  			return;
  		} else {
  			no warnings 'exiting';
  			last BREAK;
  		}
  	}
  
  	if ($type eq 'statements') {
  
  		# Execute the statements, one by one, and return the return
  		# value of the last statement that actually returned one.
  		my $returned;
  		for (@$stm[2..$#$stm]) {
  			next if $_ eq 'empty';
  			defined($returned = $_->eval) and
  				$return = $returned,
  				ref $return eq 'JE::LValue'
  					&& get $return;
  		}
  		return;
  	}
  	if ($type eq 'var') {
  		for (@$stm[2..$#$stm]) { if (@$_ == 2) {
  			my $ret = _eval_term $$_[1];
  			ref $ret eq'JE::LValue' and $ret = get $ret;
  			$scope->find_var($$_[0])->set($ret);
  		}}
  		return;
  	}
  	if ($type eq 'if') {
  		#            2       3          4
  		# we have:  expr statement statement?
  		my $returned;
  		if ($$stm[2]->eval->to_boolean->value) {
  			$$stm[3] eq 'empty' or $returned = $$stm[3]->eval;
  		}
  		else {
  			exists $$stm[4]
  				&& $$stm[4] ne 'empty'
  				and $returned = $$stm[4]->eval;
  		}
  		defined $returned and $return = $returned;
  		return
  	}
  	if ($type =~ /^(?:do|while|for|switch)\z/) {
  		# We have one of the following:
  		#
  		#  1      2          3          4          5
  		# 'do'    statement  expression
  		# 'while' expression statement
  		# 'for'   expression 'in'       expression statement
  		# 'for'   var_decl   'in'       expression statement 
  		# 'for'   expression expression expression statement
  		# 'for'   var_decl   expression expression statement
   		#
  		# In those last two cases, expression may be 'empty'.
  		# (See further down for 'switch').
  
  		no warnings 'exiting';
  
  		LOOPS:
  		my $returned;
  		
  		BREAK: {
  		if ($type eq 'do') {
  			do {
  			  CONT: {
  			    defined ($returned = ref $$stm[2]
  			      ? $$stm[2]->eval : undef)
  			    and $return = $returned;
  			  }
  
  			  if($_label and
  			     !first {$_ eq $_label} @labels) {
  			       goto NEXT;
  			  }
  			  undef $_label;
  			} while $$stm[3]->eval->to_boolean->value;
  		}
  		elsif ($type eq 'while') {
  			CONT: while ($$stm[2]->eval->to_boolean->value) {
  				defined ($returned = ref $$stm[3]
  					? $$stm[3]->eval : undef)
  				and $return = $returned;
  			}
  			continue {
  				if($_label and
  				   !first {$_ eq $_label} @labels) {
  					goto NEXT;
  				}
  			}
  			undef $_label;
  		}
  		elsif ($type eq 'for' and $$stm[3] eq 'in') {
  			my $left_side = $$stm[2];
  			if ($left_side->[1] eq 'var') {
  				$left_side->eval;
  				$left_side = $left_side->[2][0];
  				# now contains the identifier
  			}
  			my $obj = $$stm[4]->eval;
  			$obj = $obj->get if ref $obj eq 'JE::LValue';
  			ref($obj) =~ /^JE::(?:Undefined|Null)\z/
  			 # ~~~ Do we need undef $_label here?
  			 and undef $_label, return;
  			my @keys = $obj->keys;
  			CONT: for(@keys) {
  				if($_label and
  				   !first {$_ eq $_label} @labels) {
  					goto NEXT;
  				}
  				undef $_label;
  
  				next if not defined $obj->prop($_);	
  				# in which case it's been deleted
  				
  				(ref $left_side ? $left_side->eval :
  					$scope->find_var($left_side))
  				  ->set(_new JE::String $global, $_);
  
  				defined ($returned = ref $$stm[5]
  					? $$stm[5]->eval : undef)
  				and $return = $returned;
  			}
  
  			# In case 'continue LABEL' is called during the
  			# last iteration of the loop
  			if($_label and
  			   !first {$_ eq $_label} @labels) {
  				next CONT;
  			}
  			undef $_label;
  
  		}
  		elsif ($type eq 'for') { # for(;;)
  			my $tmp;
  			CONT: for (
  				$tmp = ref $$stm[2] && $$stm[2]->eval,
  				ref $tmp eq 'JE::LValue' && get $tmp;
  
  				ref $$stm[3]
  					? $$stm[3]->eval->to_boolean->value
  					: 1;
  
  				do{if($_label and
  				     !first {$_ eq $_label} @labels) {
  				       goto NEXT;
  				  }
  				  undef $_label;
  				},
  				$tmp = ref $$stm[4] && $$stm[4]->eval,
  				ref $tmp eq 'JE::LValue' && get $tmp
  			) {
  				defined ($returned = ref $$stm[5]
  					? $$stm[5]->eval : undef)
  				and $return = $returned;
  			}			
  		}
  		else { # switch
  			# $stm->[2] is the parenthesized
  			# expression.
  			# Each pair of elements thereafter
  			# represents one case clause, an expr
  			# followed by statements, except for
  			# the default clause, which has the
  			# string 'default' for its first elem
  
  			
  			# Evaluate the expression in the header
  			my $given = $$stm[2]->eval;
  			$given = get $given if ref $given eq 'JE::LValue';
  			
  			# Look through the case clauses to see
  			# which it matches. At the same time,
  			# look for the default clause.
  
  			no strict 'refs';
  
  			my($n, $default) = 1;
  			while (($n+=2) < @$stm) {
  				if($$stm[$n] eq 'default') {
  					$default = $n; next;
  				}
  
  				# Execute the statements if we have a match
  				if("JE::Code::Expression::in==="->(
  					$given, $$stm[$n]->eval
  				  )) {
  					$n++;
  					do {
  						$$stm[$n]->eval;
  					} while ($n+=2) < @$stm;
  					undef $default;
  					last;
  				}
  			} ;
  
  			# If we can't find a case that matches, but we
  			# did find a default (and $default was not erased
  			# when a case matched)
  			if(defined $default) {
  				$n = $default +1;
  				do { $$stm[$n]->eval }
  					while ($n+=2) < @$stm;
  			}
  		} # switch
  
  		} # end of BREAK
  
  
  		if(!$_label || first {$_ eq $_label} @labels) {
  			undef $_label;
  			return;
  		} else {
  			last BREAK;
  		}
  		
  		NEXT: next CONT;
  	}
  	if ($type eq 'continue') {
  		no warnings 'exiting';
  		$_label = exists $$stm[2] ? $$stm[2] : '';
  		next CONT;
  	}
  	if ($type eq 'break') {
  		no warnings 'exiting';
  		$_label = exists $$stm[2] ? $$stm[2] : '';
  		last BREAK;
  	}
  	if ($type eq 'return') {
  		no warnings 'exiting';
  		if (exists $$stm[2]) {
  			ref ($return = $$stm[2]->eval) eq 'JE::LValue'
  			and $return = get $return;
  		} else { $return = undef }
  		last RETURN;
  	}
  	if ($type eq 'with') {
  		local $scope = bless [
  			@$scope, $$stm[2]->eval->to_object
  		], 'JE::Scope';
  		my $returned = $$stm[3]->eval;
  		defined $returned and $return = $returned;
  		return;
  	}
  	if ($type eq 'throw') {
  		my $excep;
  		if (exists $$stm[2]) {
  			ref ($excep = $$stm[2]->eval) eq 'JE::LValue'
  			and $excep = get $excep;
  		}
  		die defined $excep? $excep : $global->undefined;
  	}
  	if ($type eq 'try') {
  		# We have one of the following:
  		#   1     2     3     4     5
  		# 'try' block ident block       (catch)
  		# 'try' block block             (finally)
  		# 'try' block ident block block (catch & finally)
  
  		my $result;
  		my $propagate;
  
  		eval { # try
  			local $return;
  			no warnings 'exiting';
  			RETURN: {
  			BREAK: {
  			CONT: {
  				$result = $$stm[2]->eval;
  				goto SAVERESULT;
  			} $propagate = sub{ next CONT }; goto SAVERESULT;
  			} $propagate = sub{ last BREAK }; goto SAVERESULT;
  			} $propagate = sub{ last RETURN }; goto SAVERESULT;
  
  			SAVERESULT:
  			defined $result or $result = $return;
  			goto FINALLY;
  		};
  		# check ref first to avoid the overhead of overloading
  		if (ref $@ || $@ ne '' and !ref $$stm[3]) { # catch
  			undef $result; # prevent { 3; throw ... } from
  			                # returning 3
  
  			# Turn miscellaneous errors into Error objects
  			$@ = JE'Code'_objectify_error($@);
  
  			(my $new_obj = new JE::Object $global)
  			 ->prop({
  				name => $$stm[3],
  				value => $@,
  				dontdel => 1,
  			});
  			local $scope = bless [
  				@$scope, $new_obj
  			], 'JE::Scope';
  	
  			eval { # in case the catch block ends abruptly
  			  local $return;
  			  no warnings 'exiting';
  			  RETURN: {
  			  BREAK: {
  			  CONT: {
  			    $result = $$stm[4]->eval;
  			    goto SAVE;
  			  } $propagate = sub{ next CONT }; goto SAVE;
  			  } $propagate = sub{ last BREAK }; goto SAVE;
  			  } $propagate = sub{ last RETURN }; goto SAVE;
  
  			  SAVE:
  			  defined $result or $result = $return;
  			  $@ = '';
  			}
  		}
  		# In case the 'finally' block resets $@:
  		my $exception = $@;
  		FINALLY:
  		if ($#$stm == 3 or $#$stm == 5) {
  			$$stm[-1]->eval;
  		}
  		defined $exception and ref $exception || $exception ne ''
  			and die $exception;
  		$return = $result if defined $result;
  		$propagate and &$propagate();
  	}
  }
  
  sub _create_vars {  # Process var and function declarations
  	my $vars = $code->{vars};
  	for(@$vars) {
  		if(ref) { # function
  			# format: [[...], function=> 'name',
  			#          [ (params) ], $statements_obj, \@vars ]
  			# With optimisation on, the $statements_obj will
  			# actually be a code object. 
  			$scope->[-1]->delete($$_[2], 1);
  			my $new_code_obj;
  			if(ref $$_[4] eq 'JE::Code') {
  				$new_code_obj = $$_[4]
  			}
  			else {
  			  ($new_code_obj = bless {
  			    map+($_=>$code->{$_}),
  			      qw/global source file line/
  			  }, 'JE::Code')
  			  ->{tree} = $$_[4];
  			  $new_code_obj->{vars} = $$_[5];
  			}
  			$scope->new_var($$_[2], new JE::Object::Function {
  				scope    => $scope,
  				name     => $$_[2],
  				argnames => $$_[3],
  				function => $new_code_obj
  			});
  		}
  		else {
  			$scope->new_var($_);
  		}
  	}
  }
  
  
  
  
  package JE::Code::Expression;
  
  our $VERSION = '0.066';
  
  # B::Deparse showed me how to get these values.
  use constant nan => sin 9**9**9;
  use constant inf => 9**9**9;
  
  use subs qw'_eval_term';
  use POSIX 'fmod';
  use Scalar::Util 'tainted';
  
  import JE::Code 'add_line_number';
  sub add_line_number;
  
  BEGIN{*T = *JE::Code::T;}
  
  
  #----------for reference------------#
  #sub _to_int {
  	# call to_number first
  	# then...
  	# NaN becomes 0
  	# 0 and Infinity remain as they are
  	# other nums are rounded towards zero ($_ <=> 0) * floor(abs)
  #}
  
  # Note that abs in ECMA-262
  #sub _to_uint32 {
  	# call to_number, then ...
  
  	# return 0 for Nan, -?inf and 0
  	# (round toward zero) % 2 ** 32
  #}
  
  #sub _to_int32 {
  	# calculate _to_uint32 but subtract 2**32 if the result >= 2**31
  #}
  
  #sub _to_uint16 { 
  	# just like _to_uint32, except that 2**16 is used instead.
  #}
  
  
  #---------------------------------#
  
  { # JavaScript operators
    # Note: some operators are not dealt with here, but inside
    #       sub eval.
  	no strict 'refs';
  	*{'predelete'} = sub {
  		ref(my $term = shift) eq 'JE::LValue' or return
  			new JE::Boolean $global, 1;
  		my $base = $term->base;
  		new JE::Boolean $global,
  			defined $base ? $base->delete($term->property) : 1;
  	};
  	*{'prevoid'} = sub {
  		my $term = shift;
  		$term = get $term while ref $term eq 'JE::LValue';
  		return $global->undefined;
  	};
  	*{'pretypeof'} = sub {
  		my $term = shift;
  		ref  $term eq 'JE::LValue' and
  			ref base $term eq '' and
  			return _new JE::String $global, 'undefined';
  		_new JE::String $global, typeof $term;
  	};
  	*{'pre++'} = sub {
  		# ~~~ These is supposed to use the same rules
  		#     as the + infix op for the actual
  		#     addition part. Verify that it does this.
  		my $term = shift;
  		$term->set(new JE::Number $global,
  			get $term->to_number + 1);
  	};
  	*{'pre--'} = sub {
  		# ~~~ These is supposed to use the same rules
  		#     as the - infix op for the actual
  		#     subtraction part. Verify that it does this.
  		my $term = shift;
  		$term->set(new JE::Number $global,
  			get $term->to_number->value - 1);
  	};
  	*{'pre+'} = sub {
  		shift->to_number;
  	};
  	*{'pre-'} = sub {
  		new JE::Number $global, -shift->to_number->value;
  	};
  	*{'pre~'} = sub {
  		my $num = shift->to_number->value;
  		$num = 
  			$num != $num || abs($num) == inf  # nan/+-inf
  			? 0
  			: int($num) % 2**32;
  
  		$num -= 2**32 if $num >= 2**31;
  
  		{ use integer; # for signed bitwise negation
  		  $num = ~$num; }
  		
  		new JE::Number $global, $num;	
  	};
  	*{'pre!'} = sub {
  		new JE::Boolean $global, !shift->to_boolean->value
  	};
  	*{'in*'} = sub {
  		new JE::Number $global,
  			shift->to_number->value *
  			shift->to_number->value;
  	};
  	*{'in/'} = sub {
  		my($num,$denom) = map to_number $_->value, @_[0,1];
  		new JE::Number $global,
  			$denom ?
  				$num/$denom :
  			# Divide by zero:
  			$num && $num == $num # not zero or nan
  				? $num * inf
  				: nan;
  	};
  	*{'in%'} = sub {
  		my($num,$denom) = map to_number $_->value,
  			@_[0,1];
  		new JE::Number $global,
  			$num+1 == $num ? nan :
  			$num == $num && abs($denom) == inf ?
  				$num :
  			fmod $num, $denom;
  	};
  	*{'in+'} = sub {
  		my($x, $y) = @_;
  		$x = $x->to_primitive;
  		$y = $y->to_primitive;
  		if($x->typeof eq 'string' or
  		   $y->typeof eq 'string') {
  			return _new JE::String $global,
  				$x->to_string->value16 .
  				$y->to_string->value16;
  		}
  		return new JE::Number $global,
  		                      $x->to_number->value +
  		                      $y->to_number->value;
  	};
  	*{'in-'} = sub {
  		new JE::Number $global,
  			shift->to_number->value -
  			shift->to_number->value;
  	};
  	*{'in<<'} = sub {
  		my $num = shift->to_number->value;
  		$num = 
  			$num != $num || abs($num) == inf  # nan/+-inf
  			? $num = 0
  			: int($num) % 2**32;
  		$num -= 2**32 if $num >= 2**31;
  
  		my $shift_by = shift->to_number->value;
  		$shift_by = 
  			$shift_by != $shift_by || abs($shift_by) == inf
  			? 0
  			: int($shift_by) % 32;
  
  		my $ret = ($num << $shift_by) % 2**32;
  		$ret -= 2**32 if $ret >= 2**31;
  
  		new JE::Number $global, $ret;
  
  		# Fails on 64-bit:
  		#use integer;
  		#new JE::Number $global,
  		#	$num << $shift_by;
  	};
  	*{'in>>'} = sub {
  		my $num = shift->to_number->value;
  		$num = 
  			$num != $num || abs($num) == inf  # nan/+-inf
  			? $num = 0
  			: int($num) % 2**32;
  		$num -= 2**32 if $num >= 2**31;
  
  		my $shift_by = shift->to_number->value;
  		$shift_by = 
  			$shift_by != $shift_by || abs($shift_by) == inf
  			? 0
  			: int($shift_by) % 32;
  
  		use integer;
  		new JE::Number $global,
  			$num >> $shift_by;
  	};
  	*{'in>>>'} = sub {
  		my $num = shift->to_number->value;
  		$num = 
  			$num != $num || abs($num) == inf  # nan/+-inf
  			? $num = 0
  			: int($num) % 2**32;
  
  		my $shift_by = shift->to_number->value;
  		$shift_by = 
  			$shift_by != $shift_by || abs($shift_by) == inf
  			? 0
  			: int($shift_by) % 32;
  
  		new JE::Number $global,
  			$num >> $shift_by;
  	};
  	*{'in<'} = sub {
  		my($x,$y) = map to_primitive $_, @_[0,1];
  		new JE::Boolean $global,
  			$x->typeof eq 'string' &&
  			$y->typeof eq 'string'
  			? $x->to_string->value16 lt $y->to_string->value16
  			: $x->to_number->[0] <  $y->to_number->[0];
  	};
  	*{'in>'} = sub {
  		my($x,$y) = map to_primitive $_, @_[0,1];
  		new JE::Boolean $global,
  			$x->typeof eq 'string' &&
  			$y->typeof eq 'string'
  			? $x->to_string->value16 gt $y->to_string->value16
  			: $x->to_number->[0] >  $y->to_number->[0];
  	};
  	*{'in<='} = sub {
  		my($x,$y) = map to_primitive $_, @_[0,1];
  		new JE::Boolean $global,
  			$x->typeof eq 'string' &&
  			$y->typeof eq 'string'
  			? $x->to_string->value16 le $y->to_string->value16
  			: $x->to_number->[0] <= $y->to_number->[0];
  	};
  	*{'in>='} = sub {
  		my($x,$y) = map to_primitive $_, @_[0,1];
  		new JE::Boolean $global,
  			$x->typeof eq 'string' &&
  			$y->typeof eq 'string'
  			? $x->to_string->value16 ge $y->to_string->value16
  			: $x->to_number->[0] >= $y->to_number->[0];
  	};
  	*{'ininstanceof'} = sub {
  		my($obj,$func) = @_;
  		die new JE::Object::Error::TypeError $global,
  			add_line_number "$func is not an object"
  			if $func->primitive;
  
  		die new JE::Object::Error::TypeError $global,
  			add_line_number "$func is not a function"
  			if $func->typeof ne 'function';
  		
  		return new JE::Boolean $global, 0 if $obj->primitive;
  
  		my $proto_id = $func->prop('prototype');
  		!defined $proto_id || $proto_id->primitive and die new
  		   JE::Object::Error::TypeError $global,
  		   add_line_number "Function $$$func{func_name} has no prototype property";
  		$proto_id = $proto_id->id;
  
  		0 while (defined($obj = $obj->prototype)
  		         or return new JE::Boolean $global, 0),
  			$obj->id ne $proto_id;
  		
  		new JE::Boolean $global, 1;
  	};
  	*{'inin'} = sub {
  		my($prop,$obj) = @_;
  		die new JE::Object::Error::TypeError $global,
  		    add_line_number "$obj is not an object"
  			if $obj->primitive;
  		new JE::Boolean $global, defined $obj->prop($prop);
  	};
  	*{'in=='} = sub {
  		my($x,$y) = @_;
  		my($xt,$yt) = (typeof $x, typeof $y);
  		my($xi,$yi) = (    id $x,     id $y);
  		$xt eq $yt and return new JE::Boolean $global,
  			$xi eq $yi && $xi ne 'num:nan';
  
  		$xi eq 'null' and
  			return new JE::Boolean $global,
  				$yi eq 'undef';
  		$xi eq 'undef' and
  			return new JE::Boolean $global,
  				$yi eq 'null';
  		$yi eq 'null' and
  			return new JE::Boolean $global,
  				$xi eq 'undef';
  		$yi eq 'undef' and
  			return new JE::Boolean $global,
  				$xi eq 'null';
  
  		if($xt eq 'boolean') {
  			$x = to_number $x;
  			$xt = 'number';
  		}
  		elsif($yt eq 'boolean') {
  			$y = to_number $y;
  			$yt = 'number';
  		}
  
  		if($xt eq 'string' || $xt eq 'number' and !primitive $y)
  			{ $y = to_primitive $y; $yt = typeof $y }
  		elsif
  		  ($yt eq 'string' || $yt eq 'number' and !primitive $x)
  			{ $x = to_primitive $x; $xt = typeof $x }
  
  		($xt eq 'number' and $yt eq 'string' || $yt eq 'number')
  		  ||
  		($yt eq 'number' and $xt eq 'string' || $xt eq 'number')
  		  and
  			return new JE::Boolean $global,
  			to_number $x->[0] == to_number $y->[0];
  
  		$xt eq 'string' && $yt eq 'string' and 
  			return new JE::Boolean $global,
  			$x->value16 eq $y->value16;
  		
  		new JE::Boolean $global, 0;
  	};
  	*{'in!='} = sub {
  		new JE::Boolean $global, !&{'in=='}->[0];
  	};
  	*{'in==='} = sub {
  		my($x,$y) = @_;
  		my($xi,$yi) = (    id $x,     id $y);
  		return new JE::Boolean $global,
  			$xi eq $yi && $xi ne 'num:nan';
  	};
  	*{'in!=='} = sub {
  		new JE::Boolean $global, !&{'in==='}->[0];
  	};
  
  	# ~~~ These three bitwise operators are slower than molasses. There
  	# must be some way to speed them up, but I'm not sure the research
  	# is worth it. Does anyone actually use these in JS?
  	*{'in&'} = sub {
  		my $num = shift->to_number->[0];
  		$num = 
  			$num != $num || abs($num) == inf
  			? 0
  			: int($num) % 2**32;
  		$num -= 2**32 if $num >= 2**31;
  
  		my $num2 = shift->to_number->[0];
  		$num2 = 
  			$num2 != $num2 || abs($num2) == inf
  			? 0
  			: int($num2) % 2**32;
  		$num2 -= 2**32 if $num2 >= 2**31;
  
  		use integer;
  		new JE::Number $global,
  			$num & $num2;
  	};
  	*{'in^'} = sub {
  		my $num = shift->to_number->[0];
  		$num = 
  			$num != $num || abs($num) == inf
  			? 0
  			: int($num) % 2**32;
  		$num -= 2**32 if $num >= 2**31;
  
  		my $num2 = shift->to_number->[0];
  		$num2 = 
  			$num2 != $num2 || abs($num2) == inf
  			? 0
  			: int($num2) % 2**32;
  		$num2 -= 2**32 if $num2 >= 2**31;
  
  		use integer;
  		new JE::Number $global,
  			$num ^ $num2;
  	};
  	*{'in|'} = sub {
  		my $num = shift->to_number->[0];
  		$num = 
  			$num != $num || abs($num) == inf
  			? 0
  			: int($num) % 2**32;
  		$num -= 2**32 if $num >= 2**31;
  
  		my $num2 = shift->to_number->[0];
  		$num2 = 
  			$num2 != $num2 || abs($num2) == inf
  			? 0
  			: int($num2) % 2**32;
  		$num2 -= 2**32 if $num2 >= 2**31;
  
  		use integer;
  		new JE::Number $global,
  			$num | $num2;
  	};
  }
  
  =begin for-me
  
  Types of expressions:
  
  'new' term args?
  
  'member/call' term ( subscript | args) *  
  
  'postfix' term op
  
  'hash' term*
  
  'array' term? (comma term?)*
  
  'prefix' op+ term
  
  'lassoc' term (op term)*
  
  'assign' term (op term)* (term term)?
  	(the last two terms are the 2nd and 3rd terms of ? :
  
  'expr' term*
  	(commas are omitted from the array)
  
  'function' ident? params statements
  
  =end for-me
  
  =cut
  
  
  # Note: each expression object is an array ref. The elems are:
  # [0] - an array ref containing
  #       [0] - the starting position in the source code and
  #       [1] - the ending position
  # [1] - the type of expression
  # [2..$#] - the various terms/tokens that make up the expr
  
  sub eval {  # evalate (sub)expression
  	no warnings 'exiting';
  	++ $ops>$counting and last JE_Code_OP  if $counting;
  	
  	my $expr = shift;
  
  	my $type = $$expr[1];
  	my @labels;
  
  	$pos = $$expr[0][0];
  
  	if ($type eq 'expr') {
  		my $result;
  		if(@$expr == 3) { # no comma
  			return _eval_term $$expr[-1];
  		}
  		else { # comma op
  			for (@$expr[2..$#$expr-1]) {
  				$result = _eval_term $_ ;
  				get $result if ref $result eq 'JE::LValue';
  			}
  			$result = _eval_term $$expr[-1] ;
  			return ref $result eq 'JE::LValue' ? get $result
  				: $result;
  		}
  	}
  	if ($type eq 'assign') {
  		my @copy = \(@$expr[2..$#$expr]);
  		# Evaluation is done left-first in JS, unlike in
  		# Perl, so a = b = c is evaluated in this order:
  		#  - evaluate a
  		#  - evaluate b
  		#  - evaluate c
  		#  - assign c to b
  		#  - assign b to a
  
  		# Check first to see whether we have the terms
  		# of a ? : at the end:
  		my @qc_terms = @copy >= 3 && (
  				ref ${$copy[-2]} # avoid stringification
  				|| ${$copy[-2]} =~ /^(?:[tfu]|[si0-9])/
  		)
  			? (pop @copy, pop @copy) : ();
  			# @qc_terms is now in reverse order
  
  		# Make a list of operands, evalling each
  		my @terms = _eval_term ${shift @copy};
  		my @ops;
  		while(@copy) {
  			push @ops, ${shift @copy};
  			push @terms, _eval_term ${shift @copy};
  		}
  
  		my $val = pop @terms;		
  
  		# Now apply ? : if it's there
  		@qc_terms and $val = _eval_term
  			${$qc_terms[$val->to_boolean->[0]]};
  
  		for (reverse @ops) {
  			no strict 'refs';
  			length > 1 and $val =
  				&{'in'.substr $_,0,-1}(
  					$terms[-1], $val
  				);
  			$val = $val->get if ref $val eq 'JE::LValue'; 
  			T and tainted $taint and $val->can('taint')
  				and $val = taint $val $taint;
  			eval { (pop @terms)->set($val) };
  			if (my $err = $@) {
  				die $err if UNIVERSAL::isa($err, 'JE::Object::Error');
  				die new JE::Object::Error::ReferenceError
  					$global, add_line_number "Cannot assign to a non-lvalue";
  			}
  			# ~~~ This needs to check whether it was an error
  			#     other than 'Can't locate object method "set"
  			#     since store handlers can thrown other errors.
  			
  		}
  		if(!@ops) { # If we only have ? : and no assignment
  			$val = $val->get if ref $val eq 'JE::LValue'; 
  		}
  		return $val;
  	}
  	if($type eq 'lassoc') { # left-associative
  		my @copy = \(@$expr[2..$#$expr]);
  		my $result = _eval_term ${shift @copy};
  		while(@copy) {
  			no strict 'refs';
  			# We have to deal with || && here for the sake of
  			# short-circuiting
  			my $op = ${$copy[0]};
  			if ($op eq '&&') {
  				$result = _eval_term(${$copy[1]}) if
  					$result->to_boolean->[0];
  				$result = $result->get
  					if ref $result eq 'JE::LValue'; 
  			}
  			elsif($op eq '||') {
  				$result = _eval_term(${$copy[1]}) unless
  					$result->to_boolean->[0];
  				$result = $result->get
  					if ref $result eq 'JE::LValue'; 
  			}
  			else {
  				$result = $result->get
  					if ref $result eq 'JE::LValue'; 
  				$result = &{"in$op"}(
  					$result, _eval_term ${$copy[1]}
  				);
  			}
  			splice @copy, 0, 2; # double shift
  		}
  		return $result;
  	}
  	if ($type eq 'prefix') {
  		# $$expr[1]     -- 'prefix'
  		# @$expr[2..-2] -- prefix ops
  		# $$expr[-1]    -- operand
  		my $term = _eval_term $$expr[-1];
  
  		no strict 'refs';
  		$term = &{"pre$_"}($term) for reverse @$expr[2..@$expr-2];
  		return $term;
  	}
  	if ($type eq 'postfix') {
  		# ~~~ These are supposed to use the same rules
  		#     as the + and - infix ops for the actual
  		#     addition part. Verify that they do this.
  
  		my $ret = (my $term = _eval_term $$expr[2])
  			->to_number;
  		$term->set(new JE::Number $global,
  			$ret->value + (-1,1)[$$expr[3] eq '++']);
  		return $ret;
  	}
  	if ($type eq 'new') {
  		return _eval_term($$expr[2])->construct(
  			@$expr == 4
  			? T && tainted $taint
  				? map $_->can('taint') ?taint $_ $taint:$_,
  					$$expr[-1]->list
  				: $$expr[-1]->list
  			: ()
  		);
  	}
  	if($type eq 'member/call') {
  		my $obj = _eval_term $$expr[2];
  		for (@$expr[3..$#$expr]) {
  			if(ref eq 'JE::Code::Subscript') {
  				$obj = get $obj
  					if ref $obj eq 'JE::LValue';
  				$obj = new JE::LValue $obj, $_->str_val;
  			}
  			else {
  				$obj = $obj->call(
  					T && tainted $taint
  					? map $_->can('taint')
  						? taint $_ $taint
  						: $_,
  					  $_->list
  					: $_->list
  				);
  				# If $obj is an lvalue,
  				# JE::LValue::call will make
  				# the lvalue's base object the 'this'
  				# value. Otherwise,
  				# JE::Object::Function::call 
  				# will make the
  				# global object the 'this' value.
  			}
  			# ~~~ need some error-checking
  		}
  		return $obj; # which may be an lvalue
  	}
  	if($type eq 'array') {
  		my @ary;
  		for (2..$#$expr) {
  			if(ref $$expr[$_] eq 'comma') {
  				ref $$expr[$_-1] eq 'comma' || $_ == 2
  				and ++$#ary
  			}
  			else {
  				push @ary, _eval_term $$expr[$_];
  				$ary[-1] = $ary[-1]->get
  				 if ref $ary[-1] eq 'JE::LValue';
  			}
  		}
  
  		my $ary = new JE::Object::Array $global;
  		$$$ary{array} = \@ary; # sticking it in like this
  		                       # makes 'undef' elements non-
  		                       # existent, rather
  		                       # than undefined
  		return $ary;
  	}
  	if($type eq 'hash') {
  		my $obj = new JE::Object $global;
  		local @_ = \(@$expr[2..$#$expr]);
  		my (@keys, $key, $value);
  		while(@_) { # I have to loop through them to keep
  		            # the order.
  			$key = ${+shift};
  			$value = _eval_term ${shift;};
  			$value = get $value if ref $value eq 'JE::LValue';
  			$obj->prop($key, $value);
  		}
  		return $obj;
  	}
  	if ($type eq 'func') {
  		# format: [[...], function=> 'name',
  		#          [ params ], $statements_obj, \@vars] 
  		#     or: [[...], function =>
  		#          [ params ], $statements_obj, \@vars] 
  		my($name,$params,$statements) = ref $$expr[2] ?
  			(undef, @$expr[2,3]) : @$expr[2..4];
  		my $func_scope = $name
  			? bless([@$scope, my $obj=new JE::Object $global], 
  				'JE::Scope')
  			: $scope;
  		(my $new_code_obj = bless {
  			map+($_=>$code->{$_}),qw/global source file line/
  		}, 'JE::Code')
  		 ->{tree} = $statements;
  		$new_code_obj->{vars} = $$expr[-1];
  		my $f = new JE::Object::Function {
  			scope    => $func_scope,
  			defined $name ? (name => $name) : (),
  			argnames => $params,
  			function => $new_code_obj,
  		};
  		if($name) {
  			$obj->prop({
  				name    => $name,
  				value   => $f,
  				readonly => 1,
  				dontdel  => 1,
  			});
  		}
  		return $f;
  	}
  }
  sub _eval_term {
  	my $term = $_[0];
  
  	return $term->eval if ref $term eq 'JE::Code::Expression';
  
  	ref $term     ? ref $term eq 'ARRAY'
  	                ? ( require JE::Object::RegExp,
  	                    return JE::Object::RegExp->new(
  	                      $global, @$term
  	                    ) )
  	                : $term :
  	$term eq'this'? $this :
  	$term =~ /^s/ ? $_[0] = JE::String->_new($global,substr $term,1) :
  	$term =~ /^i/ ? $scope->find_var(substr $term,1) :
  	$term eq 't'  ? $global->true :
  	$term eq 'f'  ? $global->false :
  	$term eq 'n'  ? $global->null :
  	               ($_[0] = JE::Number->new($global,$term));
  }
  
  
  
  
  package JE::Code::Subscript;
  
  our $VERSION = '0.066';
  
  sub str_val {
  	my $val = (my $self = shift)->[1];
  	ref $val ? ''.$val->eval : $val; 
  }
  
  
  
  
  package JE::Code::Arguments;
  
  our $VERSION = '0.066';
  
  sub list {
  	my $self = shift;
  
  	#  I can't use map here, because this method is called from within
  	#  a foreach loop,  and an exception might be thrown from  within
  	# _eval_term, which has strange effects in perl 5.8.x (see perl
  	#  bug #24254).
  
  if(1) {
  	my @result;
  	for(@$self[1..$#$self]) {
  		my $val = JE::Code::Expression::_eval_term($_);
  		push @result, ref $val eq 'JE::LValue' ? $val->get : $val
  	}
  	@result;
  
  }else{ # original code
  	map { my $val = JE::Code::Expression::_eval_term($_);
  	      ref $val eq 'JE::LValue' ? $val->get : $val }
  	    @$self[1..$#$self];
  }
  }
  
  
  
  
  1;
  __END__
  
  
  =head1 NAME
  
  JE::Code - ECMAScript parser and code executor for JE
  
  =head1 SYNOPSIS
  
    use JE;
  
    $j = new JE;
  
    $code = $j->compile('1+1'); # returns a JE::Code object
  
    $code->execute;
  
  =head1 METHODS
  
  =over 4
  
  =item $code->execute($this, $scope, $code_type);
  
  The C<execute> method of a parse tree executes it. All the arguments are
  optional.
  
  The first argument
  will be the 'this' value of the execution context. The global object will
  be used if it is omitted or undef.
  
  The second argument is the scope chain.
  A scope chain containing just the global object will be used if it is
  omitted or undef.
  
  The third arg indicates the type of code. B<0> or B<undef> indicates global 
  code.
  B<1> means eval code (code called by I<JavaScript's> C<eval> function, 
  which
  has nothing to do with JE's C<eval> method, which runs global code).
  Variables created with C<var> and function declarations 
  inside
  eval code can be deleted, whereas such variables in global or function
  code cannot. A value of B<2> means function code, which requires an 
  explicit C<return>
  statement for a value to be returned.
  
  If an error occurs, C<undef> will be returned and C<$@> will contain the
  error message. If no error occurs, C<$@> will be a null string.
  
  =item $code->set_global( $thing )
  
  You can transfer a JE::Code object to another JavaScript environment by
  setting the global object this way. You can also set it to C<undef>, if,
  for instance, you want to serialise the compiled code without serialising
  the entire JS environment. If you do that, you'll need to set the global
  object again before you can use the code object.
  
  =back
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item JE::Code::add_line_number($message, $code_object, $position)
  
  B<WARNING:> The parameter list is still subject to change.
  
  This routine append a string such as 'at file, line 76.' to the error 
  message passed to it,  
  unless it ends with a line break already.
  
  C<$code_object> is a code object as returned by JE's or JE::Parser's
  C<parse> method. If it is omitted, the current value of C<$JE::Code::code>
  will be used (this is set while JS code is running). If C<$JE::Code::code>
  turns out to be undefined, then C<$message> will be returned unchanged
  (B<this is subject to change>; later I might make it use Carp to add a Perl 
  file and line number).
  
  C<$position> is the position within the source code, which will be used to
  determine the line number. If this is omitted, $JE::Code::pos will be used.
  
  =begin private
  
  =item JE::Code::parse($global, $src, $file, $line)
  
  Please don't use this. It is for internal use. It might get renamed,
  or change its behaviour without notice (which has happened several times).
  Use JE's C<compile> and C<eval> methods instead.
  
  This function returns a JE::Code object.
  
  C<$global> is a global object. C<$src> is the source code. C<$file> is a
  filename, or any name you want to give the code. C<$line> is a line number.
  
  =end private
  
  =back
  
  =head1 EXPORTS
  
  C<add_line_number> can optionally be exported.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<JE>
  
  =back
  
  =cut
  
  
JE_CODE

$fatpacked{"JE/Destroyer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_DESTROYER';
  package JE::Destroyer;
  
  our $VERSION = '0.066';
  
  use strict;
  use warnings;
  
  # We cannot use JE::_FieldHash, because we end up triggering bugs in weak
  # references in 5.8.  (JE::_FieldHash uses Tie::RefHash::Weak in 5.8.)
  # (Those bugs were fixed between 5.10.1 and 5.12.4, but by which commit
  # I wot not.)
  #use JE::_FieldHash;
  BEGIN {
      require constant;
      # unsafe_helem means that $h{$foo} will stringify $foo.
      # Hash::Util::FieldHash doesnt stringify a ref key.
      import constant unsafe_helem =>
          not my $hufh = eval { require Hash::Util::FieldHash };
      if ($hufh) {
        import Hash::Util::FieldHash 'fieldhash';
      }
      else { *fieldhash = sub {$_[0]} }
  }
  
  use Scalar'Util qw 'refaddr weaken';
  
  fieldhash my %js_envs;
  
  $JE::Destroyer = 1;
  
  sub register {
      my $global = $_[0]->global;
  #    if (ref ($global) eq 'JE::Scope') { use Carp; Carp::cluck; warn "-"x70, "\n" }
      my $globaddr = refaddr $global;
      if ($globaddr == refaddr $_[0]) { return }
      ($js_envs{unsafe_helem ? $globaddr : $global} ||= &fieldhash({}))
        ->{unsafe_helem ? refaddr $_[0] : $_[0]} = \(my $entry = $_[0]);
      weaken $entry;
      return # nothing;
  }
  
  sub destroy {
   exists $js_envs{$_[0]} or return;
   # We cant just iterate over the values, because $$_->destroy might
   # actually free some of the things we are iterating over. So put them in
   # an array first.
   my @objs = values %{ $js_envs{$_[0]} };
   # And still, since the values are themselves weak references to the
   # objects, we have to check for definition.
   defined $$_ and $$_->destroy for @objs;
   delete $js_envs{$_[0]};
   $_[0]->destroy;
   return # nothing;
  }
  
  __END__
  
  =head1 NAME
  
  JE::Destroyer - Experimental destructor for JE
  
  =head1 SYNOPSIS
  
    use JE::Destroyer; # must come first
    use JE;
  
    $j = new JE;
  
    # ... do stuff ...
  
    JE::Destroyer::destroy($j); # break circular refs
    undef $j;
  
  =head1 DESCRIPTION
  
  This is an I<experimental> module that provides a way to destroy JE objects
  without leaking memory.
  
  Details of its interface are subject to change drastically between
  releases.
  
  See the L</SYNOPSIS> above for usage.
  
  =head1 SEE ALSO
  
  L<JE>
JE_DESTROYER

$fatpacked{"JE/LValue.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_LVALUE';
  package JE::LValue;
  
  our $VERSION = '0.066';
  
  use strict;
  use warnings; no warnings 'utf8';
  
  use List::Util 'first';
  use Scalar::Util 'blessed';
  
  require JE::Code;
  require JE::Object::Error::TypeError;
  require JE::Object::Error::ReferenceError;
  
  import JE::Code 'add_line_number';
  sub add_line_number;
  
  
  our $ovl_infix = join ' ', @overload::ops{qw[
  	with_assign assign num_comparison 3way_comparison str_comparison	binary
  ]};
  our $ovl_prefix = join ' ', grep !/^(?:neg|atan2)\z/,
  	map split(/ /), @overload::ops{qw[ unary mutators func ]};
  
  use overload
  fallback => !1,
  nomethod => sub {
  	my $at = $@;
  	my ($self, $other, $reversed, $symbol) = @_;
  	return $self if $symbol eq '=';
  	$self = $self->get;
  	my $sym_regexp = qr/(?:^| )\Q$symbol\E(?:$| )/;
  	my $val;
  	if ($overload::ops{conversion} =~ $sym_regexp) {
  		return $self;
  	}
  	elsif($ovl_infix =~ $sym_regexp) {
  		my $bits = (caller 0)[9];
  		$val = eval 'BEGIN{${^WARNING_BITS} = $bits}'
  		         . ( $reversed ? "\$other $symbol \$self"
  		                       : "\$self $symbol \$other" );
  	}
  	elsif($ovl_prefix =~ $sym_regexp) {
  		my $bits = (caller 0)[9];
  		$val
  		 = eval "BEGIN{\${^WARNING_BITS} = \$bits}$symbol \$self";
  	}
  	elsif($symbol eq 'neg') {
  		return -$self;
  	}
  	elsif($symbol eq 'atan2') {
  		return atan2 $self, $other;
  	}
  	elsif($symbol eq '<>') {
  		return <$self>;
  	}
  	else {
  		die "Oh no! Something is terribly wrong with " .
  		    "JE::LValue's overloading mechanism. It can't deal " .
  		    "with < $symbol >. Please send a bug report.";
  	}
  	$@ and die $@;
  	$@ = $at;
  	return $val;
  },
  '@{}' => sub {
  	caller eq __PACKAGE__ and return shift;	
  	$_[0]->get;
  },
  '%{}' => 'get', '&{}' => 'get', '*{}' => 'get', '${}' => 'get';
  
  sub new {
  	my ($class, $obj, $prop) = @_; # prop is a string
  	if(defined blessed $obj && can $obj 'id'){
  		my $id = $obj->id;
  		$id eq 'null' || $id eq 'undef' and die 
  			new JE::Object::Error::TypeError $obj->global,
  			add_line_number
  			    $obj->to_string->value . " has no properties"
  			    .", not even one named $prop";
  	}
  	bless [$obj, $prop], $class;
  }
  
  sub get {
  	my $base = (my $self = shift)->[0];
  	defined blessed $base or die new 
  		JE::Object::Error::ReferenceError $$base, add_line_number 
  		"The variable $$self[1] has not been declared";
  		
  	my $val = $base->prop($self->[1]);
  	defined $val ? $val : $base->global->undefined;
  		# If we have a Perl undef, then the property does not
  		# not exist, and we have to return a JS undefined val.
  }
  
  sub set {
  	my $obj = (my $self = shift)->[0];
  	defined blessed $obj or $obj = $$self[0] = $$obj;
  	$obj->prop($self->[1], shift);
  }
  
  sub call {
  	my $base_obj = (my $self = shift)->[0];
  	my $prop = $self->get; # dies here if $base_obj is not blessed
  	defined $prop or
  		die new JE::Object::Error::TypeError $base_obj->global,
  		add_line_number "The object's '" . $self->[1] .
  			"' property (undefined) is not a function";
  	$prop->can('apply') or
  		die new JE::Object::Error::TypeError $base_obj->global,
  		add_line_number "The object's '" . $self->[1] .
  			"' property ($prop) is not a function";
  	$prop->apply($base_obj, @_);
  }
  
  sub base { 
  	my $base = $_[0][0];
  	defined blessed $base ? $base : ()
  }
  
  sub property { shift->[1] }
  
  our $AUTOLOAD;
  
  sub AUTOLOAD {
  	my($method) = $AUTOLOAD =~ /([^:]+)\z/;
  
  	return if $method eq 'DESTROY';
  
  #my $l = $_[0]; my $ret, my @ret;;
  no warnings 'uninitialized';
  #eval {
  # $ret =	
  return shift->get->$method(@_); # ~~~ Maybe I should use goto
  	                         #     to remove AUTOLOAD from
  	                         #     the call stack.
  #1} or die add_line_number $l->base . ' ' . $l->property . ' ' . $l->get . #' ' . ref $_->get . qq': $@';
  #return $ret;
  }
  
  sub can { # I think this returns a *canned* lvalue, as opposed to a fresh
            # one. :-)
  	
  	!ref $_[0] || $_[1] eq 'DESTROY' and goto &UNIVERSAL::can;
  
  	&UNIVERSAL::can || do {
  	                        my $sub = (my $obj = shift->get)->can(@_)
  	                         or return undef;
  	                        sub { splice @'_, 0, 1, $obj; goto &$sub }
  	                      };
  }
  
  
  
  =head1 NAME
  
  JE::LValue - JavaScript lvalue class
  
  =head1 SYNOPSIS
  
    use JE::LValue;
  
    $lv = new JE::LValue $some_obj, 'property_name';
  
    $lv->get;         # get property
    $lv->set($value)  # set property
  
    $lv->some_other_method  # same as $lv->get->some_other_method
  
  =head1 DESCRIPTION
  
  This class implements JavaScript lvalues (called "Reference Types" by the
  ECMAScript specification).
  
  =head1 METHODS AND OVERLOADING
  
  If a method is called that is not listed here, it will be passed to the 
  property referenced by the lvalue. (See the last item in the L<SYNOPSIS>,
  above.) For this reason, you should never call C<UNIVERSAL::can> on a
  JE::LValue, but, rather, call it as a method (C<< $lv->can(...) >>), unless
  you really know what you are doing.
  
  Similarly, if you try to use an overloaded operator, it will be passed on 
  to
  the object that the lvalue references, such that C<!$lvalue> is the same
  as calling C<< !$lvalue->get >>.
  
  =over 4
  
  =item $lv = new JE::LValue $obj, $property
  
  Creates an lvalue/reference with $obj as the base object and $property
  as the property name. If $obj is undefined or null, a TypeError is thrown.
  To create a lvalue that has no base object, and which will throw a
  ReferenceError when 
  C<< ->get >> is
  called and create a global property upon invocation of C<< ->set >>, pass
  an unblessed reference to a global object as the first argument. (This is
  used by bare identifiers in JS expressions.)
  
  =item $lv->get
  
  Gets the value of the property.
  
  =item $lv->set($value)
  
  Sets the property to $value and returns $value. If the lvalue has no base
  object, the global object will become its base object automatically. 
  <Note:> Whether the lvalue object itself is modified in the latter case is
  not set in stone yet. (Currently it is modified, but that may change.) 
  
  =item $lv->call(@args)
  
  If the property is a function, this calls the function with the
  base object as the 'this' value.
  
  =item $lv->base
  
  Returns the base object. If there isn't any, it returns undef or an empty
  list, depending on context.
  
  =item $lv->property
  
  Returns the property name.
  
  =back
  
  =cut
  
  
  
  
  1;
JE_LVALUE

$fatpacked{"JE/Null.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_NULL';
  package JE::Null;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  use overload fallback => 1,
  	'0+' =>  sub { 0 },
  	'""' => 'id',
  #	 cmp =>  sub { "$_[0]" cmp $_[1] },
  	bool =>  sub { undef };
  
  require JE::String;
  require JE::Boolean;
  
  
  # A JE::Null object is just a reference to a global object, which itself
  # is a reference to a reference to a hash, i.e.:
  #   bless \(bless \\%thing, JE), JE::Null
  #
  # so $$$$self{keys} is a list of enumerable global property names.
  # Hmm... What does self{keys} mean?
  
  
  =head1 NAME
  
  JE::Null - JavaScript null value
  
  =head1 SYNOPSIS
  
    use JE;
  
    $j = new JE;
  
    $js_null = $j->null;
  
    $js_null->value; # undef
  
  =head1 DESCRIPTION
  
  This class implements the JavaScript "null" type. There really
  isn't much to it.
  
  Null stringifies to 'null', numifies to 0, and is false as a boolean.
  
  =cut
  
  #use Carp;
  sub new    { bless \do{my $thing = $_[1]}, $_[0] }
  sub value  { undef }
  *TO_JSON=*value;
  sub typeof { 'object' }
  sub id     { 'null' }
  sub primitive { 1 }
  sub to_primitive { $_[0] }
  sub to_boolean { JE::Boolean->new(${+shift}, '') };
  sub to_string { JE::String->_new(${+shift}, 'null') };
  sub to_number { JE::Number->new(${+shift}, 0) }
  sub global { ${$_[0]} }
  
  
  "Do you really expect a module called 'null' to return a true value?!";
  
  
  =head1 SEE ALSO
  
  =over 4
  
  =item JE
  
  =item JE::Types
  
  =item JE::Undefined
  
  =back
  
  =cut
  
  
  
  
  
  
  
  
JE_NULL

$fatpacked{"JE/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_NUMBER';
  package JE::Number;
  
  our $VERSION = '0.066';
  
  use strict;
  use warnings; no warnings 'utf8';
  
  
  # I need constants for inf and nan, because perl 5.8.6 interprets the
  # strings "inf" and "nan" as 0 in numeric context.
  
  # This is what I get running Deparse on 5.8.6:
  #    $ perl -mO=Deparse -e 'print 0+"nan"'
  #    print 0;
  #    $ perl -mO=Deparse -e 'print 0+"inf"'
  #    print 0;
  # And here is the output from 5.8.8 (PPC [big-endian]):
  #    $ perl -mO=Deparse -e 'print 0+"nan"'
  #    print unpack("F", pack("h*", "f78f000000000000"));
  #    $ perl -mO=Deparse -e 'print 0+"inf"'
  #    print 9**9**9;
  # I don't know about 5.8.7.
  
  # However, that 'unpack' does not work on little-endian Xeons running
  # Linux. What I'm testing it on is running 5.8.5, so the above one-liners
  # don't work. But I can use this:
  #    $ perl -mO=Deparse -mPOSIX=fmod -e 'use constant nan=>fmod 0,0;print nan'
  #    use POSIX (split(/,/, 'fmod', 0));
  #    use constant ('nan', fmod(0, 0));
  #    print sin(9**9**9);
  
  # sin 9**9**9 also works on the PPC.
  
  
  
  use constant nan => sin 9**9**9;
  use constant inf => 9**9**9;
  
  use overload fallback => 1,
  	'""' => sub {
  		my $value = $_[0][0];
  		$value ==   inf  ?  'Infinity' :
  		$value == -+inf  ? '-Infinity' :
  		$value == $value ? $value :
  		'NaN'
  	 },
  	'0+'  => 'value',
  	 bool =>  sub {
  		my $value = $_[0][0];
  		$value && $value == $value;
  	 },
  	'+'   => sub { $_[0]->value + $_[1] }, # ~~~ I shouldnt need this,
  	                                       #      but  perls  magic
  	                                       #      auto-generation
  	                                       #     isnt so magic.
  #	 cmp  =>  sub { "$_[0]" cmp $_[1] };
  ;
  
  use Scalar::Util qw 'blessed tainted';
  
  require JE::String;
  require JE::Boolean;
  require JE::Object::Number;
  
  
  
  # Each JE::Number object is an array ref like this: [value, global object]
  
  sub new    {
  	my ($class,$global,$val) = @_;
  	
  	if(defined blessed $val and can $val 'to_number') {
  		my $new_val = $val->to_number;
  		ref $new_val eq $class and return $new_val;
  		eval { $new_val->isa(__PACKAGE__) } and
  			$val = $new_val->[0],
  			goto RETURN;
  	}
  
  	$val = _numify($val);
  
  	RETURN:
  	bless [$val, $global], $class;
  }
  
  sub _numify {
  	my $val = shift||0;
  	# For perls that don't interpret 0+"inf" as inf:
  	if ($val =~ /^\s*([+-]?)(inf|nan)/i) {
  		$val = lc $2 eq 'nan' ? nan :
  			$1 eq '-' ? -(inf) : inf;
  	}
  	else { $val+=0 }
  	$val;
  }
  
  sub prop {
  	if(@_ > 2) { return $_[2] } # If there is a value, just return it
  
  	my ($self, $name) = @_;
  	
  	$$self[1]->prototype_for('Number')->prop($name);
  }
  
  sub keys {
  	my $self = shift;
  	$$self[1]->prototype_for('Number')->keys;
  }
  
  sub delete {1}
  
  sub method {
  	my $self = shift;
  	$$self[1]->prototype_for('Number')->prop(shift)->apply(
  		$self,$$self[1]->upgrade(@_)
  	);
  }
  
  sub value {
  	shift->[0]
  }
  *TO_JSON=*value;
  
  sub exists { !1 }
  
  sub typeof    { 'number' }
  sub class     { 'Number' }
  sub id        { 
  	my $value = shift->value;
  	# This should (I hope) take care of systems that stringify nan and
  	# inf oddly:
  	'num:' . ($value != $value ? 'nan' : 
  	          $value ==   inf ?  'inf' :
  	          $value == -+inf ? '-inf' :
  	          $value)
  }
  sub primitive { 1 }
  
  sub to_primitive { $_[0] }
  sub to_boolean   {
  	my $value = (my $self = shift)->[0];
  	JE::Boolean->new($$self[1],
  		$value && $value == $value);
  }
  
  sub to_string { # ~~~ I  need  to  find  out  whether Perl's  number
                  #     stringification is consistent with E 9.8.1 for
                  #     finite numbers.
  	my $value = (my $self = shift)->[0];
  	JE::String->_new($$self[1],
  		$value ==   inf  ?  'Infinity' :
  		$value == -(inf) ? '-Infinity' :
  		$value == $value ? $value :
  		'NaN'
  	);
  }
  
  *to_number = \& to_primitive;
  
  sub to_object {
  	my $self = shift;
  	JE::Object::Number->new($$self[1], $self);
  }
  
  sub global { $_[0][1] }
  
  sub taint {
  	my $self = shift;
  	tainted $self->[0] and return $self;
  	my $alter_ego = [@$self];
  	no warnings 'numeric';
  	$alter_ego->[0] += shift();
  	return bless $alter_ego, ref $self;
  }
  
  
  =head1 NAME
  
  JE::Number - JavaScript number value
  
  =head1 SYNOPSIS
  
    use JE;
    use JE::Number;
  
    $j = JE->new;
  
    $js_num = new JE::Number $j, 17;
  
    $perl_num = $js_num->value;
  
    $js_num->to_object; # returns a new JE::Object::Number
  
  =head1 DESCRIPTION
  
  This class implements JavaScript number values for JE. The difference
  between this and JE::Object::Number is that that module implements
  number
  I<objects,> while this module implements the I<primitive> values.
  
  Right now, this module simply uses Perl numbers underneath for storing
  the JavaScript numbers. It seems that whether Perl numbers are in accord with the IEEE 754 standard that
  ECMAScript uses is system-dependent. If anyone requires IEEE 754 
  compliancy,
  a patch would be welcome. :-)
  
  The C<new> method accepts a global (JE) object and a number as its 
  two arguments. If the latter is an object with a C<to_number> method whose
  return value isa JE::Number, that object's internal value
  will be used. Otherwise the arg itself is used. (The precise details of
  the behaviour of C<new> when the second arg is a object are subject to
  change.) It is numified Perl-style,
  so 'nancy' becomes NaN
  and 'information' becomes Infinity.
  
  The C<value> method produces a Perl scalar. The C<0+> numeric operator is
  overloaded and produces the same.
  
  Stringification and boolification are overloaded and produce the same
  results as in JavaScript
  
  The C<typeof> and C<class> methods produce the strings 'number' and 
  'Number', respectively.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<JE>
  
  =item L<JE::Types>
  
  =item L<JE::Object::Number>
  
  =back
  
  =cut
  
  
  
  
JE_NUMBER

$fatpacked{"JE/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT';
  package JE::Object;
  
  # This has to come before any pragmas and sub declarations.
  sub evall { my $global = shift; my $r = eval 'local *_;' . shift;
              $@ and die; $r }
  
  our $VERSION = '0.066';
  
  use strict;
  use warnings;
  
  use overload fallback => 1,
  	'%{}'=>  \&_get_tie,
  	'""' => 'to_string',
          '0+' => 'to_number',
  #	 cmp =>  sub { "$_[0]" cmp $_[1] },
  	bool =>  sub { 1 };
  
  use Scalar::Util qw'refaddr blessed';
  use List::Util 'first';
  use B 'svref_2object';
  #use Data::Dumper;
  
  
  require JE::Code;
  require JE::Object::Error::TypeError;
  require JE::Object::Function;
  require JE::Boolean;
  require JE::String;
  
  import JE::Code 'add_line_number';
  sub add_line_number;
  
  sub in_list { 
  	my $str = shift;
  	shift eq $str and return 1 while @_;
  	!1;
  }
  
  
  =head1 NAME
  
  JE::Object - Base class for all JavaScript objects
  
  =head1 SYNOPSIS
  
    use JE;
    use JE::Object;
  
    $j = new JE;
  
    $obj = new JE::Object $j;
  
    $obj->prop('property1', $new_value);  # sets the property
    $obj->prop('property1');              # returns $new_value;
    $obj->{property1} = $new_value;       # or use it as a hash
    $obj->{property1};                    # ref like this
  
    $obj->keys; # returns a list of the names of enumerable property
    keys %$obj;
  
    $obj->delete('property_name');
    delete $obj->{property_name};
  
    $obj->method('method_name', 'arg1', 'arg2');
      # calls a method with the given arguments
  
    $obj->value ;    # returns a value useful in Perl (a hashref)
  
    "$obj";  # "[object Object]" -- same as $obj->to_string->value
    0+$obj"; #  nan -- same as $obj->to_number->value
    # etc.
  
  =head1 DESCRIPTION
  
  This module implements JavaScript objects for JE.  It serves as a base
  class
  for all other JavaScript objects.
  
  A JavaScript object is an associative array, the elements of which are
  its properties.  A method is a property that happens to be an instance
  of the
  C<Function> class (C<JE::Object::Function>).
  
  JE::Object objects can be used in Perl as a number, string or boolean.  The 
  result will be the same as in JavaScript.  The C<%{}> (hashref) operator is 
  also overloaded and returns a hash that can be used to modify the object.
  See L<"USING AN OBJECT AS A HASH">.
  
  See also L<JE::Types> for descriptions of most of the methods.  Only what
  is specific to JE::Object is explained here.
  
  =head1 METHODS
  
  =over 4
  
  =item $obj = JE::Object->new( $global_obj )
  
  =item $obj = JE::Object->new( $global_obj, $value )
  
  =item $obj = JE::Object->new( $global_obj, \%options )
  
  This class method constructs and returns a new JavaScript object, unless 
  C<$value> is
  already a JS object, in which case it just returns it.  The behaviour is
  the
  same as the C<Object> constructor in JavaScript.
  
  The C<%options> are as follows:
  
    prototype  the object to be used as the prototype for this
               object (Object.prototype is the default)
    value      the value to be turned into an object
  
  C<prototype> only applies when C<value> is omitted, undef, undefined
  or null.
  
  To convert a hash into an object, you can use the hash ref syntax like
  this:
  
    new JE::Object $j, { value => \%hash }
  
  Though it may be easier to write:
  
    $j->upgrade(\%hash)
  
  The former is what C<upgrade> itself uses.
  
  =cut
  
  # ~~~ Perhaps I should eliminate the hash ref syntax and have new()
  #     check to see if $j->exists($class->class), and use that as the
  #     prototype. That would make the other constructors simpler, but would
  #     it make it harder to control JE and customise host objects?
  
  sub new {
  	my($class, $global, $value) = @_;
  
  	if (defined blessed $value
  	    and can $value 'to_object') {
  		return to_object $value;
  	}
  	
  	my $p;
  	my %hash;
  	my %opts;
  
  	ref $value eq 'HASH' and (%opts = %$value), $value = $opts{value};
  	
  	local $@;
  	if (!defined $value || !defined eval{$value->value} && $@ eq '') {
  		$p = exists $opts{prototype} ? $opts{prototype}
  		      : $global->prototype_for("Object");
  	}
  	elsif(ref $value eq 'HASH') {
  		%hash = %$value;
  		$p = $global->prototype_for("Object");
  	}
  	else {
  		return $global->upgrade($value);
  	}
  
  	my $self =
  	bless \{ prototype => $p,
  	         global    => $global,
  	         props     => \%hash,
  	         keys      => [keys %hash]  }, $class;
  
  	$JE::Destroyer && JE::Destroyer'register($self);
  
  	$self;
  }
  
  sub destroy { # not DESTROY; called by JE::Destroyer
   undef ${$_[0]};
  }
  
  
  =item $obj->new_function($name, sub { ... })
  
  =item $obj->new_function(sub { ... })
  
  This creates and returns a new function object.  If $name is given,
  it will become a property of the object.  The function is enumerable, like
  C<alert> I<et al.> in web browsers.
  
  For more ways to create functions, see L<JE::Object::Function>.
  
  =cut
  
  sub new_function {
  	my $self = shift;
  	my $f = JE::Object::Function->new({
  		scope   => $self->global,
  		function   => pop,
  		function_args => ['args'],
  		@_ ? (name => $_[0]) : ()
  	});
  	@_ and $self->prop({
  		name => shift,
  		value=>$f,
  	});
  	$f;
  }
  
  
  
  
  =item $obj->new_method($name, sub { ... })
  
  =item $obj->new_method(sub { ... })
  
  This is the same as C<new_function>, except that the subroutine's first
  argument will be the object with which the function is called, and that the 
  property created will not be enumerable.  This allows one to add methods to
  C<Object.prototype>, for instance, without making every for-in loop list
  that method.
  
  For more ways to create functions, see L<JE::Object::Function>.
  
  =cut
  
  sub new_method {
  	my $self = shift;
  	my $f = JE::Object::Function->new({
  		scope   => $self->global,
  		function   => pop,
  		function_args => ['this','args'],
  		@_ ? (name => $_[0]) : ()
  	});
  	@_ and $self->prop({
  		name => shift,
  		value=>$f,
  		dontenum=>1
  	});
  	$f;
  }
  
  =item $obj->prop( $name )
  
  =item $obj->prop( $name => $value )
  
  =item $obj->prop({ ... })
  
  See C<JE::Types> for the first two uses.
  
  When the C<prop> method is called with a hash ref as its argument, the 
  prototype chain is I<not> searched.
  The elements of the hash are as follows:
  
    name      property name
    value     new value
    dontenum  whether this property is unenumerable
    dontdel   whether this property is undeletable
    readonly  whether this property is read-only
    fetch     subroutine called when the property is fetched
    store     subroutine called when the property is set
    autoload  see below
  
  If C<dontenum>, C<dontdel> or C<readonly> is given, the attribute in 
  question will be set.
  If C<value> is given, the value of the property will be set, regardless of
  the attributes.
  
  C<fetch> and C<store>, if specified, must be subroutines for
  fetching/setting the value of the property.  The 'fetch' subroutine will be
  called with ($object, $storage_space) as the arguments, where
  C<$storage_space> is a hash key inside the object that the two subroutines
  can use for storing the value (they can ignore it if they like).  The
  'store' subroutine will be call with
  ($object, $new_value, $storage_space) as
  the arguments.  Values assigned to the storage space from within these 
  routines are I<not>
  upgraded, neither is the return value of C<fetch>. C<fetch> and C<store> do 
  not necessarily have to go
  together.  If you only specify C<fetch>, then the value will be set as
  usual, but C<fetch> will be able to mangle the value when it is retrieved.
  Likewise, if you only specify C<store>, the value will be retrieved the
  usual way, so you can use this for validating or normalising the assigned
  value, for
  instance.  B<Note:> Currently, a simple scalar or unblessed coderef in the
  storage space will cause autoloading, but that is subject to change.
  
  C<autoload> can be a string or a coderef.  It will be called/evalled the
  first time the property is accessed (accessing it with a hash ref as
  described here does not count). If it is a string, it will be
  evaluated in the calling package (see warning below), in a scope that has a 
  variable named
  C<$global> that refers to the global object. The result will become the
  property's value.  The value returned is not currently upgraded.  The behaviour when a simple scalar or unblessed reference is returned is
  undefined.  C<autoload> will be
  ignored completely if C<value> or C<fetch> is also given.  B<Warning:> The
  'calling package' may not be what you think it is if a subclass overrides
  C<prop>.  It may be the subclass in such cases.  To be on the safe side,
  always begin the string of code with an explicit C<package> statement.  (If
  anyone knows of a clean solution to this, please let the author know.)
  
  This hash ref calling convention does not work on Array
  objects when the property name is C<length> or an array index (a 
  non-negative integer 
  below
  4294967295).  It does not work on String objects if the
  property name is C<length>.
  
  =cut
  
  sub prop {
  	my ($self, $opts) = (shift, shift);
  	my $guts = $$self;
  
  	if(ref $opts eq 'HASH') { # special use
  		my $name = $$opts{name};
  		for (qw< dontdel readonly >) {
  			exists $$opts{$_}
  				and $$guts{"prop_$_"}{$name} = $$opts{$_};
  		}
  
  		my $props = $$guts{props};
  
  		my $dontenum;
  		if(exists $$opts{dontenum}) {
  			if($$opts{dontenum}) {
  				@{$$guts{keys}} = 
  					grep $_ ne $name, @{$$guts{keys}};
  			}
  			else {
  				push @{ $$guts{keys} }, $name
  			    	unless first {$_ eq $name} @{$$guts{keys}};
  			}
  		}
  		elsif(!exists $$props{$name}) { # new property
  			push @{ $$guts{keys} }, $name
  		}
  
  		if(exists $$opts{fetch}) {
  			$$guts{fetch_handler}{$name} = $$opts{fetch};
  			$$props{$name} = undef if !exists $$props{$name};
  		}
  		if(exists $$opts{store}) {
  			$$guts{store_handler}{$name} = $$opts{store};
  			$$props{$name} = undef if !exists $$props{$name};
  		}
  		if(exists $$opts{value}) {
  			return $$props{$name} = $$opts{value};
  		}
  		elsif(!exists $$opts{fetch} && exists $$opts{autoload}) {
  			my $auto = $$opts{autoload};
  			$$props{$name} = ref $auto eq 'CODE' ? $auto :
  				"package " . caller() . "; $auto";
  			return # ~~~ Figure out what this should
  			       #     return, if anything
  		}
  
  		# ~~~ what should we return if fetch is given,
  		#     but not value?
  
  		return exists $$opts{fetch} ? () :
  		       exists $$props{$name} ? $$props{$name} : undef;
  	}
  
  	else { # normal use
  		my $name = $opts;
  		my $props = $$guts{props};
  		if (@_) { # we is doing a assignment
  			my($new_val) = shift;
  
  			return $new_val if $self->is_readonly($name);
  
  			# Make sure we don't change attributes if the
  			# property already exists
  			my $exists = exists $$props{$name} &&
  				defined $$props{$name};
  
  			exists $$guts{store_handler}{$name}
  			? $$guts{store_handler}{$name}->(
  				$self, $new_val, $$props{$name})
  			: ($$props{$name} = $new_val);
  
  			push @{ $$guts{keys} }, $name
  			    unless $exists; 
  
  			return $new_val;
  		}
  		elsif (exists $$props{$name}) {
  			if(exists $$guts{fetch_handler}{$name}) {
  				return $$guts{fetch_handler}{$name}-> (
  					$self, $$props{$name}
  				);
  			}
  
  			my $val = $$props{$name};
  			ref $val eq 'CODE' ?
  				$val = $$props{$name} = &$val() :
  			defined $val && ref $val eq '' &&
  				($val = $$props{$name} =
  					evall $$guts{global}, $val
  				);
  			return $val;
  		}
  		else {
  			my $proto = $self->prototype;
  			return $proto ?
  				$proto->prop($name) :
  				undef;
  		}	
  	}
  
  }
  
  
  sub exists { # = hasOwnProperty
  	my($self,$name) = @_;
  	return exists $$$self{props}{$name}
  }
  
  
  sub is_readonly { # See JE::Types for a description of this.
  	my ($self,$name) = (shift,@_);  # leave $name in @_
  
  	my $guts = $$self;
  
  	my $props = $$guts{props};
  	if( exists $$props{$name}) {
  		my $read_only_list = $$guts{prop_readonly};
  		return exists $$read_only_list{$name} ?
  			$$read_only_list{$name} : !1;
  	}
  
  	if(my $proto = $self->prototype) {
  		return $proto->is_readonly(@_);
  	}
  
  	return !1;
  }
  
  
  
  
  sub is_enum {
  	my ($self, $name) = @_;
  	$self = $$self;
  	in_list $name, @{ $$self{keys} };
  }
  
  
  
  
  sub keys {
  	my $self = shift;
  	my $proto = $self->prototype;
  	@{ $$self->{keys} }, defined $proto ? $proto->keys : ();
  }
  
  
  
  
  =item $obj->delete($property_name, $even_if_it's_undeletable)
  
  Deletes the property named $name, if it is deletable.  If the property did 
  not exist or it was deletable, then
  true is returned.  If the property exists and could not be deleted, false
  is returned.
  
  If the second argument is given and is true, the property will be deleted
  even if it is marked is undeletable.  A subclass may override this,
  however.
  For instance, Array and String objects always have a 'length' property
  which cannot be deleted.
  
  =cut
  
  sub delete {
  	my ($self, $name) = @_;
  	my $guts = $$self;
  
  	unless($_[2]) { # second arg means always delete
  		my $dontdel_list = $$guts{prop_dontdel};
  		exists $$dontdel_list{$name} and $$dontdel_list{$name}
  			and return !1;
  	}
  	
  	delete $$guts{prop_dontdel }{$name};
  	delete $$guts{prop_dontenum}{$name};
  	delete $$guts{prop_readonly}{$name};
  	delete $$guts{props}{$name};
  	$$guts{keys} = [ grep $_ ne $name, @{$$guts{keys}} ];
  	return 1;
  }
  
  
  
  
  sub method {
  	my($self,$method) = (shift,shift);
  
  	$self->prop($method)->apply($self, $self->global->upgrade(@_));
  }
  
  =item $obj->typeof
  
  This returns the string 'object'.
  
  =cut
  
  sub typeof { 'object' }
  
  
  
  
  =item $obj->class
  
  Returns the string 'Object'.
  
  =cut
  
  sub class { 'Object' }
  
  
  
  
  =item $obj->value
  
  This returns a hash ref of the object's enumerable properties.  This is a 
  copy of the object's properties.  Modifying it does not modify the object
  itself.
  
  =cut
  
  sub value {
  	my $self = shift;
  	+{ map +($_ => $self->prop($_)), $self->keys };
  }
  
  *TO_JSON=*value;
  
  
  
  
  sub id {
  	refaddr shift;
  }
  
  sub primitive { !1 };
  
  sub prototype {
  	@_ > 1 ? (${+shift}->{prototype} = $_[1]) : ${+shift}->{prototype};
  }
  
  
  
  
  sub to_primitive {
  	my($self, $hint) = @_;
  
  	my @methods = ('valueOf','toString');
  	defined $hint && $hint eq 'string' and @methods = reverse @methods;
  
  	my $method; my $prim;
  	for (@methods) {
  		defined($method = $self->prop($_)) || next;
  		($prim = $method->apply($self))->primitive || next;
  		return $prim;
  	}
  
  	die new JE::Object::Error::TypeError $self->global,
  	  add_line_number "An object of type " .
  		(eval {$self->class} || ref $self) .
  		" cannot be converted to a primitive";
  }
  
  
  
  
  sub to_boolean { 
  	JE::Boolean->new( $${+shift}{global}, 1 );
  }
  
  sub to_string {
  	shift->to_primitive('string')->to_string;
  }
  
  
  sub to_number {
  	shift->to_primitive('number')->to_number;
  }
  
  sub to_object { $_[0] }
  
  sub global { ${+shift}->{global} }
  
  =back
  
  =cut
  
  
  
  
  #----------- PRIIVATE ROUTIES ---------------#
  
  # _init_proto takes the Object prototype (Object.prototype) as its sole
  # arg and adds all the default properties thereto.
  
  sub _init_proto {
  	my $proto = shift;
  	my $global = $$proto->{global};
  
  	# E 15.2.4
  
  	$proto->prop({
  		dontenum => 1,
  		name => 'constructor',
  		value => $global->prop('Object'),
  	});
  
  	my $toString_sub = sub {
  		my $self = shift;
  		JE::String->new($global,
  			'[object ' . $self->class . ']');
  	};
  
  	$proto->prop({
  		name      => 'toString',
  		value     => JE::Object::Function->new({
  			scope    => $global,
  			name     => 'toString',
  			length   => 0,
  			function_args => ['this'],
  			function => $toString_sub,
  			no_proto => 1,
  		}),
  		dontenum  => 1,
  	});
  
  	$proto->prop({
  		name      => 'toLocaleString',
  		value     => JE::Object::Function->new({
  			scope    => $global,
  			name     => 'toLocaleString',
  			length   => 0,
  			function_args => ['this'],
  			function => sub { shift->method('toString') },
  			no_proto => 1,
  		}),
  		dontenum  => 1,
  	});
  
  	$proto->prop({
  		name      => 'valueOf',
  		value     => JE::Object::Function->new({
  			scope    => $global,
  			name     => 'valueOf',
  			length   => 0,
  			function_args => ['this'],
  			function => sub { $_[0] },
  			no_proto => 1,
  		}),
  		dontenum  => 1,
  	});
  
  	$proto->prop({
  		name      => 'hasOwnProperty',
  		value     => JE::Object::Function->new({
  			scope    => $global,
  			name     => 'hasOwnProperty',
  			argnames => ['V'],
  			function_args => ['this', 'args'],
  			function => sub {
  				JE::Boolean->new($global, 
  				    shift->exists(
  				        defined $_[0] ? $_[0] : 'undefined'
  				    )
  				);
  			},
  			no_proto => 1,
  		}),
  		dontenum  => 1,
  	});
  
  	$proto->prop({
  		name      => 'isPrototypeOf',
  		value     => JE::Object::Function->new({
  			scope    => $global,
  			name     => 'isPrototypeOf',
  			argnames => ['V'],
  			function_args => ['this', 'args'],
  			function => sub {
  				my ($self, $obj) = @_;
  
  				!defined $obj || $obj->primitive and return 
  					JE::Boolean->new($global, 0);
  
  				my $id = $self->id;
  				my $proto = $obj;
  
  				while (defined($proto = $proto->prototype))
  				{
  					$proto->id eq $id and return
  					    JE::Boolean->new($global, 1);
  				}
  
  				return JE::Boolean->new($global, 0);
  			},
  			no_proto => 1,
  		}),
  		dontenum  => 1,
  	});
  
  	$proto->prop({
  		name      => 'propertyIsEnumerable',
  		value     => JE::Object::Function->new({
  			scope    => $global,
  			name     => 'propertyIsEnumerable',
  			argnames => ['V'],
  			function_args => ['this', 'args'],
  			function => sub {	
  				return JE::Boolean->new($global,
  				    shift->is_enum(
  				        defined $_[0] ? $_[0] : 'undefined'
  				    )
  				);
  			},
  			no_proto => 1,
  		}),
  		dontenum  => 1,
  	});
  }
  
  
  
  #----------- TYING MAGIC ---------------#
  
  # I'm putting the object itself behind the tied hash, so that no new object
  # has to be created.
  # That means that tied %$obj returns $obj.
  
  
  sub _get_tie {
  	my $self = shift;
  	my $guts = $$self;
  	$$guts{tie} or tie %{ $$guts{tie} }, __PACKAGE__, $self;	
  	$$guts{tie};
  }
  
  sub TIEHASH  { $_[1] }
  sub FETCH    { $_[0]->prop($_[1]) }
  sub STORE    {
  	my($self, $key, $val) = @_;
  	my $global = $self->global;
  	if(ref $val eq 'HASH' && !blessed $val
    	   && !%$val && svref_2object($val)->REFCNT == 2) {
  		$val = tie %$val, __PACKAGE__, __PACKAGE__->new(
  			$global);
  	} elsif (ref $val eq 'ARRAY' && !blessed $val && !@$val && 
  	         svref_2object($val)->REFCNT == 2) {
  		require JE::Object::Array;
  		$val = tie @$val, 'JE::Object::Array',
  			JE::Object::Array->new($global);
  	}
  	$self->prop($key => $global->upgrade($val))
  }
  #sub CLEAR   {  }
  	# ~~~ have yet to implement this
  sub DELETE   {
  	my $val = $_[0]->prop($_[1]);
  	$_[0]->delete($_[1]);
  	$val;
  }
  sub EXISTS   { $_[0]->exists($_[1]) }
  sub FIRSTKEY { ($_[0]->keys)[0] }
  sub NEXTKEY  {
  	my @keys = $_[0]->keys;
  	my $last = $_[1];
  	for (0..$#keys) {
  		if ($last eq $keys[$_]) {
  			return $keys[$_+1]
  		}
  	}
  
  	# ~~~ What *should* we do if the property has been
  	#     deleted?
  	# I think this means the iterator should have been reset (from the
  	# user's point of view), so we'll start from the beginning.
  
  	return $keys[0];
  }
  
  sub DDS_freeze { my $self = shift; delete $$$self{tie}; $self }
  
  
  #----------- THE REST OF THE DOCUMENTATION ---------------#
  
  =head1 USING AN OBJECT AS A HASH
  
  Note first of all that C<\%$obj> is I<not> the same as C<< $obj->value >>.
  The C<value> method creates a new hash containing just the enumerable
  properties of the object and its prototypes.  It's just a plain hash--no
  ties, no magic.  C<%$obj>, on the other hand, is another creature...
  
  C<%$obj> returns a magic hash which only lists enumerable properties
  when you write C<keys %$obj>, but still provides access to the rest.
  
  Using C<exists> on this hash will check to see whether it is the object's
  I<own> property, and not a prototype's.
  
  Assignment to the hash itself currently
  throws an error:
  
    %$obj = (); # no good!
  
  This is simply because I have not yet figured out what it should do.  If
  anyone has any ideas, please let me know.
  
  Autovivification works, so you can write
  
    $obj->{a}{b} = 3;
  
  and the 'a' element will be created if did not already exist.  Note that,
  if the property C<did> exist but was undefined (from JS's point of view),
  this throws an error.
  
  =begin paranoia
  
  One potential problem with this is that, when perl autovivifies in the 
  example
  above, it first calls C<FETCH> and, when it sees that the result is not
  defined, then calls C<STORE> with C<{}> as the value.  It then uses that
  same hash that it passed to C<STORE>, and does I<not> make a second call to
  C<FETCH>.  This means that, for autovivification to work, the empty hash
  that perl automatically assigns has to be tied to the new JE::Object that
  is created.  Now, the same sequence of calls to tie 
  handlers can be triggered by the following lines:
  
    my %h;
    $obj->{a};
    $h{b} = 3;
  
  And, of course, you don't want your %h hash transmogrified and tied to a 
  JE::Object, do you?  (Normally
  hashes and arrays are copied by STORE.)  So the only feasible way (I can 
  think of) to
  make the distinction is to use reference counts (which is what I'm using), 
  but I don't know whether they will change
  between versions of Perl.
  
  =end paranoia
  
  =head1 INNARDS
  
  Each C<JE::Object> instance is a blessed reference to a hash ref.  The 
  contents of the hash
  are as follows:
  
    $$self->{global}         a reference to the global object
    $$self->{props}          a hash ref of properties, the values being
                             JavaScript objects
    $$self->{prop_readonly}  a hash ref with property names for the keys
                             and booleans  (that indicate  whether  prop-
                             erties are read-only) for the values
    $$self->{prop_dontdel}   a hash ref in the same format as
                             prop_readonly that indicates whether proper-
                             ties are undeletable
    $$self->{keys}           an array of the names of enumerable
                             properties
    $$self->{prototype}      a reference to this object's prototype
  
  In derived classes, if you need to store extra information, begin the hash 
  keys with an underscore or use at least one capital letter in each key. 
  Such keys 
  will never be used by the
  classes that come with the JE distribution.
  
  =head1 SEE ALSO
  
  L<JE>
  
  L<JE::Types>
  
  =cut
  
  
  1;
  
JE_OBJECT

$fatpacked{"JE/Object/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ARRAY';
  package JE::Object::Array;
  
  our $VERSION = '0.066';
  
  use strict;
  use warnings; no warnings 'utf8';
  
  use overload fallback => 1,
  	'@{}'=> \&_get_tie;
  
  
  use List::Util qw/min max/;
  use Scalar::Util 'blessed';
  
  our @ISA = 'JE::Object';
  
  require JE::Code;
  require JE::Object     ;
  require JE::Object::Error::TypeError              ;
  require JE::Object::Function                            ;
  require JE::String                                            ;
  require JE::Number                                                       ;
  
  import JE::Code 'add_line_number';
  sub add_line_number;
  
  =head1 NAME
  
  JE::Object - JavaScript Array object class
  
  =head1 SYNOPSIS
  
    use JE;
    use JE::Object::Array;
  
    $j = new JE;
  
    $js_array = new JE::Object::Array $j, 1, 2, 3;
  
    $perl_arrayref = $js_array->value; # returns [1, 2, 3]
  
    $js_array->[1]; # same as $js_array->value->[1]
  
    "$js_array"; # returns "1,2,3"
  
  =head1 DESCRIPTION
  
  This module implements JavaScript Array objects.
  
  The C<@{}> (array ref) operator is overloaded and returns a tied array that
  you can use to modify the array object itself. The limitations and caveats 
  mentioned in
  C<JE::Object/"USING AN OBJECT AS A HASH"> apply here, too.
  
  =head1 METHODS
  
  See L<JE::Types> for descriptions of most of the methods. Only what
  is specific to JE::Object::Array is explained here.
  
  =over 4
  
  =item $a = JE::Object::Array->new($global_obj, \@elements)
  
  =item $a = JE::Object::Array->new($global_obj, $length)
  
  =item $a = JE::Object::Array->new($global_obj, @elements)
  
  This creates a new Array object.
  
  If the second argument is an unblessed array ref, the elements of that
  array become the elements of the new array object.
  
  If there are two arguments and the second
  is a JE::Number, a new array is created with that number as the length.
  
  Otherwise, all arguments starting from the second one become elements of
  the new array object.
  
  =cut
  
  sub new {
  	my($class,$global) = (shift,shift);
  
  	my @array;
  	if (ref $_[0] eq 'ARRAY') {
  		@array = $global->upgrade(@{+shift});
  	} elsif (@_ == 1 && UNIVERSAL::isa $_[0], 'JE::Number') {
  		my $num = 0+shift;
  		$num == int($num) % 2**32
  		    or require JE::Object::Error::RangeError,
  		       die JE::Object::Error::RangeError->new($global,
  		        add_line_number "$num is not a valid array index");
  		$#array = $num - 1;
  	}
  	else {
  		@array = $global->upgrade(@_);
  	}
  	my $self = SUPER::new $class $global, {
  		prototype => $global->prototype_for('Array') ||
  		             $global->prop('Array')->prop('prototype')
  	};
  
  	my $guts = $$self;
  
  	$$guts{array} = \@array;
  	bless $self, $class;
  }
  
  
  
  
  sub prop {
  	my ($self, $name, $val) =  (shift, @_);
  	my $guts = $$self;
  
  	if ($name eq 'length') {
  		if (@_ > 1) { # assignment
  			$val == int($val) % 2**32 or
  				require JE::Object::Error::RangeError,
  				die new JE::Object::Error::RangeError
  				$$guts{global},
  				add_line_number
  				 "$val is not a valid value for length";
  			$#{$$guts{array}} = $val - 1;
  			return JE::Number->new($$guts{global}, $val);
  		}
  		else {
  			return JE::Number->new($$guts{global},
  				$#{$$guts{array}} + 1);
  		}
  	}
  	elsif ($name =~ /^(?:0|[1-9]\d*)\z/ and $name < 4294967295) {
  		if (@_ > 1) { # assignment
  			return $$guts{array}[$name] =
  				$$guts{global}->upgrade($val);
  		}
  		else {
  			return exists $$guts{array}[$name]
  				? $$guts{array}[$name] : undef;
  		}
  	}
  	$self->SUPER::prop(@_);
  }
  
  
  
  
  sub is_enum {
  	my ($self,$name) = @_;
  	$name eq 'length' and return !1;
  	if ($name =~ /^(?:0|[1-9]\d*)\z/ and $name < 4294967295) {
  		my $array = $$$self{array};
  		return $name < @$array && defined $$array[$name];
  	}
  	SUPER::is_enum $self $name;
  }
  
  
  
  
  sub keys { # length is not enumerable
  	my $self = shift;
  	my $array = $$$self{array};
  	grep(defined $$array[$_], 0..$#$array),
  		SUPER::keys $self;
  }
  
  
  
  
  sub delete {  # array indices are deletable; length is not
  	my($self,$name) = @_;
  	$name eq 'length' and return !1;
  	if($name =~ /^(?:0|[1-9]\d*)\z/ and $name < 4294967295) {
  		my $array = $$$self{array};
  		$name < @$array and $$array[$name] = undef;
  		return 1;
  	}
  	SUPER::delete $self $name;
  }
  
  
  
  
  =item $a->value
  
  This returns a reference to an array. This is a copy of the Array object's
  internal array. If you want an array through which you can modify the
  object, use C<@$a>.
  
  =cut
  
  sub value { [@{$${+shift}{array}}] };
  *TO_JSON=*value;
  
  
  sub exists {
  	my ($self, $name) =  (shift, @_);
  	my $guts = $$self;
  
  	if ($name eq 'length') {
  		return 1
  	}
  	elsif ($name =~ /^(?:0|[1-9]\d*)\z/ and $name < 4294967295) {
  		return exists $$guts{array}[$name]
  		    && defined $$guts{array}[$name];
  	}
  	$self->SUPER::exists(@_);
  }
  
  sub class { 'Array' }
  
  
  
  sub _new_constructor {
  	my $global = shift;
  	my $construct_cref = sub {
  		__PACKAGE__->new(@_);
  	};
  	my $f = JE::Object::Function->new({
  		name            => 'Array',
  		scope            => $global,
  		function         => $construct_cref,
  		function_args    => ['global','args'],
  		length           => 1,
  		constructor      => $construct_cref,
  		constructor_args => ['global','args'],
  	});
  
  	my $proto = $f->prop({
  		name    => 'prototype',
  		dontenum => 1,
  		readonly => 1,
  	});
  	bless $proto, __PACKAGE__;
  	$$$proto{array} = [];
  	$global->prototype_for('Array',$proto);
  
  	$proto->prop({
  		name  => 'toString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'toString',
  			length => 0,
  			no_proto => 1,
  			function_args => ['this'],
  			function => \&_toString,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'toLocaleString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'toLocaleString',
  			length => 0,
  			no_proto => 1,
  			function_args => ['this'],
  			function => \&_toLocaleString,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'concat',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'concat',
  			length => 1,
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => \&_concat,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'join',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'join',
  			argnames => ['separator'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => \&_join,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'pop',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'pop',
  			length => 0,
  			no_proto => 1,
  			function_args => ['this'],
  			function => \&_pop,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'push',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'push',
  			length => 1,
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => \&_push,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'reverse',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'reverse',
  			length => 0,
  			no_proto => 1,
  			function_args => ['this'],
  			function => \&_reverse,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'shift',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'shift',
  			length => 0,
  			no_proto => 1,
  			function_args => ['this'],
  			function => \&_shift,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'slice',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'shift',
  			argnames => [qw/start end/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => \&_slice,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'sort',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'sort',
  			argnames => [qw/comparefn/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => \&_sort,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'splice',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'splice',
  			argnames => [qw/start
  			               deleteCount/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => \&_splice,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'unshift',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'unshift',
  			length => 1,
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => \&_unshift,
  		}),
  		dontenum => 1,
  	});
  
  	$f
  }
  
  # ~~~ I should be able to optimise those methods that are designed to work
  #    with any JS object by checking first to see whether ref eq __PACKAGE__ 
  #  and then doing a fast Perl-style algorithm (reverse would be a good
  # candidate for this) 
  
  sub _toString {
  	my $self = shift;
  
  	eval{$self->class} eq 'Array'
  	or die JE::Object::Error::TypeError->new($self->global,
  		add_line_number 'Object is not an Array');
  
  	my $guts = $$self;
  	JE::String->_new(
  		$$guts{global},
  		join ',', map
  			defined $_ && ref !~ /^JE::(?:Undefined|Null)\z/
  			? $_->to_string->value : '',
  			@{ $$guts{array} }
  	);
  }
  
  sub _toLocaleString {
  	my $self = shift;
  
  	eval{$self->class} eq 'Array'
  	or die JE::Object::Error::TypeError->new($self->global,
  		'Object is not an Array');
  
  	my $guts = $$self;
  	JE::String->_new(
  		$$guts{global},
  		join ',', map
  			defined $_ && defined $_->value
  				? $_->method('toLocaleString')->value : '',
  			@{ $$guts{array} }
  	);
  }
  
  sub _concat {
  	unshift @_, shift->to_object;
  	my $thing;
  	my $new = __PACKAGE__->new(my $global = $_[0]->global);
  	my @new;
  	while(@_) {
  		$thing = shift;
  		if(eval{$thing->class} eq 'Array') {
  			push @new, @{ $$$thing{array} };
  		}
  		else {
  			push @new, $thing;
  		}
  	}
  
  	$$$new{array} = \@new;
  
  	$new;
  }
  
  sub _join {
  	my( $self,$sep) = @_;
  	!defined $sep || $sep->id eq 'undef' and $sep = ',';
  
  	my $length = $self->prop('length');
  	if(defined $length) {
  		$length = $length->to_number->value % 2**32;
  		$length == $length or $length = 0;
  	} else { $length = 0 }
  	
  
  	my $val;
  	JE::String->_new(
  		$self->global,
  		join $sep,
  			map {
  				my $val = $self->prop($_);
  				defined $val && defined $val->value
  				? $val->to_string->value : ''
  			} 0..$length-1
  	);
  }
  
  sub _pop {
  	my( $self) = @_;
  
  	my $length = $self->prop('length');
  	if(defined $length) {
  		$length = (int $length->to_number->value) % 2**32;
  		$length == $length or $length = 0;
  	} else { $length = 0 }
  	
  	my $global = $self->global;
  	$length or
  		$self->prop('length', JE::Number->new($global,0)),
  		return $global->undefined;
  
  	
  	$length--;
  	my $val = $self->prop($length);
  	$self->delete($length);
  	$self->prop(length => JE::Number->new($global,$length));
  	$val;
  }
  
  sub _push {
  	my( $self) = shift;
  
  	my $length = $self->prop('length');
  	if(defined $length) {
  		$length = (int $length->to_number->value) % 2**32;
  		$length == $length or $length = 0;
  	} else { $length = 0 }
  	
  	while(@_) {
  		$self->prop($length++, shift);
  	}
  
  	$self->prop(length => JE::Number->new($self->global,$length));
  }
  
  sub _reverse {
  	my $self = shift;
  	
  	my $length = $self->prop('length');
  	if(defined $length) {
  		$length = (int $length->to_number->value) % 2**32;
  		$length == $length or $length = 0;
  	} else { $length = 0 }
  	
  	my($elem1,$elem2,$indx2);
  
  	for (0..int $length/2-1) {
  		$elem1 = $self->prop($_);
  		$elem2 = $self->prop($indx2 = $length - $_ - 1);
  
  		defined $elem2
  			? $self->prop($_ => $elem2)
  			: $self->delete($_);
  
  		defined $elem1
  			? $self->prop($indx2 => $elem1)
  			: $self->delete($indx2);
  	}
  
  	$self;
  }
  
  sub _shift {
  	my( $self) = @_;
  
  	my $length = $self->prop('length');
  	if(defined $length) {
  		$length = (int $length->to_number->value) % 2**32;
  		$length == $length or $length = 0;
  	} else { $length = 0 }
  	
  	$length or
  		$self->prop('length', 0),
  		return $self->global->undefined;
  
  	my $ret = $self->prop(0);
  	my $val;
  
  	for (0..$length-2) {
  		$val = $self->prop($_+1);
  		defined $val
  			? $self-> prop($_ => $val)
  			: $self->delete($_);
  	}
  	$self->delete(--$length);
  	$self->prop(length => $length);
  
  	$ret;
  }
  
  sub _slice {
  	my( $self,$start,$end) = @_;
  
  	my $length = $self->prop('length');
  	if(defined $length) {
  		$length = (int $length->to_number->value) % 2**32;
  		$length == $length or $length = 0;
  	} else { $length = 0 }
  	
  	my $new = __PACKAGE__->new(my $global = $self->global);
  	my @new;
  
  	if (defined $start) {
  		$start = int $start->to_number->value;
  		$start  = $start == $start
  			? $start < 0
  				? max($start + $length,0)
  				: min($start, $length)
  			: 0;
  	}
  	else {
  		$start = 0
  	}
  
  	if (defined $end and $end->id ne 'undef') {
  		$end = $end->to_number->value;
  		$end  = $end == $end
  			? $end < 0
  				? max($end + $length,0)
  				: min($end, $length)
  			: 0;
  	}
  	else {
  		$end = $length
  	}
  	
  
  	for ($start..$end-1) {
  		push @new, $self->prop($_);
  	}
  
  	$$$new{array} = \@new;
  
  	$new;
  }
  
  sub _sort {
  	my($self, $comp) = @_;
  	
  	my $length = $self->prop('length');
  	if(defined $length) {
  		$length = (int $length->to_number->value) % 2**32;
  		$length == $length or $length = 0;
  	} else { $length = 0 }
  	
  	my(@sortable, @undef, $nonexistent, $val);
  	for(0..$length-1) {
  		defined($val = $self->prop($_))
  			? $val->id eq 'undef'
  				? (push @undef, $val)
  				: (push @sortable, $val)
  			: ++$nonexistent;
  	}
  
  	my $comp_sub = defined $comp && $comp->can('call') 
  		? sub { 0+$comp->call($a,$b) }
  		: sub { $a->to_string->value16 cmp $b->to_string->value16};
  
  	my @sorted = ((sort $comp_sub @sortable),@undef);
  
  	for (0..$#sorted) {
  		$self->prop($_ => $sorted[$_]);
  	}
  
  	no warnings 'uninitialized';
  	for (@sorted .. $#sorted + $nonexistent) {
  		$self->delete($_);
  	}
  
  	$self;
  }
  
  sub _splice {
  	my ($self, $start, $del_count) = (shift, shift, shift);
  	my $global = $self->global;
  
  	my $length = $self->prop('length');
  	if(defined $length) {
  		$length = ($length->to_number->value) % 2**32;
  		$length == $length or $length = 0;
  	} else { $length = 0 };
  	
  	if (defined $start) {
  		$start = int $start->to_number->value;
  		$start  = $start == $start
  			? $start < 0
  				? max($start + $length,0)
  				: min($start, $length)
  			: 0;
  	}
  	else {
  		$start = 0
  	}
  
  	if(defined $del_count) {
  		$del_count = int $del_count->to_number->value;
  		$del_count = $del_count >= 0
  			? min($del_count, $length-$start)
  			: 0;
  	}
  	else {
  		$del_count = 0
  	}
  
  	my @new = map $self->prop($_),
  		$start..(my $end = $start+$del_count-1);
  
  	my $val;
  	if (@_ < $del_count) {
  		my $diff = $del_count - @_;
  		for ($end+1..$length-1) {
  			defined ($val = $self->prop($_))
  			?	$self->prop ($_ - $diff => $val)
  			:	$self->delete($_ - $diff);
  		}
  		$self->prop(length =>
  			JE::Number->new($global, $length - $diff)
  		);
  	}
  	elsif (@_ > $del_count) {
  		my $diff = @_ - $del_count;
  		for (reverse $end+1..$length-1) {
  			defined ($val = $self->prop($_))
  			?	$self->prop ($_ + $diff => $val)
  			:	$self->delete($_ + $diff);
  		}
  		$self->prop(length =>
  			JE::Number->new($global, $length + $diff)
  		);
  	}
  	else {
  		$self->prop(length => JE::Number->new($global,$length));
  	}
  
  	for (0..$#_) {
  		$self->prop($_+$start => $_[$_]);
  	}
  
  	my $new = __PACKAGE__->new($self->global);
  	$$new->{array} = \@new;
  	
  	$new;
  }
  
  sub _unshift {
  	my ($self) = (shift,);
  
  	my $length = $self->prop('length');
  	if(defined $length) {
  		$length = (int $length->to_number->value) % 2**32;
  		$length == $length or $length = 0;
  	} else { $length = 0 }
  
  	my $val;
  	for (reverse 0..$length-1) {
  		defined ($val = $self->prop($_))
  		?	$self->prop ($_ + @_ => $val)
  		:	$self->delete($_ + @_);
  	}
  
  	for (0..$#_) {
  		$self->prop($_ => $_[$_]);
  	}
  	$self->prop(length => $length += @_);
  
  	return JE::Number->new($self->global, $length);
  }
  
  
  #----------- TYING MAGIC ---------------#
  
  sub _get_tie {
  	my $self = shift;
  	my $guts = $$self;
  	$$guts{array_tie} or tie @{ $$guts{array_tie} }, __PACKAGE__,
  		$self;	
  	$$guts{array_tie};
  }
  
  # The qw/FETCH EXISTS DELETE/ methods are inherited from JE::Object.
  
  sub TIEARRAY  { $_[1] }
  sub FETCHSIZE { $_[0]->prop('length') }
  sub STORESIZE { $_[0]->prop('length' => $_[1]) }
  sub PUSH      { shift->method(push => @_) }
  sub POP       { $_[0]->method('pop') }
  sub SHIFT     { $_[0]->method('shift') }
  sub UNSHIFT   { shift->method(unshift => @_) }
  sub SPLICE    { @{ shift->method(splice  => @_)->value } }
  sub DDS_freeze {
  	my $self = shift;
  	delete $$$self{array_tie};
  	SUPER::DDS_freeze $self;
  }
  
  =back
  
  =head1 SEE ALSO
  
  L<JE>
  
  L<JE::Types>
  
  L<JE::Object>
  
  =cut
  
  1;
JE_OBJECT_ARRAY

$fatpacked{"JE/Object/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_BOOLEAN';
  package JE::Object::Boolean;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  our @ISA = 'JE::Object';
  
  use Scalar::Util 'blessed';
  
  require JE::Code;
  require JE::Boolean;
  require JE::Object::Error::TypeError;
  require JE::Object::Function;
  require JE::String;
  
  import JE::Code 'add_line_number';
  sub add_line_number;
  
  =head1 NAME
  
  JE::Object::Boolean - JavaScript Boolean object class
  
  =head1 SYNOPSIS
  
    use JE;
  
    $j = new JE;
  
    $js_bool_obj = new JE::Object::Boolean $j, 1;
  
    $perl_bool = $js_bool_obj->value;
  
    "$js_bool_obj";  # true
  
  =head1 DESCRIPTION
  
  This class implements JavaScript Boolean objects for JE. The difference
  between this and JE::Boolean is that that module implements
  I<primitive> boolean values, while this module implements the I<objects.>
  
  =head1 METHODS
  
  See L<JE::Types> for descriptions of most of the methods. Only what
  is specific to JE::Object::Boolean is explained here.
  
  =over
  
  =cut
  
  sub new {
  	my($class, $global, $val) = @_;
  	my $self = $class->SUPER::new($global, {
  		prototype => $global->prototype_for('Boolean')
  		          || $global->prop('Boolean')->prop('prototype')
  	});
  
  	$$$self{value} = defined $val
  		? defined blessed $val
  		  && $val->can('to_boolean')
  			? $val->to_boolean->[0]
  			: !!$val
  		: !1;
  	$self;
  }
  
  
  =item value
  
  Returns a Perl scalar, either 1 or the empty string (well, actually !1).
  
  =cut
  
  sub value { $${$_[0]}{value} }
  
  
  sub class { 'Boolean' }
  
  
  sub _new_constructor {
  	my $global = shift;
  	my $f = JE::Object::Function->new({
  		name            => 'Boolean',
  		scope            => $global,
  		argnames         => [qw/value/],
  		function         => sub {
  			defined $_[0] ? $_[0]->to_boolean :
  				JE::Boolean->new($global, 0);
  		},
  		function_args    => ['args'],
  		constructor      => sub {
  			unshift @_, __PACKAGE__;
  			goto &new;
  		},
  		constructor_args => ['scope','args'],
  	});
  
  	my $proto = bless $f->prop({
  		name    => 'prototype',
  		dontenum => 1,
  		readonly => 1,
  	}), __PACKAGE__;
  	$global->prototype_for('Boolean',$proto);
  
  	$$$proto{value} = !1;
  	
  	$proto->prop({
  		name  => 'toString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'valueOf',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				my $self = shift;
  				die JE::Object::Error::TypeError->new(
  					$global, add_line_number
  					"Argument to " .
  					"Boolean.prototype.toString is not"
  					. " a " .
  					"Boolean object"
  				) unless $self->class eq 'Boolean';
  
  				return JE::String->_new($global,
  					qw/false true/[$self->value]);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'valueOf',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'valueOf',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				my $self = shift;
  				die JE::Object::Error::TypeError->new(
  					$global, add_line_number
  					"Argument to " .
  					"Boolean.prototype.valueOf is not"
  					. " a " .
  					"Boolean object"
  				) unless $self->class eq 'Boolean';
  
  				return JE::Boolean->new($global,
  					$$$self{value});
  			},
  		}),
  		dontenum => 1,
  	});
  
  
  	$f;
  }
  
  return "a true value";
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item JE
  
  =item JE::Types
  
  =item JE::Object
  
  =item JE::Boolean
  
  =back
  
  =cut
  
  
  
  
JE_OBJECT_BOOLEAN

$fatpacked{"JE/Object/Date.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_DATE';
  package JE::Object::Date;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings; no warnings 'utf8';
  
  use JE::Code 'add_line_number';
  #use Memoize;
  use POSIX 'floor';
  use Scalar::Util 1.1 qw'blessed weaken looks_like_number';
  use Time::Local 'timegm_nocheck';
  use Time::Zone 'tz_local_offset';
  
  our @ISA = 'JE::Object';
  
  ##require JE::Number;
  require JE::Object;
  require JE::Object::Error::TypeError;
  require JE::Object::Function;
  require JE::String;
  
  use constant EPOCH_OFFSET => timegm_nocheck(0,0,0,1,0,1970);
  
  =head1 NAME
  
  JE::Object::Date - JavaScript Date object class
  
  =head1 SYNOPSIS
  
    use JE;
  
    $j = new JE;
  
    $js_date = new JE::Object::Date $j;
  
    $js_date->value; # 1174886940.466
    "$js_date";      # Sun Mar 25 22:29:00 2007 -0700
  
  =head1 DESCRIPTION
  
  This class implements JavaScript Date objects for JE.
  
  =head1 METHODS
  
  See L<JE::Types> and L<JE::Object> for descriptions of most of the methods. 
  Only what
  is specific to JE::Object::Date is explained here.
  
  =over
  
  =cut
  
  my %mon_numbers = qw/ Jan 0 Feb 1 Mar 2 Apr 3 May 4 Jun 5 Jul 6 Aug 7 Sep 8
                        Oct 9 Nov 10 Dec 11 /;
  
  sub new {
  	my($class, $global) = (shift, shift);
  	my $self = $class->SUPER::new($global, {
  		prototype => $global->prototype_for('Date')
  		          || $global->prop('Date')->prop('prototype')
  	});
  
  	if (@_ >= 2) {
  		my($year,$month,$date,$hours,$minutes,$seconds,$ms) = @_;
  		for($year,$month) {
  			defined()
  			? defined blessed $_ && $_->can('to_number') &&
  			  ($_ = $_->to_number->value)
  			: ($_ = sin 9**9**9);
  		}
  		defined $date
  		? defined blessed $date && $date->can('to_number') &&
  		  ($date = $date->to_number->value)
  		: ($date = 1);
  		for($hours,$minutes,$seconds,$ms) {
  			no warnings 'uninitialized'; # undef --> 0
  			$_ = defined blessed $_ && (can $_ 'to_number')
  			?	$_->to_number->value
  			:	0+$_;
  		}
  		$year >= 0 and int($year) <= 99 and $year += 1900;
  		$$$self{value} = _time_clip(_local2gm(_make_date(
  			_make_day($year,$month,$date),
  			_make_time($hours,$minutes,$seconds,$ms),
  		)));
  		
  	}
  	elsif (@_ and
              defined blessed $_[0]
  	    ? (my $prim = $_[0]->to_primitive)->isa('JE::String')
  	    : !looks_like_number $_[0]) {
  		$$$self{value} = _parse_date("$_[0]");
  			
  	} elsif(@_) {
  		$$$self{value} = _time_clip (
  			defined $_[0]
  			? defined blessed $_[0]
  			  && $_[0]->can('to_number')
  				? $_[0]->to_number->value
  				: 0+$_[0]
  			: 0
  		);
  	} else {
  		require Time::HiRes;
  		$$$self{value} =
  		 int +(Time::HiRes::time() - EPOCH_OFFSET) * 1000;
  	}
  	$self;
  }
  
  
  
  
  =item value
  
  Returns the date as the number of seconds since the epoch, with up to three
  decimal places.
  
  =cut
  
  sub value { $${$_[0]}{value}/1000 + EPOCH_OFFSET }
  
  
  
  =item class
  
  Returns the string 'Date'.
  
  =cut
  
  sub class { 'Date' }
  
  
  
  sub to_primitive { SUPER::to_primitive{shift}@_?@_:'string' }
  
  
  =back
  
  =head1 SEE ALSO
  
  L<JE>, L<JE::Types>, L<JE::Object>
  
  =cut
  
  
  # Most of these functions were copied directly from ECMA-262. Those were
  # not optimised for speed,  but apparently either for clarity or obfusca-
  # tion--Ive yet to ascertain which. These need to be optimized, and many
  # completely rewritten.
  
  # ~~~ Are these useful enough to export them?
  sub MS_PER_DAY() { 86400000 }
  use constant LOCAL_TZA => do {
   # ~~~ I need to test this by subtracting 6 mumps -- but how?
  	my $time = time;
  	1000 * (tz_local_offset($time) - (localtime $time)[8] * 3600)
  };
  
  # ~~~ I still need to figure which of these (if any) actually benefit from
  #     memoisation.
  
  # This stuff was is based on code from Time::Local 1.11, with various
  # changes (particularly the removal of stuff we dont need).
  my @MonthDays = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
  my %Cheat;
  sub _daygm {
      $_[3] + ($Cheat{(),@_[4,5]} ||= do {
          my $month = ($_[4] + 10) % 12;
          my $year = $_[5] - int $month/10;
          365*$year + floor($year/4) - floor($year/100) + floor($year/400) +
              int(($month*306 + 5)/10) - 719469
      });
  }
  sub _timegm {
  	my ($sec,$min,$hour,$mday,$month,$year) = @_;
  
  	my $days = _daygm(undef, undef, undef, $mday, $month, $year);
  	my $xsec = $sec + 60*$min + 3600*$hour;
  
  	$xsec + 86400 * $days;	
  }
  
  
  sub _day($) { floor $_[0] / MS_PER_DAY }
  sub _time_within_day($) { $_[0] % MS_PER_DAY }
  sub _days_in_year($) {
  	365 + not $_[0] % 4 || !($_[0] % 100) && $_[0] % 400
  }
  sub _day_from_year($) {
  	my $y = shift;
  	365 * ($y - 1970) + floor(($y - 1969) / 4) -
  		floor(($y - 1901) / 100) + floor(($y - 1601) / 400)
  }
  sub _time_from_year($) { MS_PER_DAY * &_day_from_year }
  sub _div($$) {
      my $mod = $_[0] % $_[1];
      return +($_[0] - $mod) / $_[1], $mod;
  }
  sub _year_from_time($) {
  	# This line adjusts the  time  so  that  1/Mar/2000  is  0,  and
  	# 29/Feb/2400, the extra leap day in the quadricentennium, is the
  	# last day therein.  (So a qcm is  4 centuries  +  1  leap  day.)
  	my $time = $_[0] - 951868800_000;
  
  	(my $prec, $time) = _div $time, MS_PER_DAY * (400 * 365 + 97);
  	$prec *= 400; # number of years preceding the current quadri-
  	                  # centennium
  
  	# Divide by a century and we have centuries preceding the current
  	# century and the time within the century, unless $tmp == 4, ...
  	(my $tmp, $time) = _div $time, MS_PER_DAY * (100 * 365 + 24);
  	if($tmp == 4) { # ... in which case we already know the year, since
  	                # this is the last day of a qcm
  		return $prec + 400 + 2000;
  	}
  	$prec += $tmp * 100; # preceding the current century
  	
  	# A century is 24 quadrennia followed by four non-leap years, or,
  	# since we are starting with March,  25 quadrennia with one day 
  	# knocked off the end.  So no special casing is  needed  here.
  	($tmp, $time) = _div $time, MS_PER_DAY * (4 * 365 + 1);
  	$prec += $tmp * 4; # preceding the current quadrennium
  	
  	($tmp, $time) = _div $time, MS_PER_DAY * 365;
  	# Same special case we encountered when dividing qcms, since there
  	# is an extra day on the end.
  	if($tmp == 4) {
  		return $prec + 4 + 2000;
  	}
  	$prec + 2000 + $tmp +    # Add 1 if we are past Dec.:
  		($time >= (31+30+31+30+31+31+30+31+30+31) * MS_PER_DAY);
  		           # days from Mar 1 to Jan 1
  }
  sub _in_leap_year($) { _days_in_year &_year_from_time == 366 }
  sub _day_within_year($) { &_day - _day_from_year &_year_from_time }
  sub _month_from_time($) {
  	my $dwy = &_day_within_year;
  	my $ily = &_in_leap_year;
  	return 0 if $dwy < 31;
  	my $counter = 1;
  	for (qw/59 90 120 151 181 212 243 273 304 334 365/) {
  		return $counter if $dwy < $_ + $ily;
  		++$counter;
  	}
  }
  sub _date_from_time($) {
  	my $dwy = &_day_within_year;
  	my $mft = &_month_from_time;
  	return $dwy+1 unless $mft;
  	return $dwy-30 if $mft == 1;
  	return $dwy - qw/0 0 58 89 119 150 180 211 242 272 303 333/[$mft]
  		- &_in_leap_year;
  }
  sub _week_day($) { (&_day + 4) % 7 }
  
  # $_dumdeedum[0] will contain the nearest non-leap-year that begins on Sun-
  # day, $_dumdeedum[1] the nearest beginning on Monday, etc.
  # @_dumdeedum[7..15] are for leap years.
  # For the life of me I can't think of a name for this array!
  {
  	my @_dumdeedum; 
  
  	my $this_year = (gmtime(my $time = time))[5]+1900;
  	$_dumdeedum[_week_day(_time_from_year _year_from_time $time*1000) +
  		7 * (_days_in_year($this_year)==366) ] = $this_year;
  
  	my $next_past = my $next_future = $this_year;
  	my $count = 1; my $index;
  	while ($count < 14) {
  		$index = (_day_from_year(--$next_past) + 4) % 7 +
  			7 * (_days_in_year($next_past)==366);
  		unless (defined $_dumdeedum[$index]) {
  			$_dumdeedum[$index] = $next_past;
  			++$count;
  		}
  		$index = (_day_from_year(++$next_future) + 4) % 7 +
  			7 * (_days_in_year($next_future)==366);
  		unless (defined $_dumdeedum[$index]) {
  			$_dumdeedum[$index] = $next_future;
  			++$count;
  		}
  	}
  # The spec requires that the same formula for daylight savings be used for
  # all years.  An ECMAScript implementation is not  allowed  to  take  into
  # account that the formula might have changed in the past. That's what the
  # @_dumdeedum array is for. The spec basically allows for fourteen differ-
  # ent possibilities for the dates for daylight savings time  change.  The
  # code above collects the 'nearest' fourteen years that are not equivalent
  # to each other.
  
  	sub _ds_time_adjust($) {
  		my $year = _year_from_time(my $time = $_[0]);
  		my $ddd_index = (_day_from_year($year) + 4) % 7 +
  				7 * (_days_in_year $year == 366);
  		my $time_within_year = $time - _time_from_year $year;
  		(localtime
  		  +(
  		    $time_within_year +
  		    _time_from_year $_dumdeedum[$ddd_index]
  		  ) / 1000 # convert to seconds
  		  + EPOCH_OFFSET
  		)[8] * 3600_000
  	}
  }
  
  sub _gm2local($) {
  	# shortcut for nan & inf to avoid localtime(nan) warning
  	return $_[0] unless $_[0] == $_[0] and $_[0]+1 != $_[0];
  
  	$_[0] + LOCAL_TZA + &_ds_time_adjust
  }
  
  sub _local2gm($) {
  	# shortcut for nan & inf to avoid localtime(nan) warning
  	return $_[0] unless $_[0] == $_[0] and $_[0]+1 != $_[0];
  
  	$_[0] - LOCAL_TZA - _ds_time_adjust $_[0] - LOCAL_TZA
  }
  
  sub _hours_from_time($) { floor($_[0] / 3600_000) % 24 }
  sub _min_from_time($) { floor($_[0] / 60_000) % 60 }
  sub _sec_from_time($) { floor($_[0] / 1000) % 60 }
  sub _ms_from_time($) { $_[0] % 1000 }
  
  sub _make_time($$$$) {
  	my ($hour, $min, $sec, $ms) = @_;
  	for(\($hour, $min, $sec, $ms)) {
  		$$_ + 1 == $$_ or $$_ != $$_ and return sin 9**9**9;
  		$$_ = int $$_; # ~~~ Is this necessary? Is it sufficient?
  	}
  	$hour * 3600_000 +
  	$min  *   60_000 +
  	$sec  *     1000 +
  	$ms;
  }
  
  sub _make_day($$$) {
  	my ($year, $month, $date) = @_;
  	for(\($year, $month, $date)) {
  		$$_ + 1 == $$_ or $$_ != $$_ and return sin 9**9**9;
  		$$_ = int $$_; # ~~~ Is it sufficient?
  	}
  	$year += floor($month/12);
  	$month %= 12;
  	_timegm(0,0,0,$date,$month,$year)
  		/
  	(MS_PER_DAY/1000)
  }
  
  sub _make_date($$) {
  	my ($day, $time) = @_;
  	for(\($day, $time)) {
  		$$_ + 1 == $$_ or $$_ != $$_ and return sin 9**9**9;
  	}
  	$day * MS_PER_DAY + $time
  }
  
  sub _time_clip($) {
  	my ($time) = @_;
  	$time + 1 == $time or $time != $time and return sin 9**9**9;
  	abs($time) > 8.64e15 and return sin 9**9**9;
  	int $time
  }
  
  sub _parse_date($) {
  	# If the date matches the format output by
  	# to(GMT|UTC|Locale)?String, we need to parse it ourselves.
  	# Otherwise, we pass it on to Date::Parse, and live with
  	# the latters limited range.
  	# ~~~ (Maybe I should change this to use
  	#      DateTime::Format::Natural.)
  
  	my $str = shift;
  	my $time;
  	if($str =~ /^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[ ]
              (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]
              ([ \d]\d)\ (\d\d):(\d\d):(\d\d)\ (\d{4,})
              [ ]([+-]\d{2})(\d{2})
            \z/x) {
  		$time = _timegm($5,$4,$3,$2,$mon_numbers{$1},$6)
  			+ $7*-3600 + $8*60;
  	} elsif($str =~ /^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat),[ ]
              (\d\d?)[ ]
              (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[ ]
  	    (\d{4,})\ (\d\d):(\d\d):(\d\d)\ GMT 
            \z/x) {
  		$time = _timegm($6,$5,$4,$1,$mon_numbers{$2},$3);
  	} else {
  		require Date::Parse;
  		if(defined($time = Date::Parse::str2time($str))) {
  			$time -= EPOCH_OFFSET
  		}
  	}
  	defined $time ? $time * 1000 :
  		sin 9**9**9;
  }
  
  my @days = qw/ Sun Mon Tue Wed Thu Fri Sat Sun /;
  my @mon  = qw/ Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec /;
  sub _new_constructor {
  	() = (@days, @mon); # work-around for perl bug #16302
  	my $global = shift;
  	my $f = JE::Object::Function->new({
  		name            => 'Date',
  		scope            => $global,
  		argnames         => [qw/year    month date hours minutes
  		                        seconds ms/],
  		function         => sub {
  			my $time = time;
  			my $offset = tz_local_offset($time);
  			my $sign = qw/- +/[$offset >= 0];
  			return JE::String->_new($global,
  				localtime($time) . " $sign" .
  				sprintf '%02d%02d',
  					_div abs($offset)/60, 60
  			);
  		},
  		function_args    => [],
  		constructor      => sub {
  			unshift @_, __PACKAGE__;
  			goto &new;
  		},
  		constructor_args => ['scope','args'],
  	});
  
  	$f->prop({
  		name  => 'parse',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'parse',
  			argnames => ['string'],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				my $str = shift;
  				JE::Number->new($global, 
  				    defined $str
  				    ? _parse_date $str->to_string->value
  				    : 'nan'
  				);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$f->prop({
  	  name  => 'UTC',
  	  value => JE::Object::Function->new({
  	    scope  => $global,
  	    name    => 'UTC',
  	    argnames => [qw 'year month date hours minutes
  	                     seconds ms' ],
  	    no_proto => 1,
  	    function_args => ['args'],
  	    function => sub {
  	      my($year,$month,$date,$hours,$minutes,$seconds,$ms) = @_;
  	      for($year,$month) {
  	        $_ = defined() ? $_->to_number->value : sin 9**9**9
  	      }
  	      $date = defined $date ? $date->to_number->value : 1;
  	      for($hours,$minutes,$seconds,$ms) {
  	        $_ = defined $_ ? $_->to_number->value : 0;
  	      }
  	      $year >= 0 and int($year) <= 99 and $year += 1900;
  	      JE::Number->new($global, 
  	        _time_clip(_make_date(
  	          _make_day($year,$month,$date),
  	          _make_time($hours,$minutes,$seconds,$ms),
  	        ))
  	      );
  	    },
  	  }),
  	  dontenum => 1,
  	});
  
  	my $proto = bless $f->prop({
  		name    => 'prototype',
  		dontenum => 1,
  		readonly => 1,
  	}), __PACKAGE__;
  	$global->prototype_for('Date'=>$proto);
  
  	$$$proto{value} = sin 9**9**9;
  
  	$proto->prop({
  		name  => 'toString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'toString',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number
  			      "Arg to toString ($_[0]) is not a date")
  			    unless $_[0]->isa('JE::Object::Date');
  			  # Cant use localtime because of its lim-
  			  # ited range.
  			  my $v = $${+shift}{value};
  			  my $time = _gm2local $v;
  			  my $offset = ($time - $v) / 60_000;
  			  my $sign = qw/- +/[$offset >= 0];
  			  return JE::String->_new($global,
  			    sprintf
  			      '%s %s %2d %02d:%02d:%02d %04d %s%02d%02d',
  			      $days[_week_day $time],       # Mon
  			      $mon[_month_from_time $time], # Dec
  			      _date_from_time $time,        # 31
  			      _hours_from_time $time,       # 11:42:40
  			      _min_from_time $time,         
  			      _sec_from_time $time,
  			      _year_from_time $time,        # 2007
  			      $sign,                        # -
  			      _div abs($offset), 60         # 0800
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'toDateString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'toString',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number
  			      "Arg to toDateString ($_[0]) is not a date")
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $time = _gm2local $${+shift}{value};
  			  return JE::String->_new($global,
  			    sprintf
  			      '%s %s %d %04d',
  			      $days[_week_day $time],       # Mon
  			      $mon[_month_from_time $time], # Dec
  			      _date_from_time $time,        # 31
  			      _year_from_time $time,        # 2007
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'toTimeString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'toTimeString',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number
  			      "Arg to toTimeString ($_[0]) is not a date")
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $time = _gm2local $${+shift}{value};
  			  return JE::String->_new($global,
  			    sprintf
  			      '%02d:%02d:%02d',
  			      _hours_from_time $time, 
  			      _min_from_time $time,         
  			      _sec_from_time $time,
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	# ~~~ How exactly should I make these three behave? Should I leave
  	#     them as they is?
  	$proto->prop({
  		name => 'toLocaleString',
  		value => $proto->prop('toString'),
  		dontenum => 1,
  	});
  	$proto->prop({
  		name => 'toLocaleDateString',
  		value => $proto->prop('toDateString'),
  		dontenum => 1,
  	});
  	$proto->prop({
  		name => 'toLocaleTimeString',
  		value => $proto->prop('toTimeString'),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'valueOf',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'valueOf',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number
  			      "Arg to valueOf ($_[0]) is not a date")
  			    unless $_[0]->isa('JE::Object::Date');
  				JE::Number->new(
  					$global,$${+shift}{value}
  				);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getTime',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getTime',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				$_[0]->class eq 'Date' or die
  					JE'Object'Error'TypeError->new(
  						$global,
  						"getTime cannot be called".
  						" on an object of type " .
  						shift->class
  					);
  				JE::Number->new(
  					$global,$${+shift}{value}
  				);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getYear',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getYear',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number
  			      "Arg to getYear ($_[0]) is not a date")
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _year_from_time(_gm2local $v) - 1900
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getFullYear',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getFullYear',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number
  			      "Arg to getFullYear ($_[0]) is not a date")
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _year_from_time(_gm2local $v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getUTCFullYear',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getUTCFullYear',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "getUTCFullYear cannot be " .
  			     "called on an object of type " . $_[0]->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _year_from_time( $v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  
  	$proto->prop({
  		name  => 'getMonth',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getMonth',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number
  			      "Arg to getMonth ($_[0]) is not a date")
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _month_from_time(_gm2local $v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getUTCMonth',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getUTCMonth',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "getUTCMonth cannot be called".
  			      " on an object of type " . $_[0]->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _month_from_time($v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getDate',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getDate',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number
  			    "getDate cannot be called on an object of type"
  			    . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _date_from_time(_gm2local $v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getUTCDate',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getUTCDate',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "getUTCDate cannot be called ".
  			    "on an object of type"
  			    . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _date_from_time($v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getDay',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getDay',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number
  			    "getDay cannot be called on an object of type"
  			    . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _week_day(_gm2local $v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getUTCDay',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getUTCDay',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "getUTCDay cannot be called ".
  			    "on an object of type"
  			    . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _week_day($v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getHours',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getHours',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number
  			   "getHours cannot be called on an object of type"
  			    . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _hours_from_time(_gm2local $v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getUTCHours',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getUTCHours',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "getUTCHours cannot be called".
  			    " on an object of type"
  			    . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _hours_from_time($v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getMinutes',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getMinutes',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "getMinutes cannot be called" .
  			      " on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _min_from_time(_gm2local $v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getUTCMinutes',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getUTCMinutes',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "getUTCMinutes cannot be " .
  			      "called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _min_from_time($v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getSeconds',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getSeconds',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "getSeconds cannot be called" .
  			      " on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _sec_from_time(_gm2local $v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name => 'getUTCSeconds',
  		value => $proto->prop('getSeconds'),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getMilliseconds',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getMilliseconds',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "getMilliseconds cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    _ms_from_time(_gm2local $v)
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name => 'getUTCMilliseconds',
  		value => $proto->prop('getMilliseconds'),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'getTimezoneOffset',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'getTimezoneOffset',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "getTimezoneOffset cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  $v == $v or return JE::Number->new($global,$v);
  			  JE::Number->new( $global,
  			    ($v - _gm2local $v) / 60_000
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setTime',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setTime',
  			argnames => ['time'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setTime cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip(
  			      defined $_[1] ? $_[1]->to_number->value :
  			        sin 9**9**9
  			    )
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setMilliseconds',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setMilliseconds',
  			argnames => ['ms'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setMilliseconds cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${$_[0]}{value};
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _make_date
  			      _day $v,
  			      _make_time
  			        _hours_from_time $v,
  			        _min_from_time $v,
  			        _sec_from_time $v,
  			        defined $_[1] ? $_[1]->to_number->value :
  			          sin 9**9**9
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name => 'setUTCMilliseconds',
  		value => $proto->prop('setMilliseconds'),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setSeconds',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setSeconds',
  			argnames => ['sec','ms'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setSeconds cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $s = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($s != $s) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new($global,sin 9**9**9);
  			  }
  			  my $v = $${$_[0]}{value};
  			  my $ms =
  			   defined $_[2]
  			   ? $_[2]->to_number->value
  			   : _ms_from_time $v;
  			  if($ms!=$ms) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new(sin 9**9**9);
  			  }
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _make_date
  			      _day $v,
  			      _make_time
  			        _hours_from_time $v,
  			        _min_from_time $v,
  			         $s,
  			         $ms,
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name => 'setUTCSeconds',
  		value => $proto->prop('setSeconds'),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setMinutes',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setMinutes',
  			argnames => ['min','sec','ms'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setMinutes cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $m = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($m != $m) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new($global,sin 9**9**9);
  			  }
  			  my $v = _gm2local $${$_[0]}{value};
  			  my $s =
  			   defined $_[2]
  			   ? $_[2]->to_number->value
  			   : _sec_from_time $v;
  			  my $ms =
  			   defined $_[3]
  			   ? $_[3]->to_number->value
  			   : _ms_from_time $v;
  			  if($s!=$s || $ms!=$ms) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new(sin 9**9**9);
  			  }
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _local2gm _make_date
  			      _day $v,
  			      _make_time _hours_from_time $v, $m, $s, $ms
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setUTCMinutes',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setUTCMinutes',
  			argnames => ['min','sec','ms'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setUTCMinutes cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $m = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($m != $m) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new($global,sin 9**9**9);
  			  }
  			  my $v = $${$_[0]}{value};
  			  my $s =
  			   defined $_[2]
  			   ? $_[2]->to_number->value
  			   : _sec_from_time $v;
  			  my $ms =
  			   defined $_[3]
  			   ? $_[3]->to_number->value
  			   : _ms_from_time $v;
  			  if($s!=$s || $ms!=$ms) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new(sin 9**9**9);
  			  }
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _make_date
  			      _day $v,
  			      _make_time _hours_from_time $v, $m, $s, $ms
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setHours',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setHours',
  			argnames => ['hour','min','sec','ms'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setHours cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $h = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($h != $h) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new($global,sin 9**9**9);
  			  }
  			  my $v = _gm2local $${$_[0]}{value};
  			  my $m =
  			   defined $_[2]
  			   ? $_[2]->to_number->value
  			   : _min_from_time $v;
  			  my $s =
  			   defined $_[3]
  			   ? $_[3]->to_number->value
  			   : _sec_from_time $v;
  			  my $ms =
  			   defined $_[4]
  			   ? $_[4]->to_number->value
  			   : _ms_from_time $v;
  			  if($m!=$m || $s!=$s || $ms!=$ms) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new(sin 9**9**9);
  			  }
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _local2gm _make_date
  			      _day $v,
  			      _make_time $h, $m, $s, $ms
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setUTCHours',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setUTCHours',
  			argnames => ['hour','min','sec','ms'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setUTCHours cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $h = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($h != $h) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new($global,sin 9**9**9);
  			  }
  			  my $v = $${$_[0]}{value};
  			  my $m =
  			   defined $_[2]
  			   ? $_[2]->to_number->value
  			   : _min_from_time $v;
  			  my $s =
  			   defined $_[3]
  			   ? $_[3]->to_number->value
  			   : _sec_from_time $v;
  			  my $ms =
  			   defined $_[4]
  			   ? $_[4]->to_number->value
  			   : _ms_from_time $v;
  			  if($m!=$m || $s!=$s || $ms!=$ms) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new(sin 9**9**9);
  			  }
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _make_date
  			      _day $v,
  			      _make_time $h, $m, $s, $ms
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setDate',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setDate',
  			argnames => ['date'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setDate cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $d = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($d != $d) {
  			   $_[0]{value} = $d;
  			   return JE::Number->new($global,$d)
  			  }
  			  my $v = _gm2local $${$_[0]}{value};
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _local2gm _make_date
  			      _make_day(
  			        _year_from_time $v,
  			        _month_from_time $v,
  			        $d
  			      ),
  			      _time_within_day $v
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setUTCDate',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setUTCDate',
  			argnames => ['date'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setUTCDate cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $d = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($d != $d) {
  			   $_[0]{value} = $d;
  			   return JE::Number->new($global,$d)
  			  }
  			  my $v = $${$_[0]}{value};
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _make_date
  			      _make_day(
  			        _year_from_time $v,
  			        _month_from_time $v,
  			        $d
  			      ),
  			      _time_within_day $v
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setMonth',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setMonth',
  			argnames => ['month','date'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setMonth cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $m = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($m != $m) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new($global,sin 9**9**9)
  			  }
  			  my $v = _gm2local $${$_[0]}{value};
  			  my $d =
  			   defined $_[2]
  			   ? $_[2]->to_number->value
  			   : _date_from_time $v;
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _local2gm _make_date
  			      _make_day(
  			        _year_from_time $v,
  			        $m,
  			        $d
  			      ),
  			      _time_within_day $v
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setUTCMonth',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setUTCMonth',
  			argnames => ['month','date'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setUTCMonth cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $m = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($m != $m) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new($global,sin 9**9**9)
  			  }
  			  my $v = $${$_[0]}{value};
  			  my $d =
  			   defined $_[2]
  			   ? $_[2]->to_number->value
  			   : _date_from_time $v;
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _make_date
  			      _make_day(
  			        _year_from_time $v,
  			        $m,
  			        $d
  			      ),
  			      _time_within_day $v
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setYear',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setMilliseconds',
  			argnames => ['ms'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setYear cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $y = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($y != $y) {
  			   $_[0]{value} = $y; return JE::Number->new($y)
  			  }
  			  my $inty = int $y;
  			  $inty >= 0 && $inty <= 99 and $y = $inty+1900;
  			  my $v = _gm2local $${$_[0]}{value};
  			  $v == $v or $v = 0;
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _local2gm _make_date
  			      _make_day(
  			        $y,
  			        _month_from_time $v,
  			        _date_from_time $v
  			      ),
  			      _time_within_day $v
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setFullYear',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setFullYear',
  			argnames => ['year','month','date'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setFullYear cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $y = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($y != $y) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new($global,sin 9**9**9)
  			  }
  			  my $v = _gm2local $${$_[0]}{value};
  			  my $m =
  			   defined $_[2]
  			   ? $_[2]->to_number->value
  			   : _month_from_time $v;
  			  my $d =
  			   defined $_[3]
  			   ? $_[3]->to_number->value
  			   : _date_from_time $v;
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _local2gm _make_date
  			      _make_day(
  			        $y,
  			        $m,
  			        $d
  			      ),
  			      _time_within_day $v
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'setUTCFullYear',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'setUTCFullYear',
  			argnames => ['year','month','date'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "setUTCFullYear cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $y = defined $_[1] ? $_[1]->to_number->value
  			    : sin 9**9**9;
  			  if($y != $y) {
  			   $_[0]{value} = sin 9**9**9;
  			   return JE::Number->new($global,sin 9**9**9)
  			  }
  			  my $v = $${$_[0]}{value};
  			  my $m =
  			   defined $_[2]
  			   ? $_[2]->to_number->value
  			   : _month_from_time $v;
  			  my $d =
  			   defined $_[3]
  			   ? $_[3]->to_number->value
  			   : _date_from_time $v;
  			  JE::Number->new( $global, $${$_[0]}{value} = 
  			    _time_clip _make_date
  			      _make_day(
  			        $y,
  			        $m,
  			        $d
  			      ),
  			      _time_within_day $v
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	my $tgs = $proto->prop({
  		name  => 'toGMTString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'toGMTString',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  			  die JE::Object::Error::TypeError->new($global,
  			    add_line_number "toGMTString cannot be" .
  			      " called on an object of type"
  			      . shift->class)
  			    unless $_[0]->isa('JE::Object::Date');
  			  my $v = $${+shift}{value};
  			  JE::String->_new( $global,
  			    sprintf "%s, %02d %s %04d %02d:%02d:%02d GMT",
  			      $days[_week_day $v], _date_from_time $v,
  			      $mon[_month_from_time $v],
  			      _year_from_time $v, _hours_from_time $v,
  			      _min_from_time $v, _sec_from_time $v
  			  );
  			},
  		}),
  		dontenum => 1,
  	});
  	$proto->prop(
  		{name => toUTCString => value => $tgs => dontenum => 1}
  	);
  
  	weaken $global;
  	$f;
  }
  
  
  
  return "a true value";
JE_OBJECT_DATE

$fatpacked{"JE/Object/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ERROR';
  package JE::Object::Error;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  our @ISA = 'JE::Object';
  
  require JE::Object;
  require JE::String;
  
  
  # ~~~ Need to add support for line number, script name, etc., or perhaps
  #     just a reference to the corresponding JE::Code object.
  
  =head1 NAME
  
  JE::Object::Error - JavaScript Error object class
  
  =head1 SYNOPSIS
  
    use JE::Object::Error;
  
    # Somewhere in code called by an eval{}
    die new JE::Object::Error $global, "(Error message here)";
  
    # Later:
    $@->prop('message');  # error message
    $@->prop('name');     # 'Error'
    "$@";                 # 'Error: ' plus the error message
  
  =head1 DESCRIPTION
  
  This class implements JavaScript Error objects for JE. This is the base
  class for all JavaScript's native error objects. (See L<SEE ALSO>, below.)
  
  =head1 METHODS
  
  See L<JE::Types> for descriptions of most of the methods. Only what
  is specific to JE::Object::Error is explained here.
  
  The C<value> method returns the string S<'Error: '> followed by the error
  message. 'Error' will be replaced with the class name (the result of 
  calling
  C<< ->class >>) for subclasses. 
  
  =cut
  
  sub new {
  	my($class, $global, $val) = @_;
  	my($js_class) = $class->name;
  	my $self = $class->SUPER::new($global, { 
  		prototype => $global->prototype_for($js_class) ||
  			$global->prop($js_class)->prop('prototype')
  	});
  
  	$self->prop({
  		dontenum => 1,
  		name => 'message',
  		value => JE::String->_new($global, $val),
  	}) if defined $val and ref $val ne 'JE::Undefined';
  	$self;
  }
  
  sub value { $_[0]->method('toString')->value }
  
  sub class { 'Error' }
  *name = *class;
  
  sub _new_constructor {
  	my $global = shift;
  	my $con = sub {
  			__PACKAGE__->new(@_);
  	};
  	my $args = ['scope','args'];
  	my $f = JE'Object'Function->new({
  		name             => 'Error',
  		scope            => $global,
  		argnames         => ['message'],
  		function         => $con,
  		function_args    => $args,
  		constructor      => $con,
  		constructor_args => $args,
  	});
  
  	my $proto = bless $f->prop({
  	 name => 'prototype', dontenum => 1, readonly => 1
  	});
  	
  	$global->prototype_for('Error',$proto);
  	$proto->prop({
  				name  => 'toString',
  				value => JE::Object::Function->new({
  					scope  => $global,
  					name   => 'toString',
  					length => 0,
  					function_args => ['this'],
  					function => sub {
  						my $self = shift;
  						JE::String->_new(
  							$$$self{global},
  							$self->prop(
  							 'name'
  							) .
  							': ' .
  							$self->prop(
  								'message'							)
  						);
  					}
  				}),
  				dontenum => 1,
  	});
  	$proto->prop({
  				name  => 'name',
  				value => JE::String->_new($global, 'Error'),
  				dontenum => 1,
  	});
  	$proto->prop({
  				name  => 'message',
  				value => JE::String->_new($global,
  					'Unknown error'),
  				dontenum => 1,
  	});
  
  	weaken $global;
  	$f
  }
  
  sub _new_subclass_constructor {
  	my($package,$global) = @_;
  
  	my $f = JE::Object::Function->new({
  		name             => my $name = $package->name,
  		scope            => $global,
  		argnames         => ['message'],
  		function         =>(sub { $package->new(@_) },
  		function_args    => ['scope','args'],
  		constructor      => #  "
  		constructor_args => #  "
  		                   )[ 0..3,0,4,2 ],
  	});
  
  	my $proto = $f->prop({
  		name    => 'prototype',
  		dontenum => 1,
  		readonly => 1,
  	});
  	$global->prototype_for($name=>$proto);
  	bless $proto, $package;
  	$proto->prototype(
  			   $global->prototype_for('Error')
  			|| $global->prop('Error')->prop('prototype')
  	);
  	$proto->prop({
  				name  => 'name',
  				value => JE::String->_new($global, $name),
  				dontenum => 1,
  	});
  	(my $msg = $name) =~ s/(?!^)([A-Z])(?![A-Z])/ \l$1/g;
  	$proto->prop({
  				name  => 'message',
  				value => JE::String->_new($global, $msg),
  				dontenum => 1,
  	});
  
  	weaken $global;
  	$f;
  }
  
  
  return "a true value";
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<JE>
  
  =item L<JE::Object>
  
  =item L<JE::Object::Error::RangeError>
  
  =item L<JE::Object::Error::SyntaxError>
  
  =item L<JE::Object::Error::TypeError>
  
  =item L<JE::Object::Error::URIError>
  
  =item L<JE::Object::Error::ReferenceError>
  
  =back
  
  =cut
  
  
  
  
JE_OBJECT_ERROR

$fatpacked{"JE/Object/Error/RangeError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ERROR_RANGEERROR';
  package JE::Object::Error::RangeError;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  our @ISA = 'JE::Object::Error';
  
  require JE::Object::Error;
  require JE::String;
  
  
  =head1 NAME
  
  JE::Object::Error::RangeError - JavaScript RangeError object class
  
  =head1 SYNOPSIS
  
    use JE::Object::Error::RangeError;
  
    # Somewhere in code called by an eval{}
    die new JE::Object::Error::RangeError $global, "(Error message here)";
  
    # Later:
    $@->prop('message');  # error message
    $@->prop('name');     # 'RangeError'
    "$@";                 # 'RangeError: ' plus the error message
  
  =head1 DESCRIPTION
  
  This class implements JavaScript RangeError objects for JE.
  
  =head1 METHODS
  
  See L<JE::Types> and L<JE::Object::Error>.
  
  =cut
  
  sub name {  q sRangeErrors }
  
  
  return "a true value";
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<JE>
  
  =item L<JE::Types>
  
  =item L<JE::Object>
  
  =item L<JE::Object::Error>
  
  =back
  
  =cut
  
  
  
  
JE_OBJECT_ERROR_RANGEERROR

$fatpacked{"JE/Object/Error/ReferenceError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ERROR_REFERENCEERROR';
  package JE::Object::Error::ReferenceError;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  our @ISA = 'JE::Object::Error';
  
  require JE::Object::Error;
  require JE::String;
  
  
  =head1 NAME
  
  JE::Object::Error::ReferenceError - JavaScript ReferenceError object class
  
  =head1 SYNOPSIS
  
    use JE::Object::Error::ReferenceError;
  
    # Somewhere in code called by an eval{}
    die new JE::Object::Error::ReferenceError $global,
            "(Error message here)";
  
    # Later:
    $@->prop('message');  # error message
    $@->prop('name');     # 'ReferenceError'
    "$@";                 # 'ReferenceError: ' plus the error message
  
  =head1 DESCRIPTION
  
  This class implements JavaScript ReferenceError objects for JE.
  
  =head1 METHODS
  
  See L<JE::Types> and L<JE::Object::Error>.
  
  =cut
  
  sub name { 'ReferenceError' }
  
  
  return "a true value";
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<JE>
  
  =item L<JE::Types>
  
  =item L<JE::Object>
  
  =item L<JE::Object::Error>
  
  =back
  
  =cut
  
  
  
  
JE_OBJECT_ERROR_REFERENCEERROR

$fatpacked{"JE/Object/Error/SyntaxError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ERROR_SYNTAXERROR';
  package JE::Object::Error::SyntaxError;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  our @ISA = 'JE::Object::Error';
  
  require JE::Object::Error;
  require JE::String;
  
  
  =head1 NAME
  
  JE::Object::Error::SyntaxError - JavaScript SyntaxError object class
  
  =head1 SYNOPSIS
  
    use JE::Object::Error::SyntaxError;
  
    # Somewhere in code called by an eval{}
    die new JE::Object::Error::SyntaxError $global, "(Error message here)";
  
    # Later:
    $@->prop('message');  # error message
    $@->prop('name');     # 'SyntaxError'
    "$@";                 # 'SyntaxError: ' plus the error message
  
  =head1 DESCRIPTION
  
  This class implements JavaScript SyntaxError objects for JE.
  
  =head1 METHODS
  
  See L<JE::Types> and L<JE::Object::Error>.
  
  =cut
  
  sub name { SyntaxError => }
  
  
  return "a true value";
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<JE>
  
  =item L<JE::Types>
  
  =item L<JE::Object>
  
  =item L<JE::Object::Error>
  
  =back
  
  =cut
  
  
  
  
JE_OBJECT_ERROR_SYNTAXERROR

$fatpacked{"JE/Object/Error/TypeError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ERROR_TYPEERROR';
  package JE::Object::Error::TypeError;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  our @ISA = 'JE::Object::Error';
  
  require JE::Object::Error;
  require JE::String;
  
  
  =head1 NAME
  
  JE::Object::Error::TypeError - JavaScript TypeError object class
  
  =head1 SYNOPSIS
  
    use JE::Object::Error::TypeError;
  
    # Somewhere in code called by an eval{}
    die new JE::Object::Error::TypeError $global, "(Error message here)";
  
    # Later:
    $@->prop('message');  # error message
    $@->prop('name');     # 'TypeError'
    "$@";                 # 'TypeError: ' plus the error message
  
  =head1 DESCRIPTION
  
  This class implements JavaScript TypeError objects for JE.
  
  =head1 METHODS
  
  See L<JE::Types> and L<JE::Object::Error>.
  
  =cut
  
  sub name { 'TypeError' }
  
  
  return "a true value";
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<JE>
  
  =item L<JE::Types>
  
  =item L<JE::Object>
  
  =item L<JE::Object::Error>
  
  =back
  
  =cut
  
  
  
  
JE_OBJECT_ERROR_TYPEERROR

$fatpacked{"JE/Object/Error/URIError.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_ERROR_URIERROR';
  package JE::Object::Error::URIError;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  our @ISA = 'JE::Object::Error';
  
  require JE::Object::Error;
  require JE::String;
  
  
  =head1 NAME
  
  JE::Object::Error::URIError - JavaScript URIError object class
  
  =head1 SYNOPSIS
  
    use JE::Object::Error::URIError;
  
    # Somewhere in code called by an eval{}
    die new JE::Object::Error::URIError $global, "(Error message here)";
  
    # Later:
    $@->prop('message');  # error message
    $@->prop('name');     # 'URIError'
    "$@";                 # 'URIError: ' plus the error message
  
  =head1 DESCRIPTION
  
  This class implements JavaScript URIError objects for JE.
  
  =head1 METHODS
  
  See L<JE::Types> and L<JE::Object::Error>.
  
  =cut
  
  sub name { scalar reverse rorrEIRU=> }
  
  
  return "a true value";
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<JE>
  
  =item L<JE::Types>
  
  =item L<JE::Object>
  
  =item L<JE::Object::Error>
  
  =back
  
  =cut
  
  
  
  
JE_OBJECT_ERROR_URIERROR

$fatpacked{"JE/Object/Function.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_FUNCTION';
  package JE::Object::Function;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings; no warnings 'utf8';
  use Carp                 ;
  use Scalar::Util 'blessed';
  
  use overload
  	fallback => 1,
  	'&{}' => sub {
  		my $self = shift;
  		sub {
  			my $ret = $self->call($self->global->upgrade(@_));
  			typeof $ret eq 'undefined' ? undef : $ret
  		}
  	 };
  
  our @ISA = 'JE::Object';
  
  require JE::Code         ;
  require JE::Number          ;
  require JE::Object              ;
  require JE::Object::Error::TypeError;
  require JE::Parser                    ;
  require JE::Scope                      ;
  
  import JE::Code 'add_line_number';
  sub add_line_number;
  
  =head1 NAME
  
  JE::Object::Function - JavaScript function class
  
  =head1 SYNOPSIS
  
    use JE::Object::Function;
  
    # simple constructors:
  
    $f = new JE::Object::Function $scope, @argnames, $function;
    $f = new JE::Object::Function $scope, $function;
  
    # constructor that lets you do anything:
  
    $f = new JE::Object::Function {
            name             => $name,
            scope            => $scope,
            length           => $number_of_args,
            argnames         => [ @argnames ],
            function         => $function,
            function_args    => [ $arglist ],
            constructor      => sub { ... },
            constructor_args => [ $arglist ],
            downgrade        => 0,
    };
  
  
    $f->(@args);
    $f->call_with($obj, @args);
  
  =head1 DESCRIPTION
  
  All JavaScript functions are instances of this class. If you want to call
  a JavaScript function from Perl, just treat is as a coderef (C<< $f->() >>)
  or use the C<call_with> method (C<< $f->call_with($obj, @args) >>) if you
  want to specify the invocant (the 'this' value).
  
  =head1 OBJECT CREATION
  
  =over 4
  
  =item new 
  
  Creates and returns a new function (see the next few items for its usage).
  The new function will have a C<prototype> property that is an object with
  a C<constructor> property that refers to the function itself.
  
  The return value of the function will be upgraded if necessary (see 
  L<UPGRADING VALUES|JE::Types/UPGRADING VALUES> in the JE::Types man page),
  which is why C<new> I<has> to be given a reference to the global object
  or the scope chain. (But see also L<JE/new_function> and L<JE/new_method>.)
  
  A function written in Perl can return an lvalue if it wants to. Use
  S<< C<new JE::LValue($object, 'property name')> >> to create it. To create 
  an lvalue 
  that
  refers to a variable visible within the function's scope, use
  S<< C<<< $scope->var('varname') >>> >> (this assumes that you have
  shifted the scope object off C<@_> and called it C<$scope>; you also need
  to call C<new> with hashref syntax and specify the C<function_args> [see
  below]).
  
  =item new JE::Object::Function $scope_or_global, @argnames, $function;
  
  =item new JE::Object::Function $scope_or_global, $function;
  
  C<$scope_or_global> is one of the following:
  
    - a global (JE) object
    - a scope chain (JE::Scope) object
  
  C<@argnames> is a list of argument names, that JavaScript functions use to access the arguments.
  
  $function is one of
  
    - a string containing the body of the function (JavaScript code)
    - a JE::Code object
    - a coderef
  
  =item new JE::Object::Function { ... };
  
  This is the big fancy way of creating a function that lets you do anything.
  The elements of the hash ref passed to C<new> are as follows (they are
  all optional, except for C<scope>):
  
  =over 4
  
  =item name
  
  The name of the function. This is used only by C<toString>.
  
  =item scope
  
  A global object or scope chain object.
  
  =item length
  
  The number of arguments expected. If this is omitted, the number of
  elements of C<argnames> will be used. If that is omitted, 0 will be used.
  Note that this does not cause the argument list to be checked. It only
  provides the C<length> property (and possibly, later, an C<arity> property)
  for inquisitive scripts to look at.
  
  =item argnames
  
  An array ref containing the variable names that a JS function uses to 
  access the 
  arguments.
  
  =item function
  
  A coderef, string of JS code or JE::Code object (the body of the function).
  
  This will be run when the function is called from JavaScript without the
  C<new> keyword, or from Perl via the C<call> method.
  
  =item function_args
  
  This only applies when C<function> is a code ref. C<function_args> is an 
  array ref, the elements being strings that indicated what arguments should
  be passed to the Perl subroutine. The strings, and what they mean, are
  as follows:
  
    self    the function object itself
    scope   the scope chain
    global  the global object
    this    the invocant
    args    the arguments passed to the function (as individual
            arguments)
    [args]  the arguments passed to the function (as an array ref)
  
  If C<function_args> is omitted, 'args' will be assumed.
  
  =item constructor
  
  A code ref that creates and initialises a new object. This is called when
  the C<new> keyword is used in JavaScript, or when the C<construct> method
  is used in Perl.
  
  If this is omitted, when C<new> or C<construct> is used, a new empty object 
  will be created and passed to the
  sub specified under C<function> as its 'this' value. The return value of 
  the sub will be
  returned I<if> it is an object; the (possibly modified) object originally
  passed to the function will be returned otherwise.
  
  =item constructor_args
  
  Like C<function_args>, but the C<'this'> string does not apply. If 
  C<constructor_args> is
  omitted, the arg list will be set to
  C<[ qw( scope args ) ]> (B<this might change>).
  
  This is completely ignored if C<constructor> is
  omitted.
  
  =item downgrade (not yet implemented)
  
  This applies only when C<function> or C<constructor> is a code ref. This
  is a boolean indicating whether the arguments to the function should have 
  their C<value> methods called automatically.; i.e., as though
  S<<< C<< map $_->value, @args >> >>> were used instead of C<@args>.
  
  =item no_proto
  
  If this is set to true, the returned function will have no C<prototype>
  property.
  
  =back
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item new JE::Object::Function
  
  See L<OBJECT CREATION>.
  
  =cut
  
  sub new {
  	# E 15.3.2
  	my($class,$scope) = (shift,shift);
  	my %opts;
  
  	if(ref $scope eq 'HASH') {
  		%opts = %$scope;
  		$scope = $opts{scope};
  	}
  	else {
  		%opts = @_ == 1  # bypass param-parsing for the sake of
  		                 # efficiency
  		? 	( function => shift )
  		: 	( argnames => do {
  				my $src = '(' . join(',', @_[0..$#_-1]) .
  					')';
  				$src =~ s/\p{Cf}//g;
  				# ~~~ What should I do here for the file
  				#     name and the starting line number?
  				my $params = JE::Parser::_parse(
  					params => $src, $scope
  				);
  				$@ and die $@;
  				$params;
  			  },
  			  function => pop )
  		;
  	}
  
  	defined blessed $scope
  	    or croak "The 'scope' passed to JE::Object::Function->new (" .
  		(defined $scope ? $scope : 'undef') . ") is not an object";
  
  # ~~~ I should be able to remove the need for this to be a JE::Scope. Per-
  #     haps it could be an array ref instead. That way, the caller wont
  #     have to bless something that we copy & bless further down anyway.
  #     Right now, other parts of the code base rely on it, so it would
  #     require a marathon debugging session.
  	ref $scope ne 'JE::Scope' and $scope = bless [$scope], 'JE::Scope';
  	my $global = $$scope[0];
  
  	my $self = $class->SUPER::new($global, {
  		prototype => $global->prototype_for('Function')
  	});
  	my $guts = $$self;
  
  	$$guts{scope} = $scope;
  
  
  	$opts{no_proto} or $self->prop({
  		name     => 'prototype',
  		dontdel  => 1,
  		value    => JE::Object->new($global),
  	})->prop({
  		name     => 'constructor',
  		dontenum => 1,
  		value    => $self,
  	});
  
  	{ no warnings 'uninitialized';
  
  	$$guts{function} =
  	  ref($opts{function}) =~ /^(?:JE::Code|CODE)\z/ ? $opts{function}
  	: length $opts{function} &&
  		(
  		  parse $global $opts{function} or die
  		)
  	;
  
  	$self->prop({
  		name     => 'length',
  		value    => JE::Number->new($global, $opts{length} ||
  		            (ref $opts{argnames} eq 'ARRAY'
  		                ? scalar @{$opts{argnames}} : 0)),
  		dontenum => 1,
  		dontdel  => 1, 
  		readonly => 1,
  	});
  
  	} #warnings back on
  
  	$$guts{func_argnames} = [
  		ref $opts{argnames} eq 'ARRAY' ? @{$opts{argnames}} : ()
  	];
  	$$guts{func_args} = [
  		ref $opts{function_args} eq 'ARRAY'
  		? @{$opts{function_args}} :
  		'args'
  	];
  
  	if(exists $opts{constructor}) {
  		$$guts{constructor} = $opts{constructor};
  		$$guts{constructor_args} = [
  			ref $opts{constructor_args} eq 'ARRAY'
  			? @{$opts{constructor_args}} : ('scope', 'args')
  				# ~~~ what is the most useful default here?
  		];
  	}
  	if(exists $opts{name}) {
  		$$guts{func_name} = $opts{name};
  	}
  
  	$self->prop({dontdel=>1, name=>'arguments',value=>$global->null});
  	 	
  	$self;
  }
  
  
  =item call_with ( $obj, @args )
  
  Calls a function with the given arguments. The C<$obj> becomes the
  function's invocant. This method is intended for general use from the Perl
  side. The arguments (including C<$obj>) are automatically upgraded.
  
  =cut
  
  sub call_with {
   my $func = shift;
   my $ret = $func->apply( $func->global->upgrade(@_) );
   typeof $ret eq 'undefined' ? undef : $ret
  }
  
  =item call ( @args )
  
  This method, intended mainly for internal use, calls a function with the 
  given arguments, without upgrading them. The invocant (the 'this' value)
  will be the global object. This is just a wrapper around C<apply>.
  
  This method is very badly named and will probably be renamed in a future
  version. Does anyone have any suggestions?
  
  =cut
  
  sub call {
  	my $self = shift;
  	$self->apply($$$self{global}, @_);
  }
  
  
  
  
  =item construct
  
  This method, likewise intended mainly for internal use, calls the 
  constructor, if this function has one (functions written in JS
  don't have this). Otherwise, an object will be created and passed to the 
  function as its invocant. The return value of the function will be
  discarded, and the object (possibly modified) will be returned instead.
  
  =cut
  
  sub construct { # ~~~ we need to upgrade the args passed to construct, but 
                  #     still retain the unupgraded values to pass to the 
                  #     function *if* the function wants them downgraded
  	my $self = shift;
  	my $guts = $$self;
  	my $global = $$guts{global};
  	if(exists $$guts{constructor}
  	   and ref $$guts{constructor} eq 'CODE') {
  		my $code = $$guts{constructor};
  		my @args;
  		for(  @{ $$guts{constructor_args} }  ) {
  			push @args,
  			  $_ eq 'self'
  			?	$self
  			: $_ eq 'scope'
  			?	_init_scope($self, $$guts{scope},
  					[], @_)
  			: $_ eq 'global'
  			?	$global
  			: $_ eq 'args'
  			?	@_ # ~~~ downgrade if wanted
  			: $_ eq '[args]'
  			?	[@_] # ~~~ downgrade if wanted
  			: 	undef;
  		}
  		# ~~~ What can we do to avoid the upgrade overhead for
  		#     JS internal functions?
  		return $global->upgrade($code->(@args));
  	}
  	else {
  		# If the prototype property does not exist, then, since it
  		# is undeletable, this can only be a function created with
  		# no_proto => 1, i.e., an internal functions thats meant
  		# to die here.
  		defined(my $proto = $self->prop('prototype'))
  			or die JE::Object::Error::TypeError->new(
  				$global, add_line_number
  				+($$guts{func_name} || 'The function').
  				    " cannot be called as a constructor");
  
  		my $obj = JE::Object->new($global,
  			!$proto->primitive ?
  				{ prototype => $proto }
  			: ()
  		);
  		my $return = $global->upgrade(
  			$self->apply($obj, @_)
  		);
  		return $return->can('primitive') && !$return->primitive
  			? $return
  			: $obj;
  	}
  }
  
  
  
  
  =item apply ( $obj, @args )
  
  This method, intended mainly for internal use just like the two above,
  calls the function with $obj as the invocant and @args as the args. No
  upgrading occurs.
  
  This method is very badly named and will probably be renamed in a future
  version. Does anyone have any suggestions?
  
  =cut
  
  sub apply { # ~~~ we need to upgrade the args passed to apply, but still
              #     retain the unupgraded values to pass to the function *if*
              #     the function wants them downgraded
  	my ($self, $obj) = (shift, shift);
  	my $guts = $$self;
  	my $global = $$guts{global};
  
  	if(!blessed $obj or ref $obj eq 'JE::Object::Function::Call' 
  	    or ref($obj) =~ /^JE::(?:Null|Undefined)\z/) {
  		$obj = $global;
  	}
  
  	if(ref $$guts{function} eq 'CODE') {
  		my @args;
  		for(  @{ $$guts{func_args} }  ) {
  			push @args,
  			  $_ eq 'self'
  			?	$self
  			: $_ eq 'scope'
  			?	_init_scope($self, $$guts{scope},
  					$$guts{func_argnames}, @_)
  			: $_ eq 'global'
  			?	$global
  			: $_ eq 'this'
  			?	$obj
  			: $_ eq 'args'
  			?	@_ # ~~~ downgrade if wanted
  			: $_ eq '[args]'
  			?	[@_] # ~~~ downgrade if wanted
  			: 	undef;
  		}
  		return $global->upgrade(
  			# This list slice is necessary to work around a bug
  			# in perl5.8.8 (but not in 5.8.6 or 5.10). Try
  			# running this code to see what  I  mean:
  			# 
  			# bless ($foo=[]); sub bar{print "ok\n"}
  			# $foo->bar(sub{warn;return "anything"}->())
  			#
  			(scalar $$guts{function}->(@args))[0]
  		);
  	}
  	elsif ($$guts{function}) {
  		my $at = $@;
  		my $scope = _init_scope(
  				$self, $$guts{scope},
  				$$guts{func_argnames}, @_
  			);
  		my $time_bomb = bless [$self, $self->prop('arguments')],
  			'JE::Object::Function::_arg_wiper';
  		$self->prop('arguments', $$scope[-1]{-arguments});
  		my $ret = $$guts{function}->execute(
  			$obj->to_object, $scope, 2
  		);
  		defined $ret or die;
  		$@ = $at;
  		return $ret;
  	}
  	else {
  if (!defined $global) { use Carp; Carp::cluck() }
  		return $global->undefined;
  	}
  }
  
  sub JE::Object::Function::_arg_wiper::DESTROY {
  	$_[0][0] # function
  	 ->prop(
  	  'arguments', $_[0][1] # old arguments value
  	 )
  }
  
  sub _init_scope { # initialise the new scope for the function call
  	my($self, $scope, $argnames, @args) = @_;
  
  	bless([ @$scope, JE::Object::Function::Call->new({
  		global   => $$$self{global},
  		argnames => $argnames,
  		args     => [@args],
  		function => $self,
  	})], 'JE::Scope');
  }
  
  
  
  
  =item typeof
  
  This returns the string 'function'.
  
  =cut
  
  sub typeof { 'function' }
  
  
  
  
  =item class
  
  This returns the string 'Function'.
  
  =cut
  
  sub class { 'Function' }
  
  
  
  
  =item value
  
  Not yet implemented.
  
  =cut
  
  sub value { die "JE::Object::Function::value is not yet implemented." }
  
  
  #----------- PRIVATE SUBROUTINES ---------------#
  
  # _init_proto takes the Function prototype (Function.prototype) as its sole
  # arg and adds all the default properties thereto.
  
  sub _init_proto {
  	my $proto = shift;
  	my $scope = $$proto->{global};
  
  	# E 15.3.4
  	$proto->prop({
  		dontenum => 1,
  		name => 'constructor',
  		value => $scope->prop('Function'),
  	});
  
  	$proto->prop({
  		name      => 'toString',
  		value     => JE::Object::Function->new({
  			scope    => $scope,
  			name     => 'toString',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				my $self = shift;
  				$self->isa(__PACKAGE__) or die new
  					JE::Object::Error::TypeError
  					$scope, add_line_number "Function."
  					."prototype.toString can only be "
  					."called on functions";
  				my $guts = $$self;
  				my $str = 'function ';
  				JE::String->_new($scope,
  				  'function ' .
  				  ( exists $$guts{func_name} ?
  				    $$guts{func_name} :
  				    'anon'.$self->id) .
  				  '(' .
  				  join(',', @{$$guts{func_argnames}})
  				  . ") {" .
  				  ( ref $$guts{function}
  				    eq 'JE::Code'
  				    ? do {
  				      my $code = 
  				        $$guts{function};
  				      my $offsets =
  				        $$guts{function}
  				          {tree}[0];
  				      $code = substr ${$$code{source}},
  				                     $$offsets[0],
  				                     $$offsets[1] -
  				                       $$offsets[0];
  				      # We have to check for a final line
  				      # break in case it ends with a sin-
  				      # gle-line comment.
  				      $code =~ /[\cm\cj\x{2028}\x{2029}]\z/
  				      ? $code : $code . "\n"
  				    }
  				    : "\n    // [native code]\n"
  				  ) . '}'
  # ~~~ perhaps this should be changed so it doesn't comment out the
  #     the [native code] thingy. That way an attempt to
  #     eval the strung version will fail. (In this case, I need to add a
  #     teest too make sure it dies.)
  				);
  			},
  		}),
  		dontenum  => 1,
  	});
  	$proto->prop({
  		name      => 'apply',
  		value     => JE::Object::Function->new({
  			scope    => $scope,
  			name     => 'apply',
  			argnames => [qw/thisArg argArray/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my($self,$obj,$args) = @_;
  
  				my $at = $@;
  
  				no warnings 'uninitialized';
  				if(defined $args and
  				   ref($args) !~ /^JE::(Null|Undefined|
  					Object::Function::Arguments)\z/x
  				   and eval{$args->class} ne 'Array') {
  					die JE::Object::Error::TypeError
  					->new($scope, add_line_number
  					      "Second argument to "
  					      . "'apply' is of type '" . 
  					      (eval{$args->class} ||
  					       eval{$args->typeof} ||
  					       ref $args) .
  					      "', not 'Arguments' or " .
  					      "'Array'");
  				}
  				$@ = $at;
  				$args = $args->value if defined $args;
  				$self->apply($obj, defined $args ?
  					@$args : ());
  			},
  		}),
  		dontenum  => 1,
  	});
  	$proto->prop({
  		name      => 'call',
  		value     => JE::Object::Function->new({
  			scope    => $scope,
  			name     => 'call',
  			argnames => ['thisArg'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				shift->apply(@_);
  			},
  		}),
  		dontenum  => 1,
  	});
  }
  
  
  #----------- THE REST OF THE DOCUMENTATION ---------------#
  
  =back
  
  =head1 OVERLOADING
  
  You can use a JE::Object::Function as a coderef. The sub returned simply
  invokes the C<call> method, so the following are equivalent:
  
    $function->call( $function->global->upgrade(@args) )
    $function->(@args)
  
  The stringification, numification, boolification, and hash dereference ops
  are also overloaded. See L<JE::Object>, which this class inherits from.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item JE
  
  =item JE::Object
  
  =item JE::Types
  
  =item JE::Scope
  
  =item JE::LValue
  
  =back
  
  =cut
  
  
  package JE::Object::Function::Call;
  
  our $VERSION = '0.066';
  
  sub new {
  	# See sub JE::Object::Function::_init_sub for the usage.
  
  	my($class,$opts) = @_;
  	my @args = @{$$opts{args}};
  	my(%self,$arg_val);
  	for(@{$$opts{argnames}}){
  		$arg_val = shift @args;
  		$self{-dontdel}{$_} = 1;
  		$self{$_} = defined $arg_val ? $arg_val :
  			$$opts{global}->undefined;
  	}
  
  	$self{-dontdel}{arguments} = 1;
  
  	$self{'-global'}  = $$opts{global};
  	# A call object's properties can never be accessed via bracket
  	# syntax, so '-global' cannot conflict with properties, since the
  	# latter have to be valid identifiers. Same 'pplies to dontdel, o'
  	# course.
  	
  	# Note on arguments vs  -arguments:  arguments  represents the
  	# actual arguments  property,  which may or may not refer to the
  	# Arguments object,  depending on  whether  there  is  an  argument
  	# named  arguments.  -arguments  always refers to the Arguments
  	# object, which we need further up when we assign to the arguments
  	# property of the function itself.
  
  	$self{-arguments} = 
  			JE::Object::Function::Arguments->new(
  				$$opts{global},
  				$$opts{function},
  				\%self,
  				$$opts{argnames},
  				@{$$opts{args}},
  			);
  	unless (exists $self{arguments}) {
  		$self{arguments} = $self{-arguments}
  	};
  
  	return bless \%self, $class;
  }
  
  sub prop {
  	my ($self, $name)  =(shift,shift);
  
  	if(ref $name eq 'HASH') {
  		my $opts = $name;
  		$name = $$opts{name};
  		@_ = exists($$opts{value}) ? $$opts{value} : ();
  		$$self{'-dontdel'}{$name} = !!$$opts{dontdel}
  			if exists $$opts{dontdel};
  	}
  
  	if (@_ ) {
  		return $$self{$name} = shift;
  	}
  
  	if (exists $$self{$name}) {
  		return $$self{$name};
  	}
  
  	return
  }
  
  sub delete {
  	my ($self,$varname) = @_;
  	unless($_[2]) { # if $_[2] is true we delete it anyway
  		exists $$self{-dontdel}{$varname}
  			&& $$self{-dontdel}{$varname}
  			&& return !1;
  	}
  	delete $$self{-dontdel}{$varname};
  	delete $$self{$varname};
  	return 1;
  }
  
  sub exists { exists $_[0]{$_[1]} }
  sub prototype{}
  
  
  
  
  package JE::Object::Function::Arguments;
  
  our $VERSION = '0.066';
  
  our @ISA = 'JE::Object';
  
  sub new {
  	my($class,$global,$function,$call,$argnames,@args) = @_;
  	
  	my $self = $class->SUPER::new($global);
  	my $guts = $$self;
  
  	$$guts{args_call} = $call;
  	$self->prop({
  		name => 'callee',
  		value => $function,
  		dontenum => 1,
  	});
  	$self->prop({
  		name => 'length',
  		value => JE::Number->new($global, scalar @args),
  		dontenum => 1,
  	});
  	$$guts{args_length} = @args; # in case the length prop
  	                              # gets changed
  
  =begin pseudocode
  
  Go through the named args one by one in reverse order, starting from $#args
  if $#args < $#params
  
  If an arg with the same name as the current one has been seen
  	Create a regular numbered property for that arg.
  Else
  	Create a magical property.
  
  =end pseudocode
  
  =cut
  
  	my (%seen,$name,$val);
  	for (reverse 0..($#args,$#$argnames)[$#$argnames < $#args]) {
  		($name,$val) = ($$argnames[$_], $args[$_]);
  		if($seen{$name}++) {
  			$self->prop({
  				name => $_,
  				value => $val,
  				dontenum => 1,
  			});
  		}
  		else {
  			$$guts{args_magic}{$_} = $name;
  		}
  	}
  
  	# deal with any extra properties
  	for (@$argnames..$#args) {
  		$self->prop({
  			name => $_,
  			value => $args[$_],
  			dontenum => 1,
  		});
  	}
  
  	$self;
  }
  
  sub prop {
  	# Some properties are magically linked to properties of
  	# the call object.
  
  	my($self,$name) = @_;
  	my $guts = $$self;
  	if (exists $$guts{args_magic} and exists $$guts{args_magic}{$name})
  	{
  		return $$guts{args_call}->prop(
  			$$guts{args_magic}{$name}, @_[2..$#_]
  		);
  	}
  	SUPER::prop $self @_[1..$#_];
  }
  
  sub delete { 
  	# Magical properties are still deleteable.
  	my($self,$name) = @_;
  	my $guts = $$self;
  	if (exists $$guts{args_magic} and exists $$guts{args_magic}{$name})
  	{
  		delete $$guts{args_magic}{$name}
  	}
  	SUPER::delete $self @_[1..$#_];
  }
  
  sub value {
  	my $self = shift;
  	[ map $self->prop($_), 0..$$$self{args_length}-1 ];
  }
  
  1;
JE_OBJECT_FUNCTION

$fatpacked{"JE/Object/Math.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_MATH';
  package JE::Object::Math;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  use constant inf => 9**9**9;
  use constant nan => sin 9**9**9;
  
  use POSIX qw'floor ceil';
  
  our @ISA = 'JE::Object';
  
  require JE::Number;
  require JE::Object;
  require JE::Object::Function;
  
  
  
  =head1 NAME
  
  JE::Object::Math - JavaScript Math object
  
  =head1 SYNOPSIS
  
    use JE;
    use JE::Object::Math;
  
    $j = new JE;
  
    $math_obj = new JE::Object::Math $j;
  
  =head1 DESCRIPTION
  
  This class implements the JavaScript Math object.
  
  =head1 METHODS
  
  See L<JE::Types> for descriptions of most of the methods. Only what
  is specific to JE::Object::Math is explained here.
  
  =over
  
  =item JE::Object::Math->new($global_obj)
  
  Creates a new Math object.
  
  =cut
  
  sub new {
  	my($class, $global) = @_;
  	my $self = $class->SUPER::new($global);
  
  	$self->prop({
  		name  => 'E',
  		value  => JE::Number->new($global, exp 1),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});	
  	$self->prop({
  		name  => 'LN10',
  		value  => JE::Number->new($global, log 10),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  	$self->prop({
  		name  => 'LN2',
  		value  => JE::Number->new($global, log 2),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  	$self->prop({
  		name  => 'LOG2E',
  		value  => JE::Number->new($global, 1/log 2),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  	$self->prop({
  		name  => 'LOG10E',
  		value  => JE::Number->new($global, 1/log 10),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  	$self->prop({
  		name  => 'PI',
  		value  => JE::Number->new($global, 4 * atan2 1,1),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  	$self->prop({
  		name  => 'SQRT1_2',
  		value  => JE::Number->new($global, .5**.5),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  	$self->prop({
  		name  => 'SQRT2',
  		value  => JE::Number->new($global, 2**.5),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  
  	$self->prop({
  		name  => 'abs',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'abs',
  			argnames => ['x'],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {	
  				JE::Number->new($global,
  					defined $_[0]
  					? abs $_[0]->to_number->value
  					: 'nan');
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'acos',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'acos',
  			argnames => ['x'],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				my $num;
  				if(defined $_[0]) {
  					$num = $_[0]->to_number->value;
  					$num = atan2+
  						(1 - $num * $num)**.5,
  						$num;
  				}
  				else {
  					$num = 'nan';
  				}	
  				JE::Number->new($global, $num);
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'asin',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'asin',
  			argnames => ['x'],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				my $num;
  				if(defined $_[0]) {
  					$num = $_[0]->to_number->value;
  					$num = atan2+
  						$num,
  						(1 - $num * $num)**.5;
  				}
  				else {
  					$num = 'nan';
  				}	
  				JE::Number->new($global, $num);
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'atan',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'atan',
  			argnames => ['x'],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				JE::Number->new($global,
  					defined $_[0]
  					? atan2($_[0]->to_number->value, 1)
  					: 'nan');
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'atan2',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'atan2',
  			argnames => [qw/y x/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				JE::Number->new($global,
  					defined $_[0] && defined $_[1]
  					? do {
  					   my $a = $_[0]->to_number->value;
  					   my $b = $_[1]->to_number->value;
  					   # Windoze has trouble
  					   # with two infs.
  					   $a + 1 == $a && $b+1 == $b
  					    ? ($b>0 ? 1 : 3) * atan2(1,1)
  					       * ($a > 0 ? 1 : -1)
  					    : atan2($a, $b)
  					  }
  					: 'nan');
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'ceil',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'ceil',
  			argnames => [qw/x/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				JE::Number->new($global,
  					defined $_[0]
  					? ceil($_[0]->to_number->value)
  					: 'nan');
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'cos',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'cos',
  			argnames => [qw/x/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				JE::Number->new($global,
  					defined $_[0]
  					? cos($_[0]->to_number->value)
  					: 'nan');
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'exp',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'exp',
  			argnames => [qw/x/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				JE::Number->new($global,
  					defined $_[0]
  					? $_[0] + 1 == $_[0] # inf
  					   ? $_[0] < 0 ? 0 : 'inf'
  					   : exp($_[0]->to_number->value)
  					: 'nan');
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'floor',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'floor',
  			argnames => [qw/x/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				JE::Number->new($global,
  					defined $_[0]
  					? floor($_[0]->to_number->value)
  					: 'nan');
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'log',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'log',
  			argnames => [qw/x/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				my $num;
  				if (defined $_[0]) {
  					$num = $_[0]->to_number->value;
  					$num = $num < 0 ? 'nan' :
  					       $num == 0 ? '-Infinity' :
  					       log $num;
  				}
  				else { $num = 'nan' }
  				JE::Number->new($global, $num);
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'max',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'max',
  			length  => 2,
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  @_ or return JE::Number->new($global, '-inf');
  my $result; my $num;
  for (@_) {
  	($num = $_->to_number->value) == $num or
  		 return JE::Number->new($global, 'nan');;
  	$result = $num if !defined $result or $result < $num;
  }
  JE::Number->new($global, $result);
  
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'min',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'min',
  			length  => 2,
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  @_ or return JE::Number->new($global, 'inf');
  my $result; my $num;
  for (@_) {
  	($num = $_->to_number->value) == $num or
  		 return JE::Number->new($global, 'nan');;
  	$result = $num if !defined $result or $result > $num;
  }
  JE::Number->new($global, $result);
  
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$self->prop({
  		name  => 'pow',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'pow',
  			argnames => [qw/x y/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  my $x = defined $_[0] ? $_[0]->to_number->value : nan;
  my $y = defined $_[1] ? $_[1]->to_number->value : nan;
  
  abs $x == 1 && abs $y == inf &&
  	return JE::Object::Number->new($global, 'nan');
  
  $y == 0 &&
  	return JE::Number->new($global, 1);
  
  $x == 0 && $y < 0 && return JE'Number->new($global, inf);
  
  $x == -+inf && $y < 0 &&
  	return JE'Number->new($global,
  	                      int $y != $y || !($y % 2) ? 0 : -0.0);
  
  $x == -+inf && $y > 0 && int $y != $y &&
  	return JE'Number->new($global, inf);
  
  return JE::Number->new($global, $x ** $y);
  
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'random',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'random',
  			no_proto => 1,
  			function_args => [],
  			function => sub {
  				JE::Number->new($global, rand);
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'round',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'round',
  			argnames => ['x'],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				JE::Number->new($global,
  					defined $_[0]
  					? floor($_[0]->to_number->value+.5)
  					: 'nan');
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'sin',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'sin',
  			argnames => [qw/x/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				JE::Number->new($global,
  					defined $_[0]
  					? sin($_[0]->to_number->value)
  					: 'nan');
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'sqrt',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'sqrt',
  			argnames => [qw/x/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				JE::Number->new($global,
  					defined $_[0]
  					? do {
  					   my $num
  					    = $_[0]->to_number->value;
  					   $num == -+inf
  					    ? 'nan'
  					    : $num ** .5
  					  }
  					: 'nan');
  			},
  		}),
  		dontenum => 1,
  	});
  	$self->prop({
  		name  => 'tan',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'tan',
  			argnames => [qw/x/],
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				my $num = shift;
  				if(defined $num) {
  					$num = $num->to_number->value;
  					$num = sin($num) / cos $num;
  				}
  				else { $num = nan }
  				JE::Number->new($global, $num);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$self;
  }
  
  
  
  =item value
  
  Not particularly useful. Returns a hash ref that is completely empty, 
  unless you've added
  your own properties to the object. This may change in a future release.
  
  =item class
  
  Returns the string 'Math'
  
  =cut
  
  sub class { 'Math' }
  
  
  
  
  return "a true value";
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item JE
  
  =item JE::Types
  
  =item JE::Object
  
  =item JE::Number
  
  =back
  
  =cut
JE_OBJECT_MATH

$fatpacked{"JE/Object/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_NUMBER';
  package JE::Object::Number;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  use constant inf => 9**9**9;
  
  our @ISA = 'JE::Object';
  
  use Scalar::Util 'blessed';
  
  require JE::Code;
  require JE::Number;
  require JE::Object;
  require JE::Object::Function;
  require JE::String;
  
  import JE::Code 'add_line_number';
  sub add_line_number;
  
  =head1 NAME
  
  JE::Object::Number - JavaScript Number object class
  
  =head1 SYNOPSIS
  
    use JE;
    use JE::Object::Number;
  
    $j = new JE;
  
    $js_num_obj = new JE::Object::Number $j, 953.7;
  
    $perl_scalar = $js_num_obj->value;
  
    0 + $js_num_obj;  # 953.7
  
  =head1 DESCRIPTION
  
  This class implements JavaScript Number objects for JE. The difference
  between this and JE::Number is that that module implements
  I<primitive> number values, while this module implements the I<objects.>
  
  =head1 METHODS
  
  See L<JE::Types> for descriptions of most of the methods. Only what
  is specific to JE::Object::Number is explained here.
  
  =over
  
  =cut
  
  sub new {
  	my($class, $global, $val) = @_;
  	my $self = $class->SUPER::new($global, {
  		prototype => $global->prototype_for('Number')
  		          || $global->prop('Number')->prop('prototype')
  	});
  
  	$$$self{value} = defined blessed $val && $val->can('to_number')
  		? $val->to_number->[0]
  		: JE::Number::_numify($val);
  	$self;
  }
  
  
  
  
  =item value
  
  Returns a Perl scalar containing the number that the object holds.
  
  =cut
  
  sub value { $${$_[0]}{value} }
  
  
  
  =item class
  
  Returns the string 'Number'.
  
  =cut
  
  sub class { 'Number' }
  
  
  
  our @_digits = (0..9, 'a' .. 'z');
  
  sub _new_constructor {
  	my $global = shift;
  	my $f = JE::Object::Function->new({
  		name            => 'Number',
  		scope            => $global,
  		argnames         => [qw/value/],
  		function         => sub {
  			defined $_[0] ? $_[0]->to_number :
  				JE'Number->new($global, 0);
  		},
  		function_args    => ['args'],
  		constructor      => sub {
  			unshift @_, __PACKAGE__;
  			goto &new;
  		},
  		constructor_args => ['scope','args'],
  	});
  
  # The max according to ECMA-262  1.7976931348623157e+308.
  # The max I can get in Perl with a literal is 1.797693134862314659999e+308,
  # probably as a result of perl bug #41202. Using ECMAs maximum does not
  # make sense in our case, anyway, as we are using perls (i.e., the sys-
  # tems) floating point.
  # So I am using routines borrowed from Data::Float to get what are the
  # actual minimum and maximum values that we can handle.
  	$f->prop({
  		name  => 'MAX_VALUE',
  		autoload  => '
  		  require "JE/Object/Number/maxvalue.pl";
  		  $JE::Object::Number::max_finite
  		',
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  
  	$f->prop({
  		name  => 'MIN_VALUE',
  		autoload  => '
  		  require "JE/Object/Number/maxvalue.pl";
  		  $JE::Object::Number::min_finite
  		',
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  
  	$f->prop({
  		name  => 'NaN',
  		value  => JE::Number->new($global, 'nan'),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  
  	$f->prop({
  		name  => 'NEGATIVE_INFINITY',
  		value  => JE::Number->new($global, '-inf'),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  
  	$f->prop({
  		name  => 'POSITIVE_INFINITY', # positively infinite
  		value  => JE::Number->new($global, 'inf'),
  		dontenum => 1,
  		dontdel   => 1,
  		readonly  => 1,
  	});
  
  	my $proto = bless $f->prop({
  		name    => 'prototype',
  		dontenum => 1,
  		readonly => 1,
  	}), __PACKAGE__;
  	$global->prototype_for(Number=>$proto);
  
  	$$$proto{value} = 0;
  	
  	$proto->prop({
  		name  => 'toString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'toString',
  			argnames => ['radix'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my $self = shift;
  				die JE::Object::Error::TypeError->new(
  					$global, add_line_number
  					"Argument to " .
  					"Number.prototype.toString is not"
  					. " a " .
  					"Number object"
  				) unless $self->class eq 'Number';
  
  				my $radix = shift;
  				!defined $radix || $radix->id eq 'undef'
  					and return
  					$self->to_primitive->to_string;
  
  				($radix = $radix->to_number->value)
  				 == 10 || $radix < 2 || $radix > 36 ||
  				$radix =~ /\./ and return $self->to_string;
  
  				if ($radix == 2) {
  					return JE::String->new($global,
  					    sprintf '%b', $self->value);
  				}
  				elsif($radix == 8) {
  					return JE::String->new($global,
  					    sprintf '%o', $self->value);
  				}
  				elsif($radix == 16) {
  					return JE::String->new($global,
  					    sprintf '%x', $self->value);
  				}
  
  				my $num = $self->value;
  				my $result = '';
  				while($num >= 1) {
  					substr($result,0,0) =
  						$_digits[$num % $radix];
  					$num /= $radix;
  				}
  
  				return JE::String->new($global, $result);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'toLocaleString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'toLocaleString',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				my $self = shift;
  				die JE::Object::Error::TypeError->new(
  					$global, add_line_number
  					"Argument to " .
  					"Number.prototype.toLocaleString ".
  					"is not"
  					. " a " .
  					"Number object"
  				) unless $self->class eq 'Number';
  
  				# ~~~ locale stuff
  
  				return JE::String->_new($global,
  					$self->value);
  			},
  		}),
  		dontenum => 1,
  	});
  	$proto->prop({
  		name  => 'valueOf',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'valueOf',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				my $self = shift;
  				die JE::Object::Error::TypeError->new(
  					$global, add_line_number
  					"Argument to " .
  					"Number.prototype.valueOf is not"
  					. " a " .
  					"Number object"
  				) unless $self->class eq 'Number';
  
  				# We also deal with plain JE::Numbers here
  				return
  				 ref $self eq 'JE::Number'
  				 ? $self
  				 : JE::Number->new($global,$$$self{value});
  			},
  		}),
  		dontenum => 1,
  	});
  	$proto->prop({
  		name  => 'toFixed',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'toFixed',
  			no_proto => 1,
  			argnames => ['fractionDigits'],
  			function_args => ['this','args'],
  			function => sub {
  my $self = shift;
  die JE::Object::Error::TypeError->new(
  	$global, add_line_number
  	"Argument to " .
  	"Number.prototype.toFixed is not"
  	. " a " .
  	"Number object"
  ) unless $self->class eq 'Number';
  
  my $places = shift;
  if(defined $places) {
  	$places = ($places = int $places->to_number) == $places && $places;
  }
  else { $places = 0 }
  
  $places < 0 and throw JE::Object::Error::RangeError->new($global,
  	"Invalid number of decimal places: $places " .
  	"(negative numbers not supported)"
  );
  
  my $num = $self->value;
  $num == $num or return JE::String->_new($global, 'NaN');
  
  abs $num >= 1000000000000000000000
  	and return JE::String->_new($global, $num);
  # ~~~ if/when JE::Number::to_string is rewritten, make this use the same
  #    algorithm
  
  # Deal with numbers ending with 5. perl (in Snow Leopard at least) rounds
  # 30.125 down, whereas ECMAScript says that it should round up. (15.7.4.5:
  # Let  n  be an  integer  for  which  the  exact  mathematical  value  of
  #  n  10^f  x is as close to zero as possible.  If there are two such n,
  # pick the larger n.)
  if((my $sprintfed = sprintf "%." . ($places+1) . 'f', $num) =~ /5\z/) {
   (my $upper = $sprintfed) =~ s/\.?.\z//;
   my $lower = $upper;
   ++substr $upper,-1,1;
   return JE::String->_new(
    $global, $upper-$num <= $num-$lower ? $upper : $lower
   );
  }
  
  return JE::String->_new($global, sprintf "%.${places}f", $num);
  
  			},
  		}),
  		dontenum => 1,
  	});
  	$proto->prop({
  		name  => 'toExponential',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'toExponential',
  			no_proto => 1,
  			argnames => ['fractionDigits'],
  			function_args => ['this','args'],
  			function => sub {
  my $self = shift;
  die JE::Object::Error::TypeError->new(
  	$global, add_line_number
  	"Argument to " .
  	"Number.prototype. toExponential is not"
  	. " a " .
  	"Number object"
  ) unless $self->class eq 'Number';
  
  my $num = $self->value;
  $num == $num or return JE::String->_new($global, 'NaN');
  abs $num == inf && return JE::String->_new($global,
  	($num < 0 && '-') . 'Infinity');
  
  my $places = shift;
  if(defined $places) {
  	$places
  	 = 0+(($places = int $places->to_number) == $places) && $places;
  }
  else { $places = !1 }
  
  $places < 0 and throw JE::Object::Error::RangeError->new($global,
  	"Invalid number of decimal places: $places " .
  	"(negative numbers not supported)"
  );
  
  # Deal with half-way rounding. See the note above in toFixed. It applies to
  # toExponential  as  well  (except  that  this  is  section  15.7.4.6).
  if((my $sprintfed = sprintf "%." . ($places+1) . 'e', $num) =~ /5e/) {
   (my $upper = $sprintfed) =~ s/\.?.(e.*)\z//;
   my $lower = $upper;
   ++substr $upper,-1,1;
   (my $ret = ($upper-$num <= $num-$lower ? $upper : $lower) . $1)
    =~ s/\.?0*e([+-])0*(?!\z)/e$1/;   # convert 0.0000e+00 to 0e+0
   return JE::String->_new(
    $global, $ret
   );
  }
  
  my $result = sprintf "%"."."x!!length($places)."${places}e", $num;
  $result =~ s/\.?0*e([+-])0*(?!\z)/e$1/;   # convert 0.0000e+00 to 0e+0
  
  return JE::String->_new($global, $result);
  
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'toPrecision',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'toPrecision',
  			no_proto => 1,
  			argnames => ['precision'],
  			function_args => ['this','args'],
  			function => sub {
  my $self = shift;
  die JE::Object::Error::TypeError->new(
  	$global, add_line_number
  	"Argument to " .
  	"Number.prototype. toPrecision is not"
  	. " a " .
  	"Number object"
  ) unless $self->class eq 'Number';
  
  my $num = $self->value;
  $num == $num or return JE::String->_new($global, 'NaN');
  abs $num == inf && return JE::String->_new($global,
  	($num < 0 && '-') . 'Infinity');
  
  my $prec = shift;
  if(!defined $prec || $prec->id eq 'undef') {
  	return JE::String->_new($global, $num);
  # ~~~ if/when JE::Number::to_string is rewritten, make this use the same
  #    algorithm
  }
  
  $prec = ($prec = int $prec->to_number) == $prec && $prec;
  
  $prec < 1 and throw JE::Object::Error::RangeError->new($global,
  	"Precision out of range: $prec " .
  	"(must be >= 1)"
  );
  
  
  # ~~~ Probably not the most efficient alrogithm. maybe I coould optimimse
  #    it later. OD yI have tot proooofrfreoad my aown tiyping.?
  
  if ($num == 0) {
  	$prec == 1 or $num = '0.' . '0' x ($prec-1);
  }
  else {
  	$num = sprintf "%.${prec}g", $num; # round it off
  	my($e) = sprintf "%.0e", $num, =~ /e(.*)/;
  	if($e < -6 || $e >= $prec) {
  		($num = sprintf "%.".($prec-1)."e", $num)	
  		 =~ s/(?<=e[+-])0+(?!\z)//;   # convert 0e+00 to 0e+0
  		$num =~ /\./ or $num =~ s/e/.e/;
  	}
  	else { $num = sprintf "%." . ($prec - 1 - $e) . 'f', $num }
  }
  
  return JE::String->_new($global, $num);
  
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$f;
  }
  
  return "a true value";
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item JE
  
  =item JE::Types
  
  =item JE::Object
  
  =item JE::Number
  
  =back
  
  =cut
JE_OBJECT_NUMBER

$fatpacked{"JE/Object/Proxy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_PROXY';
  package JE::Object::Proxy;
  
  our $VERSION = '0.066';
  
  use strict;
  use warnings; no warnings 'utf8';
  
  # ~~~ delegate overloaded methods?
  
  use JE::Code 'add_line_number';
  use Scalar::Util 1.09 qw'refaddr';
  
  require JE::Object;
  
  our @ISA = 'JE::Object';
  
  
  =head1 NAME
  
  JE::Object::Proxy - JS wrapper for Perl objects
  
  =head1 SYNOPSIS
  
    $proxy = new JE::Object::Proxy $JE_object, $some_Perl_object;
  
  =cut
  
  
  
  
  sub new {
  	my($class, $global, $obj) = @_;
  
  	my $class_info = $$$global{classes}{ref $obj};
  
  	my $self = ($class eq __PACKAGE__ # allow subclassing
  	            && ($$class_info{hash} || $$class_info{array})
  			? __PACKAGE__."::Array" : $class)
  		   ->JE::Object::new($global,
  		{ prototype => $$class_info{prototype} });
  
  	@$$self{qw/class_info value/} = ($class_info, $obj);
  
  	while(my($name,$args) = each %{$$class_info{props}}) {
  		$self->prop({ name => $name, @$args });
  	}
  
  	$self;
  }
  
  
  
  
  sub class { $${$_[0]}{class_info}{name} }
  
  
  
  
  sub value { $${$_[0]}{value} }
  
  
  
  
  sub id {
  	refaddr $${$_[0]}{value};
  }
  
  
  
  
  sub to_primitive { # ~~~ This code should  probably  be  moved  to 
                     #     &JE::bind_class for the sake of efficiency.
  	my($self, $hint) = (shift, @_);
  
  	my $guts = $$self;
  	my $value = $$guts{value};
  	my $class_info = $$guts{class_info};
  
  	if(exists $$class_info{to_primitive}) {
  		my $tp = $$class_info{to_primitive};
  		if(defined $tp) {
  			ref $tp eq 'CODE' and
  				return $$guts{global}->upgrade(
  					&$tp($value, @_)
  				);
  			($tp, my $type) = JE::_split_meth($tp);
  			return defined $type
  			?  $$guts{global}->_cast($value->$tp(@_),$type)
  			:  $$guts{global}->upgrade($value->$tp(@_))
  		} else {
  			die add_line_number
  				"The object ($$class_info{name}) cannot "
  				. "be converted to a primitive";
  		}
  	} else {
  		if(overload::Method($value,'""') ||
  		   overload::Method($value,'0+') ||
  		   overload::Method($value,'bool')){
  			return $$guts{global}->upgrade("$value");
  		}
  		return SUPER::to_primitive $self @_;
  	}
  }
  
  
  
  sub to_string {
  	my($self, $hint) = (shift, @_);
  
  	my $guts = $$self;
  	my $value = $$guts{value};
  	my $class_info = $$guts{class_info};
  
  	if(exists $$class_info{to_string}) {
  		my $tp = $$class_info{to_string};
  		if(defined $tp) {
  			ref $tp eq 'CODE' and
  				return $$guts{global}->upgrade(
  					&$tp($value, @_)
  				)->to_string;
  			($tp, my $type) = JE::_split_meth $tp;
  			return ( defined $type
  			  ?  $$guts{global}->upgrade($value->$tp(@_))
  			  :  $$guts{global}->_cast($value->$tp(@_),$type)
  			)->to_string
  		} else {
  			die add_line_number
  				"The object ($$class_info{name}) cannot "
  				. "be converted to a string";
  		}
  	} else {
  		return SUPER::to_string $self @_;
  	}
  }
  
  
  
  
  sub to_number {
  	my($self, $hint) = (shift, @_);
  
  	my $guts = $$self;
  	my $value = $$guts{value};
  	my $class_info = $$guts{class_info};
  
  	if(exists $$class_info{to_number}) {
  		my $tp = $$class_info{to_number};
  		if(defined $tp) {
  			ref $tp eq 'CODE' and
  				return $$guts{global}->upgrade(
  					&$tp($value, @_)
  				)->to_number;
  			($tp, my $type) = JE::_split_meth $tp;
  			return ( defined $type
  			  ?  $$guts{global}->upgrade($value->$tp(@_))
  			  :  $$guts{global}->_cast($value->$tp(@_),$type)
  			)->to_number
  		} else {
  			die add_line_number
  				"The object ($$class_info{name}) cannot "
  				. "be converted to a number";
  		}
  	} else {
  		return SUPER::to_number $self @_;
  	}
  }
  
  
  
  
  package JE::Object::Proxy::Array; # so this extra stuff doesn't slow down
  our $VERSION = '0.066';           # 'normal' usage
  our @ISA = 'JE::Object::Proxy';
  require JE::Number;
  
  sub prop {
  	my $self = shift;
  	my $wrappee = $self->value;
  	my $name = shift;
  	my $class_info = $$$self{class_info};
  
  	if ($$class_info{array}) {
  		if($name eq 'length') {
  			@_ ? ($#$wrappee = $_[0]-1, return shift)
  			   : return new JE::Number
  			      $self->global, scalar @$wrappee
  		}
  		if($name =~ /^(?:0|[1-9]\d*)\z/ and $name < 4294967295){
  			@_ ? $$class_info{array}{store}(
  				$wrappee,$name,$_[0]) && return shift
  		  	 : do {
  				my $ret =
  				   $$class_info{array}{fetch}(
  				      $wrappee,$name);
  				defined $ret and return $ret;
  			   }
  		}
  	}
  	if ($$class_info{hash}and !exists $$class_info{props}{$name}) {
  		if(@_){
  			$$class_info{hash}{store}->(
  				$wrappee,$name,$_[0]
  			) and return shift;
  		}else{
  			my $ret = $$class_info{hash}{fetch}
  				($wrappee,$name);
  			defined $ret and return $ret;
  		}
  	}
  	SUPER::prop $self $name, @_;
  }
  
  sub keys {
  	my $self = shift;
  	my $wrappee = $self->value;
  	my $class_info = $$$self{class_info};
  	my @keys;
  	if ($$class_info{array}){
  		@keys = grep(exists $wrappee->[$_], 0..$#$wrappee);
  	}
  	if($$class_info{hash}) {
  		push @keys, keys %$wrappee;
  	}
  	push @keys, SUPER::keys $self;
  	my @new_keys; my %seen;
  	$seen{$_}++ or push @new_keys, $_ for @keys;
  	@new_keys;
  }
  
  sub delete {
  	my $self = shift;
  	my $wrappee = $self->value;
  	my($name) = @_;
  	my $class_info = $$$self{class_info};
  	if ($$class_info{array}){
  		if ($name =~ /^(?:0|[1-9]\d*)\z/ and $name < 4294967295 and
  		    exists $wrappee->[$name]) {
  			delete $wrappee->[$name];
  			return !$self->exists($name);
  		}
  		elsif ($name eq 'length') {
  			return !1
  		}
  	}
  	if($$class_info{hash} && !exists $$class_info{props}{$name} and
  	   exists $wrappee->{$name}) {
  		delete $wrappee->{$name};
  		return !exists $wrappee->{$name};
  	}
  	SUPER::delete $self @_;
  }
  
  sub exists {
  	my $self = shift;
  	my $wrappee = $self->value;
  	my($name) = @_;
  	my $class_info = $$$self{class_info};
  	if ($$class_info{array}){
  		if ($name =~ /^(?:0|[1-9]\d*)\z/ and $name < 4294967295) {
  			return 1 if exists $wrappee->[$name];
  			# If it doesnt exists, try hash keys below.
  		}
  		elsif ($name eq 'length') {
  			return 1
  		}
  	}
  	if($$class_info{hash}) {
  	   return 1 if exists $wrappee->{$name};
  	}
  	SUPER::exists $self @_;
  
  }
  
  
  1;
  
JE_OBJECT_PROXY

$fatpacked{"JE/Object/RegExp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_REGEXP';
  package JE::Object::RegExp;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings; no warnings 'utf8';
  
  use overload fallback => 1,
  	'""'=> 'value';
  
  # This constant is true if we need to work around perl bug #122460 to keep
  # the aardvark tests (in t/15.05-string-objects.t) passing.  This only
  # applies  to  perl  5.20.0.  (perl  5.20.1  includes  a  fix.)  Basic-
  # ally,  (?=...)  can result in buggy optimisations that cause  a  faulty
  # rejection of the match at some locations, because it is assumed that it
  # cannot match in some spots.
  use constant aardvark_bug =>
   # This test should match the empty string.  If it advances (pos returns
   # true), then we have the bug.
   do { my $a = "rdvark"; $a =~ /(?{})(?=.)a*?/g; pos $a };
  
  use Scalar::Util 'blessed';
  
  our @ISA = 'JE::Object';
  
  require JE::Boolean;
  require JE::Code;
  require JE::Object;
  require JE::String;
  
  import JE::Code 'add_line_number';
  sub add_line_number;
  
  our @Match;
  our @EraseCapture;
  
  #import JE::String 'desurrogify';
  #sub desurrogify($);
  # Only need to turn these on when Perl starts adding regexp modifiers
  # outside the BMP.
  
  # JS regexp features that Perl doesn't have, or which differ from Perl's,
  # along with their Perl equivalents
  #    ^ with /m  \A|(?<=[\cm\cj\x{2028}\x{2029}])  (^ with the  /m modifier
  #                                                matches whenever a Unicode
  #                                              line  break  (not  just  \n)
  #                                           precedes the current  position,
  #                                       even at the end of the string. In
  #                                  Perl, /^/m matches \A|(?<=\n)(?!\z) .)
  #    $          \z
  #    $ with /m  (?:\z|(?=[\cm\cj\x{2028}\x{2029}]))
  #    \b         (?:(?<=$w)(?!$w)|(?<!$w)(?=$w))  (where  $w  represents
  #    \B         (?:(?<=$w)(?=$w)|(?<!$w)(?!$w))  [A-Za-z0-9_], because JS
  #                                               doesn't include  non-ASCII
  #                                             word chars in \w)
  #    .          [^\cm\cj\x{2028}\x{2029}]
  #    \v         \cK
  #    \n         \cj  (whether \n matches \cj in Perl is system-dependent)
  #    \r         \cm
  #    \uHHHH     \x{HHHH}
  #    \d         [0-9]
  #    \D         [^0-9]
  #    \s         [\p{Zs}\s\ck]
  #    \S         [^\p{Zs}\s\ck]
  #    \w         [A-Za-z0-9_]
  #    \W         [^A-Za-z0-9_]
  #    [^]	(?s:.)
  #    []         (?!)
  
  # Other differences
  #
  # A quantifier in a JS regexp will,  when repeated,  clear all values  cap-
  # tured by capturing parentheses in the term that it quantifies. This means
  # that /((a)?b)+/, when matched against "abb" will leave $2 undefined, even
  # though the second () matched  "a"  the first time the first  ()  matched.
  # (The ECMAScript spec says to do it this way,  but Safari leaves $2  with
  # "a" in it and doesn't clear it on the second iteration of the '+'.) Perl
  # does it both ways, and the rules aren't quite clear to me:
  #
  # $ perl5.8.8 -le '$, = ",";print "abb" =~ /((a)?b)+/;'
  # b,
  # $ perl5.8.8 -le '$, = ",";print "abb" =~ /((a+)?b)+/;'
  # b,a
  #
  # perl5.9.4 produces the same. perl5.002_01 crashes quite nicely.
  # 
  #
  # In ECMAScript, when the pattern inside a (?! ... ) fails (in which case
  # the (?!) succeeds), values captured by parentheses within the negative
  # lookahead are cleared, such that subsequent backreferences *outside* the
  # lookahead are equivalent to (?:) (zero-width always-match assertion). In
  # Perl, the captured values are left as they are when the pattern inside
  # the lookahead fails:
  #
  # $ perl5.8.8 -le 'print "a" =~ /(?!(a)b)a/;'
  # a
  # $ perl5.9.4 -le 'print "a" =~ /(?!(a)b)a/;'
  # a
  #
  #
  # In ECMAScript, as in Perl, a pair of capturing parentheses will produce
  # the undefined value if the parens were not  part  of  the  final  match.
  # Undefined will still be produced if there  is  a  \digit  backreference
  # reference to those parens. In ECMAScript, such a back-reference is equiv-
  # alent to (?:); in Perl it is equivalent to (?!). Therefore, ECMAScripts
  # \1  is equivalent to Perls  (?(1)\1).  (It  would  seem,  upon  testing
  # /(?:|())/ vs. /(?:|())\1/ in perl, that the \1 back-reference always suc-
  # ceeds, and ends up setting $1 to "" [as opposed to undef]. What is actu-
  # ally happening is that the failed \1 causes backtracking, so the second
  # alternative in (?:|()) matches, setting $1 to the empty string. Safari,
  # incidentally, does what Perl *appears* to do at first glance, *if* the
  # backreference itself is within capturing parentheses (as in
  # /(?:|())(\1)/).
  #
  # These issues are solved with embedded code snippets, as explained below,
  # where the actual code is.
  #
  #
  # In ECMAScript,  case-folding inside the regular expression engine is not
  # allowed to change the length of a string.  Therefore,  ""  never matches
  # /ss/i, and vice versa. Im disinclined to be ECMAScript compliant in this
  # regard though, because it would affect performance. The inefficient solu-
  # tion I have in mind is to change /x/i to /(?-i:x)/  for every character
  # that has a multi-character uppercase equivalent; and to change /xx/i to
  # /(?-i:[Xx][Xx])/  where xx  represents a multi-character sequence that
  # could match a single character in Perl. The latter is the main problem.
  # How are we to find out which character sequences need  this?  We  could
  # change /x/i to /[xX]/ for every literal character in the string, but how
  # would we take // -> /[]/ into account? And does perls regexp engine
  # slow down if we feed it a ton of character classes instead  of  literal
  # text? (Need to do some benchmarks.) (If we do fix this, we need to re-
  # enable the skipped tests.)
  
  
  
  =head1 NAME
  
  JE::Object::RegExp - JavaScript regular expression (RegExp object) class
  
  =head1 SYNOPSIS
  
    use JE;
    use JE::Object::RegExp;
  
    $j = new JE;
  
    $js_regexp = new JE::Object::RegExp $j, "(.*)", 'ims';
  
    $perl_qr = $js_regexp->value;
  
    $some_string =~ $js_regexp; # You can use it as a qr//
  
  =head1 DESCRIPTION
  
  This class implements JavaScript regular expressions for JE.
  
  See L<JE::Types> for a description of most of the interface. Only what
  is specific to JE::Object::RegExp is explained here.
  
  A RegExp object will stringify the same way as a C<qr//>, so that you can
  use C<=~> on it. This is different from the return value of the
  C<to_string> method (the way it stringifies in JS).
  
  Since JE's regular expressions use Perl's engine underneath, the 
  features that Perl provides that are not part of the ECMAScript spec are
  supported, except for C<(?s)>
  and C<(?m)>, which don't do anything, and C<(?|...)>, which is 
  unpredictable.
  
  In versions prior to 0.042, a hyphen adjacent to C<\d>, C<\s> or C<\w> in a
  character class would be unpredictable (sometimes a syntax error). Now it
  is interpreted literally. This matches what most implementations do, which
  happens to be the same as Perl's behaviour. (It is a syntax error
  in ECMAScript.)
  
  =head1 METHODS
  
  =over 4
  
  =cut
  
  # ~~~ How should surrogates work??? To make regexps work with JS strings
  #    properly, we need to use the surrogified string so that /../  will
  #  correctly match two surrogates.  In this case it won't work properly
  # with Perl strings, so what is the point of Perl-style stringification?
  # Perhaps we should allow this anyway, but warn about code points outside
  # the BMP in the documentation.  (Should we also produce a Perl  warning?
  # Though I'm not that it's possible to catch  this:  "\x{10000}" =~ $re).
  #
  # But it would be nice if this would work:
  #	$j->eval("'\x{10000}'") =~ $j->eval('/../')
  # ~~~ We might be able to make this work with perl 5.12s qr overloading.
  
  our %_patterns = qw/
  \b  (?:(?<=[A-Za-z0-9_])(?![A-Za-z0-9_])|(?<![A-Za-z0-9_])(?=[A-Za-z0-9_]))
  \B  (?:(?<=[A-Za-z0-9_])(?=[A-Za-z0-9_])|(?<![A-Za-z0-9_])(?![A-Za-z0-9_]))
  .   [^\cm\cj\x{2028}\x{2029}]
  \v  \cK
  \n  \cj
  \r  \cm
  \d  [0-9]
  \D  [^0-9]
  \s  [\p{Zs}\s\ck]
  \S  [^\p{Zs}\s\ck]
  \w  [A-Za-z0-9_]
  \W  [^A-Za-z0-9_]
  /;
  
  our %_class_patterns = qw/
  \v  \cK
  \n  \cj
  \r  \cm
  \d  0-9
  \s  \p{Zs}\s\ck
  \w  A-Za-z0-9_
  /;
  
  my $clear_captures = qr/(?{@Match=@EraseCapture=()})/;
  my $save_captures = do { no strict 'refs';
    qr/(?{$Match[$_]=$EraseCapture[$_]?undef:$$_ for 1..$#+})/; };
  # These are pretty scary, arent they?
  my $plain_regexp =
  	qr/^((?:[^\\[()]|\\.|\((?:\?#|\*)[^)]*\))[^\\[()]*(?:(?:\\.|\((?:\?#|\*)[^)]*\))[^\\[()]*)*)/s;
  my $plain_regexp_x_mode =
  	qr/^((?:[^\\[()]|\\.|\(\s*(?:\?#|\*)[^)]*\))[^\\[()]*(?:(?:\\.|\(\s*(?:\?#|\*)[^)]*\))[^\\[()]*)*)/s;
  my $plain_regexp_wo_pipe =
  	qr/^((?:[^\\[()|]|\\.|\((?:\?#|\*)[^)]*\))[^\\[()|]*(?:(?:\\.|\((?:\?#|\*)[^)]*\))[^\\[()|]*)*)/s;
  my $plain_regexp_x_mode_wo_pipe =
  	qr/^((?:[^\\[()|]|\\.|\(\s*(?:\?#|\*)[^)]*\))[^\\[()|]*(?:(?:\\.|\(\s*(?:\?#|\*)[^)]*\))[^\\[()|]*)*)/s;
  
  sub _capture_erasure_stuff {
  	"(?{local\@EraseCapture[" . join(',',@{$_[0]}) . "]=(1)x"
  		. @{$_[0]} . '})'
  }
  
  sub new {
  	my ($class, $global, $re, $flags) = @_;
  	my $self = $class->SUPER::new($global, {
  		prototype => $global->prototype_for('RegExp')
  		          || $global->prop('RegExp')->prop('prototype')
  	});
  
  	my $qr;
  
  	if(defined blessed $re) {
  		if ($re->isa(__PACKAGE__)) {
  			defined $flags && eval{$flags->id} ne 'undef' and
  				die JE::Object::Error::TypeError->new(
  					$global, add_line_number
  					'Second argument to ' .
  					'RegExp() must be undefined if ' .
  					'first arg is a RegExp');
  			$flags = $$$re{regexp_flags};
  			$qr = $$$re{value};
  			$re = $re->prop('source')->[0];
  		}
  		elsif(can $re 'id' and $re->id eq 'undef') {
  			$re = '';
  		}
  		elsif(can $re 'to_string') {
  			$re = $re->to_string->value16;
  		}
  	}
  	else {
  		defined $re or $re = '';
  	}
  
  	if(defined blessed $flags) {
  		if(can $flags 'id' and $flags->id eq 'undef') {
  			$flags = '';
  		}
  		elsif(can $flags 'to_string') {
  			$flags = $flags->to_string->value;
  		}
  	}
  	else {
  		defined $flags or $flags = '';
  	}
  
  
  	# Let's begin by processing the flags:
  
  	# Save the flags before we start mangling them
  	$$$self{regexp_flags} = $flags;
  
  	$self->prop({
  		name => global =>
  		value  => JE::Boolean->new($global, $flags =~ y/g//d),
  		dontenum => 1,
  		readonly  => 1,
  		dontdel   => 1,
  	});
  
  #	$flags = desurrogify $flags;
  # Not necessary, until Perl adds a / modifier (not likely)
  
  	# I'm not supporting /s (at least not for now)
  	no warnings 'syntax'; # so syntax errors in the eval are kept quiet
  	$flags =~ /^((?:(?!s)[\$_\p{ID_Continue}])*)\z/ and eval "qr//$1"
  		or die new JE::Object::Error::SyntaxError $global,
  		add_line_number "Invalid regexp modifiers: '$flags'";
  
  	my $m = $flags =~ /m/;
  	$self->prop({
  		name => ignoreCase =>
  		value  => JE::Boolean->new($global, $flags =~ /i/),
  		dontenum => 1,
  		readonly  => 1,
  		dontdel   => 1,
  	});
  	$self->prop({
  		name => multiline =>
  		value  => JE::Boolean->new($global, $m),
  		dontenum => 1,
  		readonly  => 1,
  		dontdel   => 1,
  	});
  
  
  	# Now we'll deal with the pattern itself.
  
  	# Save it before we go and mangle it
  	$self->prop({
  		name => source =>
  		# ~~~ Can we use ->_new here?
  		value  => JE::String->new($global, do {
  			(my $tmp = $re) =~
  				s<(\\.)|/>
  				<defined $1 ? $1 : '\/'>egg;
  			$tmp
  		}),
  		dontenum => 1,
  		readonly  => 1,
  		dontdel   => 1,
  	});
  
  	unless (defined $qr) { # processing begins here
  
  	# This horrific piece of code converts an ECMAScript regular
  	# expression into a Perl one, more or less.
  
  	# Since Perl sometimes fills in $1, etc., where they are supposed
  	# to be undefined in ECMAScript, we use embedded code snippets to
  	# put the values into @Match[1..whatever] instead.
  
  	# The cases we have to take into account are
  	# 1) quantified captures; i.e., (...)+ or (?:()?)+ ; and
  	# 2) captures within interrobang groups: (?!())
  
  	# The solution is to mark captures as erasure candidates with the
  	# @EraseCapture array.
  
  	# To solve case 1, we have to put (?{}) markers at the begin-
  	# ning of each grouping construct that has captures  in  it,
  	# and a quantifier within each pair of capturing  parenthe-
  	# ses before the closing paren.  (?:(a+)?b)+  will  become
  	# (?: (?{...}) ( a+ (?{...}) )? b )+  (spaced out for reada-
  	# bility). The first code interpolation sets $EraseCapture[n]
  	# to 1  for  all  the  captures  within  that  group.  The  sec-
  	# ond code  interpolation  will  only  be  triggered  if  the  a+
  	# matches,  and there we  set  $EraseCapture[n]  to  0.  Its actu-
  	# ally  slightly  more  complicated  than  that,  because  we  may
  	# have alternatives directly  inside  the  outer  grouping;  e.g.,
  	# (?:a|(b))+,  so we have to wrap the contents  thereof  within
  	# (?:),  making (?:(?{...})(?:a|(b(?{...}))))+.  Whew!
  
  	# For case 2 we change (?!...) to (?:(?!...)(?{...})). The embedded
  	# code marks the captures inside  (?!)  for erasure.  The  (?:  is
  	# needed because the (?!) might be quantified. (We used not to add
  	# the extra (?:),  but put the (?{})  at the end of the innermost
  	# enclosing group,  but that causes the  same  \1  problem  men-
  	# tioned above.
  
  	use constant 1.03 # multiple
  	{ # Make sure any changes to these constants are also
  	  # made at  the  end
  	  # of the subroutine
  		# array indices within each item on the @stack:
  		posi => 0, # position within $new_re where the current
  		           # groups contents start, or before the opening
  		           # paren for interrobang groups
  		type => 1, # type of group; see constants below
  		xmod => 2, # whether /x mode is active
  		capn => 3, # array ref of capture numbers within this group
  
  		# types of parens:
  		reg => 0, cap => 1, itrb => 2, brch => 3, cond => 4
  	};
  
  	my $new_re = '';
  	my $sub_pat;
  	my @stack = [0,0,$flags =~ /x/];
  	my $capture_num; # number of the most recently started capture
  	my @capture_nums;   # numbers of the captures were inside
  #my $warn;
  #++$warn if $re eq '(?p{})';
  	{
  		@stack or die new JE::Object::Error::SyntaxError $global,
  			add_line_number "Unmatched ) in regexp";
  
  		# no parens or char classes:
  		if( $stack[-1][xmod]
  		  ? $stack[-1][type] == cond || $stack[-1][type] == brch
  		    ? $re =~ s/$plain_regexp_x_mode_wo_pipe//
  		    : $re =~ s/$plain_regexp_x_mode//
  		  : $stack[-1][type] == cond || $stack[-1][type] == brch
  		    ? $re =~ s/$plain_regexp_wo_pipe//
  		    : $re =~ s/$plain_regexp//
  		) {
  			($sub_pat = $1) =~
  			s/
  				([\^\$])
  				  |
  				(\.|\\[bBvnrdDsSwW])
  				  |
  				\\u([A-Fa-f0-9]{4})
  				  |
  				\\([1-9][0-9]*)
  				  |
  				\\?([\x{d800}-\x{dfff}])
  				  |
  				(\\(?:[^c]|c.))
  			/
  			  defined $1
  			  ? $1 eq '^'
  			    ? $m
  			      ? '(?:\A|(?<=[\cm\cj\x{2028}\x{2029}]))'
  			      : '^'
  			    : $m
  			      ? '(?:\z|(?=[\cm\cj\x{2028}\x{2029}]))'
  			      : '\z'
  			  : defined $2 ? $_patterns{$2} :
  			    defined $3 ? "\\x{$3}"      :
  			    defined $4 ? "(?(?{defined\$$4&&"
  			                ."!\$EraseCapture[$4]})\\$4)" :
  			    # work around a bug in perl:
  			    defined $5 ? sprintf '\\x{%x}', ord $5 :
  			    $6
  			/egxs;
  			$new_re .= $sub_pat;
  		}
  
  		# char class:
  		elsif($re=~s/^\[([^]\\]*(?:\\.[^]\\]*)*)]//s){
  			if($1 eq '') {
  				$new_re .= '(?!)';
  			}
  			elsif($1 eq '^') {
  				$new_re .= '(?s:.)';
  			}
  			else {
  				my @full_classes;
  				($sub_pat = $1) =~ s/
  				  (\\[vnr])
  				    |
  				  (-?)(\\[dsw])(-?)
  				    |
  				  (\\[DSW])
  				    |
  				  \\u([A-Fa-f0-9]{4})
  				    |
  				  \\?([\x{d800}-\x{dfff}])
  				    |
  				  (\\(?:[^c]|c.))
  				/
  			  	  defined $1 ? $_class_patterns{$1} :
  			  	  defined $3 ?
  				     ($2 ? '\-' : '')
  				    .$_class_patterns{$3}
  				    .($4 ? '\-' : '')     :
  				  defined $5 ? ((push @full_classes,
  					$_patterns{$5}),'') :
  				  defined $6 ? "\\x{$6}"  :
  				  # work around a bug in perl:
  				  defined $7 ? sprintf '\\x{%x}', ord $7 :
  			    	  $8
  				/egxs;
  
  				$new_re .= length $sub_pat
  				  ? @full_classes
  				    ? '(?:' .
  				      join('|', @full_classes,
  				        "[$sub_pat]")
  				      . ')'
  				    : "[$sub_pat]"
  				  : @full_classes == 1
  				    ? $full_classes[0]
  				    : '(?:' . join('|', @full_classes) .
  				      ')';
  			}
  		}
  
  		# (?mods) construct (no colon) :
  		elsif( $stack[-1][xmod]
  		             ? $re =~ s/^(\(\s*\?([\w]*)(?:-([\w]*))?\))//
  		             : $re =~ s/^(\(   \?([\w]*)(?:-([\w]*))?\))//x
  		) {
  			$new_re .= $1;
  			defined $3 && index($3,'x')+1
  			? $stack[-1][xmod]=0
  			: $2 =~ /x/ && ++$stack[-1][xmod];
  		}
  
  		# start of grouping construct:
  		elsif( $stack[-1][xmod]
  		 ? $re=~s/^(\((?:\s*\?([\w-]*:|[^:{?<p]|<.|([?p]?\{)))?)//
  		 : $re=~s/^(\((?:   \?([\w-]*:|[^:{?<p]|<.|([?p]?\{)))?)//x
  		) {
  #			warn "$new_re-$1-$2-$3-$re" if $warn;
  			$3 and  die JE'Object'Error'SyntaxError->new(
  				      $global, add_line_number
  				        "Embedded code in regexps is not " 
  				        . "supported"
  				    );
  			my $pos_b4_parn = length $new_re;
  			$new_re .= $1;
  			my $caq = $2; # char(s) after question mark
  			my @current;
  			if(defined $caq) {  # (?...) patterns
  				if($caq eq '(') {
  				  $re =~ s/^([^)]*\))//;
  				  $new_re .= $1;
  				  $1 =~ /^\?[?p]?\{/ && die
  				    JE'Object'Error'SyntaxError->new(
  				      $global, add_line_number
  				        "Embedded code in regexps is not " 
  				        . "supported"
  				    );
  				  $current[type] = cond;
  				}
  				elsif($caq =~ /^[<'P](?![!=])/) {
  				  ++$capture_num;
  				  $caq eq "'" ? $re =~ s/^(.*?')//
  				              : $re =~ s/^(.*?>)//;
  				  $new_re .= $1;
  				  $current[type] = reg;
  				}
  				else {
  				  $current[type] = (reg,itrb)[$caq eq '!'];
  				}
  				$current[posi] = $caq eq '!' ? $pos_b4_parn
  					: length $new_re;
  			}else{ # capture
  				++$capture_num;
  				push @capture_nums, $capture_num;
  				push @{$$_[capn]}, $capture_num for @stack;
  				$current[posi] = length $new_re;
  				$current[type] = cap;
  			}
  			$current[xmod] = $stack[-1][xmod];
  			push @stack, \@current;
  		}
  
  		# closing paren:
  		elsif($re =~ s/^\)//) {
  			my @commands;
  			my $cur = $stack[-1];
  			if($$cur[type] != itrb) {
  				if($$cur[type] == cap) {
  				  # we are exiting a capturing group
  				  $new_re .= "(?{local" .
  				    "\$EraseCapture[$capture_nums[-1]]=0"
  				   ."})";
  				  pop @capture_nums;
  				}
  				if($$cur[capn] && @{$$cur[capn]} &&
  				   $re =~ /^[+{*?]/) { # quantified group
  				  substr $new_re,$$cur[posi],0 =>=
  				    _capture_erasure_stuff($$cur[capn])
  					. "(?:";
  				   $new_re .= ")";
  				}
  				$new_re .= ')';
  			}
  			else {{ # ?!
  				$new_re .= ')';
  				last unless($$cur[capn] && @{$$cur[capn]});
  
  				# change (?!...) to (?!...)(?{...})
  				$new_re .= _capture_erasure_stuff(
  					$$cur[capn]
  				);
  
  				# wrap (?!)(?{}) in (?:) if necessary
  				$re =~ /^[+{*?]/ and
  					substr $new_re,$$cur[posi],0 
  						=>= '(?:',
  					$new_re .= ')';
  			}}
  			pop @stack;
  		}
  
  		# pipe within (?()|) or (?|) (the latter doesnt work yet):
  		elsif($re =~ s/^\|//) {
  			my $cur = $stack[-1];
  			if($$cur[capn] && @{$$cur[capn]}
  			   #&& $re =~ /^[+{*?]/ # We cant actually tell
  			) {         # at this point whether the enclosing
  			 # group is quantified. Does anyone have any ideas?
  				substr $new_re,$$cur[posi],0 =>=
  					_capture_erasure_stuff(
  						$$cur[capn]
  					);
  				@{$$cur[capn]} = ();
  			}
  			$new_re .= '|';
  			$$cur[posi] = length $new_re;
  		}
  
  		# something invalid left over:
  		elsif($re) {
  #warn $re;
  			die JE::Object::Error::SyntaxError->new($global,
  			    add_line_number
  			    $re =~ /^\[/
  			    ? "Unterminated character class $re in regexp"
  			    : 'Trailing \ in regexp');
  		}
  		length $re and redo;
  	}
  	@stack or die new JE::Object::Error::SyntaxError $global,
  		add_line_number "Unmatched ) in regexp";
  
  	aardvark_bug && $new_re =~ /\(\?=/
  	 and substr $new_re,0,0, = '(??{""})';
  
  #warn $new_re;
  	$qr = eval {
  		use re 'eval'; no warnings 'regexp'; no strict;
  
  		# The warnings pragma doesnt make it into the re-eval, so
  		# we have to localise  $^W,  in case the  string  contains
  		# @EraseCapture[1]=(1)x1  and someone is using  -w.
  		local $^W;
  
  		# We have to put (?:)  around $new_re in the first case,
  		    # because it may contain a top-level disjunction, but
  		         # not in the second,  because the array  modifica-
  		$capture_num  # tions in $clear_captures are not localised.
  		  ? qr/(?$flags:$clear_captures(?:$new_re)$save_captures)/
  		  : qr/(?$flags:$clear_captures$new_re)/
  	} or $@ =~ s/\.?$ \n//x,
  	     die JE::Object::Error::SyntaxError->new($global,
  			add_line_number $@);
  
  	} # end of pattern processing
  
  	$$$self{value} = $qr;
  
  	$self->prop({
  		name => lastIndex =>
  		value => JE::Number->new($global, 0),
  		dontdel => 1,
  		dontenum => 1,
  	});
  
  	$self;
  }
  BEGIN {
   no strict;
   delete @{__PACKAGE__.'::'}{qw[posi type xmod capn reg cap itrb brch cond]}
  }
  
  
  
  =item value
  
  Returns a Perl C<qr//> regular expression.
  
  If the regular expression
  or the string that is being matched against it contains characters outside
  the Basic Multilingual Plane (whose character codes exceed 0xffff), the
  behavior is undefined--for now at least. I still need to solve the problem
  caused by JS's unintuitive use of raw surrogates. (In JS, C</../> will 
  match a
  surrogate pair, which is considered to be one character in Perl. This means
  that the same regexp matched against the same string will produce different
  results in Perl and JS.)
  
  =cut
  
  sub value {
  	$${$_[0]}{value};
  }
  
  
  
  
  =item class
  
  Returns the string 'RegExp'.
  
  =cut
  
  sub class { 'RegExp' }
  
  
  sub call {
  				my ($self,$str) = @_;
  
  				die JE::Object::Error::TypeError->new(
  					$self->global, add_line_number
  					"Argument to exec is not a " .
  					"RegExp object"
  				) unless $self->class eq 'RegExp';
  
  				my $je_str;
  				if (defined $str) {
  					$str =
  					($je_str=$str->to_string)->value16;
  				}
  				else {
  					$str = 'undefined';
  				}
  
  				my(@ary,$indx);
  				my $global = $$$self{global};
  
  				my $g = $self->prop('global')->value;
  				if ($g) {
  					my $pos = 
  					   $self->prop('lastIndex')
  					    ->to_number->value;
  					$pos < 0 || $pos > length $str
  					 ||
  					(
  					 pos $str = $pos, 
  					 $str !~ /$$$self{value}/g
  					)
  					 and goto phail;
  
  					@ary = @Match;
  					$ary[0] = substr($str, $-[0],
  						$+[0] - $-[0]);
  					$indx = $-[0];
  
  					$self->prop(lastIndex =>
  						JE::Number->new(
  							$global,
  							pos $str
  						));
  					$global->prototype_for('RegExp')
  					 ->prop('constructor')
  					 ->capture_re_vars($str);
  				}
  				else {
  					$str =~ /$$$self{value}/
  					 or goto phail;
  
  					@ary = @Match;
  					$ary[0] = substr($str, $-[0],
  						$+[0] - $-[0]);
  					$indx = $-[0];
  					$global->prototype_for('RegExp')
  					 ->prop('constructor')
  					 ->capture_re_vars($str);
  				}
  			
  				my $ary = JE::Object::Array->new(
  					$global, 
  					\@ary
  				);
  				$ary->prop(index =>
  					JE::Number->new($global,$indx));
  				$ary->prop(input => defined $je_str
  					? $je_str :
  					JE::String->_new(
  						$global, $str
  					));
  				
  				return $ary;
  
  				phail:
  				$self->prop(lastIndex =>
  					    JE::Number->new(
  					     $global,
  					     0
  					    ));
  				return $global->null;
  }
  
  sub apply { splice @'_, 1, 1; goto &call }
  
  @JE::Object::Function::RegExpConstructor::ISA = 'JE::Object::Function';
  sub JE::Object::Function::RegExpConstructor::capture_re_vars { 
     my $self = shift;
     my $global = $$$self{global};
     $self->prop(
      'lastMatch',
       JE::String->new($global, substr $_[0], $-[0], $+[0]-$-[0])
     );
     {
      no warnings 'uninitialized';
      $self->prop('lastParen', new JE::String $global, "$+")
     }
     $self->prop(
      'leftContext',
       new JE'String $global, substr $_[0], 0, $-[0]
     );
     $self->prop('rightContext', new JE'String $global, substr $_[0], $+[0]);
     no warnings 'uninitialized';
     $self->prop("\$$_", new JE'String $global, "$Match[$_]") for 1..9;
  }
  sub new_constructor {
  	my($package,$global) = @_;
  	my $f = JE::Object::Function::RegExpConstructor->new({
  		name            => 'RegExp',
  		scope            => $global,
  		argnames         => [qw/pattern flags/],
  		function         => sub {
  			my (undef, $re, $flags) = @_;
  			if ($re->class eq 'RegExp' and !defined $flags
  			    || $flags->id eq 'undef') {
  				return $re
  			}
  			unshift @_, __PACKAGE__;
  			goto &new;
  		},
  		function_args    => ['scope','args'],
  		constructor      => sub {
  			unshift @_, $package;
  			goto &new;
  		},
  		constructor_args => ['scope','args'],
  	});
  
  	my $proto = $f->prop({
  		name    => 'prototype',
  		dontenum => 1,
  		readonly => 1,
  	});
  	$global->prototype_for('RegExp', $proto);
  
  	$f->prop({
  	 name => '$&',
  	 dontdel => 1,
  	 fetch => sub { shift->prop('lastMatch') },
  	 store => sub { shift->prop('lastMatch', shift) },
  	});
  	$f->prop({
  	 name => '$`',
  	 dontdel => 1,
  	 fetch => sub { shift->prop('leftContext') },
  	 store => sub { shift->prop('leftContext', shift) },
  	});
  	$f->prop({
  	 name => '$\'',
  	 dontdel => 1,
  	 fetch => sub { shift->prop('rightContext') },
  	 store => sub { shift->prop('rightContext', shift) },
  	});
  	$f->prop({
  	 name => '$+',
  	 dontdel => 1,
  	 fetch => sub { shift->prop('lastParen') },
  	 store => sub { shift->prop('lastParen', shift) },
  	});
  	my $empty = JE::String->new($global,"");
  	for(
  	 qw(lastParen lastMatch leftContext rightContext),
  	 map "\$$_", 1..9
  	) {
  		$f->prop({ name => $_, dontdel => 1, value => $empty});
  	}
  	
  	$proto->prop({
  		name  => 'exec',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'exec',
  			argnames => ['string'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => \&call,
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'test',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'test',
  			argnames => ['string'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my ($self,$str) = @_;
  				die JE::Object::Error::TypeError->new(
  					$global, add_line_number
  					"Argument to test is not a " .
  					"RegExp object"
  				) unless $self->class eq 'RegExp';
  				my $ret = call($self,$str);
  				JE::Boolean->new(
  					$global, $ret->id ne 'null'
  				);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'toString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name    => 'toString',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				my ($self,) = @_;
  				die JE::Object::Error::TypeError->new(
  					$global, add_line_number
  					"Argument to toString is not a " .
  					"RegExp object"
  				) unless $self->class eq 'RegExp';
  				JE::String->_new(
  					$global,
  					"/" . $self->prop('source')->value
  					. "/$$$self{regexp_flags}"
  				);
  			},
  		}),
  		dontenum => 1,
  	});
  
  
  	$f;
  }
  
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item JE
  
  =item JE::Types
  
  =item JE::Object
  
  =back
  
  =cut
  
  
JE_OBJECT_REGEXP

$fatpacked{"JE/Object/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_OBJECT_STRING';
  package JE::Object::String;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings; no warnings 'utf8';
  
  sub surrogify($);
  sub desurrogify($);
  
  our @ISA = 'JE::Object';
  
  use POSIX qw 'floor ceil';
  use Scalar::Util 'blessed';
  
  require JE::Code;
  require JE::Number;
  require JE::Object                 ;
  require JE::Object::Error::TypeError;
  require JE::Object::Function        ;
  require JE::String                 ;
  
  JE::String->import(qw/surrogify desurrogify/);
  JE::Code->import('add_line_number');
  sub add_line_number;
  
  =encoding UTF-8
  
  =head1 NAME
  
  JE::Object::String - JavaScript String object class
  
  =head1 SYNOPSIS
  
    use JE;
    use JE::Object::String;
  
    $j = new JE;
  
    $js_str_obj = new JE::Object::String $j, "etetfyoyfoht";
  
    $perl_str = $js_str_obj->value;
  
  =head1 DESCRIPTION
  
  This class implements JavaScript String objects for JE. The difference
  between this and JE::String is that that module implements
  I<primitive> string value, while this module implements the I<objects.>
  
  =head1 METHODS
  
  See L<JE::Types> for descriptions of most of the methods. Only what
  is specific to JE::Object::String is explained here.
  
  =over 4
  
  =cut
  
  sub new {
  	my($class, $global, $val) = @_;
  	my $self = $class->SUPER::new($global, {
  		prototype => $global->prototype_for('String')
  		          || $global->prop('String')->prop('prototype')
  	});
  
  	$$$self{value} = defined $val
  		? defined blessed $val
  		  && $val->can('to_string')
  			? $val->to_string->value16
  			: surrogify $val
  		: '';
  	$self;
  }
  
  sub prop {
  	my $self = shift;
  	if($_[0] eq 'length') {
  		return JE::Number->new(
  			$$$self{global},length $$$self{value}
  		);
  	}
  	SUPER::prop $self @_;
  }
  
  sub delete {
  	my $self = shift;
  	$_[0] eq 'length' and return !1;
  	SUPER::delete $self @_;
  }
  
  =item value
  
  Returns a Perl scalar.
  
  =cut
  
  sub value { desurrogify ${+shift}->{value} }
  
  =item value16
  
  Returns a Perl scalar containing a UTF-16 string (i.e., with surrogate
  pairs if the string has chars outside the BMP). This is here more for
  internal usage than anything else.
  
  =cut
  
  sub value16 { ${+shift}->{value} }
  
  
  
  sub is_readonly {
  	my $self = shift;
  	$_[0] eq 'length' and return 1;
  	SUPER::is_readonly $self @_;
  }
  
  sub class { 'String' }
  
  no warnings 'qw';
  our %_replace = qw/
  	$	\$
  	&	".substr($str,$-[0],$+[0]-$-[0])."
  	`	".substr($str,0,$-[0])."
  	'	".substr($str,$+[0])."
  /;
  
  sub _new_constructor {
  	my $global = shift;
  	my $f = JE::Object::Function->new({
  		name            => 'String',
  		scope            => $global,
  		function         => sub {
  			my $arg = shift;
  			defined $arg ? $arg->to_string :
  				JE::String->_new($global, '');
  		},
  		function_args    => ['args'],
  		argnames         => ['value'],
  		constructor      => sub {
  			unshift @_, __PACKAGE__;
  			goto &new;
  		},
  		constructor_args => ['scope','args'],
  	});
  
  	# E 15.5.3.2
  	$f->prop({
  		name  => 'fromCharCode',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'fromCharCode',
  			length => 1,
  			no_proto => 1,
  			function_args => ['args'],
  			function => sub {
  				my $str = '';
  				my $num;
  				for (@_) {
  					# % 2**16 is buggy in perl
  					$num = $_->to_number->value;
  					$num = 
  					  ($num < 0 ? ceil$num : floor$num)
  						% 2**16 ;
  					$str .= chr($num == $num && $num);
  						# change nan to 0
  				}
  				JE::String->_new($global, $str);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	my $proto = bless $f->prop({
  		name    => 'prototype',
  		dontenum => 1,
  		readonly => 1,
  	}), __PACKAGE__;
  	$$$proto{value} = '';
  	$global->prototype_for('String', $proto);
  
  	$proto->prop({
  		name  => 'toString',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'toString',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				my $self = shift;
  				die JE::Object::Error::TypeError->new(
  					$global, add_line_number
  					"Argument to toString is not a " .
  					"String object"
  				) unless $self->class eq 'String';
  
  				return $self if ref $self eq 'JE::String';
  				JE::String->_new($global, $$$self{value});
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'valueOf',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'valueOf',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				my $self = shift;
  				die JE::Object::Error::TypeError->new(
  					$global, add_line_number
  					"Argument to valueOf is not a " .
  					"String object"
  				) unless $self->class eq 'String';
  
  				# We also deal with plain strings here.
  				ref $self eq 'JE::String'
  				 ? $self
  				 : JE::String->_new(
  				    $global, $$$self{value}
  				   );
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'charAt',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'charAt',
  			argnames => ['pos'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my ($self,$pos) = @_;
  				
  				my $str = $self->to_string->value16;
  				if (defined $pos) {
  					$pos = int $pos->to_number->[0];
  					$pos = 0 unless $pos == $pos;
  				}
  
  				JE::String->_new($global,
  					$pos < 0 || $pos >= length $str
  						? ''
  						: substr $str, $pos, 1);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'charCodeAt',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'charCodeAt',
  			argnames => ['pos'],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my ($self,$pos) = @_;
  				
  				my $str = $self->to_string->value16;
  				if (defined $pos) {
  					$pos = int $pos->to_number->[0];
  					$pos = 0 unless $pos == $pos;
  				}
  
  				JE::Number->new($global,
  					$pos < 0 || $pos >= length $str
  					    ? 'nan'
  					    : ord substr $str, $pos, 1);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'concat',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'concat',
  			length => 1,
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my $str = '';
  				for (@_) {
  					$str .= $_->to_string->value16
  				}
  				JE::String->_new($global, $str);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'indexOf',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'indexOf',
  			length => 1,
  			argnames => [qw/searchString position/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my $str = shift->to_string->value16;
  				my $find = defined $_[0]
  						? $_[0]->to_string->value16
  						: 'undefined';
  				my $start = defined $_[1]
  							? $_[1]->to_number
  								->value
  							: 0;
  				JE::Number->new($global,
  					# In -DDEBUGGING builds of perl (as
  					# of 5.13.2), a $start greater than
  					# the length causes a panick, so we
  					# avoid passing that to index(), as
  					# of version 0.049.
  					$start > length $str
  					? length $find ? -1 : length $str
  					: index $str, $find, $start
  				);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'lastIndexOf',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'lastIndexOf',
  			length => 1,
  			argnames => [qw/searchString position/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my $string = shift->to_string->value16;
  				my $pos = length $string;
  				if(defined $_[1] && $_[1]->id ne 'undef') {
  					my $p = $_[1]->to_number->value;
  					$p < $pos and $pos = $p
  				}
  				JE::Number->new($global, rindex
  					$string,
  					defined $_[0]
  						? $_[0]->to_string->value16
  						: 'undefined',
  					$pos
  				);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({   # ~~~ I need to figure out how to deal with
  	                #     locale settings
  		name  => 'localeCompare',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'localeCompare',
  			argnames => [qw/that/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my($this,$that) = @_;
  				JE::Number->new($global,
  					$this->to_string->value	
  					   cmp
  					defined $that
  						? $that->to_string->value
  						: 'undefined'
  				);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'match',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'match',
  			argnames => [qw/regexp/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my($str, $re_obj) = @_;
  
  				$str = $str->to_string;
  
  				!defined $re_obj || 
  				    (eval{$re_obj->class}||'') ne 'RegExp'
  				 and do {
  				      require JE::Object::RegExp;
  				      $re_obj =	
  					JE::Object::RegExp->new($global, 
  						$re_obj);
  				     };
  		
  				my $re = $re_obj->value;
  
  				# For non-global patterns and string, reg-
  				# exps, just return the fancy array result-
  				# from a call to String.prototype.exec
  
  				if (not $re_obj->prop('global')->value) {
  					return $global
  						->prototype_for('RegExp')
  						->prop('exec')
  						->apply($re_obj, $str);
  				}
  
  				# For global patterns, I just do the
  				# matching here, since it's faster.
  
  				# ~~~ Problem: This is meant to call String
  				#   .prototype.exec, according to the spec,
  				#  which method can, of course, be replaced
  				# with a user-defined function. So much for
  				# this optimisation. (But, then, no one
  				# else follows the spec!)
  				
  				$str = $str->value16;
  
  				my @ary;
  				while($str =~ /$re/g) {
  					push @ary, JE::String->_new($global,
  						substr $str, $-[0],
  						$+[0] - $-[0]);
  				}
  				
  				JE::Object::Array->new($global, \@ary);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'replace',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'replace',
  			argnames => [qw/searchValue replaceValue/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my($str, $foo, $bar) = @_;
  					# as in s/foo/bar/
  
  				$str = $str->to_string->value16;
  
  				my $g; # global?
  				if(defined $foo && $foo->can('class') &&
  					$foo->class eq 'RegExp') 
  				{
  					$g = $foo->prop('global')->value;
  					$foo = $$$foo{value};
  				}
  				else {
  				    $g = !1;
  				    $foo = defined $foo
  				       ? quotemeta $foo->to_string->value16
  				       : 'undefined';
  				}
  
  				if (defined $bar && $bar->can('class') &&
  				    $bar->class eq 'Function') {
  					my $replace = sub {
  					    $global
  					     ->prototype_for('RegExp')
  					     ->prop('constructor')
  					     ->capture_re_vars($str);
  					
  					    $_[0]->call(
  					      JE::String->_new($global,
  					        substr $str, $-[0],
  					          $+[0] - $-[0]),
  					      map(JE::String->_new(
  					        $global,
  					        $JE'Object'RegExp'Match[$_]
  					      ), 1..$#+),
  					      JE::Number->new($global,
  					        $-[0]),
  					      $_[1]
  					    )->to_string->value16
  					};
  
  					my $je_str = JE::String->_new(
  						$global, $str);
  
  					$g
  					? $str =~ s/$foo/
  					    &$replace($bar, $je_str)
  					/ge
  					: $str =~ s/$foo/
  					    &$replace($bar, $je_str)
  					/e
  				}
  				else {
  					# replacement string instead of
  					# function (a little tricky)
  
  					# We need to use /ee and surround
  					# bar with double quotes, so that
  					# '$1,$2' becomes eval  '"$1,$2"'.
  					# And so we also have to quotemeta
  					# the whole string.
  
  					# I know the indiscriminate
  					# untainting may seem a little
  					# dangerous, but quotemeta takes
  					# care of it.
  					$bar = defined $bar
  					   ? do {
  					      $bar->to_string->value16
  					          =~ /(.*)/s; # untaint
  					      quotemeta $1
  					   }
  					   : 'undefined';
  
  					# now $1, $&, etc have become \$1,
  					# \$\& ...
  
  					$bar =~ s/\\\$(?:
  						\\([\$&`'])
  						  |
  						([1-9][0-9]?|0[0-9])
  					)/
  						defined $1 ? $_replace{$1}
  						: "\$JE::Object::RegExp::"
  						. "Match[$2]";
  					/gex;
  
  					my $orig_str = $str;
  					no warnings 'uninitialized';
  					$g ? $str =~ s/$foo/qq'"$bar"'/gee
  					   : $str =~ s/$foo/qq'"$bar"'/ee
  					and
  					 $global
  					  ->prototype_for('RegExp')
  					  ->prop('constructor')
  					  ->capture_re_vars($orig_str);
  				}
  					
  				JE::String->_new($global, $str);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'search',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'search',
  			argnames => [qw/regexp/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function =>
  sub {
  	my($str, $re) = @_;
  
  	$re = defined $re ?(eval{$re->class}||'')eq 'RegExp' ? $re->value :
  		do {
  		  require JE::Object::RegExp;
  		  JE::Object::RegExp->new($global, $re)->value
  		} : qr//;
  
  	return JE::Number->new(
  	 $global,
  	 ($str = $str->to_string->value16) =~ $re
  	  ? scalar(
  	     $global->prototype_for('RegExp')
  	      ->prop('constructor')
  	      ->capture_re_vars($str),
  	     $-[0]
  	    )
  	  :-1
  	);
  }
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'slice',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'slice',
  			argnames => [qw/start end/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  my($str, $start, $end) = @_;
  
  $str = $str->to_string->value16;
  my $length = length $str;
  
  if (defined $start) {
  	$start = int $start->to_number->value;
  	$start = $start == $start && $start; # change nan to 0
  
  	$start >= $length and return JE::String->_new($global, '');
  #	$start < 0 and $start = 0;
  }
  else { $start =  0; }
  
  if (defined $end && $end->id ne 'undef') {
  	$end = int $end->to_number->value;
  	$end = $end == $end && $end;
  
  	$end > 0 and $end -= $start + $length * ($start < 0);
  }
  else { $end = $length }
  
  return  JE::String->_new($global, substr $str, $start, $end);
  
  			},
  		}),
  		dontenum => 1,
  	});
  
  
  =begin split-notes
  
  If the separator is a non-empty string, we need to quotemeta it.
  
  If we have an empty string, we mustnt allow a match at the end of the
  string, so we use qr/(?!\z)/.
  
  If we have a regexp, then there are several issues:
  
  A successful zero-width match that occurs at the same position as
  the end of the previous match needs to be turned into a failure
  (no backtracking after the initial successful match), so as to
  produce the aardvark result below. We could accomplish this by
  wrapping it in an atomic group: /(?> ... )/. But then we come
  to the second issue:
  
  To ensure correct (ECMAScript-compliant) capture erasure in cases
  like 'cbazyx'.split(/(a|(b))+/) (see 15.10-regexps-objects.t), we need to
  use @JE::Object::RegExp::Match, rather than $1, $2, etc.
  
  This precludes the use of perls split operator (at least for regexp sepa-
  rators), so we have to implement it ourselves.
  
  We also need to make sure that a null match does not occur at the end of
  a string. Since a successful match that begins at the end of a string can-
  not but be a zero-length match,  we could conceptually put (?!\z)  at the
  beginning of the match,  but qr/...$a_qr_with_embedded_code/ causes weird
  scoping issues (the embedded code, although it was compiled in a separate
  package,  somehow makes its way into the package that combined it  in  a
  larger regexp); hence the somewhat complex logic below.
  
  
  join ',', split /a*?/, 'aardvark'       gives ',,r,d,v,,r,k'
  'aardvark'.split(/a*?/).toString()      gives 'a,a,r,d,v,a,r,k'
  
  -----
  JS's 'aardvark'.split('', 3) means (split //, 'aardvark', 4)[0..2]
  
  =end split-notes
  
  =cut
  
  
  	$proto->prop({
  		name  => 'split',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'split',
  			argnames => [qw/separator limit/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  				my($str, $sep, $limit) = @_;
  
  				$str = (my $je_str = $str->to_string)
  					->value16;
  
  				if(!defined $limit ||
  				   $limit->id eq 'undef') {
  					$limit = -2;
  				}
  				elsif(defined $limit) {
  				  $limit = int($limit->to_number->value)
  				    % 2 ** 32;
  				  $limit = $limit == $limit && $limit;
  				    # Nan --> 0
  				}
  				
  				if (defined $sep) {
  				  if ($sep->can('class')
  				      && $sep->class eq 'RegExp') {
  				    $sep = $sep->value;
  				  }
  				  elsif($sep->id eq 'undef') {
  				    return JE::Object::Array->new(
  				      $global, $je_str
  				    );
  				  }
  				  else {
  				    $sep = $sep->to_string->value16;
  				  }
  				}
  				else {
  				    return JE::Object::Array->new(
  				      $global, $je_str
  				    );
  				}
  				
  				my @split;
  
  				if (!ref $sep) {
  				  $sep = length $sep ? quotemeta $sep :
  				    qr/(?!\z)/;
  				  @split = split $sep, $str, $limit+1;
  				  goto returne;
  				}
  
  				!length $str and
  				  ''=~ $sep || (@split = ''),
  				  goto returne;
  				
  				my$pos = 0;
  				while($str =~ /$sep/gc) {
  				  $pos == pos $str and ++pos $str, next;
  				    # That ++pos wont go past the end of
  				    # the string, so it may end up being a
  				    # no-op;  but the  next  bypasses the
  				    # pos assignment below, so perl refuses
  				    # to match again at the same  position.
  				  $-[0] == length $str and last;
  				  push @split,substr($str,$pos,$-[0]-$pos),
  				    @JE::Object::RegExp::Match[
  				      1..$#JE::Object::RegExp::Match
  				    ];
  				  $pos = pos $str = pos $str;
  				    # Assigning pos to itself has the same
  				    # effect as using an atomic group
  				    # with split
  				}
  				push @split, substr($str, $pos);
  
  				returne:
  				JE::Object::Array->new($global,
  				  $limit == -2 ? @split : @split ? @split[
  				    0..(@split>$limit?$limit-1:$#split)
  				  ] : @split);
  
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'substring',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'substring',
  			argnames => [qw/start end/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  my($str, $start, $end) = @_;
  
  $str = $str->to_string->value16;
  my $length = length $str;
  
  
  if (defined $start) {
  	$start = int $start->to_number->value;
  	$start >= 0 or $start = 0;
  }
  else { $start =  0; }
  
  
  if (!defined $end || $end->id eq 'undef') {
  	$end = $length;
  }
  else {
  	$end = int $end->to_number->value;
  	$end >= 0 or $end = 0;
  }
  
  $start > $end and ($start,$end) = ($end,$start);
  
  no warnings 'substr'; # in case start > length
  my $x= substr $str, $start, $end-$start;
  return  JE::String->_new($global, defined $x ? $x : '');
  
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'toLowerCase',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'toLowerCase',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				my $str = shift;
  
  				JE::String->_new($global,
  					lc $str->to_string->value16);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'toLocaleLowerCase',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'toLocaleLowerCase',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub { # ~~~ locale settings?
  				my $str = shift;
  
  				JE::String->_new($global,
  					lc $str->to_string->value);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'toUpperCase',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'toUpperCase',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub {
  				my $str = shift;
  
  				JE::String->_new($global,
  					uc $str->to_string->value16);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'toLocaleUpperCase',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'toLocaleUpperCase',
  			no_proto => 1,
  			function_args => ['this'],
  			function => sub { # ~~~ locale settings?
  				my $str = shift;
  
  				JE::String->_new($global,
  					uc $str->to_string->value);
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$proto->prop({
  		name  => 'substr',
  		value => JE::Object::Function->new({
  			scope  => $global,
  			name   => 'substr',
  			argnames => [qw/start length/],
  			no_proto => 1,
  			function_args => ['this','args'],
  			function => sub {
  my($str, $start, $len) = @_;
  
  $str = $str->to_string->value16;
  
  if (defined $start) {
  	$start = int $start->to_number->value;
  }
  else { $start =  0; }
  
  
  if (!defined $len || $len->id eq 'undef') {
  	$len = undef;
  }
  else {
  	$len = int $len->to_number->value;
  }
  
  return  JE::String->_new($global, defined $len ?
  	(substr $str, $start, $len) :
  	(substr $str, $start)
  );
  
  			},
  		}),
  		dontenum => 1,
  	});
  
  	$f;
  }
  
  
  
  return "a true value";
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item JE
  
  =item JE::Types
  
  =item JE::String
  
  =item JE::Object
  
  =back
  
  =cut
  
  
  
  
JE_OBJECT_STRING

$fatpacked{"JE/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_PARSER';
  package JE::Parser;
  
  our $VERSION = '0.066';
  
  use strict;  # :-(
  use warnings;# :-(
  no warnings 'utf8';
  
  use Scalar::Util 'blessed';
  
  require JE::Code  ;
  require JE::Number; # ~~~ Don't want to do this
  
  import JE::Code 'add_line_number';
  sub add_line_number;
  
  our ($_parser, $global, @_decls, @_stms, $_vars);
  
  #----------METHODS---------#
  
  sub new {
  	my %self = (
  		stm_names => [qw[
  			-function block empty if while with for switch try
  			 labelled var do continue break return throw expr
  		]],
  		stm => {
  			-function => \&function,  block    => \&block,
  			 empty    => \&empty,     if       => \&if,
  			 while    => \&while,     with     => \&with,
  			 for      => \&for,       switch   => \&switch,
  			 try      => \&try,       labelled => \&labelled,
  			 var      => \&var,       do       => \&do,
  			 continue => \&continue,  break    => \&break,
  			 return   => \&return,    throw    => \&throw,
  			 expr     => \&expr_statement,
  		},
  		global => pop,
  	);
  	return bless \%self, shift;
  }
  
  sub add_statement {
  	my($self,$name,$parser) = shift;
  	my $in_list;
  #	no warnings 'exiting';
  	grep $_ eq $name && ++$in_list && goto END_GREP,
  		@{$$self{stm_names}};
  	END_GREP: 
  	$in_list or unshift @{$$self{stm_names}} ,$name;
  	$$self{stm}{$name} = $parser;
  	return; # Don't return anything for now, because if we return some-
  	        # thing, even if it's not documented, someone might start
  		# relying on it.
  }
  
  sub delete_statement {
  	my $self = shift;
  	for my $name (@_) {
  		delete $$self{stm}{$name};
  		@{$$self{stm_names}} =
  			grep $_ ne $name, @{$$self{stm_names}};
  	}
  	return $self;
  }
  
  sub statement_list {
  	$_[0]{stm_names};
  }
  
  sub parse {
  	local $_parser = shift;
  	local(@_decls, @_stms); # Doing this here and localising it saves
  	for(@{$_parser->{stm_names}}) { # us from having to do it multiple
  		push @{/^-/ ? \@_decls : \@_stms}, # times.
  			$_parser->{stm}{$_};
  	}
  
  	JE::Code::parse($_parser->{global}, @_);
  }
  
  sub eval {
  	shift->parse(@_)->execute
  }
  
  #----------PARSER---------#
  
  use Exporter 5.57 'import';
  
  our @EXPORT_OK = qw/ $h $n $optional_sc $ss $s $S $id_cont
                       str num skip ident expr expr_noin statement
                       statements expected optional_sc/;
  our @EXPORT_TAGS = (
  	vars => [qw/ $h $n $optional_sc $ss $s $S $id_cont/],
  	functions => [qw/ str num skip ident expr expr_noin statement
                            statements expected optional_sc /],
  );
  
  use re 'taint';
  #use subs qw'statement statements assign assign_noin expr new';
  use constant JECE => 'JE::Code::Expression';
  use constant JECS => 'JE::Code::Statement';
  
  require JE::String;
  import JE::String 'desurrogify';
  import JE::String 'surrogify';
  sub desurrogify($);
  sub surrogify($);
  
  
  # die is called with a scalar ref when the  string  contains  what  is
  # expected. This will be converted to a longer message afterwards, which
  # will read something like "Expected %s but found %s"  (probably the most
  # common error message, which is why there is a shorthand). Using an array
  # ref is the easiest way to stop the 'at ..., line ...' from being appended
  # when there is no line break at the end already.  die  is  called  with  a
  # double reference to a  string  if  the  string  is  the  complete  error
  # message.
  # ~~~ We may need a function for this second usage, in case we change the
  #     \\ yet again.
  
  # @ret != push @ret, ...  is a funny way of pushing and then checking to
  # see whether anything was pushed.
  
  
  sub expected($) { # public
  	die \shift
  }
  
  
  # public vars:
  
  # optional horizontal comments and whitespace
  our $h = qr(
  	(?> [ \t\x0b\f\xa0\p{Zs}]* ) 
  	(?> (?>/\*[^\cm\cj\x{2028}\x{2029}]*?\*/) [ \t\x0b\f\xa0\p{Zs}]* )?
  )x;
  
  # line terminators
  our $n = qr((?>[\cm\cj\x{2028}\x{2029}]));
  
  # single space char
  our $ss = qr((?>[\p{Zs}\s\ck\x{2028}\x{2029}]));
  
  # optional comments and whitespace
  our $s = qr((?>
  	(?> $ss* )
  	(?> (?> //[^\cm\cj\x{2028}\x{2029}]* (?>$n|\z) | /\*.*?\*/ )
  	    (?> $ss* )
  	) *
  ))sx;
  
  # mandatory comments/whitespace
  our $S = qr(
  	(?>
  	  $ss
  	    |
  	  //[^\cm\cj\x{2028}\x{2029}]*
  	    |
  	  /\*.*?\*/
  	)
  	$s
  )xs;
  
  our $id_cont = qr(
  	(?>
  	  \\u([0-9A-Fa-f]{4})
  	    |
  	  [\p{ID_Continue}\$_]
  	)
  )x;
  
  # end public vars
  
  
  sub str() { # public
          # For very long strings (>~45000), this pattern hits a perl bug (Complex regular subexpression recursion limit (32766) exceeded) 
  	#/\G (?: '((?>(?:[^'\\] | \\.)*))'
  	#          |
  	#        "((?>(?:[^"\\] | \\.)*))"  )/xcgs or return;
  	# There are two solutions:
  	# 1) Use the unrolling technique from the Owl Book.
  	# 2) Use shorter patterns but more code (contributed by Kevin
  	#    Cameron)
  	# Number 1 should be faster, but it crashes under perl 5.8.8 on
  	# Windows, and perhaps on other platforms, too. So we use #2 for
  	# 5.8.x regardless of platform to be on the safe side.
  
  	use constant old_perl => $] < 5.01;        # Use a constant so the
  	my $yarn;                                   # if-block disappears
  	if(old_perl) {                              # at compile-time.
  		# Use a simpler pattern (but more code) to break strings up
  		# into extents bounded by the quote or escape
  		my $qt = substr($_,pos($_),1);
  		$qt =~ /['"]/ or return; # not a string literal if first
  		pos($_)++;               # char not a quote
  		my $done = 0;
  		while (defined(substr($_,pos($_),1))) {
  		    my ($part) = /\G([^\\$qt]*)/xcgs;
  		    defined($part) or $part = "";
  		    $yarn .= $part;
  		    my $next = substr($_,pos($_)++,1);
  
  		    if ($next eq "\\") {
  		        #pass on any escaped char
  		        $next = substr($_,pos($_)++,1);
  		        $yarn .= "\\$next";
  		    } else {
  		        # handle end quote
  		        $done = 1;
  		        last;
  		    }
  		}
  
  		# error if EOF before end of string
          	return if !$done;
  	}
  	else {
  		/\G (?: '([^'\\]*(?:\\.[^'\\]*)*)'
  		          |
  		        "([^"\\]*(?:\\.[^"\\]*)*)"  )/xcgs or return;
  		$yarn = $+;
  	}
  # Get rid of that constant, as its no longer needed.
  BEGIN { no strict; delete ${__PACKAGE__.'::'}{old_perl}; }
  
          # transform special chars
  	no re 'taint'; # I need eval "qq-..." to work
  	$yarn =~ s/\\(?:
  		u([0-9a-fA-F]{4})
  		 |
  		x([0-9a-fA-F]{2})
  		 |
                  (\r\n?|[\n\x{2028}\x{2029}])
  		 |
  		([bfnrt])
  		 |
  		(v)
  		 |
  		([0-3][0-7]{0,2}|[4-7][0-7]?) # actually slightly looser
  		 |                    # than what ECMAScript v3 has in its
  		(.)           # addendum (it forbids \0 when followed by 8)
  	)/
  		$1 ? chr(hex $1) :
  		$2 ? chr(hex $2) :
                  $3 ? "" :               # escaped line feed disappears
  		$4 ? eval "qq-\\$4-" :
  		$5 ? "\cK" :
  		defined $6 ? chr oct $6 :
  		$7
  	/sgex;
  	"s$yarn";
  }
  
  sub  num() { # public
  	/\G (?:
  	  0[Xx] ([A-Fa-f0-9]+)
  	    |
  	  0 ([01234567]+)
  	    |
  	  (?=[0-9]|\.[0-9])
  	  (
  	    (?:0|[1-9][0-9]*)?
  	    (?:\.[0-9]*)?
  	    (?:[Ee][+-]?[0-9]+)?
  	  )
  	) /xcg
  	or return;
  	return defined $1 ? hex $1 : defined $2 ? oct $2 : $3;
  }
  
  our $ident = qr(
            (?! (?: case | default )  (?!$id_cont) )
  	  (?:
  	    \\u[0-9A-Fa-f]{4}
  	      |
  	    [\p{ID_Start}\$_]
  	  )
  	  (?> $id_cont* )
  )x;
  
  sub unescape_ident($) {
  	my $ident = shift;
  	$ident =~ s/\\u([0-9a-fA-F]{4})/chr hex $1/ge;
  	$ident = desurrogify $ident;
  	$ident =~ /^[\p{ID_Start}\$_]
  	            [\p{ID_Continue}\$_]*
  	          \z/x
  	  or die \\"'$ident' is not a valid identifier";
  	$ident;
  }
  
   # public
  sub skip() { /\G$s/g } # skip whitespace
  
  sub ident() { # public
  	return unless my($ident) = /\G($ident)/cgox;
  	unescape_ident $ident;
  }
  
  sub params() { # Only called when we know we need it, which is why it dies
                  # on the second line
  	my @ret;
  	/\G\(/gc or expected "'('";
  	&skip;
  	if (@ret != push @ret, &ident) { # first identifier (not prec.
  	                               # by comma)
  		while (/\G$s,$s/gc) {
  			# if there's a comma we need another ident
  			@ret != push @ret, &ident or expected 'identifier';
  		}
  		&skip;
  	}
  	/\G\)/gc or expected "')'";
  	\@ret;
  }
  
  sub term() {
  	my $pos = pos;
  	my $tmp;
  	if(/\Gfunction(?!$id_cont)$s/cg) {
  		my @ret = (func => ident);
  		@ret == 2 and &skip;
  		push @ret, &params;
  		&skip;
  		/\G \{ /gcx or expected "'{'";
  		{
  			local $_vars = [];
  			push @ret, &statements, $_vars;
  		}
  		/\G \} /gocx or expected "'}'";
  
  		return bless [[$pos, pos], @ret], JECE;
  	}
  	# We dont call the ident subroutine here,
  	# because we need to sift out null/true/false/this.
  	elsif(($tmp)=/\G($ident)/cgox) {
  		$tmp=~/^(?:(?:tru|fals)e|null)\z/ &&return $global->$tmp;
  		$tmp eq 'this' and return $tmp;
  		return "i" . unescape_ident $tmp;
  	}
  	elsif(defined($tmp = &str) or
  	      defined($tmp = &num)) {
  		return $tmp;
  	}
  	elsif(m-\G
  		/
  		( (?:[^/*\\[] | \\. | \[ (?>(?:[^]\\] | \\.)*) \] )
  		  (?>(?:[^/\\[] | \\. | \[ (?>(?:[^]\\] | \\.)*) \] )*) )
  		/
  	  	($id_cont*)
  	      -cogx ) {
  
  		#  I have to use local *_ because
  		# 'require JE::Object::RegExp' causes
  		#  Scalar::Util->import() to be called (import is inherited
  		#  from Exporter), and  &Exporter::import does  'local $_',
  		#  which,  in p5.8.8  (though not  5.9.5)  causes  pos()
  		#  to be reset.
  		{ local *_; require JE::Object::RegExp; }
  # ~~~ This needs to unescape the flags.
  		return JE::Object::RegExp->new( $global, $1, $2);
  	}
  	elsif(/\G\[$s/cg) {
  		my $anon;
  		my @ret;
  		my $length;
  
  		while () {
  			@ret != ($length = push @ret, &assign) and &skip;
  			push @ret, bless \$anon, 'comma' while /\G,$s/cg;
  			$length == @ret and last;
  		}
  
  		/\G]/cg or expected "']'";
  		return bless [[$pos, pos], array => @ret], JECE;
  	}
  	elsif(/\G\{$s/cg) {
  		my @ret;
  
  		if($tmp = &ident or defined($tmp = &str)&&$tmp=~s/^s// or
  				defined($tmp = &num)) {
  			# first elem, not preceded by comma
  			push @ret, $tmp;
  			&skip;
  			/\G:$s/cggg or expected 'colon';
  			@ret != push @ret, &assign
  				or expected \'expression';
  			&skip;
  
  			while (/\G,$s/cg) {
  				$tmp = ident
  				or defined($tmp = &str)&&$tmp=~s/^s// or
  					defined($tmp = &num)
  				or do {
  					# ECMAScript 5 allows a
  					# trailing comma
  					/\G}/cg or expected
  					 "'}', identifier, or string or ".
  					 " number literal";
  					return bless [[$pos, pos],
  					              hash => @ret], JECE;
  				};
  
  				push @ret, $tmp;
  				&skip;
  				/\G:$s/cggg or expected 'colon';
  				@ret != push @ret, &assign
  					or expected 'expression';
  				&skip;
  			}
  		}
  		/\G}/cg or expected "'}'";
  		return bless [[$pos, pos], hash => @ret], JECE;
  	}
  	elsif (/\G\($s/cg) {
  		my $ret = &expr or expected 'expression';
  		&skip;
  		/\G\)/cg or expected "')'";
  		return $ret;
  	}
  	return
  }
  
  sub subscript() { # skips leading whitespace
  	my $pos = pos;
  	my $subscript;
  	if (/\G$s\[$s/cg) {
  		$subscript = &expr or expected 'expression';
  		&skip;
  		/\G]/cog or expected "']'";
  	}
  	elsif (/\G$s\.$s/cg) {
  		$subscript = &ident or expected 'identifier';
  	} 
  	else { return }
  
  	return bless [[$pos, pos], $subscript], 'JE::Code::Subscript';
  }
  
  sub args() { # skips leading whitespace
  	my $pos = pos;
  	my @ret;
  	/\G$s\($s/gc or return;
  	if (@ret != push @ret, &assign) { # first expression (not prec.
  	                               # by comma)
  		while (/\G$s,$s/gc) {
  			# if there's a comma we need another expression
  			@ret != push @ret, &assign
  				or expected 'expression';
  		}
  		&skip;
  	}
  	/\G\)/gc or expected "')'";
  	return bless [[$pos, pos], @ret], 'JE::Code::Arguments';
  }
  
  sub new_expr() {
  	/\G new(?!$id_cont) $s /cgx or return;
  	my $ret = bless [[pos], 'new'], JECE;
  	
  	my $pos = pos;
  	my @member_expr = &new_expr || &term
  		|| expected "identifier, literal, 'new' or '('";
  
  	0 while @member_expr != push @member_expr, &subscript;
  
  	push @$ret, @member_expr == 1 ? @member_expr :
  		bless [[$pos, pos], 'member/call', @member_expr],
  		      JECE;
  	push @$ret, args;
  	$ret;
  }
  
  sub left_expr() {
  	my($pos,@ret) = pos;
  	@ret != push @ret, &new_expr || &term or return;
  
  	0 while @ret != push @ret, &subscript, &args;
  	@ret ? @ret == 1 ? @ret : 
  		bless([[$pos, pos], 'member/call', @ret],
  			JECE)
  		: return;
  }
  
  sub postfix() {
  	my($pos,@ret) = pos;
  	@ret != push @ret, &left_expr or return;
  	push @ret, $1 while /\G $h ( \+\+ | -- ) /cogx;
  	@ret == 1 ? @ret : bless [[$pos, pos], 'postfix', @ret],
  		JECE;
  }
  
  sub unary() {
  	my($pos,@ret) = pos;
  	push @ret, $1 while /\G $s (
  	    (?: delete | void | typeof )(?!$id_cont)
  	      |
  	    \+\+? | --? | ~ | !
  	) $s /cgx;
  	@ret != push @ret, &postfix or (
  		@ret
  		? expected "expression"
  		: return
  	);
  	@ret == 1 ? @ret : bless [[$pos, pos], 'prefix', @ret],
  		JECE;
  }
  
  sub multi() {
  	my($pos,@ret) = pos;
  	@ret != push @ret, &unary or return;
  	while(m-\G $s ( [*%](?!=) | / (?![*/=]) ) $s -cgx) {
  		push @ret, $1;
  		@ret == push @ret, &unary and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub add() {
  	my($pos,@ret) = pos;
  	@ret != push @ret, &multi or return;
  	while(/\G $s ( \+(?![+=]) | -(?![-=]) ) $s /cgx) {
  		push @ret, $1;
  		@ret == push @ret, &multi and expected 'expression'
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub bitshift() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &add and return;
  	while(/\G $s (>>> | >>(?!>) | <<)(?!=) $s /cgx) {
  		push @ret, $1;
  		@ret == push @ret, &add and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub rel() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &bitshift and return;
  	while(/\G $s ( ([<>])(?!\2|=) | [<>]= |
  	               in(?:stanceof)?(?!$id_cont) ) $s /cgx) {
  		push @ret, $1;
  		@ret== push @ret, &bitshift and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub rel_noin() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &bitshift and return;
  	while(/\G $s ( ([<>])(?!\2|=) | [<>]= | instanceof(?!$id_cont) )
  	          $s /cgx) {
  		push @ret, $1;
  		@ret == push @ret, &bitshift and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub equal() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &rel and return;
  	while(/\G $s ([!=]==?) $s /cgx) {
  		push @ret, $1;
  		@ret == push @ret, &rel and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub equal_noin() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &rel_noin and return;
  	while(/\G $s ([!=]==?) $s /cgx) {
  		push @ret, $1;
  		@ret == push @ret, &rel_noin and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub bit_and() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &equal and return;
  	while(/\G $s &(?![&=]) $s /cgx) {
  		@ret == push @ret, '&', &equal and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub bit_and_noin() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &equal_noin and return;
  	while(/\G $s &(?![&=]) $s /cgx) {
  		@ret == push @ret, '&', &equal_noin
  			and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub bit_or() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &bit_and and return;
  	while(/\G $s \|(?![|=]) $s /cgx) {
  		@ret == push @ret, '|', &bit_and and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub bit_or_noin() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &bit_and_noin and return;
  	while(/\G $s \|(?![|=]) $s /cgx) {
  		@ret == push @ret, '|', &bit_and_noin
  			and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub bit_xor() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &bit_or and return;
  	while(/\G $s \^(?!=) $s /cgx) {
  		@ret == push @ret, '^', &bit_or and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub bit_xor_noin() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &bit_or_noin and return;
  	while(/\G $s \^(?!=) $s /cgx) {
  		@ret == push @ret, '^', &bit_or_noin
  			and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub and_expr() { # If I just call it 'and', then I have to write
                   # CORE::and for the operator! (Far too cumbersome.)
  	my($pos,@ret) = pos;
  	@ret == push @ret, &bit_xor and return;
  	while(/\G $s && $s /cgx) {
  		@ret == push @ret, '&&', &bit_xor
  			and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub and_noin() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &bit_xor_noin and return;
  	while(/\G $s && $s /cgx) {
  		@ret == push @ret, '&&', &bit_xor_noin
  			and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub or_expr() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &and_expr and return;
  	while(/\G $s \|\| $s /cgx) {
  		@ret == push @ret, '||', &and_expr
  			and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub or_noin() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &and_noin and return;
  	while(/\G $s \|\| $s /cgx) {
  		@ret == push @ret, '||', &and_noin
  			and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'lassoc', @ret],
  		JECE;
  }
  
  sub assign() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &or_expr and return;
  	while(m@\G $s ((?>(?: [-*/%+&^|] | << | >>>? )?)=) $s @cgx) {
  		push @ret, $1;
  		@ret == push @ret, &or_expr and expected 'expression';
  	}
  	if(/\G$s\?$s/cg) {
  		@ret == push @ret, &assign and expected 'expression';
  		&skip;
  		/\G:$s/cg or expected "colon";
  		@ret == push @ret, &assign and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'assign', @ret],
  		JECE;
  }
  
  sub assign_noin() {
  	my($pos,@ret) = pos;
  	@ret == push @ret, &or_noin and return;
  	while(m~\G $s ((?>(?: [-*/%+&^|] | << | >>>? )?)=) $s ~cgx) {
  		push @ret, $1;
  		@ret == push @ret, &or_noin and expected 'expression';
  	}
  	if(/\G$s\?$s/cg) {
  		@ret == push @ret, &assign and expected 'expression';
  		&skip;
  		/\G:$s/cg or expected "colon";
  		@ret == push @ret, &assign_noin and expected 'expression';
  	}
  	@ret == 1 ? @ret : bless [[$pos, pos], 'assign', @ret],
  		JECE;
  }
  
  sub expr() { # public
  	my $ret = bless [[pos], 'expr'], JECE;
  	@$ret == push @$ret, &assign and return;
  	while(/\G$s,$s/cg) {
  		@$ret == push @$ret,& assign and expected 'expression';
  	}
  	push @{$$ret[0]},pos;
  	$ret;
  }
  
  sub expr_noin() { # public
  	my $ret = bless [[pos], 'expr'], JECE;
  	@$ret == push @$ret, &assign_noin and return;
  	while(/\G$s,$s/cg) {
  		@$ret == push @$ret, &assign_noin
  			and expected 'expression';
  	}
  	push @{$$ret[0]},pos;
  	$ret;
  }
  
  sub vardecl() { # vardecl is only called when we *know* we need it, so it
                  # will die when it can't get the first identifier, instead
                  # of returning undef
  	my @ret;
  	@ret == push @ret, &ident and expected 'identifier';
  	/\G$s=$s/cg and
  		(@ret != push @ret, &assign or expected 'expression');
  	push @$_vars, $ret[0];
  	\@ret;
  }
  
  sub vardecl_noin() {
  	my @ret;
  	@ret == push @ret, &ident and expected 'identifier';
  	/\G$s=$s/cg and
  		(@ret != push @ret, &assign_noin or expected 'expression');
  	push @$_vars, $ret[0];
  	\@ret;
  }
  
  sub finish_for_sc_sc() {  # returns the last two expressions of a for (;;)
                            # loop header
  	my @ret;
  	my $msg;
  	if(@ret != push @ret, expr) {
  		$msg = '';
  		&skip
  	} else {
  		push @ret, 'empty';
  		$msg = 'expression or '
  	}
  	/\G;$s/cg or expected "${msg}semicolon";
  	if(@ret != push @ret, expr) {
  		$msg = '';
  		&skip
  	} else {
  		push @ret, 'empty';
  		$msg = 'expression or '
  	}
  	/\G\)$s/cg or expected "${msg}')'";
  
  	@ret;
  }
  
  # ----------- Statement types ------------ #
  #        (used by custom parsers)
  
  our $optional_sc = # public
  		qr-\G (?:
  		    $s (?: \z | ; $s | (?=\}) )
  		      |
  
  		    # optional horizontal whitespace
  		    # then a line terminator or a comment containing one
  		    # then optional trailing whitespace
  		    $h
  		    (?: $n | //[^\cm\cj\x{2028}\x{2029}]* $n |
  		        /\* [^*\cm\cj\x{2028}\x{2029}]* 
  			    (?: \*(?!/) [^*\cm\cj\x{2028}\x{2029}] )*
  			  $n
  		          (?s:.)*?
  		        \*/
  		    )
  		    $s
  		)-x;
  
  sub optional_sc() {
  	/$optional_sc/gc or expected "semicolon, '}' or end of line";
  }
  
  sub block() {
  	/\G\{/gc or return;
  	my $ret = [[pos()-1], 'statements'];
  	&skip;
  	while() { # 'last' does not work when 'while' is a
  	         # statement modifier
  		@$ret == push @$ret, &statement and last;
  	}
  	expected "'}'" unless /\G\}$s/gc;
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub empty() {
  	my $pos = pos;
  	/\G;$s/cg or return;
  	bless [[$pos,pos], 'empty'], JECS;
  }
  
  sub function() {
  	my $pos = pos;
  	/\Gfunction$S/cg or return;
  	my $ret = [[$pos], 'function'];
  	@$ret == push @$ret, &ident
  		and expected "identifier";
  	&skip;
  	push @$ret, &params;
  	&skip;
  	/\G \{ /gcx or expected "'{'";
  	{
  		local $_vars = [];
  		push @$ret, &statements, $_vars;
  	}
  	/\G \}$s /gcx or expected "'}'";
  
  	push @{$$ret[0]},pos;
  
  	push @$_vars, $ret;
  
  	bless $ret, JECS;
  }
  
  sub if() {
  	my $pos = pos;
  	/\Gif$s\($s/cg or return;
  	my $ret = [[$pos], 'if'];
  
  	@$ret == push @$ret, &expr
  		and expected 'expression';
  	&skip;
  	/\G\)$s/gc or expected "')'";
  	@$ret != push @$ret, &statement
  		or expected 'statement';
  	if (/\Gelse(?!$id_cont)$s/cg) {
  		@$ret == push @$ret, &statement
  			and expected 'statement';
  	}
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub while() {
  	my $pos = pos;
  	/\Gwhile$s\($s/cg or return;
  	my $ret = [[$pos], 'while'];
  
  	@$ret == push @$ret, &expr
  		and expected 'expression';
  	&skip;
  	/\G\)$s/gc or expected "')'";
  	@$ret != push @$ret, &statement
  		or expected 'statement';
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub for() {
  	my $pos = pos;
  	/\Gfor$s\($s/cg or return;
  	my $ret = [[$pos], 'for'];
  
  	if (/\G var$S/cgx) {
  		push @$ret, my $var = bless
  			[[pos() - length $1], 'var'],
  			'JE::Code::Statement';
  
  		push @$var, &vardecl_noin;
  		&skip;
  		if (/\G([;,])$s/gc) {
  			# if there's a comma or sc then
  			# this is a for(;;) loop
  			if ($1 eq ',') {
  				# finish getting the var
  				# decl list
  				do{
  				    @$var ==
  				    push @$var, &vardecl 
  				    and expected
  				      'identifier'
  				} while (/\G$s,$s/gc);
  				&skip;
  				/\G;$s/cg
  				   or expected 'semicolon';
  			}
  			push @$ret, &finish_for_sc_sc;
  		}
  		else {
  			/\Gin$s/cg or expected
  			    "'in', comma or semicolon";
  			push @$ret, 'in';
  			@$ret == push @$ret, &expr
  				and expected 'expresssion';
  			&skip;
  			/\G\)$s/cg or expected "')'";
  		}
  	}
  	elsif(@$ret != push @$ret, &expr_noin) {
  		&skip;
  		if (/\G;$s/gc) {
  			# if there's a semicolon then
  			# this is a for(;;) loop
  			push @$ret, &finish_for_sc_sc;
  		}
  		else {
  			/\Gin$s/cg or expected
  				"'in' or semicolon";
  			push @$ret, 'in';
  			@$ret == push @$ret, &expr
  				and expected 'expresssion';
  			&skip;
  			/\G\)$s/cg or expected "')'";
  		}
  	}
  	else {
  		push @$ret, 'empty';
  		/\G;$s/cg
  		    or expected 'expression or semicolon';
  		push @$ret, &finish_for_sc_sc;
  	}
  
  	# body of the for loop
  	@$ret != push @$ret, &statement
  		or expected 'statement';
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub with() { # almost identical to while
  	my $pos = pos;
  	/\Gwith$s\($s/cg or return;
  	my $ret = [[$pos], 'with'];
  
  	@$ret == push @$ret, &expr
  		and expected 'expression';
  	&skip;
  	/\G\)$s/gc or expected "')'";
  	@$ret != push @$ret, &statement
  		or expected 'statement';
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub switch() {
  	my $pos = pos;
  	/\Gswitch$s\($s/cg or return;
  	my $ret = [[$pos], 'switch'];
  
  	@$ret == push @$ret, &expr
  		 and expected 'expression';
  	&skip;
  	/\G\)$s/gc or expected "')'";
  	/\G\{$s/gc or expected "'{'";
  
  	while (/\G case(?!$id_cont) $s/cgx) {
  		@$ret == push @$ret, &expr
  			and expected 'expression';
  		&skip;
  		/\G:$s/cg or expected 'colon';
  		push @$ret, &statements;
  	}
  	my $default=0;
  	if (/\G default(?!$id_cont) $s/cgx) {
  		/\G : $s /cgx or expected 'colon';
  		push @$ret, default => &statements;
  		++$default;
  	}
  	while (/\G case(?!$id_cont) $s/cgx) {
  		@$ret == push @$ret, &expr
  			and expected 'expression';
  		&skip;
  		/\G:$s/cg or expected 'colon';
  		push @$ret, &statements;
  	}
  	/\G \} $s /cgx or expected (
  		$default
  		? "'}' or 'case'"
  		: "'}', 'case' or 'default'"
  	); 
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub try() {
  	my $pos = pos;
  	/\Gtry$s\{$s/cg or return;
  	my $ret = [[$pos], 'try', &statements];
  
  	/\G \} $s /cgx or expected "'}'";
  
  	$pos = pos;
  
  	if(/\Gcatch$s/cg) {
  		/\G \( $s /cgx or expected "'('";
  		@$ret == push @$ret, &ident
  			and expected 'identifier';
  		&skip;
  		/\G \) $s /cgx or expected "')'";
  
  		/\G \{ $s /cgx or expected "'{'";
  		push @$ret, &statements;
  		/\G \} $s /cgx or expected "'}'";
  	}
  	if(/\Gfinally$s/cg) {
  		/\G \{ $s /cgx or expected "'{'";
  		push @$ret, &statements;
  		/\G \} $s /cgx or expected "'}'";
  	}
  
  	pos eq $pos and expected "'catch' or 'finally'";
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub labelled() {
  	my $pos = pos;
  	/\G ($ident) $s : $s/cgx or return;
  	my $ret = [[$pos], 'labelled', unescape_ident $1];
  
  	while (/\G($ident)$s:$s/cg) {
  		push @$ret, unescape_ident $1;
  	}
  	@$ret != push @$ret, &statement
  		or expected 'statement';
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub var() {
  	my $pos = pos;
  	/\G var $S/cgx or return;
  	my $ret = [[$pos], 'var'];
  
  	do{
  		push @$ret, &vardecl;
  	} while(/\G$s,$s/gc);
  
  	optional_sc;
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub do() {
  	my $pos = pos;
  	/\G do(?!$id_cont)$s/cgx or return;
  	my $ret = [[$pos], 'do'];
  
  	@$ret != push @$ret, &statement
  		or expected 'statement';
  	/\Gwhile$s/cg               or expected "'while'";
  	/\G\($s/cg                or expected "'('";
  	@$ret != push @$ret, &expr
  		or expected 'expression';
  	&skip;
  	/\G\)/cog or expected "')'";
  
  	optional_sc;
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub continue() {
  	my $pos = pos;
  	/\G continue(?!$id_cont)/cogx or return;
  	my $ret = [[$pos], 'continue'];
  
  	/\G$h($ident)/cog
  		and push @$ret, unescape_ident $1;
  
  	optional_sc;
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub break() { # almost identical to continue
  	my $pos = pos;
  	/\G break(?!$id_cont)/cogx or return;
  	my $ret = [[$pos], 'break'];
  
  	/\G$h($ident)/cog
  		and push @$ret, unescape_ident $1;
  
  	optional_sc;
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub return() {
  	my $pos = pos;
  	/\G return(?!$id_cont)/cogx or return;
  	my $ret = [[$pos], 'return'];
  
  	$pos = pos;
  	/\G$h/g; # skip horz ws
  	@$ret == push @$ret, &expr and pos = $pos;
  		# reverse to before the white space if
  		# there is no expr
  
  	optional_sc;
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub throw() {
  	my $pos = pos;
  	/\G throw(?!$id_cont)/cogx
  	        or return; 
  	my $ret = [[$pos], 'throw'];
  
  	/\G$h/g; # skip horz ws
  	@$ret == push @$ret, &expr and expected 'expression';
  
  	optional_sc;
  
  	push @{$$ret[0]},pos;
  
  	bless $ret, JECS;
  }
  
  sub expr_statement() {
  	my $ret = &expr or return;
  	optional_sc; # the only difference in behaviour between
  	             # this and &expr
  	$ret;
  }
  
  
  
  # -------- end of statement types----------#
  
  # This takes care of trailing white space.
  sub statement_default() {
  	my $ret = [[pos]];
  
  	# Statements that do not have an optional semicolon
  	if (/\G (?:
  		( \{ | ; )
  		  |
  		(function)$S
  		  |
  		( if | w(?:hile|ith) | for | switch ) $s \( $s
  		  |
  		( try $s \{ $s )
  		  |
  		($ident) $s : $s
  	   ) /xgc) {
  		no warnings 'uninitialized';
  		if($1 eq '{') {
  			push @$ret, 'statements';
  			&skip;
  			while() { # 'last' does not work when 'while' is a
  			         # statement modifier
  				@$ret == push @$ret, 
  					&statement_default and last;
  			}
  			
  			expected "'}'" unless /\G\}$s/gc;
  		}
  		elsif($1 eq ';') {
  			push @$ret, 'empty';
  			&skip;
  		}
  		elsif($2) {
  			push @$ret, 'function';
  			@$ret == push @$ret, &ident
  				and expected "identifier";
  			&skip;
  			push @$ret, &params;
  			&skip;
  			/\G \{ /gcx or expected "'{'";
  			{
  				local $_vars = [];
  				push @$ret, &statements, $_vars;
  			}
  			/\G \}$s /gcx or expected "'}'";
  			push @$_vars, $ret;
  		}
  		elsif($3 eq 'if') {
  			push @$ret, 'if';
  			@$ret == push @$ret, &expr
  				and expected 'expression';
  			&skip;
  			/\G\)$s/gc or expected "')'";
  			@$ret != push @$ret, &statement_default
  				or expected 'statement';
  			if (/\Gelse(?!$id_cont)$s/cg) {
  				@$ret == push @$ret, 
  					&statement_default
  					and expected 'statement';
  			}
  		}
  		elsif($3 eq 'while') {
  			push @$ret, 'while';
  			@$ret == push @$ret, &expr
  				and expected 'expression';
  			&skip;
  			/\G\)$s/gc or expected "')'";
  			@$ret != push @$ret, &statement_default
  				or expected 'statement';
  		}
  		elsif($3 eq 'for') {
  			push @$ret, 'for';
  			if (/\G var$S/cgx) {
  				push @$ret, my $var = bless
  					[[pos() - length $1], 'var'],
  					'JE::Code::Statement';
  
  				push @$var, &vardecl_noin;
  				&skip;
  				if (/\G([;,])$s/gc) {
  					# if there's a comma or sc then
  					# this is a for(;;) loop
  					if ($1 eq ',') {
  						# finish getting the var
  						# decl list
  						do{
  						    @$var ==
  						    push @$var, &vardecl 
  						    and expected
  						      'identifier'
  						} while (/\G$s,$s/gc);
  						&skip;
  						/\G;$s/cg
  						   or expected 'semicolon';
  					}
  					push @$ret, &finish_for_sc_sc;
  				}
  				else {
  					/\Gin$s/cg or expected
  					    "'in', comma or semicolon";
  					push @$ret, 'in';
  					@$ret == push @$ret, &expr
  						and expected 'expresssion';
  					&skip;
  					/\G\)$s/cg or expected "')'";
  				}
  			}
  			elsif(@$ret != push @$ret, &expr_noin) {
  				&skip;
  				if (/\G;$s/gc) {
  					# if there's a semicolon then
  					# this is a for(;;) loop
  					push @$ret, &finish_for_sc_sc;
  				}
  				else {
  					/\Gin$s/cg or expected
  						"'in' or semicolon";
  					push @$ret, 'in';
  					@$ret == push @$ret, &expr
  						and expected 'expresssion';
  					&skip;
  					/\G\)$s/cg or expected "')'";
  				}
  			}
  			else {
  				push @$ret, 'empty';
  				/\G;$s/cg
  				    or expected 'expression or semicolon';
  				push @$ret, &finish_for_sc_sc;
  			}
  
  			# body of the for loop
  			@$ret != push @$ret, &statement_default
  				or expected 'statement';
  		}
  		elsif($3 eq 'with') {
  			push @$ret, 'with';
  			@$ret == push @$ret, &expr
  				and expected 'expression';
  			&skip;
  			/\G\)$s/gc or expected "')'";
  			@$ret != push @$ret, &statement_default
  				or expected 'statement';
  		}
  		elsif($3 eq 'switch') {
  			push @$ret, 'switch';
  			@$ret == push @$ret, &expr
  				 and expected 'expression';
  			&skip;
  			/\G\)$s/gc or expected "')'";
  			/\G\{$s/gc or expected "'{'";
  
  			while (/\G case(?!$id_cont) $s/cgx) {
  				@$ret == push @$ret, &expr
  					and expected 'expression';
  				&skip;
  				/\G:$s/cg or expected 'colon';
  				push @$ret, &statements;
  			}
  			my $default=0;
  			if (/\G default(?!$id_cont) $s/cgx) {
  				/\G : $s /cgx or expected 'colon';
  				push @$ret, default => &statements;
  				++$default;
  			}
  			while (/\G case(?!$id_cont) $s/cgx) {
  				@$ret == push @$ret, &expr
  					and expected 'expression';
  				&skip;
  				/\G:$s/cg or expected 'colon';
  				push @$ret, &statements;
  			}
  			/\G \} $s /cgx or expected (
  				$default
  				? "'}' or 'case'"
  				: "'}', 'case' or 'default'"
  			); 
  		}
  		elsif($4) { # try
  			push @$ret, 'try', &statements;
  			/\G \} $s /cgx or expected "'}'";
  
  			my $pos = pos;
  
  			if(/\Gcatch$s/cg) {
  				/\G \( $s /cgx or expected "'('";
  				@$ret == push @$ret, &ident
  					and expected 'identifier';
  				&skip;
  				/\G \) $s /cgx or expected "')'";
  
  				/\G \{ $s /cgx or expected "'{'";
  				push @$ret, &statements;
  				/\G \} $s /cgx or expected "'}'";
  			}
  			if(/\Gfinally$s/cg) {
  				/\G \{ $s /cgx or expected "'{'";
  				push @$ret, &statements;
  				/\G \} $s /cgx or expected "'}'";
  			}
  
  			pos eq $pos and expected "'catch' or 'finally'";
  		}
  		else { # labelled statement
  			push @$ret, 'labelled', unescape_ident $5;
  			while (/\G($ident)$s:$s/cg) {
  				push @$ret, unescape_ident $1;
  			}
  			@$ret != push @$ret, &statement_default
  				or expected 'statement';
  		}
  	}
  	# Statements that do have an optional semicolon
  	else {
  		if (/\G var$S/xcg) {
  			push @$ret, 'var';
  
  			do{
  				push @$ret, &vardecl;
  			} while(/\G$s,$s/gc);
  		}
  		elsif(/\Gdo(?!$id_cont)$s/cg) {
  			push @$ret, 'do';
  			@$ret != push @$ret, &statement_default
  				or expected 'statement';
  			/\Gwhile$s/cg               or expected "'while'";
  			/\G\($s/cg                or expected "'('";
  			@$ret != push @$ret, &expr
  				or expected 'expression';
  			&skip;
  			/\G\)/cog or expected "')'";
  		}
  		elsif(/\G(continue|break)(?!$id_cont)/cog) {
  			push @$ret, $1;
  			/\G$h($ident)/cog
  				and push @$ret, unescape_ident $1;
  		}
  		elsif(/\Greturn(?!$id_cont)/cog) {
  			push @$ret, 'return';
  			my $pos = pos;
  			/\G$h/g; # skip horz ws
  			@$ret == push @$ret, &expr and pos = $pos;
  				# reverse to before the white space if
  				# there is no expr
  		}
  		elsif(/\Gthrow(?!$id_cont)/cog) {
  			push @$ret, 'throw';
  			/\G$h/g; # skip horz ws
  			@$ret == push @$ret, &expr
  				and expected 'expression';
  		}
  		else { # expression statement
  			$ret = &expr or return;
  		}
  
  		# Check for optional semicolon
  		m-$optional_sc-cgx
  		 or expected "semicolon, '}' or end of line";
  	}
  	push @{$$ret[0]},pos unless @{$$ret[0]} == 2; # an expr will 
  	                                             # already have this
  
  	ref $ret eq 'ARRAY' and bless $ret, 'JE::Code::Statement';
  
  	return $ret;
  }
  
  sub statement() { # public
  	my $ret;
  	for my $sub(@_stms) {
  		defined($ret = &$sub)
  			and last;
  	}
  	defined $ret ? $ret : ()
  }
  
  # This takes care of leading white space.
  sub statements() {
  	my $ret = bless [[pos], 'statements'], 'JE::Code::Statement';
  	/\G$s/g; # skip initial whitespace
  	while () { # 'last' does not work when 'while' is a
  	           # statement modifier
  		@$ret != push @$ret,
  			$_parser ? &statement : &statement_default
  			or last;
  	}
  	push @{$$ret[0]},pos;
  	return $ret;
  }
  
  sub program() { # like statements(), but it allows function declarations
                  # as well
  	my $ret = bless [[pos], 'statements'], 'JE::Code::Statement';
  	/\G$s/g; # skip initial whitespace
  	if($_parser) {
  		while () {	
  			DECL: {
  				for my $sub(@_decls) {
  					@$ret != push @$ret, &$sub
  						and redo DECL;
  				}
  			}
  			@$ret != push @$ret, &statement or last;
  		}
  	}
  	else {
  		while () {	
  			while() {
  				@$ret == push @$ret, &function and last;
  			}
  			@$ret != push @$ret, &statement_default or last;
  		}
  	}
  	push @{$$ret[0]},pos;
  	return $ret;
  }
  
  
  # ~~~ The second arg to add_line_number is a bit ridiculous. I may change
  #     add_line_number's parameter list, perhaps so it accepts either a
  #     code object, or (src,file,line) if $_[1] isn'ta JE::Code. I don't
  #     know....
  sub _parse($$$;$$) { # Returns just the parse tree, not a JE::Code object.
                       # Actually,  it returns the source followed  by  the
                       # parse tree in list context, or just the parse tree
                       # in scalar context.
  	my ($rule, $src, $my_global, $file, $line) = @_;
  	local our($_source, $_file, $_line) =($src,$file,$line);
  
  	# Note: We *hafta* stringify the $src, because it could be an
  	# object  with  overloading  (e.g.,  JE::String)  and  we
  	# need to rely on its  pos(),  which simply cannot be
  	# done with an object.  Furthermore,  perl5.8.5 is
  	# a bit buggy and sometimes mangles the contents
  	# of $1 when one does $obj =~ /(...)/.
  	$src = defined blessed $src && $src->isa("JE::String")
  	       ? $src->value16
  	       : surrogify("$src");
  
  	# remove unicode format chrs
  	$src =~ s/\p{Cf}//g;
  
  	# In HTML mode, modify the whitespace regexps to remove HTML com-
  	# ment delimiters and following junk up to the end of the line.
  	$my_global->html_mode and
  	 local $s = qr((?>
  	  (?> [ \t\x0b\f\xa0\p{Zs}]* )
  	  (?> (?>
  	       $n
  	       (?>(?:
  	        (?>[ \t\x0b\f\xa0\p{Zs}]*) -->
  	        (?>[^\cm\cj\x{2028}\x{2029}]*)(?>$n|\z)
  	       )?)
  	        |
  	       ^
  	       (?>[ \t\x0b\f\xa0\p{Zs}]*) -->
  	       (?>[^\cm\cj\x{2028}\x{2029}]*)(?>$n|\z)
  	        |
  	       (?>//|<!--)(?>[^\cm\cj\x{2028}\x{2029}]*)(?>$n|\z)
  	        |
  	       /\*.*?\*/
  	      )
  	      (?> [ \t\x0b\f\xa0\p{Zs}]* )
  	  ) *
  	 ))sx,
  	 local $S = qr(
  	  (?>
  	   $ss
  	    |
  	   (?>//|<!--)[^\cm\cj\x{2028}\x{2029}]*
  	    |
  	   /\*.*?\*/
  	  )
  	  $s
  	 )xs,
  	 local $optional_sc = qr _\G (?:
  	    $s (?: \z | ; $s | (?=\}) )
  	      |
  	    # optional horizontal whitespace
  	    # then a line terminator or a comment containing one
  	    # then optional trailing whitespace
  	    $h
  	    (?:
  	        $n
  	         |
  	        (?>//|<!--)[^\cm\cj\x{2028}\x{2029}]* $n
  	         |
  	        /\* [^*\cm\cj\x{2028}\x{2029}]* 
  	            (?: \*(?!/) [^*\cm\cj\x{2028}\x{2029}] )*
  	          $n
  	          (?s:.)*?
  	        \*/
  	    )
  	    $s
  	 )_x;
  
  	my $tree;
  	local $_vars = [];
  	$rule eq 'program' and !$_parser
  	 and ($ENV{'YES_I_WANT_JE_TO_OPTIMISE'}||'') eq 2
  	 and do { require 'JE/parsetoperl.pl', $rule = \&ptp_program };
  	for($src) {
  		pos = 0;
  		eval {
  			local $global = $my_global;
  			$tree = (\&$rule)->();
  			!defined pos or pos == length 
  			   or expected 'statement or function declaration';
  		};
  		if(ref $@ ne '') {
  			defined blessed $@ and
  				$@->isa('JE::Object::Error')
  				? last : die;
  			ref($@) =~ /^(?:SCALAR|REF)\z/ or die;
  			$@
  			 = ref ${$@} eq 'SCALAR'
  			   ? JE::Object::Error::SyntaxError->new(
  				$my_global,
  				add_line_number(
  				    $${$@},	
  				   {file=>$file,line=>$line,source=>\$src},
  				     pos)
  			     )
  			   : JE::Object::Error::SyntaxError->new(
  				$my_global,
  			# ~~~ This should perhaps show more context
  				add_line_number
  				    "Expected ${$@} but found '".
  				    substr($_, pos, 10) . "'",
  				   {file=>$file,line=>$line,source=>\$src},
  				     pos
  			     );
  			return;
  		}
  		elsif($@) { die }
  	}
  #use Data::Dumper;
  #print Dumper $tree;
  	wantarray ? ($src, $tree, $_vars) : $tree;
  }
  
  
  
  #----------DOCS---------#
  
  !!!0;
  
  =head1 NAME
  
  JE::Parser - Framework for customising JE's parser
  
  =cut
  
  # Actually, this *is* JE's parser. But since JE::Parser's methods are never
  # used directly with the default parser, I think it's actually less confus-
  # ing to call it this.
  
  =head1 SYNOPSIS
  
    use JE;
    use JE::Parser;
  
    $je = new JE;
    $p = new JE::Parser $je; # or: $p = $je->new_parser
  
    $p->delete_statement('for', 'while', 'do'); # disable loops
    $p->add_statement(try => \&parser); # replace existing 'try' statement
  
  =head1 DESCRIPTION
  
  This allows one to change the list of statement types that the parser
  looks for. For instance, one could disable loops for a mini-JavaScript, or
  add extensions to the language, such as the 'catch-if' clause of a C<try> 
  statement.
  
  As yet, C<delete_statement> works, but I've not finished
  designing the API for C<add_statement>.
  
  I might provide an API for extending expressions, if I can resolve the
  complications caused by the 'new' operator. If anyone else wants to have a
  go at it, be my guest. :-)
  
  =head1 METHODS
  
  =over 4
  
  =item $p = new JE::Parser
  
  Creates a new parser object.
  
  =item $p->add_statement($name, \&parser);
  
  This adds a new statement (source element, to be precise) type 
  to the
  list of statements types the parser supports. If a statement type called 
  C<$name> already exists, it will be replaced.
  Otherwise, the new statement type will be added to the top of the list.
  
  (C<$name> ought to be optional; it should only be necessary if one wants to 
  delete 
  it
  afterwards or rearrange the list.)
  
  If the name of a statement type begins with a hyphen, it is only allowed at
  the 'program' level, not within compound statements. Function declarations
  use this. Maybe this
  convention is too unintuitive.... (Does anyone think I should change it?
  What should I change it too?)
  
  C<&parser> will need to parse code contained in C<$_> starting at C<pos()>, then either
  return an object, list or coderef (see below)
  and set C<pos()> to the position of the next token[1], or, if it 
  could not
  parse anything, return undef and reset C<pos()> to its initial value if it
  changed.
  
  [1] I.e., it is expected to move C<pos> past any trailing whitespace.
  
  The return value of C<&parser> can be one of the following:
  
  =over 4
  
  =item 1)
  
  An object with an C<eval> method, that will execute the statement, and/or 
  an C<init> method, which will be called
  before the code runs.
  
  =item 2)
  
  B<(Not yet 
  supported!)> A coderef, which will be called when the code is executed.
  
  =item 3)
  
  B<(Not yet 
  supported.)> A hash-style list, the two keys being C<eval> and C<init> 
  (corresponding to
  the methods under item 1) and the values being coderefs; i.e.:
  
    ( init => \&init_sub, eval => \&eval_sub )
  
  =back
  
  Maybe we need support for a JavaScript function to be called to handnle the
  statement.
  
  =item $p->delete_statement(@names);
  
  Deletes the given statement types and returns C<$p>.
  
  =item $p->statement_list
  
  B<(Not yet implemented.)>
  
  Returns an array ref of the names of the various statement types. You can 
  rearrange this
  list, but it is up to you to make sure you do not add to it any statement
  types that have not been added via C<add_statement> (or were not there by
  default). The statement types in the list will be tried in order, except
  that items beginning with a hyphen always come before other items.
  
  The default list is C<qw/-function block empty if while with for switch try
  labelled var do continue break return throw expr/>
  
  =item $p->parse($code)
  
  Parses the C<$code> and returns a parse tree (JE::Code object).
  
  =item $p->eval($code)
  
  Shorthand for $p->parse($code)->execute;
  
  =back
  
  =head1 EXPORTS
  
  None by default. You may choose to export the following:
  
  =head2 Exported Variables
  
  ... blah blah blah ...
  
  =head2 Exported Functions
  
  These all have C<()> for their prototype, except for C<expected> which has
  C<($)>.
  
  ... blah blah blah ...
  
  =head1 SYNTAX ERRORS
  
  (To be written)
  
    expected 'aaaa'; # will be changed to 'Expected aaaa but found....'
    die \\"You can't put a doodad after a frombiggle!"; # complete message
    die 'aoenstuhoeanthu'; # big no-no (the error is propagated)
  
  =head1 EXAMPLES
  
  =head2 Mini JavaScript
  
  This is an example of a mini JavaScript that does not allow loops or the
  creation of functions.
  
    use JE;
    $j = new JE;
    $p = $j->new_parser;
    $p->delete_statement('for','while','do','-function');
  
  Since function expressions could still create functions, we need to remove
  the Function prototype object. Someone might then try to put it back with
  C<Function = parseInt.constructor>, so we'll overwrite Function with an
  undeletable read-only undefined property.
  
    $j->prop({ name     => 'Function',
               value    => undef,
               readonly => 1,
               dontdel  => 1 });
  
  Then, after this, we call C<< $p->eval('...') >> to run JS code.
  
  =head2 Perl-style for(LIST) loop
  
  Well, after writing this example, it seems to me this API is not 
  sufficient....
  
  This example doesn't actually work yet.
  
    use JE;
    use JE::Parser qw'$s ident expr statement expected';
    
    $j = new JE;
    $p = $j->new_parser;
    $p->add_statement('for-list',
        sub {
            /\Gfor$s/cog or return;
            my $loopvar = ident or return;
            /\G$s\($s/cog or return;
            my @expressions;
            do {
                # This line doesn't actually work properly because
                # 'expr' will gobble up all the commas
                @expressions == push @expressions, expr
                    and return; # If nothing gets pushed on  to  the
                                # list,  we need to give the default
                                # 'for' handler a chance, instead of
                                # throwing an error.
            } while /\G$s,$s/cog;
            my $statement = statement or expected 'statement';
            return bless {
                var => $loopvar,
                expressions => \@expressions,
                statement => $statement
            }, 'Local::JEx::ForList';
        }
    );
    
    package Local::JEx::ForList;
    
    sub eval {
        my $self = shift;
        local $JE::Code::scope =
            bless [@$JE::Code::scope], 'JE::Scope';
            # I've got to come up with a better interface than this.
        my $obj = $JE::Code::global->eval('new Object');
        push @$JE::Code::scope, $obj;
  
        for (@{$self->{expressions}}) {
            $obj->{ $self->{loopvar} } = $_->eval;
            $self->{statement}->execute;
        }
    }
  
  =head1 SEE ALSO
  
  L<JE> and L<JE::Code>.
  
  =cut
  
  
  
  
JE_PARSER

$fatpacked{"JE/Scope.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_SCOPE';
  package JE::Scope;
  
  our $VERSION = '0.066';
  
  use strict;
  use warnings; no warnings 'utf8';
  
  require JE::LValue;
  
  our $AUTOLOAD;
  
  # ~~~ We need a C<can> method.
  
  sub find_var {
  	my ($self,$var) = @_;
  	my $lvalue;
  
  	for(reverse @$self) {
  		my $p = $_;
  		defined($p=$p->prototype) or next  while !$p->exists($var);
  		return new JE::LValue $_, $var;
  	}
  	# if we get this far, then we create an lvalue without a base obj
  	new JE::LValue \$self->[0], $var;
  }
  
  sub new_var {
  	my ($self,$var) = (shift,shift);
  	my $var_obj;
  	for(reverse @$self[1..$#$self]) { # Object  0  can't  be  a  call 
  	                                 # object. Omitting it should the-
  	                               # oretically make  things  margin-
  	                            # ally faster.
  		ref $_ eq 'JE::Object::Function::Call' and
  			$var_obj = $_,
  			last;
  	}
  	defined $var_obj or $var_obj = $$self[0];
  
  	if (defined $var_obj->prop($var)) {
  		$var_obj->prop($var, shift) if @_;
  	}
  	else {
  		$var_obj->prop($var, @_ ? shift :
  			$$self[0]->undefined);
  
  		# This is very naughty code, but it works.	
  		$JE::Code::Expression::_eval or $var_obj->prop({
  			name => $var,
  			dontdel => 1,
  		});
  	}
  
  	return new JE::LValue $var_obj, $var
  		unless not defined wantarray;
  }
  
  sub AUTOLOAD { # This delegates the method to the global object
  	my($method) = $AUTOLOAD =~ /([^:]+)\z/;
  
  	 # deal with various ALLCAPS names
  	if($method =~ /^[A-Z]+\z/) {
  		substr($method,0,0) = 'SUPER::';
  		local *@;
  		return eval { shift->$method(@_) };
  	}
  
  	shift->[0]->$method(@_); # ~~~ Maybe I should use goto
  	                         #     to remove AUTOLOAD from
  	                         #     the call stack.
  }
  
  sub DESTROY {}
  
  1;
  
  =head1 NAME
  
  JE::Scope - JavaScript scope chain (what makes closures work)
  
  =head1 DESCRIPTION
  
  JavaScript code runs within an execution context which has a scope chain
  associated with it. This class implements this scope chain. When a variable 
  is accessed the objects in the scope chain are searched till the variable
  is found.
  
  A JE::Scope object can also be used as global (JE) object. Any methods it
  does not understand will be delegated to the object at the bottom of the
  stack (the far end of the chain), so that C<< $scope->null >> means the
  same thing as C<< $scope->[0]->null >>.
  
  Objects of this class consist of a reference to an array, the elements of
  which are the objects in the chain (the first element
  being the global object). (Think
  of it as a stack.)
  
  =head1 METHODS
  
  =over 4
  
  =item find_var($name, $value)
  
  =item find_var($name)
  
  This method searches through
  the scope chain, starting at the end of the array, until it 
  finds the
  variable named by the first argument. If the second argument is
  present, it sets the variable. It then returns an lvalue (a
  JE::LValue object) that references the variable.
  
  =item new_var($name, $value)
  
  =item new_var($name)
  
  This method creates (and optionally sets the value of) a new
  variable in the variable object (the same thing that JavaScript's C<var>
  keyword does) and returns an lvalue.
  
  The variable object is the first object in the scope chain 
  (searching from the top of the 
  stack) that is a call object, or C<< $scope->[0] >> if no call object is 
  found.
  
  =back
  
  =head1 CONSTRUCTOR
  
  None. Just bless an array reference. You should not need to do
  this because it is done for you by the C<JE> and C<JE::Object::Function> 
  classes.
  
  =head1 SEE ALSO
  
  =over
  
  =item L<JE>
  
  =item L<JE::LValue>
  
  =item L<JE::Object::Function>
  
  =back
  
  =cut
  
  
  
  
JE_SCOPE

$fatpacked{"JE/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_STRING';
  package JE::String;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings; no warnings 'utf8';
  
  use overload fallback => 1,
  	'""' => 'value',
  #	 cmp =>  sub { "$_[0]" cmp $_[1] }
  ;
  
  use Carp;
  use Scalar::Util qw 'blessed tainted';
  
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw'surrogify desurrogify';
  
  require JE::Object::String;
  require JE::Boolean;
  require JE::Number;
  
  
  # Internals:
  # bless [ $utf16_string, $unicode_string, $global_object], 'JE::String';
  # Either of the first two slots may be empty. It will be filled in
  # on demand.
  
  
  sub new {
  	my($class, $global, $val) = @_;
  	defined blessed $global
  	   or croak "First argument to JE::String->new is not an object";
  
  	my $self;
  	if(defined blessed $val and $val->can('to_string')) {
  		$self = bless [$val->to_string->[0],undef,$global], $class;
  	}
  	else {
  		$self = bless [undef,$val, $global], $class;
  	}
  	$self;
  }
  
  sub _new { # ~~~ Should we document this and make it public? The problem
              #     with it is that it has no error-checking whatsoever, and
              #     can consequently make JS do weird things. (Maybe its OK,
              #     since I doubt any code would choke on a charCodeAt result
              #     > 0xffff.)
  	bless [defined $_[2] ? $_[2] : '',undef,$_[1]], $_[0];
  }
  
  sub prop {
  	 # ~~~ Make prop simply return the value if the prototype has that
  	 #      property.
  	my $self = shift;
  
  	if ($_[0] eq 'length') {
  		return JE::Number->new($$self[2], length (
  				defined $$self[0] ? $$self[0] :
  					($$self[0]=surrogify($$self[1]))
  		));
  	}
  
  	$$self[2]->prototype_for('String')->prop(@_);
  }
  
  sub keys {
  	my $self = shift;
  	$$self[2]->prototype_for('String')->keys;}
  
  sub delete {
  	return $_[1] ne 'length'
  }
  
  sub method {
  	my $self = shift;
  	$$self[2]->prototype_for('String')->prop(shift)->apply(
  		$self,$$self[2]->upgrade(@_)
  	);
  }
  
  
  sub value {
  	defined $_[0][1] ? $_[0][1] : ($_[0][1] = desurrogify($_[0][0]));
  }
  *TO_JSON=*value;
  
  sub value16 {
  	defined $_[0][0] ? $_[0][0] : ($_[0][0] = surrogify($_[0][1]));
  }
  
  
  sub typeof    { 'string' }
  sub id        { 'str:' . $_[0]->value16 }
  sub class     { 'String' }
  sub primitive { 1 }
  
  sub to_primitive { $_[0] }
  sub to_string    { $_[0] }
                                         # $_[0][2] is the global obj
  sub to_boolean { JE::Boolean->new(       $_[0][2],
  	length defined $_[0][0]
  		? $_[0][0] : $_[0][1]
  ) }
  sub to_object  { JE::Object::String->new($_[0][2], shift) }
  
  our $s = qr.[\p{Zs}\s\ck\x{2028}\x{2029}]*.;
  
  sub to_number  {
  	my $value = (my $self = shift)->[0];
  	defined $value or $value = $$self[1];
  	JE::Number->new($self->[2],
  		$value =~ /^$s
  		  (
  		    [+-]?
  		    (?:
  		      (?=[0-9]|\.[0-9]) [0-9]* (?:\.[0-9]*)?
  		      (?:[Ee][+-]?[0-9]+)?
  		        |
  		      Infinity
  		    )
  		    $s
  		  )?
  		  \z
  		/ox ? defined $1 ? $value : 0 :
  		$value =~ /^$s   0[Xx] ([A-Fa-f0-9]+)   $s\z/ox ? hex $1 :
  		'NaN'
  	);
  }
  
  sub global { $_[0][2] }
  
  sub taint {
  	my $self = shift;
  	tainted $self->[0] || tainted $self->[1] and return $self;
  	my $alter_ego = [@$self];
  	$alter_ego->[defined $alter_ego->[0] ? 0 : 1] .= shift();
  	return bless $alter_ego, ref $self;
  }
  
  
  sub desurrogify($) {
  	my $ret = shift;
  	my($ord1, $ord2);
  	for(my $n = 0; $n < length $ret; ++$n) {  # really slow
  		($ord1 = ord substr $ret,$n,1) >= 0xd800 and
  		 $ord1                          <= 0xdbff and
  		($ord2 = ord substr $ret,$n+1,1) >= 0xdc00 and
  		$ord2                            <= 0xdfff and
  		substr($ret,$n,2) =
  		chr 0x10000 + ($ord1 - 0xD800) * 0x400 + ($ord2 - 0xDC00);
  	}
  
  	# In perl 5.8.8, if there is a sub on the call stack that was
  	# triggered by the overloading mechanism when the object with the 
  	# overloaded operator was passed as the only argument to 'die',
  	# then the following substitution magically calls that subroutine
  	# again with the same arguments, thereby causing infinite
  	# recursion:
  	#
  	# $ret =~ s/([\x{d800}-\x{dbff}])([\x{dc00}-\x{dfff}])/
  	# 	chr 0x10000 + (ord($1) - 0xD800) * 0x400 +
  	#		(ord($2) - 0xDC00)
  	# /ge;
  	#
  	# 5.9.4 still has this bug.
  
  	$ret;
  }
  
  sub surrogify($) {
  	my $ret = shift;
  
  	no warnings 'utf8';
  
  	$ret =~ s<([^\0-\x{ffff}])><
  		  chr((ord($1) - 0x10000) / 0x400 + 0xD800)
  		. chr((ord($1) - 0x10000) % 0x400 + 0xDC00)
  	>eg;
  	$ret;
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  JE::String - JavaScript string value
  
  =head1 SYNOPSIS
  
    use JE;
    use JE::String;
  
    $j = JE->new;
  
    $js_str = new JE::String $j, "etetfyoyfoht";
  
    $perl_str = $js_str->value;
  
    $js_str->to_object; # retuns a new JE::String::Object;
  
  =head1 DESCRIPTION
  
  This class implements JavaScript string values for JE. The difference
  in use between this and JE::Object::String is that that module implements
  string
  I<objects,> while this module implements the I<primitive> values.
  
  The stringification operator is overloaded.
  
  =head1 THE FUNCTION
  
  There are two exportable functions, C<surrogify> and C<desurrogify>, which
  convert characters outside the BMP into surrogate pairs, and convert
  surrogate pairs in the string input argument into the characters they
  represent, respectively, and return the modified string. E.g.:
  
    use JE::String qw 'desurrogify surrogify';
    
    {
            no warnings 'utf8';
            $str = "\x{d834}\x{dd2b}";
    }
  
    $str = desurrogify $str;  # $str now contains "\x{1d12b}" (double flat)
    $str = surrogify $str;    # back to "\x{d834}\x{dd2b}"
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<JE>
  
  =item L<JE::Types>
  
  =item L<JE::Object::String>
  
  =back
JE_STRING

$fatpacked{"JE/Undefined.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE_UNDEFINED';
  package JE::Undefined;
  
  our $VERSION = '0.066';
  
  use strict;
  use warnings;
  
  use overload fallback => 1,
  	'""' => 'typeof',
  #	 cmp =>  sub { "$_[0]" cmp $_[1] },
  	bool => \&value,
  	'0+' =>  sub { sin 9**9**9 };
  
  # ~~~ How should this numify?
  
  require JE::String;
  require JE::Boolean;
  
  
  =head1 NAME
  
  JE::Undefined - JavaScript undefined value
  
  =head1 SYNOPSIS
  
    use JE;
  
    $j = new JE;
  
    $js_undefined = $j->undef;
  
    $js_undefined->value; # undef
  
  =head1 DESCRIPTION
  
  This class implements the JavaScript "undefined" type. There really
  isn't much to it.
  
  Undefined stringifies to 'undefined', and is false as a boolean.
  
  =cut
  
  # A JE::Undefined object is a reference to a global object.
  
  sub new    { bless \do{my $thing = $_[1]}, $_[0] }
  sub value  { undef }
  *TO_JSON=*value;
  sub typeof { 'undefined' }
  sub id     { 'undef' }
  sub primitive { 1 }
  sub to_primitive { $_[0] }
  sub to_boolean   { JE::Boolean->new(${+shift}, 0) }
  sub to_string { JE::String->_new(${+shift}, 'undefined') };
  sub to_number { JE::Number->new(${+shift}, 'NaN') }
  sub global { ${$_[0]} }
  
  return "undef";
  __END__
  
  =head1 SEE ALSO
  
  =over 4
  
  =item JE::Types
  
  =item JE::Null
  
  =item JE
  
  =back
JE_UNDEFINED

$fatpacked{"JE/_FieldHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JE__FIELDHASH';
  package JE::_FieldHash;
  
  our $VERSION = '0.066';
  
  
  use strict;
  use warnings;
  
  BEGIN {
  	eval { require Hash::Util::FieldHash;
  	       import  Hash::Util::FieldHash 'fieldhash'; };
  	if ($@) {
  		require Tie::RefHash::Weak;
  		eval 'sub fieldhash(\%) {
  			tie %{$_[0]}, "Tie::RefHash::Weak";
  			$_[0];
  		}';
  	}
  }
  
  use Exporter 5.57 'import';
  
  our @EXPORT = 'fieldhash'; # this returns a veracious value
  
  __END__
  
  =head1 NAME
  
  JE::_FieldHash - This module is solely for JE's private use.
  
  =head1 SYNOPSIS
  
    use JE::_FieldHash;
    fieldhash my %foo;
  
  =head1 DESCRIPTION
  
  This is a thin wrapper around Hash::Util::FieldHash, or Tie::RefHash::Weak
  if the former is not available. B<It is liable to change or vanish without
  notice.>
  
  =head1 SEE ALSO
  
  L<JE>
JE__FIELDHASH

$fatpacked{"JavaScript/Engine.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JAVASCRIPT_ENGINE';
  package JavaScript::Engine;
  
  our $VERSION = '0.066';
  
  use JE;
  
  =head1 NAME
  
  JavaScript::Engine - Pure-Perl ECMAScript (JavaScript) engine
  
  =head1 DESCRIPTION
  
  This is just a pointer to L<JE>, a pure-Perl JS engine.
  
  "JE" stands for 
  JavaScript::Engine. I named it this, following the example of PPI, to avoid
  long class names like JavaScript::Engine::Object::Error::ReferenceError,
  which I thought would be a little ridiculous, and also time-consuming to
  type.
  
  I included this module
  in the JE distribution so that
  one might be able to find JE when typing C<i /javascript/> in the CPAN
  shell or when looking under modules/by-module/JavaScript/ on the CPAN.
  
  =head1 AUTHOR
  
  Father Chrysostomos <sprout at cpan.org>
  
  =cut
  
  1; # End of JavaScript::Engine
JAVASCRIPT_ENGINE

$fatpacked{"common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMON_SENSE';
  package common::sense;
  
  our $VERSION = 3.75;
  
  # overload should be included
  
  sub import {
     local $^W; # work around perl 5.16 spewing out warnings for next statement
     # use warnings
     ${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x03\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\x0c\x00\x00\x00\x00";
     # use strict, use utf8; use feature;
     $^H |= 0x1c820fc0;
     @^H{qw(feature___SUB__ feature_evalbytes feature_fc feature_indirect feature_say feature_state feature_switch feature_unicode)} = (1) x 8;
  }
  
  1
COMMON_SENSE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use 5.010;
use strict;
use warnings qw(all);
# CORE dependencies
use Getopt::Long;
use IO::Socket;
use Net::Domain;
use POSIX;
# external dependencies
use AnyEvent::HTTP;
use AnyEvent::Log;
use AnyEvent::Socket;
use AnyEvent::Util;
use JE;

main();

sub _help {
    return print <<'END_HELP';
Usage: depac [options] [command]
    --help              This screen
    --stop              Stop the running instance
    --reload            Reload the running instance
    --status            Output the environment settings if an instance is running
    --wpad_file URL     Manually specify the URL of the "wpad.dat" file (default: DNS autodiscovery)
                        Alternatively: --wpad_file=skip to short-circuit the relay proxy
    --env_file FILE     File for environment persistence (default: ~/.depac.env)
    --log_file FILE     File for the log (default: ~/.depac.log; /dev/null to disable :)
    --log_level LEVEL   fatal/warn/info/debug/trace (default: warn)
    --nodetach          Do not daemonize
    --bind_host ADDR    Accept connection at this host address (default: 127.0.0.1)
    --bind_port PORT    Accept connection at this port (default: random port)
    --custom DEST,REGEX Custom routes AKA "poor man's WPAD"; overrides for the WPAD rules.
                        DEST is the destination proxy address (or "direct"),
                        REGEX is a regular expression that matches the hostname.
                        Multiple custom routes can be defined adding --custom ...
                        as much as necessary.
                        Example: --custom '192.168.253.15:8080,dev\.company\.com$'

 * To run a single process through the relay proxy:

    depac curl ifconfig.me/all

 * Add this line to your ~/.profile file to start the relay proxy in background
   and update HTTP_PROXY environment variables appropriately:

    eval $(depac)

 * To gracefully terminate the relay proxy and unset HTTP_PROXY environment:

    eval $(depac --stop)
END_HELP
}

# shamelessly stolen from https://metacpan.org/source/MACKENNA/HTTP-ProxyPAC-0.31/lib/HTTP/ProxyPAC/Functions.pm
sub _validIP {
    return ($_[0] =~ m{^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$}x
        && $1 <= 255 && $2 <= 255 && $3 <= 255 && $4 <= 255);
}

our %memoize;
sub _process_wpad {
    my ($wpad_file) = @_;
    my $je = JE->new;
    for my $stub (qw(alert weekDayRange dateRange timeRange)) {
        $je->new_function($stub => sub {
            AE::log warn => 'WPAD CALLED: %s("%s")',
                $stub,
                join '","', map { quotemeta } @_;
            return;
        });
    }
    $je->new_function(dnsDomainIs => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            my $d = length($_[0]) - length($_[1]);
            ($d >= 0) && (substr($_[0], $d) eq $_[1]);
        };
    });
    $je->new_function(dnsDomainLevels => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            $#{[ split m{\.}x, $_[0] ]};
        };
    });
    $je->new_function(dnsResolve => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            my $addr = Socket::inet_aton($_[0]);
            $addr ? inet_ntoa($addr) : ();
        };
    });
    $je->new_function(isInNet => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            $_[0] = dnsResolve($_[0]) unless _validIP($_[0]);
            (!$_[0] || !_validIP($_[1]) || !_validIP($_[2]))
                ? () : (Socket::inet_aton($_[0]) & Socket::inet_aton($_[2])) eq (Socket::inet_aton($_[1]) & Socket::inet_aton($_[2]));
        };
    });
    $je->new_function(isPlainHostName => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            index($_[0], '.') == -1;
        };
    });
    $je->new_function(isResolvable => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            defined(gethostbyname($_[0]));
        };
    });
    $je->new_function(localHostOrDomainIs => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            ($_[0] eq $_[1]) || rindex($_[1], $_[0] . '.') == 0;
        };
    });
    $je->new_function(myIpAddress => sub {
        $memoize{myIpAddress} //= do {
            my $addr = Socket::inet_aton(Net::Domain::hostname);
            $addr ? inet_ntoa($addr) : '127.0.0.1';
        };
    });
    $je->new_function(shExpMatch => sub {
        $memoize{ join('|', __LINE__, @_) } //= do {
            my ($str, $shExp) = @_;
            $shExp =~ s{ \. }{\.}gx;
            $shExp =~ s{ \? }{.}gx;
            $shExp =~ s{ \* }{.*?}gx;
            !!($str =~ m{^ $shExp $}ix);
        };
    });
    my $cv = AnyEvent->condvar;
    if ($wpad_file) {
        if (open(my $fh, '<', $wpad_file)) {
            AE::log info => 'reading local file %s', $wpad_file;
            local $/ = undef;
            my $body = <$fh>;
            close $fh;
            $cv->send([$body, "$wpad_file"]);
        } else {
            AE::log info => 'fetching resource %s', $wpad_file;
            http_get $wpad_file,
                proxy => undef,
                timeout => 1.0,
                sub {
                    my ($body, $hdr) = @_;
                    if (($hdr->{Status} != 200) || !length($body)) {
                        AE::log fatal => "couldn't GET %s", $wpad_file;
                    } else {
                        $cv->send([$body, "$wpad_file"]);
                    }
                };
        }
    } else {
        my $hostdomain  = Net::Domain::hostdomain;
        AE::log info => 'searching domain %s', $hostdomain;
        my @hostdomain = split m{\.}x, $hostdomain;
        while ($#hostdomain) {
            my $wpad = 'http://wpad.' . join('.', @hostdomain) . '/wpad.dat';
            AE::log info => 'fetching %s', $wpad;
            $cv->begin;
            http_get $wpad,
                proxy => undef,
                timeout => 1.0,
                sub {
                    my ($body, $hdr) = @_;
                    $cv->end;
                    if (($hdr->{Status} != 200) || !length($body)) {
                        AE::log debug => "couldn't GET %s", $wpad;
                    } else {
                        $cv->send([$body, "$wpad"]);
                    }
                };
            shift @hostdomain;
        }
    }
    (my $body, $je->{last_working_wpad_file}) = @{ $cv->recv || [''] };
    AE::log fatal => "COULDN'T FIND WPAD" unless $body;
    $je->eval($body);
    AE::log fatal => "COULDN'T EVALUATE WPAD: $@" if $@;
    AE::log info => 'using WPAD %s', $je->{last_working_wpad_file};
    return $je;
}

sub _ping_pid {
    my ($proxy) = @_;
    my $cv = AnyEvent->condvar;
    AE::log info => 'pinging %s:%d', @$proxy;
    http_get 'http://depac/pid',
        proxy   => $proxy,
        timeout => 1.0,
        sub {
            my ($body, $hdr) = @_;
            if (($hdr->{Status} != 200) || !length($body)) {
                AE::log info => "couldn't GET /pid from %s:%d", @$proxy;
                $cv->send(0);
            } else {
                chomp $body;
                $cv->send($body);
            }
        };
    return $cv->recv;
}

our ($sigint, $sighup); # keep the reference
sub run {
    my ($bind_host, $bind_port, $je, $routes, $cb) = @_;
    my (%pool, %status);
    my $cv = AnyEvent->condvar;
    my $reload = sub {
        AE::log info => 'cleaning up caches...';
        %pool = ();
        %status = ();
        %memoize = ();
        AE::log info => 'reprocessing WPAD %s', $je->{last_working_wpad_file};
        http_get $je->{last_working_wpad_file},
            proxy => undef,
            timeout => 1.0,
            sub {
                my ($body, $hdr) = @_;
                if (($hdr->{Status} != 200) || !length($body)) {
                    AE::log fatal => "couldn't GET %s", $je->{last_working_wpad_file};
                } else {
                    $je->eval($body);
                    AE::log fatal => "COULDN'T EVALUATE WPAD: $@" if $@;
                }
            };
    };
    $sighup = AnyEvent->signal(signal => 'HUP', cb => $reload);
    $sigint = AnyEvent->signal(signal => 'INT', cb => sub {
        AE::log info => 'shutting down...';
        $cv->send;
    });
    tcp_server $bind_host, $bind_port, sub {
        my ($fh, $host, $port) = @_;
        AE::log info => 'new connection from %s:%d (%d in pool)', $host, $port, scalar keys %pool;
        my $h = AnyEvent::Handle->new(
            fh          => $fh,
            on_eof    => sub {
                $_[0]->destroy;
                delete $pool{ fileno($fh) };
            },
            on_error    => sub {
                $_[0]->destroy;
                delete $pool{ fileno($fh) };
            },
        );
        $pool{ fileno($fh) } = $h;
        $status{connections}++;
        $h->push_read(line => sub {
            my ($_h, $line, $eol) = @_;
            AE::log debug => '[from %s:%d] %s', $host, $port, $line;
            my ($verb, $peer_host, $peer_port, $proto, $uri);
            if ($line =~ m{^CONNECT\s+([\w\.\-]+):([0-9]+)\s+(HTTP/1\.[01])$}ix) {
                ($verb, $peer_host, $peer_port, $proto) = ('CONNECT', $1, $2, $3);
            } elsif ($line =~ m{^(DELETE|GET|HEAD|OPTIONS|POST|PUT|TRACE)\s+(https?)://([\w\.\-]+)(?::([0-9]+))?(\S*)\s+(HTTP/1\.[01])$}ix) {
                ($verb, my $scheme, $peer_host, $peer_port, $uri, $proto) = (uc($1), lc($2), $3, $4, $5, $6);
                $peer_port ||= $scheme eq 'http' ? 80 : 443;
            } else {
                AE::log warn => 'bad request from %s:%d', $host, $port;
                $_h->push_write(
                    'HTTP/1.0 400 Bad request' . $eol .
                    'Cache-Control: no-cache' . $eol .
                    'Connection: close' . $eol .
                    'Content-Type: text/html' . $eol . $eol .
                    '<html><body><h1>400 Bad request</h1></body></html>'
                );
                $_h->push_shutdown;
                delete $pool{ fileno($fh) };
                return;
            }
            if ($peer_host eq 'depac') {
                $status{cache} = keys %memoize;
                $status{pool} = keys %pool;
                if (my $response = {
                        '/pid'      => sub { $$ },
                        '/status'   => sub { join $eol => map { $_ . "\t" . $status{$_} } sort keys %status },
                        '/reload'   => sub { $reload->(); $je->{last_working_wpad_file} },
                    }->{ $uri }) {
                    AE::log info => '%s request from %s:%d (OK)', $uri, $host, $port;
                    $_h->push_write(
                        'HTTP/1.0 200 OK' . $eol .
                        'Cache-Control: no-cache' . $eol .
                        'Connection: close' . $eol .
                        'Content-Type: text/plain' . $eol . $eol .
                        $response->() . $eol
                    );
                } else {
                    AE::log warn => '%s request from %s:%d (Not found)', $uri, $host, $port;
                    $_h->push_write(
                        'HTTP/1.0 404 Not found' . $eol .
                        'Cache-Control: no-cache' . $eol .
                        'Connection: close' . $eol .
                        'Content-Type: text/html' . $eol . $eol .
                        '<html><body><h1>404 Not found</h1></body></html>'
                    );
                }
                $_h->push_shutdown;
                delete $pool{ fileno($fh) };
                return;
            }

            my ($proxy) = map {
                ($peer_host =~ $_->[0]) ? $_->[1] : ()
            } @$routes;
            AE::log debug => 'overriding with %s', $proxy if $proxy;
            $proxy ||= $je ? $je->{FindProxyForURL}->(
                ($verb eq 'CONNECT' ? 'https' : 'http') . '://' . $peer_host, # HACK!
                $peer_host,
            ) : 'DIRECT';
            AE::log debug => 'selected proxy %s', $proxy;

            my $peer_h;
            if ($proxy =~ m{^DIRECT\b}ix) {
                AE::log debug => 'connecting directly to %s:%d', $peer_host, $peer_port;
                $peer_h = AnyEvent::Handle->new(
                    connect     => [$peer_host => $peer_port],
                    on_eof      => sub { $_[0]->destroy },
                    on_error    => sub { $_[0]->destroy },
                    on_connect  => sub {
                        if ($verb eq 'CONNECT') {
                            AE::log debug => '[to %s:%d]', $peer_host, $peer_port;
                            $_h->push_read(regex => qr{(?:\015?\012){2}}x, sub {
                                AE::log debug => 'skipping headers on CONNECT';
                                $_h->push_write('HTTP/1.0 200 Connection established' . $eol . $eol);
                            });
                        } else {
                            $line = join ' ', $verb, $uri, $proto;
                            AE::log debug => '[to %s:%d] %s', $peer_host, $peer_port, $line;
                            $peer_h->push_write($line . $eol);
                        }
                        $_h->on_read(sub {
                            my $l = length $_[0]->rbuf;
                            $status{sent_bytes} += $l;
                            AE::log trace => 'send %d bytes to %s:%d', $l, $peer_host, $peer_port;
                            $peer_h->push_write($_[0]->rbuf);
                            $_[0]->rbuf = '';
                        });
                        $peer_h->on_read(sub {
                            my $l = length $_[0]->rbuf;
                            $status{recv_bytes} += $l;
                            AE::log trace => 'recv %d bytes from %s:%d', $l, $peer_host, $peer_port;
                            $_h->push_write($_[0]->rbuf);
                            $_[0]->rbuf = '';
                        });
                    }
                );
            } else {
                my ($proxy_host, $proxy_port) = ($proxy =~ m{^PROXY\s+([\w\.]+):([0-9]+)}ix);
                AE::log debug => 'connecting to %s:%d via %s:%d', $peer_host, $peer_port, $proxy_host, $proxy_port;
                $peer_h = AnyEvent::Handle->new(
                    connect     => [$proxy_host => $proxy_port],
                    on_eof      => sub { $_[0]->destroy },
                    on_error    => sub { $_[0]->destroy },
                    on_connect  => sub {
                        AE::log debug => '[to %s:%d] %s', $proxy_host, $proxy_port, $line;
                        $peer_h->push_write($line . $eol);
                        $_h->on_read(sub {
                            my $l = length $_[0]->rbuf;
                            $status{sent_bytes} += $l;
                            AE::log trace => 'send %d bytes to %s:%d', $l, $proxy_host, $proxy_port;
                            $peer_h->push_write($_[0]->rbuf);
                            $_[0]->rbuf = '';
                        });
                        $peer_h->on_read(sub {
                            my $l = length $_[0]->rbuf;
                            $status{recv_bytes} += $l;
                            AE::log trace => 'recv %d bytes from %s:%d', $l, $proxy_host, $proxy_port;
                            $_h->push_write($_[0]->rbuf);
                            $_[0]->rbuf = '';
                        });
                    }
                );
            }
        });
    }, $cb;
    return $cv;
}

sub _daemonize {
    open(\*STDOUT, '>', '/dev/null') || AE::log fatal => "open >/dev/null: $@";
    open(\*STDIN,  '<', '/dev/null') || AE::log fatal => "open </dev/null: $@";
    open(\*STDERR, '>', '/dev/null') || AE::log fatal => "dup stdout > stderr: $@";
    my $pid;
    POSIX::_exit(0) if $pid = fork;
    AE::log fatal => "couldn't fork: $@" unless defined $pid;
    POSIX::setsid();
    return;
}

sub main {
    my $bind_host = '127.0.0.1';
    my $env_file = $ENV{HOME} . '/.depac.env';
    my $log_file = $ENV{HOME} . '/.depac.log';
    my $log_level = 'warn';
    my $detach = 1;
    my ($bind_port, $wpad_file, $help, $stop, $reload, $status, @custom);
    GetOptions(
        'bind_host=s'   => \$bind_host,
        'bind_port=i'   => \$bind_port,
        'detach!'       => \$detach,
        'env_file=s'    => \$env_file,
        'log_file=s'    => \$log_file,
        'log_level=s'   => \$log_level,
        'help'          => \$help,
        'reload'        => \$reload,
        'status'        => \$status,
        'stop'          => \$stop,
        'wpad_file=s'   => \$wpad_file,
        'custom=s'      => \@custom,
    );
    _help && exit if $help;

    umask 077;

    $AnyEvent::Log::FILTER->level($log_level);
    $AnyEvent::Log::FILTER->attach(AnyEvent::Log::Ctx->new(
        log_to_file => $log_file,
    ));

    my $routes = [];
    for (@custom) {
        my ($dest, $regex) = /^([\w\.:]+),(.+)$/x;
        AE::log fatal => "Bad route: $_" if !$dest || !$regex;
        AE::log debug => 'Custom route [ qr/%s/ix => "%s" ]', $regex, quotemeta $dest;
        push @$routes => [ qr/$regex/ix => $dest ];
    }

    if (@ARGV) {
        my $je = _process_wpad($wpad_file);
        my ($relay, $command);
        $relay = run($bind_host, $bind_port, $je, $routes, sub {
            my (undef, $this_host, $this_port) = @_;
            AE::log info => 'STARTED THE SERVER AT %s:%d', $this_host, $this_port;
            $ENV{$_} = 'http://' . $this_host . ':' . $this_port
                for map { $_ => uc } qw(http_proxy https_proxy);
            AE::log info => 'STARTING THE COMMAND: %s', join ' ', @ARGV;
            $command = run_cmd [@ARGV];
            $command->cb(sub {
                my $exit = shift->recv;
                AE::log info => 'COMMAND EXITED WITH CODE %d', $exit;
                $relay->send;
            });
        });
        $relay->recv;
    } else {
        my $proxy;
        if (-e $env_file) {
            AE::log debug => 'checking previous environment at %s', $env_file;
            open(my $fh, '<', $env_file)
                || AE::log fatal => "can't read from %s: %s", $env_file, $@;
            my @env;
            while (my $line = <$fh>) {
                $proxy = [$1, $2] if $line =~ m{^export\s+https?_proxy="http://([\w\.\-]+):([0-9]+)"}isx;
                push @env => $line;
            }
            close $fh;
            AE::log fatal => "couldn't find running process address in %s", $env_file
                unless $proxy;
            if (my $pid = _ping_pid($proxy)) {
                AE::log info => 'running proxy has PID %d', $pid;
                if ($stop) {
                    AE::log debug => 'sending SIGINT to PID %d', $pid;
                    kill INT => $pid;
                    print qq(unset $_\n) for map { $_ => uc } qw(http_proxy https_proxy);
                } elsif ($reload) {
                    AE::log debug => 'sending SIGHUP to PID %d', $pid;
                    kill HUP => $pid;
                } else {
                    print for @env;
                }
                exit;
            }
        }
        if ($stop) {
            print qq(unset $_\n) for map { $_ => uc } qw(http_proxy https_proxy);
            exit;
        } elsif ($status) {
            # not running
            exit;
        }
        my $je = _process_wpad($wpad_file);
        run($bind_host, $bind_port, $je, $routes, sub {
            my (undef, $this_host, $this_port) = @_;
            my @env;
            AE::log info => 'STARTED THE SERVER AT %s:%d', $this_host, $this_port;
            $proxy = 'http://' . $this_host . ':' . $this_port;
            AE::log info => 'writing environment proxy settings to %s', $env_file;
            push @env => qq(export $_="$proxy"\n) for map { $_ => uc } qw(http_proxy https_proxy);
            print for @env;
            unlink $env_file;
            open(my $fh, '>', $env_file)
                || AE::log fatal => "can't write to %s: %s", $env_file, $@;
            print $fh $_ for @env;
            close $fh;
            _daemonize if $detach;
        })->recv;
    }
    exit;
}
